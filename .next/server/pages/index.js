/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/index";
exports.ids = ["pages/index"];
exports.modules = {

/***/ "./atoms/modalAtom.js":
/*!****************************!*\
  !*** ./atoms/modalAtom.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"modalState\": () => (/* binding */ modalState)\n/* harmony export */ });\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! recoil */ \"recoil\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(recoil__WEBPACK_IMPORTED_MODULE_0__);\n\nconst modalState = (0,recoil__WEBPACK_IMPORTED_MODULE_0__.atom)({\n    key: \"modalState\",\n    default: false\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hdG9tcy9tb2RhbEF0b20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZCO0FBRXRCLEtBQUssQ0FBQ0MsVUFBVSxHQUFHRCw0Q0FBSSxDQUFDLENBQUM7SUFDOUJFLEdBQUcsRUFBRSxDQUFZO0lBQ2pCQyxPQUFPLEVBQUUsS0FBSztBQUNoQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXRvbXMvbW9kYWxBdG9tLmpzP2I0ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXRvbSB9IGZyb20gXCJyZWNvaWxcIjtcblxuZXhwb3J0IGNvbnN0IG1vZGFsU3RhdGUgPSBhdG9tKHtcbiAga2V5OiBcIm1vZGFsU3RhdGVcIixcbiAgZGVmYXVsdDogZmFsc2UsXG59KTtcbiJdLCJuYW1lcyI6WyJhdG9tIiwibW9kYWxTdGF0ZSIsImtleSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./atoms/modalAtom.js\n");

/***/ }),

/***/ "./components/Feed.js":
/*!****************************!*\
  !*** ./components/Feed.js ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Posts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Posts */ \"./components/Posts.js\");\n/* harmony import */ var _MiniProfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MiniProfile */ \"./components/MiniProfile.js\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next-auth/react */ \"next-auth/react\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_3__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Posts__WEBPACK_IMPORTED_MODULE_1__]);\n_Posts__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\n\n\n\n\nfunction Feed() {\n    const { data: session  } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_3__.useSession)();\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"main\", {\n        className: `grid grid-cols-1 \n    md:grid-cols-2 md:max-w-3xl xl:grid-cols-3 \n    xl:max-w-6xl mx-auto ${!session && \"!grid-cols-1 !max-w-3xl\"}`,\n        __source: {\n            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Feed.js\",\n            lineNumber: 7\n        },\n        __self: this,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"section\", {\n                className: \"col-span-2\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Feed.js\",\n                    lineNumber: 13\n                },\n                __self: this,\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Posts__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                    __source: {\n                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Feed.js\",\n                        lineNumber: 16\n                    },\n                    __self: this\n                })\n            }),\n            session && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"section\", {\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Feed.js\",\n                    lineNumber: 20\n                },\n                __self: this,\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    __source: {\n                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Feed.js\",\n                        lineNumber: 21\n                    },\n                    __self: this,\n                    children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_MiniProfile__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Feed.js\",\n                            lineNumber: 22\n                        },\n                        __self: this\n                    })\n                })\n            })\n        ]\n    }));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Feed);\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0ZlZWQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMkI7QUFDWTtBQUNLO1NBQ25DRyxJQUFJLEdBQUcsQ0FBQztJQUNmLEtBQUssQ0FBQyxDQUFDLENBQUNDLElBQUksRUFBRUMsT0FBTyxFQUFDLENBQUMsR0FBR0gsMkRBQVU7SUFDcEMsTUFBTSx1RUFDSEksQ0FBSTtRQUNIQyxTQUFTLEdBQUc7Ozs7Ozs7O2dCQUtIQTs7Ozs7Ozs7Ozs7Ozs7WUFNUkY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVVAsQ0FBQztBQUVELE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL0ZlZWQuanM/NDZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUG9zdHMgZnJvbSBcIi4vUG9zdHNcIjtcbmltcG9ydCBNaW5pUHJvZmlsZSBmcm9tIFwiLi9NaW5pUHJvZmlsZVwiO1xuaW1wb3J0IHsgdXNlU2Vzc2lvbiB9IGZyb20gXCJuZXh0LWF1dGgvcmVhY3RcIjtcbmZ1bmN0aW9uIEZlZWQoKSB7XG4gIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xuICByZXR1cm4gKFxuICAgIDxtYWluXG4gICAgICBjbGFzc05hbWU9e2BncmlkIGdyaWQtY29scy0xIFxuICAgIG1kOmdyaWQtY29scy0yIG1kOm1heC13LTN4bCB4bDpncmlkLWNvbHMtMyBcbiAgICB4bDptYXgtdy02eGwgbXgtYXV0byAkeyFzZXNzaW9uICYmIFwiIWdyaWQtY29scy0xICFtYXgtdy0zeGxcIn1gfVxuICAgID5cbiAgICAgIHsvKiBTZWN0aW9uICovfVxuICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwiY29sLXNwYW4tMlwiPlxuICAgICAgICB7LyogU3RvcmllcyAqL31cbiAgICAgICAgey8qIFBvc3RzICAqL31cbiAgICAgICAgPFBvc3RzIC8+XG4gICAgICA8L3NlY3Rpb24+XG5cbiAgICAgIHtzZXNzaW9uICYmIChcbiAgICAgICAgPHNlY3Rpb24+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxNaW5pUHJvZmlsZSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3NlY3Rpb24+XG4gICAgICApfVxuICAgICAgey8qIFNlY3Rpb24gKi99XG4gICAgPC9tYWluPlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBGZWVkO1xuIl0sIm5hbWVzIjpbIlBvc3RzIiwiTWluaVByb2ZpbGUiLCJ1c2VTZXNzaW9uIiwiRmVlZCIsImRhdGEiLCJzZXNzaW9uIiwibWFpbiIsImNsYXNzTmFtZSIsInNlY3Rpb24iLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Feed.js\n");

/***/ }),

/***/ "./components/Header.js":
/*!******************************!*\
  !*** ./components/Header.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _heroicons_react_outline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @heroicons/react/outline */ \"@heroicons/react/outline\");\n/* harmony import */ var _heroicons_react_outline__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_heroicons_react_outline__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _heroicons_react_solid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @heroicons/react/solid */ \"@heroicons/react/solid\");\n/* harmony import */ var _heroicons_react_solid__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_heroicons_react_solid__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-auth/react */ \"next-auth/react\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/router */ \"next/router\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! recoil */ \"recoil\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(recoil__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _atoms_modalAtom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../atoms/modalAtom */ \"./atoms/modalAtom.js\");\n\n\n\n\n\n\n\n\nfunction Header() {\n    const { data: session  } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_4__.useSession)();\n    const [open, setOpen] = (0,recoil__WEBPACK_IMPORTED_MODULE_6__.useRecoilState)(_atoms_modalAtom__WEBPACK_IMPORTED_MODULE_7__.modalState);\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_5__.useRouter)();\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"shadow-sm border-b bg-white sticky top-0 z-50\",\n        __source: {\n            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n            lineNumber: 21\n        },\n        __self: this,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n            className: \"flex justify-between max-w-6xl mx-5 xl:mx-auto\",\n            __source: {\n                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                lineNumber: 22\n            },\n            __self: this,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    onClick: ()=>router.push(\"/\")\n                    ,\n                    className: \" mt-2 relative hidden lg:inline-grid w-24 cursor-pointer\",\n                    __source: {\n                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                        lineNumber: 24\n                    },\n                    __self: this,\n                    children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)((next_image__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        src: \"/photoapp.png\",\n                        layout: \"fill\",\n                        objectFit: \"contain\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                            lineNumber: 28\n                        },\n                        __self: this\n                    })\n                }),\n                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    onClick: ()=>router.push(\"/\")\n                    ,\n                    className: \"relative w-10 lg:hidden flex-shrink-0 cursor-pointer\",\n                    __source: {\n                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                        lineNumber: 30\n                    },\n                    __self: this,\n                    children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)((next_image__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        src: \"https://www.seekpng.com/png/full/131-1310384_png-file-diary-icon-png.png\",\n                        layout: \"fill\",\n                        objectFit: \"contain\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                            lineNumber: 34\n                        },\n                        __self: this\n                    })\n                }),\n                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                    className: \"flex items-center justify-end space-x-4\",\n                    __source: {\n                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                        lineNumber: 42\n                    },\n                    __self: this,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_heroicons_react_solid__WEBPACK_IMPORTED_MODULE_3__.HomeIcon, {\n                            onClick: ()=>router.push(\"/\")\n                            ,\n                            className: \"navBtn\",\n                            __source: {\n                                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                                lineNumber: 43\n                            },\n                            __self: this\n                        }),\n                        session ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_heroicons_react_outline__WEBPACK_IMPORTED_MODULE_2__.PlusCircleIcon, {\n                                    onClick: ()=>setOpen(true)\n                                    ,\n                                    className: \"navBtn\",\n                                    __source: {\n                                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                                        lineNumber: 47\n                                    },\n                                    __self: this\n                                }),\n                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                                    onClick: next_auth_react__WEBPACK_IMPORTED_MODULE_4__.signOut,\n                                    src: session.user.image,\n                                    alt: \"profile pic\",\n                                    className: \" mt-2 mb-2 h-10 rounded-full cursor-pointer\",\n                                    __source: {\n                                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                                        lineNumber: 51\n                                    },\n                                    __self: this\n                                })\n                            ]\n                        }) : /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n                            onClick: next_auth_react__WEBPACK_IMPORTED_MODULE_4__.signIn,\n                            __source: {\n                                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Header.js\",\n                                lineNumber: 59\n                            },\n                            __self: this,\n                            children: \"Sign In \"\n                        })\n                    ]\n                })\n            ]\n        })\n    }));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Header);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL0hlYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QjtBQVFHO0FBQ2dCO0FBQ1k7QUFDdEI7QUFDQTtBQUNRO1NBRXRDYyxNQUFNLEdBQUcsQ0FBQztJQUNqQixLQUFLLENBQUMsQ0FBQyxDQUFDQyxJQUFJLEVBQUVDLE9BQU8sRUFBQyxDQUFDLEdBQUdOLDJEQUFVO0lBQ3BDLEtBQUssRUFBRU8sSUFBSSxFQUFFQyxPQUFPLElBQUlOLHNEQUFjLENBQUNDLHdEQUFVO0lBQ2pELEtBQUssQ0FBQ00sTUFBTSxHQUFHUixzREFBUztJQUN4QixNQUFNLHNFQUNIUyxDQUFHO1FBQUNDLFNBQVMsRUFBQyxDQUErQzs7Ozs7O3dGQUMzREQsQ0FBRztZQUFDQyxTQUFTLEVBQUMsQ0FBZ0Q7Ozs7Ozs7cUZBRTVERCxDQUFHO29CQUNGRSxPQUFPLE1BQVFILE1BQU0sQ0FBQ0ksSUFBSSxDQUFDLENBQUc7O29CQUM5QkYsU0FBUyxFQUFDLENBQTBEOzs7Ozs7bUdBRW5FckIsbURBQUs7d0JBQUN3QixHQUFHLEVBQUMsQ0FBZTt3QkFBQ0MsTUFBTSxFQUFDLENBQU07d0JBQUNDLFNBQVMsRUFBQyxDQUFTOzs7Ozs7OztxRkFFN0ROLENBQUc7b0JBQ0ZFLE9BQU8sTUFBUUgsTUFBTSxDQUFDSSxJQUFJLENBQUMsQ0FBRzs7b0JBQzlCRixTQUFTLEVBQUMsQ0FBc0Q7Ozs7OzttR0FFL0RyQixtREFBSzt3QkFDSndCLEdBQUcsRUFBQyxDQUEwRTt3QkFDOUVDLE1BQU0sRUFBQyxDQUFNO3dCQUNiQyxTQUFTLEVBQUMsQ0FBUzs7Ozs7Ozs7c0ZBS3RCTixDQUFHO29CQUFDQyxTQUFTLEVBQUMsQ0FBeUM7Ozs7Ozs7NkZBQ3JEZCw0REFBUTs0QkFBQ2UsT0FBTyxNQUFRSCxNQUFNLENBQUNJLElBQUksQ0FBQyxDQUFHOzs0QkFBR0YsU0FBUyxFQUFDLENBQVE7Ozs7Ozs7d0JBRTVETCxPQUFPOztxR0FFSGQsb0VBQWM7b0NBQ2JvQixPQUFPLE1BQVFKLE9BQU8sQ0FBQyxJQUFJOztvQ0FDM0JHLFNBQVMsRUFBQyxDQUFROzs7Ozs7O3FHQUVuQk0sQ0FBRztvQ0FDRkwsT0FBTyxFQUFFYixvREFBTztvQ0FDaEJlLEdBQUcsRUFBRVIsT0FBTyxDQUFDWSxJQUFJLENBQUNDLEtBQUs7b0NBQ3ZCQyxHQUFHLEVBQUMsQ0FBYTtvQ0FDakJULFNBQVMsRUFBQyxDQUE2Qzs7Ozs7Ozs7a0dBSTFEVSxDQUFNOzRCQUFDVCxPQUFPLEVBQUVkLG1EQUFNOzs7Ozs7c0NBQUUsQ0FBUTs7Ozs7OztBQU03QyxDQUFDO0FBRUQsaUVBQWVNLE1BQU0sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NvbXBvbmVudHMvSGVhZGVyLmpzPzRkYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XG5pbXBvcnQge1xuICBTZWFyY2hJY29uLFxuICBQbHVzQ2lyY2xlSWNvbixcbiAgVXNlckdyb3VwSWNvbixcbiAgSGVhcnRJY29uLFxuICBQYXBlckFpcnBsYW5lSWNvbixcbiAgTWVudUljb24sXG59IGZyb20gXCJAaGVyb2ljb25zL3JlYWN0L291dGxpbmVcIjtcbmltcG9ydCB7IEhvbWVJY29uIH0gZnJvbSBcIkBoZXJvaWNvbnMvcmVhY3Qvc29saWRcIjtcbmltcG9ydCB7IHNpZ25Jbiwgc2lnbk91dCwgdXNlU2Vzc2lvbiB9IGZyb20gXCJuZXh0LWF1dGgvcmVhY3RcIjtcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xuaW1wb3J0IHsgdXNlUmVjb2lsU3RhdGUgfSBmcm9tIFwicmVjb2lsXCI7XG5pbXBvcnQgeyBtb2RhbFN0YXRlIH0gZnJvbSBcIi4uL2F0b21zL21vZGFsQXRvbVwiO1xuXG5mdW5jdGlvbiBIZWFkZXIoKSB7XG4gIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xuICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VSZWNvaWxTdGF0ZShtb2RhbFN0YXRlKTtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJzaGFkb3ctc20gYm9yZGVyLWIgYmctd2hpdGUgc3RpY2t5IHRvcC0wIHotNTBcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gbWF4LXctNnhsIG14LTUgeGw6bXgtYXV0b1wiPlxuICAgICAgICB7LyogTEVGVCAqL31cbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHJvdXRlci5wdXNoKFwiL1wiKX1cbiAgICAgICAgICBjbGFzc05hbWU9XCIgbXQtMiByZWxhdGl2ZSBoaWRkZW4gbGc6aW5saW5lLWdyaWQgdy0yNCBjdXJzb3ItcG9pbnRlclwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW1hZ2Ugc3JjPVwiL3Bob3RvYXBwLnBuZ1wiIGxheW91dD1cImZpbGxcIiBvYmplY3RGaXQ9XCJjb250YWluXCIgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiByb3V0ZXIucHVzaChcIi9cIil9XG4gICAgICAgICAgY2xhc3NOYW1lPVwicmVsYXRpdmUgdy0xMCBsZzpoaWRkZW4gZmxleC1zaHJpbmstMCBjdXJzb3ItcG9pbnRlclwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW1hZ2VcbiAgICAgICAgICAgIHNyYz1cImh0dHBzOi8vd3d3LnNlZWtwbmcuY29tL3BuZy9mdWxsLzEzMS0xMzEwMzg0X3BuZy1maWxlLWRpYXJ5LWljb24tcG5nLnBuZ1wiXG4gICAgICAgICAgICBsYXlvdXQ9XCJmaWxsXCJcbiAgICAgICAgICAgIG9iamVjdEZpdD1cImNvbnRhaW5cIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIHsvKiBSSUdIVCAqL31cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWVuZCBzcGFjZS14LTRcIj5cbiAgICAgICAgICA8SG9tZUljb24gb25DbGljaz17KCkgPT4gcm91dGVyLnB1c2goXCIvXCIpfSBjbGFzc05hbWU9XCJuYXZCdG5cIiAvPlxuXG4gICAgICAgICAge3Nlc3Npb24gPyAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICA8UGx1c0NpcmNsZUljb25cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRPcGVuKHRydWUpfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm5hdkJ0blwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtzaWduT3V0fVxuICAgICAgICAgICAgICAgIHNyYz17c2Vzc2lvbi51c2VyLmltYWdlfVxuICAgICAgICAgICAgICAgIGFsdD1cInByb2ZpbGUgcGljXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCIgbXQtMiBtYi0yIGgtMTAgcm91bmRlZC1mdWxsIGN1cnNvci1wb2ludGVyXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvPlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e3NpZ25Jbn0+U2lnbiBJbiA8L2J1dHRvbj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBIZWFkZXI7XG4iXSwibmFtZXMiOlsiSW1hZ2UiLCJTZWFyY2hJY29uIiwiUGx1c0NpcmNsZUljb24iLCJVc2VyR3JvdXBJY29uIiwiSGVhcnRJY29uIiwiUGFwZXJBaXJwbGFuZUljb24iLCJNZW51SWNvbiIsIkhvbWVJY29uIiwic2lnbkluIiwic2lnbk91dCIsInVzZVNlc3Npb24iLCJ1c2VSb3V0ZXIiLCJ1c2VSZWNvaWxTdGF0ZSIsIm1vZGFsU3RhdGUiLCJIZWFkZXIiLCJkYXRhIiwic2Vzc2lvbiIsIm9wZW4iLCJzZXRPcGVuIiwicm91dGVyIiwiZGl2IiwiY2xhc3NOYW1lIiwib25DbGljayIsInB1c2giLCJzcmMiLCJsYXlvdXQiLCJvYmplY3RGaXQiLCJpbWciLCJ1c2VyIiwiaW1hZ2UiLCJhbHQiLCJidXR0b24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Header.js\n");

/***/ }),

/***/ "./components/MiniProfile.js":
/*!***********************************!*\
  !*** ./components/MiniProfile.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next-auth/react */ \"next-auth/react\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction MiniProfile() {\n    var ref, ref1;\n    const { data: session  } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_1__.useSession)();\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"flex items-center justify-between mt-14 ml-10\",\n        __source: {\n            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/MiniProfile.js\",\n            lineNumber: 5\n        },\n        __self: this,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                className: \"w-16 h-16 rounded-full border p-[2px]\",\n                src: session === null || session === void 0 ? void 0 : (ref = session.user) === null || ref === void 0 ? void 0 : ref.image,\n                alt: \"\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/MiniProfile.js\",\n                    lineNumber: 9\n                },\n                __self: this\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                className: \"flex-1 mx-4\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/MiniProfile.js\",\n                    lineNumber: 15\n                },\n                __self: this,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h2\", {\n                        className: \"font-bold\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/MiniProfile.js\",\n                            lineNumber: 16\n                        },\n                        __self: this,\n                        children: session === null || session === void 0 ? void 0 : (ref1 = session.user) === null || ref1 === void 0 ? void 0 : ref1.username\n                    }),\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"h3\", {\n                        className: \"text-sm text-gray-400\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/MiniProfile.js\",\n                            lineNumber: 17\n                        },\n                        __self: this,\n                        children: \" Welcome to Photo App\"\n                    })\n                ]\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n                onClick: next_auth_react__WEBPACK_IMPORTED_MODULE_1__.signOut,\n                className: \"text-blue-400 text-sm font-semibold\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/MiniProfile.js\",\n                    lineNumber: 19\n                },\n                __self: this,\n                children: \"Sign out\"\n            })\n        ]\n    }));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MiniProfile);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL01pbmlQcm9maWxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFxRDtTQUM1Q0UsV0FBVyxHQUFHLENBQUM7UUFTWEMsR0FBYSxFQUtTQSxJQUFhO0lBYjlDLEtBQUssQ0FBQyxDQUFDLENBQUNDLElBQUksRUFBRUQsT0FBTyxFQUFDLENBQUMsR0FBR0gsMkRBQVU7SUFDcEMsTUFBTSx1RUFDSEssQ0FBRztRQUNGQyxTQUFTLEVBQUMsQ0FDQTs7Ozs7OztpRkFFVEMsQ0FBRztnQkFDRkQsU0FBUyxFQUFDLENBQXVDO2dCQUNqREUsR0FBRyxFQUFFTCxPQUFPLGFBQVBBLE9BQU8sS0FBUEEsSUFBSSxDQUFKQSxDQUFhLEdBQWJBLElBQUksQ0FBSkEsQ0FBYSxJQUFiQSxHQUFhLEdBQWJBLE9BQU8sQ0FBRU0sSUFBSSxjQUFiTixHQUFhLEtBQWJBLElBQUksQ0FBSkEsQ0FBYSxHQUFiQSxJQUFJLENBQUpBLENBQWEsR0FBYkEsR0FBYSxDQUFFTyxLQUFLO2dCQUN6QkMsR0FBRyxFQUFDLENBQUU7Ozs7Ozs7a0ZBR1BOLENBQUc7Z0JBQUNDLFNBQVMsRUFBQyxDQUFhOzs7Ozs7O3lGQUN6Qk0sQ0FBRTt3QkFBQ04sU0FBUyxFQUFDLENBQVc7Ozs7OztrQ0FBRUgsT0FBTyxhQUFQQSxPQUFPLEtBQVBBLElBQUksQ0FBSkEsQ0FBYSxHQUFiQSxJQUFJLENBQUpBLENBQWEsSUFBYkEsSUFBYSxHQUFiQSxPQUFPLENBQUVNLElBQUksY0FBYk4sSUFBYSxLQUFiQSxJQUFJLENBQUpBLENBQWEsR0FBYkEsSUFBSSxDQUFKQSxDQUFhLEdBQWJBLElBQWEsQ0FBRVUsUUFBUTs7eUZBQ2pEQyxDQUFFO3dCQUFDUixTQUFTLEVBQUMsQ0FBdUI7Ozs7OztrQ0FBQyxDQUFxQjs7OztpRkFFNURTLENBQU07Z0JBQUNDLE9BQU8sRUFBRWYsb0RBQU87Z0JBQUVLLFNBQVMsRUFBQyxDQUFxQzs7Ozs7OzBCQUFDLENBRTFFOzs7O0FBR04sQ0FBQztBQUNELGlFQUFlSixXQUFXLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL01pbmlQcm9maWxlLmpzPzFjNmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU2Vzc2lvbiwgc2lnbk91dCB9IGZyb20gXCJuZXh0LWF1dGgvcmVhY3RcIjtcbmZ1bmN0aW9uIE1pbmlQcm9maWxlKCkge1xuICBjb25zdCB7IGRhdGE6IHNlc3Npb24gfSA9IHVzZVNlc3Npb24oKTtcbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cbiAgICBtdC0xNCBtbC0xMFwiXG4gICAgPlxuICAgICAgPGltZ1xuICAgICAgICBjbGFzc05hbWU9XCJ3LTE2IGgtMTYgcm91bmRlZC1mdWxsIGJvcmRlciBwLVsycHhdXCJcbiAgICAgICAgc3JjPXtzZXNzaW9uPy51c2VyPy5pbWFnZX1cbiAgICAgICAgYWx0PVwiXCJcbiAgICAgIC8+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIG14LTRcIj5cbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cImZvbnQtYm9sZFwiPntzZXNzaW9uPy51c2VyPy51c2VybmFtZX08L2gyPlxuICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNDAwXCI+IFdlbGNvbWUgdG8gUGhvdG8gQXBwPC9oMz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtzaWduT3V0fSBjbGFzc05hbWU9XCJ0ZXh0LWJsdWUtNDAwIHRleHQtc20gZm9udC1zZW1pYm9sZFwiPlxuICAgICAgICBTaWduIG91dFxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59XG5leHBvcnQgZGVmYXVsdCBNaW5pUHJvZmlsZTtcbiJdLCJuYW1lcyI6WyJ1c2VTZXNzaW9uIiwic2lnbk91dCIsIk1pbmlQcm9maWxlIiwic2Vzc2lvbiIsImRhdGEiLCJkaXYiLCJjbGFzc05hbWUiLCJpbWciLCJzcmMiLCJ1c2VyIiwiaW1hZ2UiLCJhbHQiLCJoMiIsInVzZXJuYW1lIiwiaDMiLCJidXR0b24iLCJvbkNsaWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/MiniProfile.js\n");

/***/ }),

/***/ "./components/Modal.js":
/*!*****************************!*\
  !*** ./components/Modal.js ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! recoil */ \"recoil\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(recoil__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _atoms_modalAtom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../atoms/modalAtom */ \"./atoms/modalAtom.js\");\n/* harmony import */ var _headlessui_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @headlessui/react */ \"@headlessui/react\");\n/* harmony import */ var _heroicons_react_outline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @heroicons/react/outline */ \"@heroicons/react/outline\");\n/* harmony import */ var _heroicons_react_outline__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_heroicons_react_outline__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../firebase */ \"./firebase.js\");\n/* harmony import */ var _firebase_firestore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @firebase/firestore */ \"./node_modules/@firebase/firestore/dist/index.node.mjs\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next-auth/react */ \"next-auth/react\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _firebase_storage__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @firebase/storage */ \"@firebase/storage\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_headlessui_react__WEBPACK_IMPORTED_MODULE_3__, _firebase__WEBPACK_IMPORTED_MODULE_6__, _firebase_firestore__WEBPACK_IMPORTED_MODULE_7__, _firebase_storage__WEBPACK_IMPORTED_MODULE_9__]);\n([_headlessui_react__WEBPACK_IMPORTED_MODULE_3__, _firebase__WEBPACK_IMPORTED_MODULE_6__, _firebase_firestore__WEBPACK_IMPORTED_MODULE_7__, _firebase_storage__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\nfunction Modal() {\n    const { data: session  } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_8__.useSession)();\n    const [open, setOpen] = (0,recoil__WEBPACK_IMPORTED_MODULE_1__.useRecoilState)(_atoms_modalAtom__WEBPACK_IMPORTED_MODULE_2__.modalState);\n    const filePickerRef = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(null);\n    const { 0: selectedFile , 1: setSelectedFile  } = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(null);\n    const captionRef = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(null);\n    const { 0: loading , 1: setLoading  } = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(false);\n    const uploadPost = async ()=>{\n        if (loading) return;\n        setLoading(true);\n        const docRef = await (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_7__.addDoc)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_7__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_6__.db, \"posts\"), {\n            username: session.user.username,\n            caption: captionRef.current.value,\n            profileImg: session.user.image,\n            timestamp: (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_7__.serverTimestamp)()\n        });\n        console.log(\"New doc added with ID\", docRef.id);\n        const imageRef = (0,_firebase_storage__WEBPACK_IMPORTED_MODULE_9__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_6__.storage, `posts/${docRef.id}/image`);\n        await (0,_firebase_storage__WEBPACK_IMPORTED_MODULE_9__.uploadString)(imageRef, selectedFile, \"data_url\").then(async (snapshot)=>{\n            const downloadURL = await (0,_firebase_storage__WEBPACK_IMPORTED_MODULE_9__.getDownloadURL)(imageRef);\n            await (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_7__.updateDoc)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_7__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_6__.db, \"posts\", docRef.id), {\n                image: downloadURL\n            });\n        });\n        setOpen(false);\n        setLoading(false);\n        setSelectedFile(null);\n    };\n    const addImageToPost = (e)=>{\n        const reader = new FileReader();\n        if (e.target.files[0]) {\n            reader.readAsDataURL(e.target.files[0]);\n        }\n        reader.onload = (readerEvent)=>{\n            setSelectedFile(readerEvent.target.result);\n        };\n    };\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_headlessui_react__WEBPACK_IMPORTED_MODULE_3__.Transition.Root, {\n        show: open,\n        as: react__WEBPACK_IMPORTED_MODULE_5__.Fragment,\n        __source: {\n            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n            lineNumber: 59\n        },\n        __self: this,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_headlessui_react__WEBPACK_IMPORTED_MODULE_3__.Dialog, {\n            as: \"div\",\n            className: \"fixed z-10 inset-0 overflow-y-auto\",\n            onClose: setOpen,\n            __source: {\n                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                lineNumber: 60\n            },\n            __self: this,\n            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                className: \"flex items-end justify-center min-h-[800px] sm:min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                    lineNumber: 65\n                },\n                __self: this,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_headlessui_react__WEBPACK_IMPORTED_MODULE_3__.Transition.Child, {\n                        as: react__WEBPACK_IMPORTED_MODULE_5__.Fragment,\n                        enter: \"ease-out duration-300\",\n                        enterFrom: \"opacity-0\",\n                        enterTo: \"opacity-100\",\n                        leave: \"ease-in duration-200\",\n                        leaveFrom: \"opacity-100\",\n                        leaveTo: \"opacity-0\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                            lineNumber: 66\n                        },\n                        __self: this,\n                        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_headlessui_react__WEBPACK_IMPORTED_MODULE_3__.Dialog.Overlay, {\n                            className: \"fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity\",\n                            __source: {\n                                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                lineNumber: 75\n                            },\n                            __self: this\n                        })\n                    }),\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                        className: \"hidden sm:inline-block sm:align-middle sm:h-screen\",\n                        \"aria-hidden\": \"true\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                            lineNumber: 78\n                        },\n                        __self: this\n                    }),\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_headlessui_react__WEBPACK_IMPORTED_MODULE_3__.Transition.Child, {\n                        as: react__WEBPACK_IMPORTED_MODULE_5__.Fragment,\n                        enter: \"ease-out duration-300\",\n                        enterfrom: \"opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95\",\n                        enterTo: \"opacity-100 translate-y-0 sm:scale-100\",\n                        leave: \"ease-in duration-200\",\n                        leaveFrom: \"opacity-100 translate-y-0 sm: scale-100\",\n                        leaveTo: \"opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                            lineNumber: 83\n                        },\n                        __self: this,\n                        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                            className: \"inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-sm sm:w-full sm:p-6\",\n                            __source: {\n                                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                lineNumber: 92\n                            },\n                            __self: this,\n                            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                                __source: {\n                                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                    lineNumber: 98\n                                },\n                                __self: this,\n                                children: [\n                                    selectedFile ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                                        src: selectedFile,\n                                        className: \"w-full object-contain cursor-pointer\",\n                                        onClick: ()=>setSelectedFile(null)\n                                        ,\n                                        alt: \"\",\n                                        __source: {\n                                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                            lineNumber: 100\n                                        },\n                                        __self: this\n                                    }) : /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                                        onClick: ()=>filePickerRef.current.click()\n                                        ,\n                                        className: \"mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 cursor-pointer\",\n                                        __source: {\n                                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                            lineNumber: 107\n                                        },\n                                        __self: this,\n                                        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_heroicons_react_outline__WEBPACK_IMPORTED_MODULE_4__.CameraIcon, {\n                                            className: \"h-6 w-6 text-red-600\",\n                                            \"aria-hidden\": \"true\",\n                                            __source: {\n                                                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                                lineNumber: 111\n                                            },\n                                            __self: this\n                                        })\n                                    }),\n                                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                                        __source: {\n                                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                            lineNumber: 118\n                                        },\n                                        __self: this,\n                                        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                                            className: \"mt-3 text-center sm:mt-5\",\n                                            __source: {\n                                                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                                lineNumber: 119\n                                            },\n                                            __self: this,\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_headlessui_react__WEBPACK_IMPORTED_MODULE_3__.Dialog.Title, {\n                                                    as: \"h3\",\n                                                    className: \"text-lg leading-6 font-medium text-gray-900\",\n                                                    __source: {\n                                                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                                        lineNumber: 120\n                                                    },\n                                                    __self: this,\n                                                    children: \"Upload a photo\"\n                                                }),\n                                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                                                    __source: {\n                                                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                                        lineNumber: 127\n                                                    },\n                                                    __self: this,\n                                                    children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", {\n                                                        ref: filePickerRef,\n                                                        type: \"file\",\n                                                        hidden: true,\n                                                        onChange: addImageToPost,\n                                                        __source: {\n                                                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                                            lineNumber: 128\n                                                        },\n                                                        __self: this\n                                                    })\n                                                }),\n                                                /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                                                    className: \"mt-2\",\n                                                    __source: {\n                                                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                                        lineNumber: 135\n                                                    },\n                                                    __self: this,\n                                                    children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", {\n                                                        className: \"border-none focus:ring-0 w-full text-center\",\n                                                        type: \"text\",\n                                                        ref: captionRef,\n                                                        placeholder: \"Please enter a caption...\",\n                                                        __source: {\n                                                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                                            lineNumber: 136\n                                                        },\n                                                        __self: this\n                                                    })\n                                                })\n                                            ]\n                                        })\n                                    }),\n                                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                                        className: \"mt-5 sm:mt-6\",\n                                        __source: {\n                                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                            lineNumber: 145\n                                        },\n                                        __self: this,\n                                        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n                                            type: \"button\",\n                                            disabled: !selectedFile,\n                                            className: \"inline-flex justify-center w-full rounded-md border border-transparent shadow-sm px-4 py-2 bg-red-600 text-base font-medium text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 sm:text-sm disabled:bg-gray-300 disabled:cursor-not-allowed hover:disabled:bg-gray-300\",\n                                            onClick: uploadPost,\n                                            __source: {\n                                                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Modal.js\",\n                                                lineNumber: 146\n                                            },\n                                            __self: this,\n                                            children: loading ? \"Uploading ... \" : \"Upload Post\"\n                                        })\n                                    })\n                                ]\n                            })\n                        })\n                    })\n                ]\n            })\n        })\n    }));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Modal);\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL01vZGFsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ1E7QUFDTztBQUNEO0FBQ0g7QUFDVDtBQU9iO0FBQ2dCO0FBQ3lCO1NBQzVEbUIsS0FBSyxHQUFHLENBQUM7SUFDaEIsS0FBSyxDQUFDLENBQUMsQ0FBQ0MsSUFBSSxFQUFFQyxPQUFPLEVBQUMsQ0FBQyxHQUFHTiwyREFBVTtJQUNwQyxLQUFLLEVBQUVPLElBQUksRUFBRUMsT0FBTyxJQUFJdkIsc0RBQWMsQ0FBQ0Msd0RBQVU7SUFDakQsS0FBSyxDQUFDdUIsYUFBYSxHQUFHbEIsNkNBQU0sQ0FBQyxJQUFJO0lBQ2pDLEtBQUssTUFBRW1CLFlBQVksTUFBRUMsZUFBZSxNQUFJbkIsK0NBQVEsQ0FBQyxJQUFJO0lBQ3JELEtBQUssQ0FBQ29CLFVBQVUsR0FBR3JCLDZDQUFNLENBQUMsSUFBSTtJQUM5QixLQUFLLE1BQUVzQixPQUFPLE1BQUVDLFVBQVUsTUFBSXRCLCtDQUFRLENBQUMsS0FBSztJQUM1QyxLQUFLLENBQUN1QixVQUFVLGFBQWUsQ0FBQztRQUM5QixFQUFFLEVBQUVGLE9BQU8sRUFBRSxNQUFNO1FBQ25CQyxVQUFVLENBQUMsSUFBSTtRQUVmLEtBQUssQ0FBQ0UsTUFBTSxHQUFHLEtBQUssQ0FBQ3JCLDJEQUFNLENBQUNJLCtEQUFVLENBQUNOLHlDQUFFLEVBQUUsQ0FBTyxTQUFHLENBQUM7WUFDcER3QixRQUFRLEVBQUVYLE9BQU8sQ0FBQ1ksSUFBSSxDQUFDRCxRQUFRO1lBQy9CRSxPQUFPLEVBQUVQLFVBQVUsQ0FBQ1EsT0FBTyxDQUFDQyxLQUFLO1lBQ2pDQyxVQUFVLEVBQUVoQixPQUFPLENBQUNZLElBQUksQ0FBQ0ssS0FBSztZQUM5QkMsU0FBUyxFQUFFNUIsb0VBQWU7UUFDNUIsQ0FBQztRQUVENkIsT0FBTyxDQUFDQyxHQUFHLENBQUMsQ0FBdUIsd0JBQUVWLE1BQU0sQ0FBQ1csRUFBRTtRQUM5QyxLQUFLLENBQUNDLFFBQVEsR0FBRzNCLHNEQUFHLENBQUNQLDhDQUFPLEdBQUcsTUFBTSxFQUFFc0IsTUFBTSxDQUFDVyxFQUFFLENBQUMsTUFBTTtRQUV2RCxLQUFLLENBQUN4QiwrREFBWSxDQUFDeUIsUUFBUSxFQUFFbEIsWUFBWSxFQUFFLENBQVUsV0FBRW1CLElBQUksUUFDbERDLFFBQVEsR0FBSyxDQUFDO1lBQ25CLEtBQUssQ0FBQ0MsV0FBVyxHQUFHLEtBQUssQ0FBQzdCLGlFQUFjLENBQUMwQixRQUFRO1lBQ2pELEtBQUssQ0FBQy9CLDhEQUFTLENBQUNDLHdEQUFHLENBQUNMLHlDQUFFLEVBQUUsQ0FBTyxRQUFFdUIsTUFBTSxDQUFDVyxFQUFFLEdBQUcsQ0FBQztnQkFDNUNKLEtBQUssRUFBRVEsV0FBVztZQUNwQixDQUFDO1FBQ0gsQ0FBQztRQUVIdkIsT0FBTyxDQUFDLEtBQUs7UUFDYk0sVUFBVSxDQUFDLEtBQUs7UUFDaEJILGVBQWUsQ0FBQyxJQUFJO0lBQ3RCLENBQUM7SUFDRCxLQUFLLENBQUNxQixjQUFjLElBQUlDLENBQUMsR0FBSyxDQUFDO1FBQzdCLEtBQUssQ0FBQ0MsTUFBTSxHQUFHLEdBQUcsQ0FBQ0MsVUFBVTtRQUM3QixFQUFFLEVBQUVGLENBQUMsQ0FBQ0csTUFBTSxDQUFDQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUM7WUFDdEJILE1BQU0sQ0FBQ0ksYUFBYSxDQUFDTCxDQUFDLENBQUNHLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDLENBQUM7UUFDdkMsQ0FBQztRQUNESCxNQUFNLENBQUNLLE1BQU0sSUFBSUMsV0FBVyxHQUFLLENBQUM7WUFDaEM3QixlQUFlLENBQUM2QixXQUFXLENBQUNKLE1BQU0sQ0FBQ0ssTUFBTTtRQUMzQyxDQUFDO0lBQ0gsQ0FBQztJQUNELE1BQU0sc0VBQ0hyRCw4REFBZTtRQUFDdUQsSUFBSSxFQUFFcEMsSUFBSTtRQUFFcUMsRUFBRSxFQUFFdEQsMkNBQVE7Ozs7Ozt1RkFDdENILHFEQUFNO1lBQ0x5RCxFQUFFLEVBQUMsQ0FBSztZQUNSQyxTQUFTLEVBQUMsQ0FBb0M7WUFDOUNDLE9BQU8sRUFBRXRDLE9BQU87Ozs7Ozs0RkFFZnVDLENBQUc7Z0JBQUNGLFNBQVMsRUFBQyxDQUF5Rzs7Ozs7Ozt5RkFDckh6RCwrREFBZ0I7d0JBQ2Z3RCxFQUFFLEVBQUV0RCwyQ0FBUTt3QkFDWjJELEtBQUssRUFBQyxDQUF1Qjt3QkFDN0JDLFNBQVMsRUFBQyxDQUFXO3dCQUNyQkMsT0FBTyxFQUFDLENBQWE7d0JBQ3JCQyxLQUFLLEVBQUMsQ0FBc0I7d0JBQzVCQyxTQUFTLEVBQUMsQ0FBYTt3QkFDdkJDLE9BQU8sRUFBQyxDQUFXOzs7Ozs7dUdBRWxCbkUsNkRBQWM7NEJBQUMwRCxTQUFTLEVBQUMsQ0FBNEQ7Ozs7Ozs7O3lGQUd2RlcsQ0FBSTt3QkFDSFgsU0FBUyxFQUFDLENBQW9EO3dCQUM5RFksQ0FBVyxjQUFDLENBQU07Ozs7Ozs7eUZBR25CckUsK0RBQWdCO3dCQUNmd0QsRUFBRSxFQUFFdEQsMkNBQVE7d0JBQ1oyRCxLQUFLLEVBQUMsQ0FBdUI7d0JBQzdCUyxTQUFTLEVBQUMsQ0FBc0Q7d0JBQ2hFUCxPQUFPLEVBQUMsQ0FBd0M7d0JBQ2hEQyxLQUFLLEVBQUMsQ0FBc0I7d0JBQzVCQyxTQUFTLEVBQUMsQ0FBeUM7d0JBQ25EQyxPQUFPLEVBQUMsQ0FBc0Q7Ozs7Ozt1R0FFN0RQLENBQUc7NEJBQ0ZGLFNBQVMsRUFBQyxDQUd5Qzs7Ozs7OzRHQUVsREUsQ0FBRzs7Ozs7OztvQ0FDRHJDLFlBQVksd0VBQ1ZpRCxDQUFHO3dDQUNGQyxHQUFHLEVBQUVsRCxZQUFZO3dDQUNqQm1DLFNBQVMsRUFBQyxDQUFzQzt3Q0FDaERnQixPQUFPLE1BQVFsRCxlQUFlLENBQUMsSUFBSTs7d0NBQ25DbUQsR0FBRyxFQUFDLENBQUU7Ozs7Ozs4R0FHUGYsQ0FBRzt3Q0FDRmMsT0FBTyxNQUFRcEQsYUFBYSxDQUFDVyxPQUFPLENBQUMyQyxLQUFLOzt3Q0FDMUNsQixTQUFTLEVBQUMsQ0FBMkY7Ozs7Ozt1SEFFcEd4RCxnRUFBVTs0Q0FDVHdELFNBQVMsRUFBQyxDQUFzQjs0Q0FDaENZLENBQVcsY0FBQyxDQUFNOzs7Ozs7Ozt5R0FLdkJWLENBQUc7Ozs7Ozt3SEFDREEsQ0FBRzs0Q0FBQ0YsU0FBUyxFQUFDLENBQTBCOzs7Ozs7O3FIQUN0QzFELDJEQUFZO29EQUNYeUQsRUFBRSxFQUFDLENBQUk7b0RBQ1BDLFNBQVMsRUFBQyxDQUE2Qzs7Ozs7OzhEQUN4RCxDQUVEOztxSEFFQ0UsQ0FBRzs7Ozs7O21JQUNEa0IsQ0FBSzt3REFDSmhFLEdBQUcsRUFBRVEsYUFBYTt3REFDbEJ5RCxJQUFJLEVBQUMsQ0FBTTt3REFDWEMsTUFBTTt3REFDTkMsUUFBUSxFQUFFcEMsY0FBYzs7Ozs7Ozs7cUhBRzNCZSxDQUFHO29EQUFDRixTQUFTLEVBQUMsQ0FBTTs7Ozs7O21JQUNsQm9CLENBQUs7d0RBQ0pwQixTQUFTLEVBQUMsQ0FBNkM7d0RBQ3ZEcUIsSUFBSSxFQUFDLENBQU07d0RBQ1hqRSxHQUFHLEVBQUVXLFVBQVU7d0RBQ2Z5RCxXQUFXLEVBQUMsQ0FBMkI7Ozs7Ozs7Ozs7O3lHQUs5Q3RCLENBQUc7d0NBQUNGLFNBQVMsRUFBQyxDQUFjOzs7Ozs7dUhBQzFCeUIsQ0FBTTs0Q0FDTEosSUFBSSxFQUFDLENBQVE7NENBQ2JLLFFBQVEsR0FBRzdELFlBQVk7NENBQ3ZCbUMsU0FBUyxFQUFDLENBR2dHOzRDQUMxR2dCLE9BQU8sRUFBRTlDLFVBQVU7Ozs7OztzREFFbEJGLE9BQU8sR0FBRyxDQUFnQixrQkFBRyxDQUFhOzs7Ozs7Ozs7OztBQVUvRCxDQUFDO0FBRUQsaUVBQWVULEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NvbXBvbmVudHMvTW9kYWwuanM/MDI4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSZWNvaWxTdGF0ZSB9IGZyb20gXCJyZWNvaWxcIjtcbmltcG9ydCB7IG1vZGFsU3RhdGUgfSBmcm9tIFwiLi4vYXRvbXMvbW9kYWxBdG9tXCI7XG5pbXBvcnQgeyBEaWFsb2csIFRyYW5zaXRpb24gfSBmcm9tIFwiQGhlYWRsZXNzdWkvcmVhY3RcIjtcbmltcG9ydCB7IENhbWVyYUljb24gfSBmcm9tIFwiQGhlcm9pY29ucy9yZWFjdC9vdXRsaW5lXCI7XG5pbXBvcnQgeyBGcmFnbWVudCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZGIsIHN0b3JhZ2UgfSBmcm9tIFwiLi4vZmlyZWJhc2VcIjtcbmltcG9ydCB7XG4gIGFkZERvYyxcbiAgc2VydmVyVGltZXN0YW1wLFxuICB1cGRhdGVEb2MsXG4gIGRvYyxcbiAgY29sbGVjdGlvbixcbn0gZnJvbSBcIkBmaXJlYmFzZS9maXJlc3RvcmVcIjtcbmltcG9ydCB7IHVzZVNlc3Npb24gfSBmcm9tIFwibmV4dC1hdXRoL3JlYWN0XCI7XG5pbXBvcnQgeyByZWYsIGdldERvd25sb2FkVVJMLCB1cGxvYWRTdHJpbmcgfSBmcm9tIFwiQGZpcmViYXNlL3N0b3JhZ2VcIjtcbmZ1bmN0aW9uIE1vZGFsKCkge1xuICBjb25zdCB7IGRhdGE6IHNlc3Npb24gfSA9IHVzZVNlc3Npb24oKTtcbiAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlUmVjb2lsU3RhdGUobW9kYWxTdGF0ZSk7XG4gIGNvbnN0IGZpbGVQaWNrZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY2FwdGlvblJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB1cGxvYWRQb3N0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChsb2FkaW5nKSByZXR1cm47XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcblxuICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCBcInBvc3RzXCIpLCB7XG4gICAgICB1c2VybmFtZTogc2Vzc2lvbi51c2VyLnVzZXJuYW1lLFxuICAgICAgY2FwdGlvbjogY2FwdGlvblJlZi5jdXJyZW50LnZhbHVlLFxuICAgICAgcHJvZmlsZUltZzogc2Vzc2lvbi51c2VyLmltYWdlLFxuICAgICAgdGltZXN0YW1wOiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKFwiTmV3IGRvYyBhZGRlZCB3aXRoIElEXCIsIGRvY1JlZi5pZCk7XG4gICAgY29uc3QgaW1hZ2VSZWYgPSByZWYoc3RvcmFnZSwgYHBvc3RzLyR7ZG9jUmVmLmlkfS9pbWFnZWApO1xuXG4gICAgYXdhaXQgdXBsb2FkU3RyaW5nKGltYWdlUmVmLCBzZWxlY3RlZEZpbGUsIFwiZGF0YV91cmxcIikudGhlbihcbiAgICAgIGFzeW5jIChzbmFwc2hvdCkgPT4ge1xuICAgICAgICBjb25zdCBkb3dubG9hZFVSTCA9IGF3YWl0IGdldERvd25sb2FkVVJMKGltYWdlUmVmKTtcbiAgICAgICAgYXdhaXQgdXBkYXRlRG9jKGRvYyhkYiwgXCJwb3N0c1wiLCBkb2NSZWYuaWQpLCB7XG4gICAgICAgICAgaW1hZ2U6IGRvd25sb2FkVVJMLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIHNldE9wZW4oZmFsc2UpO1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIHNldFNlbGVjdGVkRmlsZShudWxsKTtcbiAgfTtcbiAgY29uc3QgYWRkSW1hZ2VUb1Bvc3QgPSAoZSkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgaWYgKGUudGFyZ2V0LmZpbGVzWzBdKSB7XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChlLnRhcmdldC5maWxlc1swXSk7XG4gICAgfVxuICAgIHJlYWRlci5vbmxvYWQgPSAocmVhZGVyRXZlbnQpID0+IHtcbiAgICAgIHNldFNlbGVjdGVkRmlsZShyZWFkZXJFdmVudC50YXJnZXQucmVzdWx0KTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gKFxuICAgIDxUcmFuc2l0aW9uLlJvb3Qgc2hvdz17b3Blbn0gYXM9e0ZyYWdtZW50fT5cbiAgICAgIDxEaWFsb2dcbiAgICAgICAgYXM9XCJkaXZcIlxuICAgICAgICBjbGFzc05hbWU9XCJmaXhlZCB6LTEwIGluc2V0LTAgb3ZlcmZsb3cteS1hdXRvXCJcbiAgICAgICAgb25DbG9zZT17c2V0T3Blbn1cbiAgICAgID5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWVuZCBqdXN0aWZ5LWNlbnRlciBtaW4taC1bODAwcHhdIHNtOm1pbi1oLXNjcmVlbiBwdC00IHB4LTQgcGItMjAgdGV4dC1jZW50ZXIgc206YmxvY2sgc206cC0wXCI+XG4gICAgICAgICAgPFRyYW5zaXRpb24uQ2hpbGRcbiAgICAgICAgICAgIGFzPXtGcmFnbWVudH1cbiAgICAgICAgICAgIGVudGVyPVwiZWFzZS1vdXQgZHVyYXRpb24tMzAwXCJcbiAgICAgICAgICAgIGVudGVyRnJvbT1cIm9wYWNpdHktMFwiXG4gICAgICAgICAgICBlbnRlclRvPVwib3BhY2l0eS0xMDBcIlxuICAgICAgICAgICAgbGVhdmU9XCJlYXNlLWluIGR1cmF0aW9uLTIwMFwiXG4gICAgICAgICAgICBsZWF2ZUZyb209XCJvcGFjaXR5LTEwMFwiXG4gICAgICAgICAgICBsZWF2ZVRvPVwib3BhY2l0eS0wXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8RGlhbG9nLk92ZXJsYXkgY2xhc3NOYW1lPVwiZml4ZWQgaW5zZXQtMCBiZy1ncmF5LTUwMCBiZy1vcGFjaXR5LTc1IHRyYW5zaXRpb24tb3BhY2l0eVwiIC8+XG4gICAgICAgICAgPC9UcmFuc2l0aW9uLkNoaWxkPlxuXG4gICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImhpZGRlbiBzbTppbmxpbmUtYmxvY2sgc206YWxpZ24tbWlkZGxlIHNtOmgtc2NyZWVuXCJcbiAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICAgPjwvc3Bhbj5cblxuICAgICAgICAgIDxUcmFuc2l0aW9uLkNoaWxkXG4gICAgICAgICAgICBhcz17RnJhZ21lbnR9XG4gICAgICAgICAgICBlbnRlcj1cImVhc2Utb3V0IGR1cmF0aW9uLTMwMFwiXG4gICAgICAgICAgICBlbnRlcmZyb209XCJvcGFjaXR5LTAgdHJhbnNsYXRlLXktNCBzbTp0cmFuc2xhdGUteS0wIHNtOnNjYWxlLTk1XCJcbiAgICAgICAgICAgIGVudGVyVG89XCJvcGFjaXR5LTEwMCB0cmFuc2xhdGUteS0wIHNtOnNjYWxlLTEwMFwiXG4gICAgICAgICAgICBsZWF2ZT1cImVhc2UtaW4gZHVyYXRpb24tMjAwXCJcbiAgICAgICAgICAgIGxlYXZlRnJvbT1cIm9wYWNpdHktMTAwIHRyYW5zbGF0ZS15LTAgc206IHNjYWxlLTEwMFwiXG4gICAgICAgICAgICBsZWF2ZVRvPVwib3BhY2l0eS0wIHRyYW5zbGF0ZS15LTQgc206dHJhbnNsYXRlLXktMCBzbTpzY2FsZS05NVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJpbmxpbmUtYmxvY2sgYWxpZ24tYm90dG9tIFxuICAgICAgICAgICAgYmctd2hpdGUgcm91bmRlZC1sZyBweC00IHB0LTUgcGItNCB0ZXh0LWxlZnQgXG4gICAgICAgICAgICBvdmVyZmxvdy1oaWRkZW4gc2hhZG93LXhsIHRyYW5zZm9ybSB0cmFuc2l0aW9uLWFsbCBcbiAgICAgICAgICAgIHNtOm15LTggc206YWxpZ24tbWlkZGxlIHNtOm1heC13LXNtIHNtOnctZnVsbCBzbTpwLTZcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIHtzZWxlY3RlZEZpbGUgPyAoXG4gICAgICAgICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgICAgICAgIHNyYz17c2VsZWN0ZWRGaWxlfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgb2JqZWN0LWNvbnRhaW4gY3Vyc29yLXBvaW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZEZpbGUobnVsbCl9XG4gICAgICAgICAgICAgICAgICAgIGFsdD1cIlwiXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGZpbGVQaWNrZXJSZWYuY3VycmVudC5jbGljaygpfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJteC1hdXRvIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGgtMTIgdy0xMiByb3VuZGVkLWZ1bGwgYmctcmVkLTEwMCBjdXJzb3ItcG9pbnRlclwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxDYW1lcmFJY29uXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaC02IHctNiB0ZXh0LXJlZC02MDBcIlxuICAgICAgICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMyB0ZXh0LWNlbnRlciBzbTptdC01XCI+XG4gICAgICAgICAgICAgICAgICAgIDxEaWFsb2cuVGl0bGVcbiAgICAgICAgICAgICAgICAgICAgICBhcz1cImgzXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LWxnIGxlYWRpbmctNiBmb250LW1lZGl1bSB0ZXh0LWdyYXktOTAwXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIFVwbG9hZCBhIHBob3RvXG4gICAgICAgICAgICAgICAgICAgIDwvRGlhbG9nLlRpdGxlPlxuXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY9e2ZpbGVQaWNrZXJSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXthZGRJbWFnZVRvUG9zdH1cbiAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJib3JkZXItbm9uZSBmb2N1czpyaW5nLTAgdy1mdWxsIHRleHQtY2VudGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17Y2FwdGlvblJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiUGxlYXNlIGVudGVyIGEgY2FwdGlvbi4uLlwiXG4gICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTUgc206bXQtNlwiPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFzZWxlY3RlZEZpbGV9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImlubGluZS1mbGV4IGp1c3RpZnktY2VudGVyIHctZnVsbCByb3VuZGVkLW1kIFxuICAgICAgICAgICAgICAgICAgICBib3JkZXIgYm9yZGVyLXRyYW5zcGFyZW50IHNoYWRvdy1zbSBweC00IHB5LTIgYmctcmVkLTYwMFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LWJhc2UgZm9udC1tZWRpdW0gdGV4dC13aGl0ZSBob3ZlcjpiZy1yZWQtNzAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1vZmZzZXQtMlxuICAgICAgICAgICAgICAgICAgICBmb2N1czpyaW5nLXJlZC01MDAgc206dGV4dC1zbSBkaXNhYmxlZDpiZy1ncmF5LTMwMCBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgaG92ZXI6ZGlzYWJsZWQ6YmctZ3JheS0zMDBcIlxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXt1cGxvYWRQb3N0fVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICB7bG9hZGluZyA/IFwiVXBsb2FkaW5nIC4uLiBcIiA6IFwiVXBsb2FkIFBvc3RcIn1cbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvVHJhbnNpdGlvbi5DaGlsZD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0RpYWxvZz5cbiAgICA8L1RyYW5zaXRpb24uUm9vdD5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kYWw7XG4iXSwibmFtZXMiOlsidXNlUmVjb2lsU3RhdGUiLCJtb2RhbFN0YXRlIiwiRGlhbG9nIiwiVHJhbnNpdGlvbiIsIkNhbWVyYUljb24iLCJGcmFnbWVudCIsInVzZVJlZiIsInVzZVN0YXRlIiwiZGIiLCJzdG9yYWdlIiwiYWRkRG9jIiwic2VydmVyVGltZXN0YW1wIiwidXBkYXRlRG9jIiwiZG9jIiwiY29sbGVjdGlvbiIsInVzZVNlc3Npb24iLCJyZWYiLCJnZXREb3dubG9hZFVSTCIsInVwbG9hZFN0cmluZyIsIk1vZGFsIiwiZGF0YSIsInNlc3Npb24iLCJvcGVuIiwic2V0T3BlbiIsImZpbGVQaWNrZXJSZWYiLCJzZWxlY3RlZEZpbGUiLCJzZXRTZWxlY3RlZEZpbGUiLCJjYXB0aW9uUmVmIiwibG9hZGluZyIsInNldExvYWRpbmciLCJ1cGxvYWRQb3N0IiwiZG9jUmVmIiwidXNlcm5hbWUiLCJ1c2VyIiwiY2FwdGlvbiIsImN1cnJlbnQiLCJ2YWx1ZSIsInByb2ZpbGVJbWciLCJpbWFnZSIsInRpbWVzdGFtcCIsImNvbnNvbGUiLCJsb2ciLCJpZCIsImltYWdlUmVmIiwidGhlbiIsInNuYXBzaG90IiwiZG93bmxvYWRVUkwiLCJhZGRJbWFnZVRvUG9zdCIsImUiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwidGFyZ2V0IiwiZmlsZXMiLCJyZWFkQXNEYXRhVVJMIiwib25sb2FkIiwicmVhZGVyRXZlbnQiLCJyZXN1bHQiLCJSb290Iiwic2hvdyIsImFzIiwiY2xhc3NOYW1lIiwib25DbG9zZSIsImRpdiIsIkNoaWxkIiwiZW50ZXIiLCJlbnRlckZyb20iLCJlbnRlclRvIiwibGVhdmUiLCJsZWF2ZUZyb20iLCJsZWF2ZVRvIiwiT3ZlcmxheSIsInNwYW4iLCJhcmlhLWhpZGRlbiIsImVudGVyZnJvbSIsImltZyIsInNyYyIsIm9uQ2xpY2siLCJhbHQiLCJjbGljayIsIlRpdGxlIiwiaW5wdXQiLCJ0eXBlIiwiaGlkZGVuIiwib25DaGFuZ2UiLCJwbGFjZWhvbGRlciIsImJ1dHRvbiIsImRpc2FibGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Modal.js\n");

/***/ }),

/***/ "./components/Post.js":
/*!****************************!*\
  !*** ./components/Post.js ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/firestore */ \"./node_modules/@firebase/firestore/dist/index.node.mjs\");\n/* harmony import */ var _heroicons_react_outline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @heroicons/react/outline */ \"@heroicons/react/outline\");\n/* harmony import */ var _heroicons_react_outline__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_heroicons_react_outline__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _heroicons_react_solid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @heroicons/react/solid */ \"@heroicons/react/solid\");\n/* harmony import */ var _heroicons_react_solid__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_heroicons_react_solid__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next-auth/react */ \"next-auth/react\");\n/* harmony import */ var next_auth_react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_auth_react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../firebase */ \"./firebase.js\");\n/* harmony import */ var react_moment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-moment */ \"react-moment\");\n/* harmony import */ var react_moment__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react_moment__WEBPACK_IMPORTED_MODULE_7__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__, _firebase__WEBPACK_IMPORTED_MODULE_6__]);\n([_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__, _firebase__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\nfunction Post({ id , username , userImg , img , caption  }) {\n    const { data: session  } = (0,next_auth_react__WEBPACK_IMPORTED_MODULE_4__.useSession)();\n    const { 0: comments , 1: setComments  } = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)([]);\n    const { 0: comment1 , 1: setComment  } = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(\"\");\n    const { 0: likes , 1: setLikes  } = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)([]);\n    const { 0: hasLiked , 1: setHasLiked  } = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)(()=>(0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_6__.db, \"posts\", id, \"comments\"), (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)(\"timestamp\", \"desc\")), (snapshot)=>setComments(snapshot.docs)\n        )\n    , [\n        _firebase__WEBPACK_IMPORTED_MODULE_6__.db,\n        id\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)(()=>(0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_6__.db, \"posts\", id, \"likes\"), (snapshot)=>setLikes(snapshot.docs)\n        )\n    , [\n        _firebase__WEBPACK_IMPORTED_MODULE_6__.db,\n        id\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)(()=>{\n        return setHasLiked(likes.findIndex((like)=>{\n            var ref;\n            return like.id === (session === null || session === void 0 ? void 0 : (ref = session.user) === null || ref === void 0 ? void 0 : ref.uid);\n        }) !== -1);\n    }, [\n        likes\n    ]);\n    const likePost = async ()=>{\n        if (hasLiked) {\n            await (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.deleteDoc)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_6__.db, \"posts\", id, \"likes\", session.user.uid));\n        } else {\n            await (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_firebase__WEBPACK_IMPORTED_MODULE_6__.db, \"posts\", id, \"likes\", session.user.uid), {\n                username: session.user.username\n            });\n        }\n    };\n    console.log(hasLiked);\n    const sendComment = async (e)=>{\n        e.preventDefault();\n        const commentTosend = comment1;\n        setComment(\"\");\n        await (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_6__.db, \"posts\", id, \"comments\"), {\n            comment: commentTosend,\n            username: session.user.username,\n            userImage: session.user.image,\n            timestamp: (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n        });\n    };\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"bg-white my-7 border rounded-sm\",\n        __source: {\n            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n            lineNumber: 84\n        },\n        __self: this,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                className: \"flex items-center p-5\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                    lineNumber: 85\n                },\n                __self: this,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                        src: userImg,\n                        className: \"rounded-full h-12 w-12 object-contain border p-1 mr-3\",\n                        alt: \"\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                            lineNumber: 86\n                        },\n                        __self: this\n                    }),\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n                        className: \"flex-1 font-bold\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                            lineNumber: 91\n                        },\n                        __self: this,\n                        children: [\n                            \" \",\n                            username\n                        ]\n                    })\n                ]\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                src: img,\n                className: \"object-cover w-full\",\n                alts: \"\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                    lineNumber: 93\n                },\n                __self: this\n            }),\n            session && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                className: \"flex justify-between px-4 pt-4\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                    lineNumber: 95\n                },\n                __self: this,\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"flex space-x-4\",\n                    __source: {\n                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                        lineNumber: 96\n                    },\n                    __self: this,\n                    children: hasLiked ? /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_heroicons_react_solid__WEBPACK_IMPORTED_MODULE_3__.HeartIcon, {\n                        onClick: likePost,\n                        className: \"btn text-red-500\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                            lineNumber: 98\n                        },\n                        __self: this\n                    }) : /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_heroicons_react_outline__WEBPACK_IMPORTED_MODULE_2__.HeartIcon, {\n                        onClick: likePost,\n                        className: \"btn\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                            lineNumber: 103\n                        },\n                        __self: this\n                    })\n                })\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                    lineNumber: 109\n                },\n                __self: this,\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n                    className: \"p-5 truncate\",\n                    __source: {\n                        fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                        lineNumber: 110\n                    },\n                    __self: this,\n                    children: [\n                        likes.length > 0 && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n                            className: \"font-bold mb-1\",\n                            __source: {\n                                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                                lineNumber: 112\n                            },\n                            __self: this,\n                            children: [\n                                likes.length,\n                                \" likes\"\n                            ]\n                        }),\n                        /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                            className: \"font-bold mr-1\",\n                            __source: {\n                                fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                                lineNumber: 114\n                            },\n                            __self: this,\n                            children: username\n                        }),\n                        caption\n                    ]\n                })\n            }),\n            comments.length > 0 && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                className: \"ml-10 h-20 overflow-y-scroll scrollbar-thumb-black scrollbar-thin\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                    lineNumber: 119\n                },\n                __self: this,\n                children: comments.map((comment)=>{\n                    var ref;\n                    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                        className: \"flex items-center space-x-2 mb-3\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                            lineNumber: 121\n                        },\n                        __self: this,\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"img\", {\n                                className: \"h-7 rounded-full\",\n                                src: comment.data().userImage,\n                                alt: \"\",\n                                __source: {\n                                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                                    lineNumber: 122\n                                },\n                                __self: this\n                            }),\n                            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"p\", {\n                                className: \"text-sm flex-1\",\n                                __source: {\n                                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                                    lineNumber: 127\n                                },\n                                __self: this,\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"span\", {\n                                        className: \"font-bold\",\n                                        __source: {\n                                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                                            lineNumber: 128\n                                        },\n                                        __self: this,\n                                        children: comment.data().username\n                                    }),\n                                    \" \",\n                                    comment.data().comment\n                                ]\n                            }),\n                            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)((react_moment__WEBPACK_IMPORTED_MODULE_7___default()), {\n                                fromNow: true,\n                                className: \"pr-5 text-xs\",\n                                __source: {\n                                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                                    lineNumber: 131\n                                },\n                                __self: this,\n                                children: (ref = comment.data().timestamp) === null || ref === void 0 ? void 0 : ref.toDate()\n                            })\n                        ]\n                    }, comment.id));\n                })\n            }),\n            session && /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"form\", {\n                className: \"flex items-center p-4\",\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                    lineNumber: 139\n                },\n                __self: this,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_heroicons_react_outline__WEBPACK_IMPORTED_MODULE_2__.EmojiHappyIcon, {\n                        className: \"h-7\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                            lineNumber: 140\n                        },\n                        __self: this\n                    }),\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"input\", {\n                        type: \"text\",\n                        value: comment1,\n                        onChange: (e)=>setComment(e.target.value)\n                        ,\n                        placeholder: \"Add a comment... \",\n                        className: \"border-none flex-1 focus:ring-0 outline-none\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                            lineNumber: 141\n                        },\n                        __self: this\n                    }),\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n                        type: \"submit\",\n                        disabled: !comment1.trim(),\n                        onClick: sendComment,\n                        className: \"font-semibold text-blue-400\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Post.js\",\n                            lineNumber: 148\n                        },\n                        __self: this,\n                        children: \"Comment\"\n                    })\n                ]\n            })\n        ]\n    }));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Post);\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1Bvc3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVU0QjtBQVFLO0FBQ29DO0FBRXpCO0FBQ007QUFDbEI7QUFDQztTQUV4QnNCLElBQUksQ0FBQyxDQUFDLENBQUNDLEVBQUUsR0FBRUMsUUFBUSxHQUFFQyxPQUFPLEdBQUVDLEdBQUcsR0FBRUMsT0FBTyxFQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3RELEtBQUssQ0FBQyxDQUFDLENBQUNDLElBQUksRUFBRUMsT0FBTyxFQUFDLENBQUMsR0FBR2IsMkRBQVU7SUFDcEMsS0FBSyxNQUFFYyxRQUFRLE1BQUVDLFdBQVcsTUFBSWIsK0NBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0MsS0FBSyxNQUFFYyxRQUFPLE1BQUVDLFVBQVUsTUFBSWYsK0NBQVEsQ0FBQyxDQUFFO0lBQ3pDLEtBQUssTUFBRWdCLEtBQUssTUFBRUMsUUFBUSxNQUFJakIsK0NBQVEsQ0FBQyxDQUFDLENBQUM7SUFDckMsS0FBSyxNQUFFa0IsUUFBUSxNQUFFQyxXQUFXLE1BQUluQiwrQ0FBUSxDQUFDLEtBQUs7SUFFOUNDLGdEQUFTLEtBRUxmLCtEQUFVLENBQ1JFLDBEQUFLLENBQ0hOLCtEQUFVLENBQUNvQix5Q0FBRSxFQUFFLENBQU8sUUFBRUcsRUFBRSxFQUFFLENBQVUsWUFDdENwQiw0REFBTyxDQUFDLENBQVcsWUFBRSxDQUFNLFVBRTVCbUMsUUFBUSxHQUFLUCxXQUFXLENBQUNPLFFBQVEsQ0FBQ0MsSUFBSTs7TUFFM0MsQ0FBQ25CO1FBQUFBLHlDQUFFO1FBQUVHLEVBQUU7SUFBQSxDQUFDO0lBR1ZKLGdEQUFTLEtBRUxmLCtEQUFVLENBQUNKLCtEQUFVLENBQUNvQix5Q0FBRSxFQUFFLENBQU8sUUFBRUcsRUFBRSxFQUFFLENBQU8sVUFBSWUsUUFBUSxHQUN4REgsUUFBUSxDQUFDRyxRQUFRLENBQUNDLElBQUk7O01BRTFCLENBQUNuQjtRQUFBQSx5Q0FBRTtRQUFFRyxFQUFFO0lBQUEsQ0FBQztJQUVWSixnREFBUztlQUVMa0IsV0FBVyxDQUNUSCxLQUFLLENBQUNNLFNBQVMsRUFBRUMsSUFBSTtnQkFBaUJaLEdBQWE7bUJBQXpCWSxJQUFJLENBQUNsQixFQUFFLE1BQUtNLE9BQU8sYUFBUEEsT0FBTyxLQUFQQSxJQUFJLENBQUpBLENBQWEsR0FBYkEsSUFBSSxDQUFKQSxDQUFhLElBQWJBLEdBQWEsR0FBYkEsT0FBTyxDQUFFYSxJQUFJLGNBQWJiLEdBQWEsS0FBYkEsSUFBSSxDQUFKQSxDQUFhLEdBQWJBLElBQUksQ0FBSkEsQ0FBYSxHQUFiQSxHQUFhLENBQUVjLEdBQUc7Z0JBQU8sQ0FBQztPQUVwRSxDQUFDVDtRQUFBQSxLQUFLO0lBQUEsQ0FBQztJQUdULEtBQUssQ0FBQ1UsUUFBUSxhQUFlLENBQUM7UUFDNUIsRUFBRSxFQUFFUixRQUFRLEVBQUUsQ0FBQztZQUNiLEtBQUssQ0FBQzdCLDhEQUFTLENBQUNDLHdEQUFHLENBQUNZLHlDQUFFLEVBQUUsQ0FBTyxRQUFFRyxFQUFFLEVBQUUsQ0FBTyxRQUFFTSxPQUFPLENBQUNhLElBQUksQ0FBQ0MsR0FBRztRQUNoRSxDQUFDLE1BQU0sQ0FBQztZQUNOLEtBQUssQ0FBQ3RDLDJEQUFNLENBQUNHLHdEQUFHLENBQUNZLHlDQUFFLEVBQUUsQ0FBTyxRQUFFRyxFQUFFLEVBQUUsQ0FBTyxRQUFFTSxPQUFPLENBQUNhLElBQUksQ0FBQ0MsR0FBRyxHQUFHLENBQUM7Z0JBQzdEbkIsUUFBUSxFQUFFSyxPQUFPLENBQUNhLElBQUksQ0FBQ2xCLFFBQVE7WUFDakMsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBQ0RxQixPQUFPLENBQUNDLEdBQUcsQ0FBQ1YsUUFBUTtJQUNwQixLQUFLLENBQUNXLFdBQVcsVUFBVUMsQ0FBQyxHQUFLLENBQUM7UUFDaENBLENBQUMsQ0FBQ0MsY0FBYztRQUNoQixLQUFLLENBQUNDLGFBQWEsR0FBR2xCLFFBQU87UUFDN0JDLFVBQVUsQ0FBQyxDQUFFO1FBRWIsS0FBSyxDQUFDaEMsMkRBQU0sQ0FBQ0QsK0RBQVUsQ0FBQ29CLHlDQUFFLEVBQUUsQ0FBTyxRQUFFRyxFQUFFLEVBQUUsQ0FBVSxZQUFHLENBQUM7WUFDckRTLE9BQU8sRUFBRWtCLGFBQWE7WUFDdEIxQixRQUFRLEVBQUVLLE9BQU8sQ0FBQ2EsSUFBSSxDQUFDbEIsUUFBUTtZQUMvQjJCLFNBQVMsRUFBRXRCLE9BQU8sQ0FBQ2EsSUFBSSxDQUFDVSxLQUFLO1lBQzdCQyxTQUFTLEVBQUVuRCxvRUFBZTtRQUM1QixDQUFDO0lBQ0gsQ0FBQztJQUNELE1BQU0sdUVBQ0hvRCxDQUFHO1FBQUNDLFNBQVMsRUFBQyxDQUFpQzs7Ozs7OztrRkFDN0NELENBQUc7Z0JBQUNDLFNBQVMsRUFBQyxDQUF1Qjs7Ozs7Ozt5RkFDbkM3QixDQUFHO3dCQUNGOEIsR0FBRyxFQUFFL0IsT0FBTzt3QkFDWjhCLFNBQVMsRUFBQyxDQUF1RDt3QkFDakVFLEdBQUcsRUFBQyxDQUFFOzs7Ozs7OzBGQUVQQyxDQUFDO3dCQUFDSCxTQUFTLEVBQUMsQ0FBa0I7Ozs7Ozs7NEJBQUMsQ0FBQzs0QkFBQy9CLFFBQVE7Ozs7O2lGQUUzQ0UsQ0FBRztnQkFBQzhCLEdBQUcsRUFBRTlCLEdBQUc7Z0JBQUU2QixTQUFTLEVBQUMsQ0FBcUI7Z0JBQUNJLElBQUksRUFBQyxDQUFFOzs7Ozs7O1lBQ3JEOUIsT0FBTyx5RUFDTHlCLENBQUc7Z0JBQUNDLFNBQVMsRUFBQyxDQUFnQzs7Ozs7OytGQUM1Q0QsQ0FBRztvQkFBQ0MsU0FBUyxFQUFDLENBQWdCOzs7Ozs7OEJBQzVCbkIsUUFBUSx3RUFDTnJCLDZEQUFlO3dCQUNkNkMsT0FBTyxFQUFFaEIsUUFBUTt3QkFDakJXLFNBQVMsRUFBQyxDQUFrQjs7Ozs7OzhGQUc3QjFDLCtEQUFTO3dCQUFDK0MsT0FBTyxFQUFFaEIsUUFBUTt3QkFBRVcsU0FBUyxFQUFDLENBQUs7Ozs7Ozs7OztpRkFNcERELENBQUc7Ozs7OztnR0FDREksQ0FBQztvQkFBQ0gsU0FBUyxFQUFDLENBQWM7Ozs7Ozs7d0JBQ3hCckIsS0FBSyxDQUFDMkIsTUFBTSxHQUFHLENBQUMsMEVBQ2RILENBQUM7NEJBQUNILFNBQVMsRUFBQyxDQUFnQjs7Ozs7OztnQ0FBRXJCLEtBQUssQ0FBQzJCLE1BQU07Z0NBQUMsQ0FBTTs7OzZGQUVuREMsQ0FBSTs0QkFBQ1AsU0FBUyxFQUFDLENBQWdCOzs7Ozs7c0NBQUUvQixRQUFROzt3QkFDekNHLE9BQU87Ozs7WUFHWEcsUUFBUSxDQUFDK0IsTUFBTSxHQUFHLENBQUMseUVBQ2pCUCxDQUFHO2dCQUFDQyxTQUFTLEVBQUMsQ0FBbUU7Ozs7OzswQkFDL0V6QixRQUFRLENBQUNpQyxHQUFHLEVBQUUvQixPQUFPO3dCQVlmQSxHQUF3QjtpR0FYNUJzQixDQUFHO3dCQUFrQkMsU0FBUyxFQUFDLENBQWtDOzs7Ozs7O2lHQUMvRDdCLENBQUc7Z0NBQ0Y2QixTQUFTLEVBQUMsQ0FBa0I7Z0NBQzVCQyxHQUFHLEVBQUV4QixPQUFPLENBQUNKLElBQUksR0FBR3VCLFNBQVM7Z0NBQzdCTSxHQUFHLEVBQUMsQ0FBRTs7Ozs7OztrR0FFUEMsQ0FBQztnQ0FBQ0gsU0FBUyxFQUFDLENBQWdCOzs7Ozs7O3lHQUMxQk8sQ0FBSTt3Q0FBQ1AsU0FBUyxFQUFDLENBQVc7Ozs7OztrREFBRXZCLE9BQU8sQ0FBQ0osSUFBSSxHQUFHSixRQUFROztvQ0FBUyxDQUFHO29DQUMvRFEsT0FBTyxDQUFDSixJQUFJLEdBQUdJLE9BQU87OztpR0FFeEJYLHFEQUFNO2dDQUFDMkMsT0FBTztnQ0FBQ1QsU0FBUyxFQUFDLENBQWM7Ozs7OzsyQ0FDckN2QixHQUF3QixHQUF4QkEsT0FBTyxDQUFDSixJQUFJLEdBQUd5QixTQUFTLGNBQXhCckIsR0FBd0IsS0FBeEJBLElBQUksQ0FBSkEsQ0FBZ0MsR0FBaENBLElBQUksQ0FBSkEsQ0FBZ0MsR0FBaENBLEdBQXdCLENBQUVpQyxNQUFNOzs7dUJBWDNCakMsT0FBTyxDQUFDVCxFQUFFOzs7WUFpQnpCTSxPQUFPLDBFQUNMcUMsQ0FBSTtnQkFBQ1gsU0FBUyxFQUFDLENBQXVCOzs7Ozs7O3lGQUNwQzNDLG9FQUFjO3dCQUFDMkMsU0FBUyxFQUFDLENBQUs7Ozs7Ozs7eUZBQzlCWSxDQUFLO3dCQUNKQyxJQUFJLEVBQUMsQ0FBTTt3QkFDWEMsS0FBSyxFQUFFckMsUUFBTzt3QkFDZHNDLFFBQVEsR0FBR3RCLENBQUMsR0FBS2YsVUFBVSxDQUFDZSxDQUFDLENBQUN1QixNQUFNLENBQUNGLEtBQUs7O3dCQUMxQ0csV0FBVyxFQUFDLENBQW1CO3dCQUMvQmpCLFNBQVMsRUFBQyxDQUE4Qzs7Ozs7Ozt5RkFFekRrQixDQUFNO3dCQUNMTCxJQUFJLEVBQUMsQ0FBUTt3QkFDYk0sUUFBUSxHQUFHMUMsUUFBTyxDQUFDMkMsSUFBSTt3QkFDdkJmLE9BQU8sRUFBRWIsV0FBVzt3QkFDcEJRLFNBQVMsRUFBQyxDQUE2Qjs7Ozs7O2tDQUN4QyxDQUVEOzs7Ozs7QUFLVixDQUFDO0FBRUQsaUVBQWVqQyxJQUFJLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL1Bvc3QuanM/MzQ1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBjb2xsZWN0aW9uLFxuICBhZGREb2MsXG4gIHNlcnZlclRpbWVzdGFtcCxcbiAgb3JkZXJCeSxcbiAgb25TbmFwc2hvdCxcbiAgc2V0RG9jLFxuICBxdWVyeSxcbiAgZGVsZXRlRG9jLFxuICBkb2MsXG59IGZyb20gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5pbXBvcnQge1xuICBCb29rbWFya0ljb24sXG4gIENoYXRJY29uLFxuICBEb3RzSG9yaXpvbnRhbEljb24sXG4gIEVtb2ppSGFwcHlJY29uLFxuICBIZWFydEljb24sXG4gIFBhcGVyQWlycGxhbmVJY29uLFxufSBmcm9tIFwiQGhlcm9pY29ucy9yZWFjdC9vdXRsaW5lXCI7XG5pbXBvcnQgeyBIZWFydEljb24gYXMgSGVhcnRJY29uRmlsbGVkIH0gZnJvbSBcIkBoZXJvaWNvbnMvcmVhY3Qvc29saWRcIjtcblxuaW1wb3J0IHsgdXNlU2Vzc2lvbiB9IGZyb20gXCJuZXh0LWF1dGgvcmVhY3RcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBkYiB9IGZyb20gXCIuLi9maXJlYmFzZVwiO1xuaW1wb3J0IE1vbWVudCBmcm9tIFwicmVhY3QtbW9tZW50XCI7XG5cbmZ1bmN0aW9uIFBvc3QoeyBpZCwgdXNlcm5hbWUsIHVzZXJJbWcsIGltZywgY2FwdGlvbiB9KSB7XG4gIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiB9ID0gdXNlU2Vzc2lvbigpO1xuICBjb25zdCBbY29tbWVudHMsIHNldENvbW1lbnRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2NvbW1lbnQsIHNldENvbW1lbnRdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtsaWtlcywgc2V0TGlrZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbaGFzTGlrZWQsIHNldEhhc0xpa2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICB1c2VFZmZlY3QoXG4gICAgKCkgPT5cbiAgICAgIG9uU25hcHNob3QoXG4gICAgICAgIHF1ZXJ5KFxuICAgICAgICAgIGNvbGxlY3Rpb24oZGIsIFwicG9zdHNcIiwgaWQsIFwiY29tbWVudHNcIiksXG4gICAgICAgICAgb3JkZXJCeShcInRpbWVzdGFtcFwiLCBcImRlc2NcIilcbiAgICAgICAgKSxcbiAgICAgICAgKHNuYXBzaG90KSA9PiBzZXRDb21tZW50cyhzbmFwc2hvdC5kb2NzKVxuICAgICAgKSxcbiAgICBbZGIsIGlkXVxuICApO1xuXG4gIHVzZUVmZmVjdChcbiAgICAoKSA9PlxuICAgICAgb25TbmFwc2hvdChjb2xsZWN0aW9uKGRiLCBcInBvc3RzXCIsIGlkLCBcImxpa2VzXCIpLCAoc25hcHNob3QpID0+XG4gICAgICAgIHNldExpa2VzKHNuYXBzaG90LmRvY3MpXG4gICAgICApLFxuICAgIFtkYiwgaWRdXG4gICk7XG4gIHVzZUVmZmVjdChcbiAgICAoKSA9PlxuICAgICAgc2V0SGFzTGlrZWQoXG4gICAgICAgIGxpa2VzLmZpbmRJbmRleCgobGlrZSkgPT4gbGlrZS5pZCA9PT0gc2Vzc2lvbj8udXNlcj8udWlkKSAhPT0gLTFcbiAgICAgICksXG4gICAgW2xpa2VzXVxuICApO1xuXG4gIGNvbnN0IGxpa2VQb3N0ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChoYXNMaWtlZCkge1xuICAgICAgYXdhaXQgZGVsZXRlRG9jKGRvYyhkYiwgXCJwb3N0c1wiLCBpZCwgXCJsaWtlc1wiLCBzZXNzaW9uLnVzZXIudWlkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHNldERvYyhkb2MoZGIsIFwicG9zdHNcIiwgaWQsIFwibGlrZXNcIiwgc2Vzc2lvbi51c2VyLnVpZCksIHtcbiAgICAgICAgdXNlcm5hbWU6IHNlc3Npb24udXNlci51c2VybmFtZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgY29uc29sZS5sb2coaGFzTGlrZWQpO1xuICBjb25zdCBzZW5kQ29tbWVudCA9IGFzeW5jIChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGNvbW1lbnRUb3NlbmQgPSBjb21tZW50O1xuICAgIHNldENvbW1lbnQoXCJcIik7XG5cbiAgICBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgXCJwb3N0c1wiLCBpZCwgXCJjb21tZW50c1wiKSwge1xuICAgICAgY29tbWVudDogY29tbWVudFRvc2VuZCxcbiAgICAgIHVzZXJuYW1lOiBzZXNzaW9uLnVzZXIudXNlcm5hbWUsXG4gICAgICB1c2VySW1hZ2U6IHNlc3Npb24udXNlci5pbWFnZSxcbiAgICAgIHRpbWVzdGFtcDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgfSk7XG4gIH07XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJiZy13aGl0ZSBteS03IGJvcmRlciByb3VuZGVkLXNtXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHAtNVwiPlxuICAgICAgICA8aW1nXG4gICAgICAgICAgc3JjPXt1c2VySW1nfVxuICAgICAgICAgIGNsYXNzTmFtZT1cInJvdW5kZWQtZnVsbCBoLTEyIHctMTIgb2JqZWN0LWNvbnRhaW4gYm9yZGVyIHAtMSBtci0zXCJcbiAgICAgICAgICBhbHQ9XCJcIlxuICAgICAgICAvPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJmbGV4LTEgZm9udC1ib2xkXCI+IHt1c2VybmFtZX08L3A+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxpbWcgc3JjPXtpbWd9IGNsYXNzTmFtZT1cIm9iamVjdC1jb3ZlciB3LWZ1bGxcIiBhbHRzPVwiXCIgLz5cbiAgICAgIHtzZXNzaW9uICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBweC00IHB0LTRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggc3BhY2UteC00XCI+XG4gICAgICAgICAgICB7aGFzTGlrZWQgPyAoXG4gICAgICAgICAgICAgIDxIZWFydEljb25GaWxsZWRcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtsaWtlUG9zdH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gdGV4dC1yZWQtNTAwXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgIDxIZWFydEljb24gb25DbGljaz17bGlrZVBvc3R9IGNsYXNzTmFtZT1cImJ0blwiIC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG5cbiAgICAgIDxkaXY+XG4gICAgICAgIDxwIGNsYXNzTmFtZT1cInAtNSB0cnVuY2F0ZVwiPlxuICAgICAgICAgIHtsaWtlcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtYm9sZCBtYi0xXCI+e2xpa2VzLmxlbmd0aH0gbGlrZXM8L3A+XG4gICAgICAgICAgKX1cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LWJvbGQgbXItMVwiPnt1c2VybmFtZX08L3NwYW4+XG4gICAgICAgICAge2NhcHRpb259XG4gICAgICAgIDwvcD5cbiAgICAgIDwvZGl2PlxuICAgICAge2NvbW1lbnRzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1sLTEwIGgtMjAgb3ZlcmZsb3cteS1zY3JvbGwgc2Nyb2xsYmFyLXRodW1iLWJsYWNrIHNjcm9sbGJhci10aGluXCI+XG4gICAgICAgICAge2NvbW1lbnRzLm1hcCgoY29tbWVudCkgPT4gKFxuICAgICAgICAgICAgPGRpdiBrZXk9e2NvbW1lbnQuaWR9IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMiBtYi0zXCI+XG4gICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJoLTcgcm91bmRlZC1mdWxsXCJcbiAgICAgICAgICAgICAgICBzcmM9e2NvbW1lbnQuZGF0YSgpLnVzZXJJbWFnZX1cbiAgICAgICAgICAgICAgICBhbHQ9XCJcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZsZXgtMVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtYm9sZFwiPntjb21tZW50LmRhdGEoKS51c2VybmFtZX08L3NwYW4+e1wiIFwifVxuICAgICAgICAgICAgICAgIHtjb21tZW50LmRhdGEoKS5jb21tZW50fVxuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDxNb21lbnQgZnJvbU5vdyBjbGFzc05hbWU9XCJwci01IHRleHQteHNcIj5cbiAgICAgICAgICAgICAgICB7Y29tbWVudC5kYXRhKCkudGltZXN0YW1wPy50b0RhdGUoKX1cbiAgICAgICAgICAgICAgPC9Nb21lbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAge3Nlc3Npb24gJiYgKFxuICAgICAgICA8Zm9ybSBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBwLTRcIj5cbiAgICAgICAgICA8RW1vamlIYXBweUljb24gY2xhc3NOYW1lPVwiaC03XCIgLz5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHZhbHVlPXtjb21tZW50fVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRDb21tZW50KGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQWRkIGEgY29tbWVudC4uLiBcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyLW5vbmUgZmxleC0xIGZvY3VzOnJpbmctMCBvdXRsaW5lLW5vbmVcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICBkaXNhYmxlZD17IWNvbW1lbnQudHJpbSgpfVxuICAgICAgICAgICAgb25DbGljaz17c2VuZENvbW1lbnR9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIHRleHQtYmx1ZS00MDBcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIENvbW1lbnRcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9mb3JtPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9zdDtcbiJdLCJuYW1lcyI6WyJjb2xsZWN0aW9uIiwiYWRkRG9jIiwic2VydmVyVGltZXN0YW1wIiwib3JkZXJCeSIsIm9uU25hcHNob3QiLCJzZXREb2MiLCJxdWVyeSIsImRlbGV0ZURvYyIsImRvYyIsIkJvb2ttYXJrSWNvbiIsIkNoYXRJY29uIiwiRG90c0hvcml6b250YWxJY29uIiwiRW1vamlIYXBweUljb24iLCJIZWFydEljb24iLCJQYXBlckFpcnBsYW5lSWNvbiIsIkhlYXJ0SWNvbkZpbGxlZCIsInVzZVNlc3Npb24iLCJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZGIiLCJNb21lbnQiLCJQb3N0IiwiaWQiLCJ1c2VybmFtZSIsInVzZXJJbWciLCJpbWciLCJjYXB0aW9uIiwiZGF0YSIsInNlc3Npb24iLCJjb21tZW50cyIsInNldENvbW1lbnRzIiwiY29tbWVudCIsInNldENvbW1lbnQiLCJsaWtlcyIsInNldExpa2VzIiwiaGFzTGlrZWQiLCJzZXRIYXNMaWtlZCIsInNuYXBzaG90IiwiZG9jcyIsImZpbmRJbmRleCIsImxpa2UiLCJ1c2VyIiwidWlkIiwibGlrZVBvc3QiLCJjb25zb2xlIiwibG9nIiwic2VuZENvbW1lbnQiLCJlIiwicHJldmVudERlZmF1bHQiLCJjb21tZW50VG9zZW5kIiwidXNlckltYWdlIiwiaW1hZ2UiLCJ0aW1lc3RhbXAiLCJkaXYiLCJjbGFzc05hbWUiLCJzcmMiLCJhbHQiLCJwIiwiYWx0cyIsIm9uQ2xpY2siLCJsZW5ndGgiLCJzcGFuIiwibWFwIiwiZnJvbU5vdyIsInRvRGF0ZSIsImZvcm0iLCJpbnB1dCIsInR5cGUiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwidGFyZ2V0IiwicGxhY2Vob2xkZXIiLCJidXR0b24iLCJkaXNhYmxlZCIsInRyaW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Post.js\n");

/***/ }),

/***/ "./components/Posts.js":
/*!*****************************!*\
  !*** ./components/Posts.js ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Post__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Post */ \"./components/Post.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _firebase_firestore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/firestore */ \"./node_modules/@firebase/firestore/dist/index.node.mjs\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../firebase */ \"./firebase.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Post__WEBPACK_IMPORTED_MODULE_1__, _firebase__WEBPACK_IMPORTED_MODULE_5__, _firebase_firestore__WEBPACK_IMPORTED_MODULE_4__]);\n([_Post__WEBPACK_IMPORTED_MODULE_1__, _firebase__WEBPACK_IMPORTED_MODULE_5__, _firebase_firestore__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__);\n\n\n\n\n\n\nfunction Posts() {\n    const { 0: posts , 1: setPosts  } = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>(0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_4__.onSnapshot)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_4__.query)((0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_4__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_5__.db, \"posts\"), (0,_firebase_firestore__WEBPACK_IMPORTED_MODULE_4__.orderBy)(\"timestamp\", \"desc\")), (snapshot)=>{\n            setPosts(snapshot.docs);\n        })\n    , [\n        _firebase__WEBPACK_IMPORTED_MODULE_5__.db\n    ]);\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        __source: {\n            fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Posts.js\",\n            lineNumber: 21\n        },\n        __self: this,\n        children: posts.map((post)=>/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Post__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                id: post.id,\n                username: post.data().username,\n                userImg: post.data().profileImg,\n                img: post.data().image,\n                caption: post.data().caption,\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/components/Posts.js\",\n                    lineNumber: 24\n                },\n                __self: this\n            }, post.id)\n        )\n    }));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Posts);\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1Bvc3RzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlCO0FBQ0s7QUFDYTtBQUNpQztBQUM1QztTQUV2QlMsS0FBSyxHQUFHLENBQUM7SUFDaEIsS0FBSyxNQUFFQyxLQUFLLE1BQUVDLFFBQVEsTUFBSVQsK0NBQVEsQ0FBQyxDQUFDLENBQUM7SUFFckNDLGdEQUFTLEtBRUxFLCtEQUFVLENBQ1JFLDBEQUFLLENBQUNILCtEQUFVLENBQUNJLHlDQUFFLEVBQUUsQ0FBTyxTQUFHRiw0REFBTyxDQUFDLENBQVcsWUFBRSxDQUFNLFVBQ3pETSxRQUFRLEdBQUssQ0FBQztZQUNiRCxRQUFRLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtRQUN4QixDQUFDO01BRUwsQ0FBQ0w7UUFBQUEseUNBQUU7SUFBQSxDQUFDO0lBRU4sTUFBTSxzRUFDSE0sQ0FBRzs7Ozs7O2tCQUVESixLQUFLLENBQUNLLEdBQUcsRUFBRUMsSUFBSSx3RUFDYmhCLDZDQUFJO2dCQUVIaUIsRUFBRSxFQUFFRCxJQUFJLENBQUNDLEVBQUU7Z0JBQ1hDLFFBQVEsRUFBRUYsSUFBSSxDQUFDRyxJQUFJLEdBQUdELFFBQVE7Z0JBQzlCRSxPQUFPLEVBQUVKLElBQUksQ0FBQ0csSUFBSSxHQUFHRSxVQUFVO2dCQUMvQkMsR0FBRyxFQUFFTixJQUFJLENBQUNHLElBQUksR0FBR0ksS0FBSztnQkFDdEJDLE9BQU8sRUFBRVIsSUFBSSxDQUFDRyxJQUFJLEdBQUdLLE9BQU87Ozs7OztlQUx2QlIsSUFBSSxDQUFDQyxFQUFFOzs7QUFVdEIsQ0FBQztBQUNELGlFQUFlUixLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL1Bvc3RzLmpzPzc1ZGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBvc3QgZnJvbSBcIi4vUG9zdFwiO1xuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBjb2xsZWN0aW9uLCBvblNuYXBzaG90LCBvcmRlckJ5LCBxdWVyeSB9IGZyb20gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5pbXBvcnQgeyBkYiB9IGZyb20gXCIuLi9maXJlYmFzZVwiO1xuXG5mdW5jdGlvbiBQb3N0cygpIHtcbiAgY29uc3QgW3Bvc3RzLCBzZXRQb3N0c10gPSB1c2VTdGF0ZShbXSk7XG5cbiAgdXNlRWZmZWN0KFxuICAgICgpID0+XG4gICAgICBvblNuYXBzaG90KFxuICAgICAgICBxdWVyeShjb2xsZWN0aW9uKGRiLCBcInBvc3RzXCIpLCBvcmRlckJ5KFwidGltZXN0YW1wXCIsIFwiZGVzY1wiKSksXG4gICAgICAgIChzbmFwc2hvdCkgPT4ge1xuICAgICAgICAgIHNldFBvc3RzKHNuYXBzaG90LmRvY3MpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgIFtkYl1cbiAgKTtcbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAgey8qUE9TVCovfVxuICAgICAge3Bvc3RzLm1hcCgocG9zdCkgPT4gKFxuICAgICAgICA8UG9zdFxuICAgICAgICAgIGtleT17cG9zdC5pZH1cbiAgICAgICAgICBpZD17cG9zdC5pZH1cbiAgICAgICAgICB1c2VybmFtZT17cG9zdC5kYXRhKCkudXNlcm5hbWV9XG4gICAgICAgICAgdXNlckltZz17cG9zdC5kYXRhKCkucHJvZmlsZUltZ31cbiAgICAgICAgICBpbWc9e3Bvc3QuZGF0YSgpLmltYWdlfVxuICAgICAgICAgIGNhcHRpb249e3Bvc3QuZGF0YSgpLmNhcHRpb259XG4gICAgICAgIC8+XG4gICAgICApKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbmV4cG9ydCBkZWZhdWx0IFBvc3RzO1xuIl0sIm5hbWVzIjpbIlBvc3QiLCJJbWFnZSIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiY29sbGVjdGlvbiIsIm9uU25hcHNob3QiLCJvcmRlckJ5IiwicXVlcnkiLCJkYiIsIlBvc3RzIiwicG9zdHMiLCJzZXRQb3N0cyIsInNuYXBzaG90IiwiZG9jcyIsImRpdiIsIm1hcCIsInBvc3QiLCJpZCIsInVzZXJuYW1lIiwiZGF0YSIsInVzZXJJbWciLCJwcm9maWxlSW1nIiwiaW1nIiwiaW1hZ2UiLCJjYXB0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Posts.js\n");

/***/ }),

/***/ "./firebase.js":
/*!*********************!*\
  !*** ./firebase.js ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"app\": () => (/* binding */ app),\n/* harmony export */   \"db\": () => (/* binding */ db),\n/* harmony export */   \"storage\": () => (/* binding */ storage)\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"./node_modules/firebase/app/dist/index.mjs\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/index.mjs\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/storage */ \"./node_modules/firebase/storage/dist/index.mjs\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([firebase_storage__WEBPACK_IMPORTED_MODULE_2__, firebase_firestore__WEBPACK_IMPORTED_MODULE_1__, firebase_app__WEBPACK_IMPORTED_MODULE_0__]);\n([firebase_storage__WEBPACK_IMPORTED_MODULE_2__, firebase_firestore__WEBPACK_IMPORTED_MODULE_1__, firebase_app__WEBPACK_IMPORTED_MODULE_0__] = __webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__);\n\n\n\nconst firebaseConfig = {\n    apiKey: \"AIzaSyAojCu1TIMNb2w50DICgeOayH8vjYcKXT0\",\n    authDomain: \"photo-app-46eae.firebaseapp.com\",\n    projectId: \"photo-app-46eae\",\n    storageBucket: \"photo-app-46eae.appspot.com\",\n    messagingSenderId: \"833056749354\",\n    appId: \"1:833056749354:web:c628ce76dd76763f1c9053\"\n};\n// const firebaseConfig = {\n//     apiKey: \"AIzaSyAtX31-MUw1DOiitQ0b17psUlKBMnL-xSA\",\n//     authDomain: \"interactive-journal-cop4331.firebaseapp.com\",\n//     projectId: \"interactive-journal-cop4331\",\n//     storageBucket: \"interactive-journal-cop4331.appspot.com\",\n//     messagingSenderId: \"414492863642\",\n//     appId: \"1:414492863642:web:29df146ef5a8f113798323\",\n//     measurementId: \"G-XJJD98RWWF\"\n//   };\nconst app = !(0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)().length ? (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig) : (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getFirestore)();\nconst storage = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_2__.getStorage)();\n\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9maXJlYmFzZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDWjtBQUNKO0FBRTdDLEtBQUssQ0FBQ0ssY0FBYyxHQUFHLENBQUM7SUFDdEJDLE1BQU0sRUFBRSxDQUF5QztJQUNqREMsVUFBVSxFQUFFLENBQWlDO0lBQzdDQyxTQUFTLEVBQUUsQ0FBaUI7SUFDNUJDLGFBQWEsRUFBRSxDQUE2QjtJQUM1Q0MsaUJBQWlCLEVBQUUsQ0FBYztJQUNqQ0MsS0FBSyxFQUFFLENBQTJDO0FBQ3BELENBQUM7QUFFRCxFQUEyQjtBQUMzQixFQUF5RDtBQUN6RCxFQUFpRTtBQUNqRSxFQUFnRDtBQUNoRCxFQUFnRTtBQUNoRSxFQUF5QztBQUN6QyxFQUEwRDtBQUMxRCxFQUFvQztBQUNwQyxFQUFPO0FBRVAsS0FBSyxDQUFDQyxHQUFHLElBQUlYLHFEQUFPLEdBQUdZLE1BQU0sR0FBR2IsMkRBQWEsQ0FBQ0ssY0FBYyxJQUFJSCxvREFBTTtBQUN0RSxLQUFLLENBQUNZLEVBQUUsR0FBR1gsZ0VBQVk7QUFDdkIsS0FBSyxDQUFDWSxPQUFPLEdBQUdYLDREQUFVO0FBRUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9maXJlYmFzZS5qcz80ZDk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluaXRpYWxpemVBcHAsIGdldEFwcHMsIGdldEFwcCB9IGZyb20gXCJmaXJlYmFzZS9hcHBcIjtcbmltcG9ydCB7IGdldEZpcmVzdG9yZSB9IGZyb20gXCJmaXJlYmFzZS9maXJlc3RvcmVcIjtcbmltcG9ydCB7IGdldFN0b3JhZ2UgfSBmcm9tIFwiZmlyZWJhc2Uvc3RvcmFnZVwiO1xuXG5jb25zdCBmaXJlYmFzZUNvbmZpZyA9IHtcbiAgYXBpS2V5OiBcIkFJemFTeUFvakN1MVRJTU5iMnc1MERJQ2dlT2F5SDh2alljS1hUMFwiLFxuICBhdXRoRG9tYWluOiBcInBob3RvLWFwcC00NmVhZS5maXJlYmFzZWFwcC5jb21cIixcbiAgcHJvamVjdElkOiBcInBob3RvLWFwcC00NmVhZVwiLFxuICBzdG9yYWdlQnVja2V0OiBcInBob3RvLWFwcC00NmVhZS5hcHBzcG90LmNvbVwiLFxuICBtZXNzYWdpbmdTZW5kZXJJZDogXCI4MzMwNTY3NDkzNTRcIixcbiAgYXBwSWQ6IFwiMTo4MzMwNTY3NDkzNTQ6d2ViOmM2MjhjZTc2ZGQ3Njc2M2YxYzkwNTNcIixcbn07XG5cbi8vIGNvbnN0IGZpcmViYXNlQ29uZmlnID0ge1xuLy8gICAgIGFwaUtleTogXCJBSXphU3lBdFgzMS1NVXcxRE9paXRRMGIxN3BzVWxLQk1uTC14U0FcIixcbi8vICAgICBhdXRoRG9tYWluOiBcImludGVyYWN0aXZlLWpvdXJuYWwtY29wNDMzMS5maXJlYmFzZWFwcC5jb21cIixcbi8vICAgICBwcm9qZWN0SWQ6IFwiaW50ZXJhY3RpdmUtam91cm5hbC1jb3A0MzMxXCIsXG4vLyAgICAgc3RvcmFnZUJ1Y2tldDogXCJpbnRlcmFjdGl2ZS1qb3VybmFsLWNvcDQzMzEuYXBwc3BvdC5jb21cIixcbi8vICAgICBtZXNzYWdpbmdTZW5kZXJJZDogXCI0MTQ0OTI4NjM2NDJcIixcbi8vICAgICBhcHBJZDogXCIxOjQxNDQ5Mjg2MzY0Mjp3ZWI6MjlkZjE0NmVmNWE4ZjExMzc5ODMyM1wiLFxuLy8gICAgIG1lYXN1cmVtZW50SWQ6IFwiRy1YSkpEOThSV1dGXCJcbi8vICAgfTtcblxuY29uc3QgYXBwID0gIWdldEFwcHMoKS5sZW5ndGggPyBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKSA6IGdldEFwcCgpO1xuY29uc3QgZGIgPSBnZXRGaXJlc3RvcmUoKTtcbmNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKCk7XG5cbmV4cG9ydCB7IGFwcCwgZGIsIHN0b3JhZ2UgfTtcbiJdLCJuYW1lcyI6WyJpbml0aWFsaXplQXBwIiwiZ2V0QXBwcyIsImdldEFwcCIsImdldEZpcmVzdG9yZSIsImdldFN0b3JhZ2UiLCJmaXJlYmFzZUNvbmZpZyIsImFwaUtleSIsImF1dGhEb21haW4iLCJwcm9qZWN0SWQiLCJzdG9yYWdlQnVja2V0IiwibWVzc2FnaW5nU2VuZGVySWQiLCJhcHBJZCIsImFwcCIsImxlbmd0aCIsImRiIiwic3RvcmFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./firebase.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = Image;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _head = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/head */ \"../shared/lib/head\"));\nvar _toBase64 = __webpack_require__(/*! ../shared/lib/to-base-64 */ \"../shared/lib/to-base-64\");\nvar _imageConfig = __webpack_require__(/*! ../server/image-config */ \"../server/image-config\");\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {\n        };\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {\n    };\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {\n    };\n    var target = {\n    };\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst loadedImageURLs = new Set();\nconst allImgs = new Map();\nlet perfObserver;\nconst emptyDataURL = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\nif (true) {\n    global.__NEXT_IMAGE_IMPORTED = true;\n}\nconst VALID_LOADING_VALUES = [\n    'lazy',\n    'eager',\n    undefined\n];\nconst loaders = new Map([\n    [\n        'default',\n        defaultLoader\n    ],\n    [\n        'imgix',\n        imgixLoader\n    ],\n    [\n        'cloudinary',\n        cloudinaryLoader\n    ],\n    [\n        'akamai',\n        akamaiLoader\n    ],\n    [\n        'custom',\n        customLoader\n    ], \n]);\nconst VALID_LAYOUT_VALUES = [\n    'fill',\n    'fixed',\n    'intrinsic',\n    'responsive',\n    undefined, \n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst { deviceSizes: configDeviceSizes , imageSizes: configImageSizes , loader: configLoader , path: configPath , domains: configDomains ,  } = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"domains\":[\"www.seekpng.com\"]} || _imageConfig.imageConfigDefault;\n// sort smallest to largest\nconst allSizes = [\n    ...configDeviceSizes,\n    ...configImageSizes\n];\nconfigDeviceSizes.sort((a, b)=>a - b\n);\nallSizes.sort((a, b)=>a - b\n);\nfunction getWidths(width, layout, sizes) {\n    if (sizes && (layout === 'fill' || layout === 'responsive')) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= configDeviceSizes[0] * smallestRatio\n                ),\n                kind: 'w'\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: 'w'\n        };\n    }\n    if (typeof width !== 'number' || layout === 'fill' || layout === 'responsive') {\n        return {\n            widths: configDeviceSizes,\n            kind: 'w'\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w\n            ) || allSizes[allSizes.length - 1]\n        )), \n    ];\n    return {\n        widths,\n        kind: 'x'\n    };\n}\nfunction generateImgAttrs({ src , unoptimized , layout , width , quality , sizes , loader  }) {\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths , kind  } = getWidths(width, layout, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === 'w' ? '100vw' : sizes,\n        srcSet: widths.map((w, i)=>`${loader({\n                src,\n                quality,\n                width: w\n            })} ${kind === 'w' ? w : i + 1}${kind}`\n        ).join(', '),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getInt(x) {\n    if (typeof x === 'number') {\n        return x;\n    }\n    if (typeof x === 'string') {\n        return parseInt(x, 10);\n    }\n    return undefined;\n}\nfunction defaultImageLoader(loaderProps) {\n    const load = loaders.get(configLoader);\n    if (load) {\n        return load(_objectSpread({\n            root: configPath\n        }, loaderProps));\n    }\n    throw new Error(`Unknown \"loader\" found in \"next.config.js\". Expected: ${_imageConfig.VALID_LOADERS.join(', ')}. Received: ${configLoader}`);\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, src, layout, placeholder, onLoadingComplete) {\n    if (!img) {\n        return;\n    }\n    const handleLoad = ()=>{\n        if (img.src !== emptyDataURL) {\n            const p = 'decode' in img ? img.decode() : Promise.resolve();\n            p.catch(()=>{\n            }).then(()=>{\n                if (placeholder === 'blur') {\n                    img.style.filter = 'none';\n                    img.style.backgroundSize = 'none';\n                    img.style.backgroundImage = 'none';\n                }\n                loadedImageURLs.add(src);\n                if (onLoadingComplete) {\n                    const { naturalWidth , naturalHeight  } = img;\n                    // Pass back read-only primitive values but not the\n                    // underlying DOM element because it could be misused.\n                    onLoadingComplete({\n                        naturalWidth,\n                        naturalHeight\n                    });\n                }\n                if (true) {\n                    var ref;\n                    if ((ref = img.parentElement) === null || ref === void 0 ? void 0 : ref.parentElement) {\n                        const parent = getComputedStyle(img.parentElement.parentElement);\n                        if (layout === 'responsive' && parent.display === 'flex') {\n                            console.warn(`Image with src \"${src}\" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.`);\n                        } else if (layout === 'fill' && parent.position !== 'relative') {\n                            console.warn(`Image with src \"${src}\" may not render properly with a parent using position:\"${parent.position}\". Consider changing the parent style to position:\"relative\" with a width and height.`);\n                        }\n                    }\n                }\n            });\n        }\n    };\n    if (img.complete) {\n        // If the real image fails to load, this will still remove the placeholder.\n        // This is the desired behavior for now, and will be revisited when error\n        // handling is worked on for the image component itself.\n        handleLoad();\n    } else {\n        img.onload = handleLoad;\n    }\n}\nfunction Image(_param) {\n    var { src , sizes , unoptimized =false , priority =false , loading , lazyBoundary ='200px' , className , quality , width , height , objectFit , objectPosition , onLoadingComplete , loader =defaultImageLoader , placeholder ='empty' , blurDataURL  } = _param, all = _objectWithoutProperties(_param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"lazyBoundary\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"onLoadingComplete\",\n        \"loader\",\n        \"placeholder\",\n        \"blurDataURL\"\n    ]);\n    let rest = all;\n    let layout = sizes ? 'responsive' : 'intrinsic';\n    if ('layout' in rest) {\n        // Override default layout if the user specified one:\n        if (rest.layout) layout = rest.layout;\n        // Remove property so it's not spread into image:\n        delete rest['layout'];\n    }\n    let staticSrc = '';\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received ${JSON.stringify(staticImageData)}`);\n        }\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!layout || layout !== 'fill') {\n            height = height || staticImageData.height;\n            width = width || staticImageData.width;\n            if (!staticImageData.height || !staticImageData.width) {\n                throw new Error(`An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received ${JSON.stringify(staticImageData)}`);\n            }\n        }\n    }\n    src = typeof src === 'string' ? src : staticSrc;\n    const widthInt = getInt(width);\n    const heightInt = getInt(height);\n    const qualityInt = getInt(quality);\n    let isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');\n    if (src.startsWith('data:') || src.startsWith('blob:')) {\n        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (false) {}\n    if (true) {\n        if (!src) {\n            throw new Error(`Image is missing required \"src\" property. Make sure you pass \"src\" in props to the \\`next/image\\` component. Received: ${JSON.stringify({\n                width,\n                height,\n                quality\n            })}`);\n        }\n        if (!VALID_LAYOUT_VALUES.includes(layout)) {\n            throw new Error(`Image with src \"${src}\" has invalid \"layout\" property. Provided \"${layout}\" should be one of ${VALID_LAYOUT_VALUES.map(String).join(',')}.`);\n        }\n        if (typeof widthInt !== 'undefined' && isNaN(widthInt) || typeof heightInt !== 'undefined' && isNaN(heightInt)) {\n            throw new Error(`Image with src \"${src}\" has invalid \"width\" or \"height\" property. These should be numeric values.`);\n        }\n        if (layout === 'fill' && (width || height)) {\n            console.warn(`Image with src \"${src}\" and \"layout='fill'\" has unused properties assigned. Please remove \"width\" and \"height\".`);\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error(`Image with src \"${src}\" has invalid \"loading\" property. Provided \"${loading}\" should be one of ${VALID_LOADING_VALUES.map(String).join(',')}.`);\n        }\n        if (priority && loading === 'lazy') {\n            throw new Error(`Image with src \"${src}\" has both \"priority\" and \"loading='lazy'\" properties. Only one should be used.`);\n        }\n        if (placeholder === 'blur') {\n            if (layout !== 'fill' && (widthInt || 0) * (heightInt || 0) < 1600) {\n                console.warn(`Image with src \"${src}\" is smaller than 40x40. Consider removing the \"placeholder='blur'\" property to improve performance.`);\n            }\n            if (!blurDataURL) {\n                const VALID_BLUR_EXT = [\n                    'jpeg',\n                    'png',\n                    'webp',\n                    'avif'\n                ] // should match next-image-loader\n                ;\n                throw new Error(`Image with src \"${src}\" has \"placeholder='blur'\" property but is missing the \"blurDataURL\" property.\n          Possible solutions:\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\n            - Change the \"src\" property to a static import with one of the supported file types: ${VALID_BLUR_EXT.join(',')}\n            - Remove the \"placeholder\" property, effectively no blur effect\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url`);\n            }\n        }\n        if ('ref' in rest) {\n            console.warn(`Image with src \"${src}\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.`);\n        }\n        if ('style' in rest) {\n            console.warn(`Image with src \"${src}\" is using unsupported \"style\" property. Please use the \"className\" property instead.`);\n        }\n        const rand = Math.floor(Math.random() * 1000) + 100;\n        if (!unoptimized && !loader({\n            src,\n            width: rand,\n            quality: 75\n        }).includes(rand.toString())) {\n            console.warn(`Image with src \"${src}\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.` + `\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width`);\n        }\n        if (false) {}\n    }\n    const [setRef, isIntersected] = (0, _useIntersection).useIntersection({\n        rootMargin: lazyBoundary,\n        disabled: !isLazy\n    });\n    const isVisible = !isLazy || isIntersected;\n    const wrapperStyle = {\n        boxSizing: 'border-box',\n        display: 'block',\n        overflow: 'hidden',\n        width: 'initial',\n        height: 'initial',\n        background: 'none',\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    const sizerStyle = {\n        boxSizing: 'border-box',\n        display: 'block',\n        width: 'initial',\n        height: 'initial',\n        background: 'none',\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    let hasSizer = false;\n    let sizerSvg;\n    const imgStyle = {\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        boxSizing: 'border-box',\n        padding: 0,\n        border: 'none',\n        margin: 'auto',\n        display: 'block',\n        width: 0,\n        height: 0,\n        minWidth: '100%',\n        maxWidth: '100%',\n        minHeight: '100%',\n        maxHeight: '100%',\n        objectFit,\n        objectPosition\n    };\n    const blurStyle = placeholder === 'blur' ? {\n        filter: 'blur(20px)',\n        backgroundSize: objectFit || 'cover',\n        backgroundImage: `url(\"${blurDataURL}\")`,\n        backgroundPosition: objectPosition || '0% 0%'\n    } : {\n    };\n    if (layout === 'fill') {\n        // <Image src=\"i.png\" layout=\"fill\" />\n        wrapperStyle.display = 'block';\n        wrapperStyle.position = 'absolute';\n        wrapperStyle.top = 0;\n        wrapperStyle.left = 0;\n        wrapperStyle.bottom = 0;\n        wrapperStyle.right = 0;\n    } else if (typeof widthInt !== 'undefined' && typeof heightInt !== 'undefined') {\n        // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n        const quotient = heightInt / widthInt;\n        const paddingTop = isNaN(quotient) ? '100%' : `${quotient * 100}%`;\n        if (layout === 'responsive') {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"responsive\" />\n            wrapperStyle.display = 'block';\n            wrapperStyle.position = 'relative';\n            hasSizer = true;\n            sizerStyle.paddingTop = paddingTop;\n        } else if (layout === 'intrinsic') {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"intrinsic\" />\n            wrapperStyle.display = 'inline-block';\n            wrapperStyle.position = 'relative';\n            wrapperStyle.maxWidth = '100%';\n            hasSizer = true;\n            sizerStyle.maxWidth = '100%';\n            sizerSvg = `<svg width=\"${widthInt}\" height=\"${heightInt}\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"/>`;\n        } else if (layout === 'fixed') {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"fixed\" />\n            wrapperStyle.display = 'inline-block';\n            wrapperStyle.position = 'relative';\n            wrapperStyle.width = widthInt;\n            wrapperStyle.height = heightInt;\n        }\n    } else {\n        // <Image src=\"i.png\" />\n        if (true) {\n            throw new Error(`Image with src \"${src}\" must use \"width\" and \"height\" properties or \"layout='fill'\" property.`);\n        }\n    }\n    let imgAttributes = {\n        src: emptyDataURL,\n        srcSet: undefined,\n        sizes: undefined\n    };\n    if (isVisible) {\n        imgAttributes = generateImgAttrs({\n            src,\n            unoptimized,\n            layout,\n            width: widthInt,\n            quality: qualityInt,\n            sizes,\n            loader\n        });\n    }\n    let srcString = src;\n    if (true) {\n        if (false) {}\n    }\n    return(/*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: wrapperStyle\n    }, hasSizer ? /*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: sizerStyle\n    }, sizerSvg ? /*#__PURE__*/ _react.default.createElement(\"img\", {\n        style: {\n            display: 'block',\n            maxWidth: '100%',\n            width: 'initial',\n            height: 'initial',\n            background: 'none',\n            opacity: 1,\n            border: 0,\n            margin: 0,\n            padding: 0\n        },\n        alt: \"\",\n        \"aria-hidden\": true,\n        src: `data:image/svg+xml;base64,${(0, _toBase64).toBase64(sizerSvg)}`\n    }) : null) : null, /*#__PURE__*/ _react.default.createElement(\"img\", Object.assign({\n    }, rest, imgAttributes, {\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        className: className,\n        ref: (img)=>{\n            setRef(img);\n            handleLoading(img, srcString, layout, placeholder, onLoadingComplete);\n        },\n        style: _objectSpread({\n        }, imgStyle, blurStyle)\n    })), /*#__PURE__*/ _react.default.createElement(\"noscript\", null, /*#__PURE__*/ _react.default.createElement(\"img\", Object.assign({\n    }, rest, generateImgAttrs({\n        src,\n        unoptimized,\n        layout,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    }), {\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        style: imgStyle,\n        className: className,\n        // @ts-ignore - TODO: upgrade to `@types/react@17`\n        loading: loading || 'lazy'\n    }))), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n    // it would likely cause the incorrect image to be preloaded.\n    //\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n    /*#__PURE__*/ _react.default.createElement(_head.default, null, /*#__PURE__*/ _react.default.createElement(\"link\", {\n        key: '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n        rel: \"preload\",\n        as: \"image\",\n        href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n        // @ts-ignore: imagesrcset is not yet in the link element type.\n        imagesrcset: imgAttributes.srcSet,\n        // @ts-ignore: imagesizes is not yet in the link element type.\n        imagesizes: imgAttributes.sizes\n    })) : null));\n}\nfunction normalizeSrc(src) {\n    return src[0] === '/' ? src.slice(1) : src;\n}\nfunction imgixLoader({ root , src , width , quality  }) {\n    // Demo: https://static.imgix.net/daisy.png?auto=format&fit=max&w=300\n    const url = new URL(`${root}${normalizeSrc(src)}`);\n    const params = url.searchParams;\n    params.set('auto', params.get('auto') || 'format');\n    params.set('fit', params.get('fit') || 'max');\n    params.set('w', params.get('w') || width.toString());\n    if (quality) {\n        params.set('q', quality.toString());\n    }\n    return url.href;\n}\nfunction akamaiLoader({ root , src , width  }) {\n    return `${root}${normalizeSrc(src)}?imwidth=${width}`;\n}\nfunction cloudinaryLoader({ root , src , width , quality  }) {\n    // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\n    const params = [\n        'f_auto',\n        'c_limit',\n        'w_' + width,\n        'q_' + (quality || 'auto')\n    ];\n    let paramsString = params.join(',') + '/';\n    return `${root}${paramsString}${normalizeSrc(src)}`;\n}\nfunction customLoader({ src  }) {\n    throw new Error(`Image with src \"${src}\" is missing \"loader\" prop.` + `\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader`);\n}\nfunction defaultLoader({ root , src , width , quality  }) {\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push('src');\n        if (!width) missingValues.push('width');\n        if (missingValues.length > 0) {\n            throw new Error(`Next Image Optimization requires ${missingValues.join(', ')} to be provided. Make sure you pass them as props to the \\`next/image\\` component. Received: ${JSON.stringify({\n                src,\n                width,\n                quality\n            })}`);\n        }\n        if (src.startsWith('//')) {\n            throw new Error(`Failed to parse src \"${src}\" on \\`next/image\\`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)`);\n        }\n        if (!src.startsWith('/') && configDomains) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error(`Failed to parse src \"${src}\" on \\`next/image\\`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)`);\n            }\n            if ( true && !configDomains.includes(parsedSrc.hostname)) {\n                throw new Error(`Invalid src prop (${src}) on \\`next/image\\`, hostname \"${parsedSrc.hostname}\" is not configured under images in your \\`next.config.js\\`\\n` + `See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host`);\n            }\n        }\n    }\n    return `${root}?url=${encodeURIComponent(src)}&w=${width}&q=${quality || 75}`;\n} //# sourceMappingURL=image.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaQSw4Q0FBNkMsQ0FBQztJQUMxQ0csS0FBSyxFQUFFLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0csS0FBSztBQUN2QixHQUFHLENBQUNDLE1BQU0sR0FBR0Msc0JBQXNCLENBQUNDLG1CQUFPLENBQUMsb0JBQU87QUFDbkQsR0FBRyxDQUFDQyxLQUFLLEdBQUdGLHNCQUFzQixDQUFDQyxtQkFBTyxDQUFDLDhDQUFvQjtBQUMvRCxHQUFHLENBQUNFLFNBQVMsR0FBR0YsbUJBQU8sQ0FBQywwREFBMEI7QUFDbEQsR0FBRyxDQUFDRyxZQUFZLEdBQUdILG1CQUFPLENBQUMsc0RBQXdCO0FBQ25ELEdBQUcsQ0FBQ0ksZ0JBQWdCLEdBQUdKLG1CQUFPLENBQUMsK0VBQW9CO1NBQzFDSyxlQUFlLENBQUNDLEdBQUcsRUFBRUMsR0FBRyxFQUFFWixLQUFLLEVBQUUsQ0FBQztJQUN2QyxFQUFFLEVBQUVZLEdBQUcsSUFBSUQsR0FBRyxFQUFFLENBQUM7UUFDYmQsTUFBTSxDQUFDQyxjQUFjLENBQUNhLEdBQUcsRUFBRUMsR0FBRyxFQUFFLENBQUM7WUFDN0JaLEtBQUssRUFBRUEsS0FBSztZQUNaYSxVQUFVLEVBQUUsSUFBSTtZQUNoQkMsWUFBWSxFQUFFLElBQUk7WUFDbEJDLFFBQVEsRUFBRSxJQUFJO1FBQ2xCLENBQUM7SUFDTCxDQUFDLE1BQU0sQ0FBQztRQUNKSixHQUFHLENBQUNDLEdBQUcsSUFBSVosS0FBSztJQUNwQixDQUFDO0lBQ0QsTUFBTSxDQUFDVyxHQUFHO0FBQ2QsQ0FBQztTQUNRUCxzQkFBc0IsQ0FBQ08sR0FBRyxFQUFFLENBQUM7SUFDbEMsTUFBTSxDQUFDQSxHQUFHLElBQUlBLEdBQUcsQ0FBQ0ssVUFBVSxHQUFHTCxHQUFHLEdBQUcsQ0FBQztRQUNsQ1YsT0FBTyxFQUFFVSxHQUFHO0lBQ2hCLENBQUM7QUFDTCxDQUFDO1NBQ1FNLGFBQWEsQ0FBQ0MsTUFBTSxFQUFFLENBQUM7SUFDNUIsR0FBRyxDQUFDLEdBQUcsQ0FBQ0MsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHQyxTQUFTLENBQUNDLE1BQU0sRUFBRUYsQ0FBQyxHQUFHLENBQUM7UUFDdEMsR0FBRyxDQUFDRyxNQUFNLEdBQUdGLFNBQVMsQ0FBQ0QsQ0FBQyxLQUFLLElBQUksR0FBR0MsU0FBUyxDQUFDRCxDQUFDLElBQUksQ0FBQztRQUNwRCxDQUFDO1FBQ0QsR0FBRyxDQUFDSSxPQUFPLEdBQUcxQixNQUFNLENBQUMyQixJQUFJLENBQUNGLE1BQU07UUFDaEMsRUFBRSxFQUFFLE1BQU0sQ0FBQ3pCLE1BQU0sQ0FBQzRCLHFCQUFxQixLQUFLLENBQVUsV0FBRSxDQUFDO1lBQ3JERixPQUFPLEdBQUdBLE9BQU8sQ0FBQ0csTUFBTSxDQUFDN0IsTUFBTSxDQUFDNEIscUJBQXFCLENBQUNILE1BQU0sRUFBRUssTUFBTSxDQUFDLFFBQVEsQ0FBQ0MsR0FBRyxFQUFFLENBQUM7Z0JBQ2hGLE1BQU0sQ0FBQy9CLE1BQU0sQ0FBQ2dDLHdCQUF3QixDQUFDUCxNQUFNLEVBQUVNLEdBQUcsRUFBRWYsVUFBVTtZQUNsRSxDQUFDO1FBQ0wsQ0FBQztRQUNEVSxPQUFPLENBQUNPLE9BQU8sQ0FBQyxRQUFRLENBQUNsQixHQUFHLEVBQUUsQ0FBQztZQUMzQkYsZUFBZSxDQUFDUSxNQUFNLEVBQUVOLEdBQUcsRUFBRVUsTUFBTSxDQUFDVixHQUFHO1FBQzNDLENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTSxDQUFDTSxNQUFNO0FBQ2pCLENBQUM7U0FDUWEsd0JBQXdCLENBQUNULE1BQU0sRUFBRVUsUUFBUSxFQUFFLENBQUM7SUFDakQsRUFBRSxFQUFFVixNQUFNLElBQUksSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFDRCxHQUFHLENBQUNKLE1BQU0sR0FBR2UsNkJBQTZCLENBQUNYLE1BQU0sRUFBRVUsUUFBUTtJQUMzRCxHQUFHLENBQUNwQixHQUFHLEVBQUVPLENBQUM7SUFDVixFQUFFLEVBQUV0QixNQUFNLENBQUM0QixxQkFBcUIsRUFBRSxDQUFDO1FBQy9CLEdBQUcsQ0FBQ1MsZ0JBQWdCLEdBQUdyQyxNQUFNLENBQUM0QixxQkFBcUIsQ0FBQ0gsTUFBTTtRQUMxRCxHQUFHLENBQUNILENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR2UsZ0JBQWdCLENBQUNiLE1BQU0sRUFBRUYsQ0FBQyxHQUFHLENBQUM7WUFDekNQLEdBQUcsR0FBR3NCLGdCQUFnQixDQUFDZixDQUFDO1lBQ3hCLEVBQUUsRUFBRWEsUUFBUSxDQUFDRyxPQUFPLENBQUN2QixHQUFHLEtBQUssQ0FBQyxFQUFFLFFBQVE7WUFDeEMsRUFBRSxHQUFHZixNQUFNLENBQUN1QyxTQUFTLENBQUNDLG9CQUFvQixDQUFDQyxJQUFJLENBQUNoQixNQUFNLEVBQUVWLEdBQUcsR0FBRyxRQUFRO1lBQ3RFTSxNQUFNLENBQUNOLEdBQUcsSUFBSVUsTUFBTSxDQUFDVixHQUFHO1FBQzVCLENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTSxDQUFDTSxNQUFNO0FBQ2pCLENBQUM7U0FDUWUsNkJBQTZCLENBQUNYLE1BQU0sRUFBRVUsUUFBUSxFQUFFLENBQUM7SUFDdEQsRUFBRSxFQUFFVixNQUFNLElBQUksSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFDRCxHQUFHLENBQUNKLE1BQU0sR0FBRyxDQUFDO0lBQ2QsQ0FBQztJQUNELEdBQUcsQ0FBQ3FCLFVBQVUsR0FBRzFDLE1BQU0sQ0FBQzJCLElBQUksQ0FBQ0YsTUFBTTtJQUNuQyxHQUFHLENBQUNWLEdBQUcsRUFBRU8sQ0FBQztJQUNWLEdBQUcsQ0FBQ0EsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHb0IsVUFBVSxDQUFDbEIsTUFBTSxFQUFFRixDQUFDLEdBQUcsQ0FBQztRQUNuQ1AsR0FBRyxHQUFHMkIsVUFBVSxDQUFDcEIsQ0FBQztRQUNsQixFQUFFLEVBQUVhLFFBQVEsQ0FBQ0csT0FBTyxDQUFDdkIsR0FBRyxLQUFLLENBQUMsRUFBRSxRQUFRO1FBQ3hDTSxNQUFNLENBQUNOLEdBQUcsSUFBSVUsTUFBTSxDQUFDVixHQUFHO0lBQzVCLENBQUM7SUFDRCxNQUFNLENBQUNNLE1BQU07QUFDakIsQ0FBQztBQUNELEtBQUssQ0FBQ3NCLGVBQWUsR0FBRyxHQUFHLENBQUNDLEdBQUc7QUFDL0IsS0FBSyxDQUFDQyxPQUFPLEdBQUcsR0FBRyxDQUFDQyxHQUFHO0FBQ3ZCLEdBQUcsQ0FBQ0MsWUFBWTtBQUNoQixLQUFLLENBQUNDLFlBQVksR0FBRyxDQUFnRjtBQUNyRyxFQUFFLEVBQUUsSUFBNkIsRUFBRSxDQUFDO0lBQ2hDQyxNQUFNLENBQUNDLHFCQUFxQixHQUFHLElBQUk7QUFDdkMsQ0FBQztBQUNELEtBQUssQ0FBQ0Msb0JBQW9CLEdBQUcsQ0FBQztJQUMxQixDQUFNO0lBQ04sQ0FBTztJQUNQQyxTQUFTO0FBQ2IsQ0FBQztBQUNELEtBQUssQ0FBQ0MsT0FBTyxHQUFHLEdBQUcsQ0FBQ1AsR0FBRyxDQUFDLENBQUM7SUFDckIsQ0FBQztRQUNHLENBQVM7UUFDVFEsYUFBYTtJQUNqQixDQUFDO0lBQ0QsQ0FBQztRQUNHLENBQU87UUFDUEMsV0FBVztJQUNmLENBQUM7SUFDRCxDQUFDO1FBQ0csQ0FBWTtRQUNaQyxnQkFBZ0I7SUFDcEIsQ0FBQztJQUNELENBQUM7UUFDRyxDQUFRO1FBQ1JDLFlBQVk7SUFDaEIsQ0FBQztJQUNELENBQUM7UUFDRyxDQUFRO1FBQ1JDLFlBQVk7SUFDaEIsQ0FBQztBQUNMLENBQUM7QUFDRCxLQUFLLENBQUNDLG1CQUFtQixHQUFHLENBQUM7SUFDekIsQ0FBTTtJQUNOLENBQU87SUFDUCxDQUFXO0lBQ1gsQ0FBWTtJQUNaUCxTQUFTO0FBQ2IsQ0FBQztTQUNRUSxlQUFlLENBQUNDLEdBQUcsRUFBRSxDQUFDO0lBQzNCLE1BQU0sQ0FBQ0EsR0FBRyxDQUFDekQsT0FBTyxLQUFLZ0QsU0FBUztBQUNwQyxDQUFDO1NBQ1FVLGlCQUFpQixDQUFDRCxHQUFHLEVBQUUsQ0FBQztJQUM3QixNQUFNLENBQUNBLEdBQUcsQ0FBQ0EsR0FBRyxLQUFLVCxTQUFTO0FBQ2hDLENBQUM7U0FDUVcsY0FBYyxDQUFDRixHQUFHLEVBQUUsQ0FBQztJQUMxQixNQUFNLENBQUMsTUFBTSxDQUFDQSxHQUFHLEtBQUssQ0FBUSxZQUFLRCxlQUFlLENBQUNDLEdBQUcsS0FBS0MsaUJBQWlCLENBQUNELEdBQUc7QUFDcEYsQ0FBQztBQUNELEtBQUssQ0FBQyxDQUFDLENBQUNHLFdBQVcsRUFBRUMsaUJBQWlCLEdBQUdDLFVBQVUsRUFBRUMsZ0JBQWdCLEdBQUdDLE1BQU0sRUFBRUMsWUFBWSxHQUFHQyxJQUFJLEVBQUVDLFVBQVUsR0FBR0MsT0FBTyxFQUFFQyxhQUFhLElBQUksQ0FBQyxHQUFHQyx1S0FBNkIsSUFBSS9ELFlBQVksQ0FBQ2tFLGtCQUFrQjtBQUNoTixFQUEyQjtBQUMzQixLQUFLLENBQUNDLFFBQVEsR0FBRyxDQUFDO09BQ1hiLGlCQUFpQjtPQUNqQkUsZ0JBQWdCO0FBQ3ZCLENBQUM7QUFDREYsaUJBQWlCLENBQUNjLElBQUksRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEdBQUdELENBQUMsR0FBR0MsQ0FBQzs7QUFFcENILFFBQVEsQ0FBQ0MsSUFBSSxFQUFFQyxDQUFDLEVBQUVDLENBQUMsR0FBR0QsQ0FBQyxHQUFHQyxDQUFDOztTQUVsQkMsU0FBUyxDQUFDQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFLENBQUM7SUFDdEMsRUFBRSxFQUFFQSxLQUFLLEtBQUtELE1BQU0sS0FBSyxDQUFNLFNBQUlBLE1BQU0sS0FBSyxDQUFZLGNBQUcsQ0FBQztRQUMxRCxFQUF5RDtRQUN6RCxLQUFLLENBQUNFLGVBQWU7UUFDckIsS0FBSyxDQUFDQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZCLEdBQUcsQ0FBQyxHQUFHLENBQUNDLEtBQUssRUFBRUEsS0FBSyxHQUFHRixlQUFlLENBQUNHLElBQUksQ0FBQ0osS0FBSyxHQUFHRyxLQUFLLENBQUMsQ0FBQztZQUN2REQsWUFBWSxDQUFDRyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsS0FBSyxDQUFDLENBQUM7UUFDdEMsQ0FBQztRQUNELEVBQUUsRUFBRUQsWUFBWSxDQUFDL0QsTUFBTSxFQUFFLENBQUM7WUFDdEIsS0FBSyxDQUFDb0UsYUFBYSxHQUFHQyxJQUFJLENBQUNDLEdBQUcsSUFBSVAsWUFBWSxJQUFJLElBQUk7WUFDdEQsTUFBTSxDQUFDLENBQUM7Z0JBQ0pRLE1BQU0sRUFBRWpCLFFBQVEsQ0FBQ2hELE1BQU0sRUFBRWtFLENBQUMsR0FBR0EsQ0FBQyxJQUFJL0IsaUJBQWlCLENBQUMsQ0FBQyxJQUFJMkIsYUFBYTs7Z0JBRXRFSyxJQUFJLEVBQUUsQ0FBRztZQUNiLENBQUM7UUFDTCxDQUFDO1FBQ0QsTUFBTSxDQUFDLENBQUM7WUFDSkYsTUFBTSxFQUFFakIsUUFBUTtZQUNoQm1CLElBQUksRUFBRSxDQUFHO1FBQ2IsQ0FBQztJQUNMLENBQUM7SUFDRCxFQUFFLEVBQUUsTUFBTSxDQUFDZCxLQUFLLEtBQUssQ0FBUSxXQUFJQyxNQUFNLEtBQUssQ0FBTSxTQUFJQSxNQUFNLEtBQUssQ0FBWSxhQUFFLENBQUM7UUFDNUUsTUFBTSxDQUFDLENBQUM7WUFDSlcsTUFBTSxFQUFFOUIsaUJBQWlCO1lBQ3pCZ0MsSUFBSSxFQUFFLENBQUc7UUFDYixDQUFDO0lBQ0wsQ0FBQztJQUNELEtBQUssQ0FBQ0YsTUFBTSxHQUFHLENBQUM7V0FDVCxHQUFHLENBQUNuRCxHQUFHLENBQ1YsRUFBcUU7UUFDckUsRUFBa0U7UUFDbEUsRUFBb0U7UUFDcEUsRUFBdUU7UUFDdkUsRUFBc0U7UUFDdEUsRUFBdUM7UUFDdkMsRUFBcUk7UUFDckksQ0FBQztZQUNHdUMsS0FBSztZQUNMQSxLQUFLLEdBQUcsQ0FBQyxDQUFnQjtRQUM3QixDQUFDLENBQUNlLEdBQUcsRUFBRUMsQ0FBQyxHQUFHckIsUUFBUSxDQUFDc0IsSUFBSSxFQUFFQyxDQUFDLEdBQUdBLENBQUMsSUFBSUYsQ0FBQztpQkFDM0JyQixRQUFRLENBQUNBLFFBQVEsQ0FBQ3RELE1BQU0sR0FBRyxDQUFDOztJQUV6QyxDQUFDO0lBQ0QsTUFBTSxDQUFDLENBQUM7UUFDSnVFLE1BQU07UUFDTkUsSUFBSSxFQUFFLENBQUc7SUFDYixDQUFDO0FBQ0wsQ0FBQztTQUNRSyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUN6QyxHQUFHLEdBQUcwQyxXQUFXLEdBQUduQixNQUFNLEdBQUdELEtBQUssR0FBR3FCLE9BQU8sR0FBR25CLEtBQUssR0FBR2pCLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUMzRixFQUFFLEVBQUVtQyxXQUFXLEVBQUUsQ0FBQztRQUNkLE1BQU0sQ0FBQyxDQUFDO1lBQ0oxQyxHQUFHO1lBQ0g0QyxNQUFNLEVBQUVyRCxTQUFTO1lBQ2pCaUMsS0FBSyxFQUFFakMsU0FBUztRQUNwQixDQUFDO0lBQ0wsQ0FBQztJQUNELEtBQUssQ0FBQyxDQUFDLENBQUMyQyxNQUFNLEdBQUdFLElBQUksRUFBRSxDQUFDLEdBQUdmLFNBQVMsQ0FBQ0MsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLEtBQUs7SUFDekQsS0FBSyxDQUFDcUIsSUFBSSxHQUFHWCxNQUFNLENBQUN2RSxNQUFNLEdBQUcsQ0FBQztJQUM5QixNQUFNLENBQUMsQ0FBQztRQUNKNkQsS0FBSyxHQUFHQSxLQUFLLElBQUlZLElBQUksS0FBSyxDQUFHLEtBQUcsQ0FBTyxTQUFHWixLQUFLO1FBQy9Db0IsTUFBTSxFQUFFVixNQUFNLENBQUNHLEdBQUcsRUFBRUMsQ0FBQyxFQUFFN0UsQ0FBQyxNQUFNOEMsTUFBTSxDQUFDLENBQUM7Z0JBQzlCUCxHQUFHO2dCQUNIMkMsT0FBTztnQkFDUHJCLEtBQUssRUFBRWdCLENBQUM7WUFDWixDQUFDLEVBQUUsQ0FBQyxFQUFFRixJQUFJLEtBQUssQ0FBRyxLQUFHRSxDQUFDLEdBQUc3RSxDQUFDLEdBQUcsQ0FBQyxHQUFHMkUsSUFBSTtVQUN2Q1UsSUFBSSxDQUFDLENBQUk7UUFDWCxFQUF1RTtRQUN2RSxFQUFtRTtRQUNuRSxFQUF5RTtRQUN6RSxFQUEwRTtRQUMxRSxFQUEyQjtRQUMzQixFQUFzRDtRQUN0RDlDLEdBQUcsRUFBRU8sTUFBTSxDQUFDLENBQUM7WUFDVFAsR0FBRztZQUNIMkMsT0FBTztZQUNQckIsS0FBSyxFQUFFWSxNQUFNLENBQUNXLElBQUk7UUFDdEIsQ0FBQztJQUNMLENBQUM7QUFDTCxDQUFDO1NBQ1FFLE1BQU0sQ0FBQ0MsQ0FBQyxFQUFFLENBQUM7SUFDaEIsRUFBRSxFQUFFLE1BQU0sQ0FBQ0EsQ0FBQyxLQUFLLENBQVEsU0FBRSxDQUFDO1FBQ3hCLE1BQU0sQ0FBQ0EsQ0FBQztJQUNaLENBQUM7SUFDRCxFQUFFLEVBQUUsTUFBTSxDQUFDQSxDQUFDLEtBQUssQ0FBUSxTQUFFLENBQUM7UUFDeEIsTUFBTSxDQUFDbEIsUUFBUSxDQUFDa0IsQ0FBQyxFQUFFLEVBQUU7SUFDekIsQ0FBQztJQUNELE1BQU0sQ0FBQ3pELFNBQVM7QUFDcEIsQ0FBQztTQUNRMEQsa0JBQWtCLENBQUNDLFdBQVcsRUFBRSxDQUFDO0lBQ3RDLEtBQUssQ0FBQ0MsSUFBSSxHQUFHM0QsT0FBTyxDQUFDNEQsR0FBRyxDQUFDNUMsWUFBWTtJQUNyQyxFQUFFLEVBQUUyQyxJQUFJLEVBQUUsQ0FBQztRQUNQLE1BQU0sQ0FBQ0EsSUFBSSxDQUFDNUYsYUFBYSxDQUFDLENBQUM7WUFDdkI4RixJQUFJLEVBQUUzQyxVQUFVO1FBQ3BCLENBQUMsRUFBRXdDLFdBQVc7SUFDbEIsQ0FBQztJQUNELEtBQUssQ0FBQyxHQUFHLENBQUNJLEtBQUssRUFBRSxzREFBc0QsRUFBRXhHLFlBQVksQ0FBQ3lHLGFBQWEsQ0FBQ1QsSUFBSSxDQUFDLENBQUksS0FBRSxZQUFZLEVBQUV0QyxZQUFZO0FBQzdJLENBQUM7QUFDRCxFQUEwRTtBQUMxRSxFQUFpRDtTQUN4Q2dELGFBQWEsQ0FBQ0MsR0FBRyxFQUFFekQsR0FBRyxFQUFFdUIsTUFBTSxFQUFFbUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRSxDQUFDO0lBQ3RFLEVBQUUsR0FBR0YsR0FBRyxFQUFFLENBQUM7UUFDUCxNQUFNO0lBQ1YsQ0FBQztJQUNELEtBQUssQ0FBQ0csVUFBVSxPQUFPLENBQUM7UUFDcEIsRUFBRSxFQUFFSCxHQUFHLENBQUN6RCxHQUFHLEtBQUtiLFlBQVksRUFBRSxDQUFDO1lBQzNCLEtBQUssQ0FBQ3FELENBQUMsR0FBRyxDQUFRLFdBQUlpQixHQUFHLEdBQUdBLEdBQUcsQ0FBQ0ksTUFBTSxLQUFLQyxPQUFPLENBQUNDLE9BQU87WUFDMUR2QixDQUFDLENBQUN3QixLQUFLLEtBQUssQ0FBQztZQUNiLENBQUMsRUFBRUMsSUFBSSxLQUFLLENBQUM7Z0JBQ1QsRUFBRSxFQUFFUCxXQUFXLEtBQUssQ0FBTSxPQUFFLENBQUM7b0JBQ3pCRCxHQUFHLENBQUNTLEtBQUssQ0FBQ2pHLE1BQU0sR0FBRyxDQUFNO29CQUN6QndGLEdBQUcsQ0FBQ1MsS0FBSyxDQUFDQyxjQUFjLEdBQUcsQ0FBTTtvQkFDakNWLEdBQUcsQ0FBQ1MsS0FBSyxDQUFDRSxlQUFlLEdBQUcsQ0FBTTtnQkFDdEMsQ0FBQztnQkFDRHRGLGVBQWUsQ0FBQ3VGLEdBQUcsQ0FBQ3JFLEdBQUc7Z0JBQ3ZCLEVBQUUsRUFBRTJELGlCQUFpQixFQUFFLENBQUM7b0JBQ3BCLEtBQUssQ0FBQyxDQUFDLENBQUNXLFlBQVksR0FBR0MsYUFBYSxFQUFFLENBQUMsR0FBR2QsR0FBRztvQkFDN0MsRUFBbUQ7b0JBQ25ELEVBQXNEO29CQUN0REUsaUJBQWlCLENBQUMsQ0FBQzt3QkFDZlcsWUFBWTt3QkFDWkMsYUFBYTtvQkFDakIsQ0FBQztnQkFDTCxDQUFDO2dCQUNELEVBQUUsRUFqUWxCLElBaVF5RCxFQUFFLENBQUM7b0JBQ3hDLEdBQUcsQ0FBQ0MsR0FBRztvQkFDUCxFQUFFLEdBQUdBLEdBQUcsR0FBR2YsR0FBRyxDQUFDZ0IsYUFBYSxNQUFNLElBQUksSUFBSUQsR0FBRyxLQUFLLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBR0EsR0FBRyxDQUFDQyxhQUFhLEVBQUUsQ0FBQzt3QkFDcEYsS0FBSyxDQUFDQyxNQUFNLEdBQUdDLGdCQUFnQixDQUFDbEIsR0FBRyxDQUFDZ0IsYUFBYSxDQUFDQSxhQUFhO3dCQUMvRCxFQUFFLEVBQUVsRCxNQUFNLEtBQUssQ0FBWSxlQUFJbUQsTUFBTSxDQUFDRSxPQUFPLEtBQUssQ0FBTSxPQUFFLENBQUM7NEJBQ3ZEQyxPQUFPLENBQUNDLElBQUksRUFBRSxnQkFBZ0IsRUFBRTlFLEdBQUcsQ0FBQyx3SEFBd0g7d0JBQ2hLLENBQUMsTUFBTSxFQUFFLEVBQUV1QixNQUFNLEtBQUssQ0FBTSxTQUFJbUQsTUFBTSxDQUFDSyxRQUFRLEtBQUssQ0FBVSxXQUFFLENBQUM7NEJBQzdERixPQUFPLENBQUNDLElBQUksRUFBRSxnQkFBZ0IsRUFBRTlFLEdBQUcsQ0FBQyx3REFBd0QsRUFBRTBFLE1BQU0sQ0FBQ0ssUUFBUSxDQUFDLHFGQUFxRjt3QkFDdk0sQ0FBQztvQkFDTCxDQUFDO2dCQUNMLENBQUM7WUFDTCxDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUM7SUFDRCxFQUFFLEVBQUV0QixHQUFHLENBQUN1QixRQUFRLEVBQUUsQ0FBQztRQUNmLEVBQTJFO1FBQzNFLEVBQXlFO1FBQ3pFLEVBQXdEO1FBQ3hEcEIsVUFBVTtJQUNkLENBQUMsTUFBTSxDQUFDO1FBQ0pILEdBQUcsQ0FBQ3dCLE1BQU0sR0FBR3JCLFVBQVU7SUFDM0IsQ0FBQztBQUNMLENBQUM7U0FDUXBILEtBQUssQ0FBQzBJLE1BQU0sRUFBRSxDQUFDO0lBQ3BCLEdBQUcsQ0FBQyxDQUFDLENBQUNsRixHQUFHLEdBQUd3QixLQUFLLEdBQUdrQixXQUFXLEVBQUUsS0FBSyxHQUFHeUMsUUFBUSxFQUFFLEtBQUssR0FBR0MsT0FBTyxHQUFHQyxZQUFZLEVBQUUsQ0FBTyxTQUFHQyxTQUFTLEdBQUczQyxPQUFPLEdBQUdyQixLQUFLLEdBQUdpRSxNQUFNLEdBQUdDLFNBQVMsR0FBR0MsY0FBYyxHQUFHOUIsaUJBQWlCLEdBQUdwRCxNQUFNLEVBQUUwQyxrQkFBa0IsR0FBR1MsV0FBVyxFQUFFLENBQU8sU0FBR2dDLFdBQVcsRUFBRSxDQUFDLEdBQUdSLE1BQU0sRUFBRVMsR0FBRyxHQUFHdEgsd0JBQXdCLENBQUM2RyxNQUFNLEVBQUUsQ0FBQztRQUFBLENBQUs7UUFBRSxDQUFPO1FBQUUsQ0FBYTtRQUFFLENBQVU7UUFBRSxDQUFTO1FBQUUsQ0FBYztRQUFFLENBQVc7UUFBRSxDQUFTO1FBQUUsQ0FBTztRQUFFLENBQVE7UUFBRSxDQUFXO1FBQUUsQ0FBZ0I7UUFBRSxDQUFtQjtRQUFFLENBQVE7UUFBRSxDQUFhO1FBQUUsQ0FBYTtJQUFBLENBQUM7SUFDdGYsR0FBRyxDQUFDVSxJQUFJLEdBQUdELEdBQUc7SUFDZCxHQUFHLENBQUNwRSxNQUFNLEdBQUdDLEtBQUssR0FBRyxDQUFZLGNBQUcsQ0FBVztJQUMvQyxFQUFFLEVBQUUsQ0FBUSxXQUFJb0UsSUFBSSxFQUFFLENBQUM7UUFDbkIsRUFBcUQ7UUFDckQsRUFBRSxFQUFFQSxJQUFJLENBQUNyRSxNQUFNLEVBQUVBLE1BQU0sR0FBR3FFLElBQUksQ0FBQ3JFLE1BQU07UUFDckMsRUFBaUQ7UUFDakQsTUFBTSxDQUFDcUUsSUFBSSxDQUFDLENBQVE7SUFDeEIsQ0FBQztJQUNELEdBQUcsQ0FBQ0MsU0FBUyxHQUFHLENBQUU7SUFDbEIsRUFBRSxFQUFFM0YsY0FBYyxDQUFDRixHQUFHLEdBQUcsQ0FBQztRQUN0QixLQUFLLENBQUM4RixlQUFlLEdBQUcvRixlQUFlLENBQUNDLEdBQUcsSUFBSUEsR0FBRyxDQUFDekQsT0FBTyxHQUFHeUQsR0FBRztRQUNoRSxFQUFFLEdBQUc4RixlQUFlLENBQUM5RixHQUFHLEVBQUUsQ0FBQztZQUN2QixLQUFLLENBQUMsR0FBRyxDQUFDc0QsS0FBSyxFQUFFLDJJQUEySSxFQUFFeUMsSUFBSSxDQUFDQyxTQUFTLENBQUNGLGVBQWU7UUFDaE0sQ0FBQztRQUNESixXQUFXLEdBQUdBLFdBQVcsSUFBSUksZUFBZSxDQUFDSixXQUFXO1FBQ3hERyxTQUFTLEdBQUdDLGVBQWUsQ0FBQzlGLEdBQUc7UUFDL0IsRUFBRSxHQUFHdUIsTUFBTSxJQUFJQSxNQUFNLEtBQUssQ0FBTSxPQUFFLENBQUM7WUFDL0JnRSxNQUFNLEdBQUdBLE1BQU0sSUFBSU8sZUFBZSxDQUFDUCxNQUFNO1lBQ3pDakUsS0FBSyxHQUFHQSxLQUFLLElBQUl3RSxlQUFlLENBQUN4RSxLQUFLO1lBQ3RDLEVBQUUsR0FBR3dFLGVBQWUsQ0FBQ1AsTUFBTSxLQUFLTyxlQUFlLENBQUN4RSxLQUFLLEVBQUUsQ0FBQztnQkFDcEQsS0FBSyxDQUFDLEdBQUcsQ0FBQ2dDLEtBQUssRUFBRSx3SkFBd0osRUFBRXlDLElBQUksQ0FBQ0MsU0FBUyxDQUFDRixlQUFlO1lBQzdNLENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQztJQUNEOUYsR0FBRyxHQUFHLE1BQU0sQ0FBQ0EsR0FBRyxLQUFLLENBQVEsVUFBR0EsR0FBRyxHQUFHNkYsU0FBUztJQUMvQyxLQUFLLENBQUNJLFFBQVEsR0FBR2xELE1BQU0sQ0FBQ3pCLEtBQUs7SUFDN0IsS0FBSyxDQUFDNEUsU0FBUyxHQUFHbkQsTUFBTSxDQUFDd0MsTUFBTTtJQUMvQixLQUFLLENBQUNZLFVBQVUsR0FBR3BELE1BQU0sQ0FBQ0osT0FBTztJQUNqQyxHQUFHLENBQUN5RCxNQUFNLElBQUlqQixRQUFRLEtBQUtDLE9BQU8sS0FBSyxDQUFNLFNBQUksTUFBTSxDQUFDQSxPQUFPLEtBQUssQ0FBVztJQUMvRSxFQUFFLEVBQUVwRixHQUFHLENBQUNxRyxVQUFVLENBQUMsQ0FBTyxXQUFLckcsR0FBRyxDQUFDcUcsVUFBVSxDQUFDLENBQU8sU0FBRyxDQUFDO1FBQ3JELEVBQTZFO1FBQzdFM0QsV0FBVyxHQUFHLElBQUk7UUFDbEIwRCxNQUFNLEdBQUcsS0FBSztJQUNsQixDQUFDO0lBQ0QsRUFBRSxFQUFFLEtBQXlELEVBQUUsRUFFOUQ7SUFDRCxFQUFFLEVBL1ROLElBK1Q2QyxFQUFFLENBQUM7UUFDeEMsRUFBRSxHQUFHcEcsR0FBRyxFQUFFLENBQUM7WUFDUCxLQUFLLENBQUMsR0FBRyxDQUFDc0QsS0FBSyxFQUFFLHVIQUF1SCxFQUFFeUMsSUFBSSxDQUFDQyxTQUFTLENBQUMsQ0FBQztnQkFDdEoxRSxLQUFLO2dCQUNMaUUsTUFBTTtnQkFDTjVDLE9BQU87WUFDWCxDQUFDO1FBQ0wsQ0FBQztRQUNELEVBQUUsR0FBRzdDLG1CQUFtQixDQUFDeUcsUUFBUSxDQUFDaEYsTUFBTSxHQUFHLENBQUM7WUFDeEMsS0FBSyxDQUFDLEdBQUcsQ0FBQytCLEtBQUssRUFBRSxnQkFBZ0IsRUFBRXRELEdBQUcsQ0FBQywyQ0FBMkMsRUFBRXVCLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRXpCLG1CQUFtQixDQUFDdUMsR0FBRyxDQUFDbUUsTUFBTSxFQUFFMUQsSUFBSSxDQUFDLENBQUcsSUFBRSxDQUFDO1FBQy9KLENBQUM7UUFDRCxFQUFFLEVBQUUsTUFBTSxDQUFDbUQsUUFBUSxLQUFLLENBQVcsY0FBSVEsS0FBSyxDQUFDUixRQUFRLEtBQUssTUFBTSxDQUFDQyxTQUFTLEtBQUssQ0FBVyxjQUFJTyxLQUFLLENBQUNQLFNBQVMsR0FBRyxDQUFDO1lBQzdHLEtBQUssQ0FBQyxHQUFHLENBQUM1QyxLQUFLLEVBQUUsZ0JBQWdCLEVBQUV0RCxHQUFHLENBQUMsMkVBQTJFO1FBQ3RILENBQUM7UUFDRCxFQUFFLEVBQUV1QixNQUFNLEtBQUssQ0FBTSxVQUFLRCxLQUFLLElBQUlpRSxNQUFNLEdBQUcsQ0FBQztZQUN6Q1YsT0FBTyxDQUFDQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUU5RSxHQUFHLENBQUMseUZBQXlGO1FBQ2pJLENBQUM7UUFDRCxFQUFFLEdBQUdWLG9CQUFvQixDQUFDaUgsUUFBUSxDQUFDbkIsT0FBTyxHQUFHLENBQUM7WUFDMUMsS0FBSyxDQUFDLEdBQUcsQ0FBQzlCLEtBQUssRUFBRSxnQkFBZ0IsRUFBRXRELEdBQUcsQ0FBQyw0Q0FBNEMsRUFBRW9GLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRTlGLG9CQUFvQixDQUFDK0MsR0FBRyxDQUFDbUUsTUFBTSxFQUFFMUQsSUFBSSxDQUFDLENBQUcsSUFBRSxDQUFDO1FBQ2xLLENBQUM7UUFDRCxFQUFFLEVBQUVxQyxRQUFRLElBQUlDLE9BQU8sS0FBSyxDQUFNLE9BQUUsQ0FBQztZQUNqQyxLQUFLLENBQUMsR0FBRyxDQUFDOUIsS0FBSyxFQUFFLGdCQUFnQixFQUFFdEQsR0FBRyxDQUFDLCtFQUErRTtRQUMxSCxDQUFDO1FBQ0QsRUFBRSxFQUFFMEQsV0FBVyxLQUFLLENBQU0sT0FBRSxDQUFDO1lBQ3pCLEVBQUUsRUFBRW5DLE1BQU0sS0FBSyxDQUFNLFVBQUswRSxRQUFRLElBQUksQ0FBQyxLQUFLQyxTQUFTLElBQUksQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO2dCQUNqRXJCLE9BQU8sQ0FBQ0MsSUFBSSxFQUFFLGdCQUFnQixFQUFFOUUsR0FBRyxDQUFDLG9HQUFvRztZQUM1SSxDQUFDO1lBQ0QsRUFBRSxHQUFHMEYsV0FBVyxFQUFFLENBQUM7Z0JBQ2YsS0FBSyxDQUFDZ0IsY0FBYyxHQUFHLENBQUM7b0JBQ3BCLENBQU07b0JBQ04sQ0FBSztvQkFDTCxDQUFNO29CQUNOLENBQU07Z0JBQ1YsQ0FBQyxDQUFrQzs7Z0JBRW5DLEtBQUssQ0FBQyxHQUFHLENBQUNwRCxLQUFLLEVBQUUsZ0JBQWdCLEVBQUV0RCxHQUFHLENBQUM7WUFNM0MsQ0FBQztRQUNMLENBQUM7UUFDRCxFQUFFLEVBQUUsQ0FBSyxRQUFJNEYsSUFBSSxFQUFFLENBQUM7WUFDaEJmLE9BQU8sQ0FBQ0MsSUFBSSxFQUFFLGdCQUFnQixFQUFFOUUsR0FBRyxDQUFDO1FBQ3hDLENBQUM7UUFDRCxFQUFFLEVBQUUsQ0FBTzs7UUFFWCxDQUFDO1FBQ0QsS0FBSyxDQUFDMkcsSUFBSSxHQUFHM0UsSUFBSSxDQUFDNEUsS0FBSyxDQUFDNUUsSUFBSSxDQUFDNkUsTUFBTSxLQUFLLElBQUksSUFBSSxHQUFHO1FBQ25EO1lBQ0k3RyxHQUFHO1lBQ0hzQixLQUFLLEVBQUVxRixJQUFJOztRQUVmLENBQUMsRUFBRUosUUFBUSxDQUFDSSxJQUFJLENBQUNHLFFBQVEsS0FBSyxDQUFDO1lBQzNCakMsT0FBTyxDQUFDQyxJQUFJLEVBQUU7UUFDbEIsQ0FBQztRQUNELEVBQUUsRUFBRSxDQUFhO1lBQ2I1RjtnQkFDSSxHQUFHLEVBQUUsS0FBSyxDQUFDZ0ksS0FBSyxJQUFJRDtvQkFDaEIsR0FBRyxDQUFDekMsR0FBRzs7aUJBRTJELElBaUJqRjtJQUNEO0lBQ0EsS0FBSyxDQUFDd0QsWUFBWSxHQUFHLENBQUM7UUFDbEJDLFNBQVMsRUFBRSxDQUFZO1FBQ3ZCckQsT0FBTyxFQUFFLENBQU87O1FBRWhCdEQsS0FBSyxFQUFFLENBQVM7UUFDaEJpRSxNQUFNLEVBQUUsQ0FBUztRQUNqQjRDLFVBQVUsRUFBRSxDQUFNO1FBQ2xCQyxPQUFPLEVBQUUsQ0FBQztRQUNWQyxNQUFNLEVBQUUsQ0FBQztRQUNUQyxNQUFNLEVBQUUsQ0FBQztRQUNUQyxPQUFPLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFDRCxLQUFLLENBQUNDO1FBQ0ZQLFNBQVM7UUFDVHJELE9BQU8sRUFBRSxDQUFPO1FBQ2hCdEQsS0FBSyxFQUFFLENBQVM7O1FBRWhCNkcsVUFBVSxFQUFFLENBQU07UUFDbEJDLE9BQU8sRUFBRSxDQUFDO1FBQ1ZDLE1BQU0sRUFBRSxDQUFDO1FBQ1RDLE1BQU0sRUFBRSxDQUFDO1FBQ1RDLE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUNELEdBQUcsQ0FBQ0UsUUFBUSxHQUFHO0lBQ2YsR0FBRyxDQUFDQyxRQUFRO0lBQ1osS0FBSyxDQUFDQyxRQUFRO1FBQ1Y1RCxRQUFRLEVBQUU7O1FBRVY4RCxJQUFJLEVBQUUsQ0FBQztRQUNQQyxNQUFNLEVBQUUsQ0FBQztRQUNUQyxLQUFLLEVBQUUsQ0FBQztRQUNSZCxTQUFTLEVBQUUsQ0FBWTtRQUN2Qk0sT0FBTztRQUNQRixNQUFNLEVBQUU7UUFDUkMsTUFBTSxFQUFFLENBQU07UUFDZDFELE9BQU8sRUFBRTtRQUNUdEQsS0FBSyxFQUFFLENBQUM7UUFDUmlFLE1BQU0sRUFBRSxDQUFDO1FBQ1R5RCxRQUFRLEVBQUUsQ0FBTTtRQUNoQkMsUUFBUSxFQUFFLENBQU07UUFDaEJDLFNBQVMsRUFBRSxDQUFNO1FBQ2pCQyxTQUFTO1FBQ1QzRCxTQUFTO1FBQ1RDLGNBQWM7SUFDbEIsQ0FBQztJQUNELEtBQUssQ0FBQzJELFNBQVMsR0FBRzFGO1FBQ2R6RixNQUFNLEVBQUUsQ0FBWTtRQUNwQmtHO1FBQ0FDOztJQUVKLENBQUMsR0FBRyxDQUFDO0lBQ0wsQ0FBQztJQUNELEVBQUUsRUFBRTdDLE1BQU0sS0FBSyxDQUFNLE9BQUUsQ0FBQztRQUNwQixFQUFzQztRQUN0Q3lHLFlBQVksQ0FBQ3BELE9BQU8sR0FBRyxDQUFPO1FBQzlCb0Q7O1FBRUFBLFlBQVksQ0FBQ2EsSUFBSSxHQUFHO1FBQ3BCYixZQUFZLENBQUNjLE1BQU0sR0FBRyxDQUFDO1FBQ3ZCZCxZQUFZLENBQUNlLEtBQUssR0FBRyxDQUFDO0lBQzFCLENBQUMsTUFBTSxFQUFFLEVBQUUsTUFBTSxDQUFDOUMsUUFBUSxLQUFLLENBQVc7UUFDdEMsRUFBaUQ7UUFDakQsS0FBSyxDQUFDcUQsUUFBUSxHQUFHcEQ7UUFDakIsS0FBSyxDQUFDcUQsVUFBVSxHQUFHOUMsS0FBSztRQUN4QixFQUFFLEVBQUVsRixNQUFNLEtBQUssQ0FBWTtZQUN2QixFQUFxRTtZQUNyRXlHLFlBQVksQ0FBQ3BELE9BQU8sR0FBRyxDQUFPO1lBQzlCb0QsWUFBWSxDQUFDakQsUUFBUSxHQUFHLENBQVU7WUFDbEMwRCxRQUFRLEdBQUcsSUFBSTtZQUNmRCxVQUFVLENBQUNlLFVBQVUsR0FBR0E7UUFDNUIsQ0FBQyxNQUFNLEVBQUUsRUFBRWhJLE1BQU0sS0FBSyxDQUFXLFlBQUUsQ0FBQztZQUNoQyxFQUFvRTtZQUNwRXlHLFlBQVksQ0FBQ3BELE9BQU8sR0FBRyxDQUFjO1lBQ3JDb0QsWUFBWSxDQUFDakQ7WUFDYmlELFlBQVksQ0FBQ2lCLFFBQVEsR0FBRyxDQUFNO1lBQzlCUixRQUFRLEdBQUcsSUFBSTtZQUNmRCxVQUFVLENBQUNTLFFBQVEsR0FBRyxDQUFNO1lBQzVCUCxRQUFRLElBQUksWUFBWSxFQUFFekMsUUFBUSxDQUFDO1FBQ3ZDLENBQUMsTUFBTSxFQUFFLEVBQUUxRSxNQUFNLEtBQUssQ0FBTyxRQUFFLENBQUM7WUFDNUIsRUFBZ0U7WUFDaEV5RyxZQUFZLENBQUNwRDtZQUNib0QsWUFBWSxDQUFDakQsUUFBUSxHQUFHLENBQVU7WUFDbENpRCxZQUFZLENBQUMxRyxLQUFLLEdBQUcyRSxRQUFRO1lBQzdCK0IsWUFBWSxDQUFDekMsTUFBTSxHQUFHVztRQUMxQixDQUFDO0lBQ0wsQ0FBQyxNQUFNLENBQUM7UUFDSixFQUF3QjtRQUN4QixFQUFFLEVBdmVWLENBQWEsaUJBdWV3QixDQUFZO1lBQ3JDLEtBQUssQ0FBQyxHQUFHLENBQUM1QyxLQUFLLEVBQUU7UUFDckIsQ0FBQztJQUNMLENBQUM7SUFDRCxHQUFHLENBQUNrRyxhQUFhLEdBQUcsQ0FBQztRQUNqQnhKLEdBQUcsS0FBYztRQUNqQjRDLE1BQU0sRUFBRXJELFNBQVM7UUFDakJpQztJQUNKLENBQUM7SUFDRCxFQUFFLEVBQUV1RyxTQUFTLEVBQUUsQ0FBQztRQUNaeUIsYUFBYSxHQUFHL0c7WUFDWnpDLEdBQUc7WUFDSDBDLFdBQVc7O1lBRVhwQixLQUFLLEVBQUUyRTtZQUNQdEQsT0FBTyxFQUFFd0QsVUFBVTtZQUNuQjNFO1lBQ0FqQixNQUFNO1FBQ1YsQ0FBQztJQUNMLENBQUM7SUFDRCxHQUFHLENBQUNrSixTQUFTLEdBQUd6SixHQUFHO0lBQ25CLEVBQUUsRUE1Zk4sQ0FBYTtRQTZmTCxFQUFFLEVBQUUsQ0FBYTs7O2dCQUdUMEosT0FBTztZQUNFO2lCQUNTRixFQUFBQSxFQVkxQnRGO0lBQ0osQ0FBQztRQUNHQSxLQUFLLEVBQUUsQ0FBQztZQUNKVSxPQUFPLEVBQUUsQ0FBTztZQUNoQnFFLFFBQVEsRUFBRSxDQUFNO1lBQ2hCM0gsS0FBSyxFQUFFLENBQVM7WUFDaEJpRSxNQUFNLEVBQUUsQ0FBUztZQUNqQjRDO1lBQ0FDLE9BQU8sRUFBRSxDQUFDO1lBQ1ZDLE1BQU0sRUFBRSxDQUFDO1lBQ1RDLE1BQU0sRUFBRSxDQUFDO1lBQ1RDLE9BQU8sRUFBRSxDQUFDO1FBQ2QsQ0FBQztRQUNEMEIsR0FBRyxFQUFFLENBQUU7UUFDUCxDQUFhO1FBQ2JqSyxHQUFHLEdBQUc7SUFDVixDQUFDLElBQUksSUFBSSxJQUFJLElBQUk7SUFDakIsQ0FBQyxFQUFFNEY7UUFDQ3dFLFFBQVE7UUFDUixDQUFXLFlBQUU3SSxNQUFNO1FBQ25CK0QsU0FBUyxFQUFFQSxTQUFTO1FBQ3BCZCxHQUFHLEdBQUdmLEdBQUcsR0FBRyxDQUFDO1lBQ1RpRSxNQUFNLENBQUNqRSxHQUFHO1lBQ1ZELGFBQWEsQ0FBQ0M7UUFDbEIsQ0FBQztRQUNEUyxLQUFLLEVBQUUzRyxhQUFhLENBQUM7UUFDckIsQ0FBQyxFQUFFb0wsUUFBUSxFQUFFUztJQUNqQixDQUFDLElBQUksRUFBYSxZQUFDM007SUFDbkIsQ0FBQyxFQUFFbUosSUFBSSxFQUFFbkQsZ0JBQWdCLENBQUMsQ0FBQztRQUN2QnpDO1FBQ0EwQyxXQUFXO1FBQ1huQixNQUFNO1FBQ05ELEtBQUssRUFBRTJFLFFBQVE7UUFDZnRELE9BQU8sRUFBRXdELFVBQVU7UUFDbkIzRTtRQUNBakIsTUFBTTtJQUNWLENBQUMsR0FBRyxDQUFDO1FBQ0Q2SixRQUFRLEVBQUUsQ0FBTztRQUNqQixDQUFXLFlBQUU3SSxNQUFNO1FBQ25CMkMsS0FBSztRQUNMb0I7UUFDQTtRQUNBRixPQUFPLEVBQUVBLE9BQU87SUFDcEIsQ0FBQyxLQUFLRCxRQUFRLEdBQ2QsRUFBcUU7SUFDckUsRUFBNkQ7SUFDN0QsRUFBRTtJQUNGLEVBQThFO0lBQzlFLEVBQWEsWUFBQzFJLE1BQU0sQ0FBQ0YsT0FBTyxDQUFDeU47UUFDekI5TSxHQUFHLEVBQUUsQ0FBUyxXQUFHc00sYUFBYSxDQUFDeEosR0FBRyxHQUFHd0osYUFBYSxDQUFDNUcsTUFBTSxHQUFHNEcsYUFBYSxDQUFDaEksS0FBSztRQUMvRTZJLEdBQUcsRUFBRSxDQUFTOztRQUVkUCxJQUFJLEVBQUVOLGFBQWEsQ0FBQzVHLE1BQU0sR0FBR3JELFNBQVMsR0FBR2lLLGFBQWEsQ0FBQ3hKLEdBQUc7UUFDMUQsRUFBK0Q7UUFDL0R1SyxXQUFXLEVBQUVmLGFBQWEsQ0FBQzVHLE1BQU07UUFDakMsRUFBOEQ7UUFDOUQ0SCxVQUFVLEVBQUVoQjtJQUNoQixDQUFDLEtBQUssSUFBSTtBQUNkLENBQUM7U0FDUWlCLFlBQVksQ0FBQ3pLLEdBQUcsRUFBRSxDQUFDO0lBQ3hCLE1BQU0sQ0FBQ0EsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFHLEtBQUdBLEdBQUcsQ0FBQzBLLEtBQUssQ0FBQyxDQUFDLElBQUkxSyxHQUFHO0FBQzlDLENBQUM7U0FDUU47O0lBRUwsS0FBSyxDQUFDaUwsR0FBRyxHQUFHLEdBQUcsQ0FBQ2hCLEdBQUcsSUFBSXRHO0lBQ3ZCLEtBQUssQ0FBQ3VILE1BQU0sR0FBR0QsR0FBRyxDQUFDRSxZQUFZOztJQUUvQkQsTUFBTSxDQUFDYixHQUFHLENBQUMsQ0FBSyxNQUFFYSxNQUFNLENBQUN4SCxHQUFHLENBQUMsQ0FBSyxTQUFLLENBQUs7SUFDNUN3SCxNQUFNLENBQUNiLEdBQUcsQ0FBQyxDQUFHLElBQUVhLE1BQU0sQ0FBQ3hILEdBQUcsQ0FBQyxDQUFHLE9BQUs5QixLQUFLLENBQUN3RixRQUFRO0lBQ2pELEVBQUUsRUFBRW5FLE9BQU8sRUFBRSxDQUFDO1FBQ1ZpSSxNQUFNLENBQUNiLEdBQUcsQ0FBQyxDQUFHLElBQUVwSCxPQUFPLENBQUNtRTtJQUM1QixDQUFDO0lBQ0QsTUFBTSxDQUFDNkQsR0FBRyxDQUFDYixJQUFJO0FBQ25CLENBQUM7U0FDUWxLO0lBQ0wsTUFBTSxJQUFJeUQsSUFBSSxHQUFHb0gsWUFBWSxDQUFDekssR0FBRyxFQUFFO0FBQ3ZDLENBQUM7U0FDUUw7O0lBRUwsS0FBSyxDQUFDaUwsTUFBTSxHQUFHLENBQUM7UUFDWixDQUFROztRQUVSLENBQUksTUFBR3RKLEtBQUs7UUFDWixDQUFJLE9BQUlxQixPQUFPLElBQUksQ0FBTTtJQUM3QixDQUFDO0lBQ0QsR0FBRyxDQUFDbUk7SUFDSixNQUFNLElBQUl6SCxJQUFJO0FBQ2xCLENBQUM7U0FDUXhELFlBQVksQ0FBQyxDQUFDLENBQUNHLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUM3QjtBQUNKLENBQUM7U0FDUVAsYUFBYSxDQUFDLENBQUMsQ0FBQzRELElBQUksR0FBR3JELEdBQUcsR0FBR3NCLEtBQUssR0FBR3FCLE9BQU8sRUFBRSxDQUFDOztRQUVoRCxLQUFLLENBQUNvSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLEVBQXlEOztRQUV6RCxFQUFFLEdBQUd6SixLQUFLLEVBQUV5SixhQUFhLENBQUNsSixJQUFJLENBQUMsQ0FBTztRQUN0QyxJQUE4QixDQUFDO1lBQzNCLEtBQUssQ0FBQyxHQUFHLENBQUN5QixLQUFLLEVBQUU7Z0JBQ2J0RCxHQUFHO2dCQUNIc0IsS0FBSztnQkFDTHFCLE9BQU87WUFDWCxDQUFDO1FBQ0wsQ0FBQztRQUNELEVBQUUsRUFBRTNDLEdBQUcsQ0FBQ3FHO1lBQ0osS0FBSyxDQUFDLEdBQUcsQ0FBQy9DO1FBQ2QsQ0FBQztRQUNELEVBQUUsR0FBR3RELEdBQUcsQ0FBQ3FHOztZQUVMLEdBQUcsQ0FBQyxDQUFDO2dCQUNEMkUsU0FBUyxHQUFHLEdBQUcsQ0FBQ3JCLEdBQUcsQ0FBQzNKLEdBQUc7O2dCQUV2QjZFLE9BQU8sQ0FBQ3FHLEtBQUssQ0FBQ0QsR0FBRztnQkFDakIsS0FBSyxDQUFDLEdBQUcsQ0FBQzNIO1lBQ2QsQ0FBQztZQUNELEVBQUUsRUFqb0JkLENBQWEsaUJBaW9CNEIsQ0FBTTtnQkFDL0IsS0FBSyxDQUFDLEdBQUcsQ0FBQ0E7WUFDZCxDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUM7SUFDRCxNQUFNLElBQUlELEVBQUFBLEtBQVkrSCxJQUFrQixDQUFDcEwsR0FBRyxFQUFFLEdBQUcsRUFBRXNCLEtBQUssQ0FBQyxHQUFHLEVBQUVxQixPQUFPLElBQUksRUFBRTtBQUMvRSxDQUFDLENBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW1hZ2UuanM/ODJmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEltYWdlO1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaGVhZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZFwiKSk7XG52YXIgX3RvQmFzZTY0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdG8tYmFzZS02NFwiKTtcbnZhciBfaW1hZ2VDb25maWcgPSByZXF1aXJlKFwiLi4vc2VydmVyL2ltYWdlLWNvbmZpZ1wiKTtcbnZhciBfdXNlSW50ZXJzZWN0aW9uID0gcmVxdWlyZShcIi4vdXNlLWludGVyc2VjdGlvblwiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICB9O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHtcbiAgICB9O1xuICAgIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7XG4gICAgfTtcbiAgICB2YXIgdGFyZ2V0ID0ge1xuICAgIH07XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5jb25zdCBsb2FkZWRJbWFnZVVSTHMgPSBuZXcgU2V0KCk7XG5jb25zdCBhbGxJbWdzID0gbmV3IE1hcCgpO1xubGV0IHBlcmZPYnNlcnZlcjtcbmNvbnN0IGVtcHR5RGF0YVVSTCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWU7XG59XG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFtcbiAgICAnbGF6eScsXG4gICAgJ2VhZ2VyJyxcbiAgICB1bmRlZmluZWRcbl07XG5jb25zdCBsb2FkZXJzID0gbmV3IE1hcChbXG4gICAgW1xuICAgICAgICAnZGVmYXVsdCcsXG4gICAgICAgIGRlZmF1bHRMb2FkZXJcbiAgICBdLFxuICAgIFtcbiAgICAgICAgJ2ltZ2l4JyxcbiAgICAgICAgaW1naXhMb2FkZXJcbiAgICBdLFxuICAgIFtcbiAgICAgICAgJ2Nsb3VkaW5hcnknLFxuICAgICAgICBjbG91ZGluYXJ5TG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdha2FtYWknLFxuICAgICAgICBha2FtYWlMb2FkZXJcbiAgICBdLFxuICAgIFtcbiAgICAgICAgJ2N1c3RvbScsXG4gICAgICAgIGN1c3RvbUxvYWRlclxuICAgIF0sIFxuXSk7XG5jb25zdCBWQUxJRF9MQVlPVVRfVkFMVUVTID0gW1xuICAgICdmaWxsJyxcbiAgICAnZml4ZWQnLFxuICAgICdpbnRyaW5zaWMnLFxuICAgICdyZXNwb25zaXZlJyxcbiAgICB1bmRlZmluZWQsIFxuXTtcbmZ1bmN0aW9uIGlzU3RhdGljUmVxdWlyZShzcmMpIHtcbiAgICByZXR1cm4gc3JjLmRlZmF1bHQgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljSW1hZ2VEYXRhKHNyYykge1xuICAgIHJldHVybiBzcmMuc3JjICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0ltcG9ydChzcmMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgKGlzU3RhdGljUmVxdWlyZShzcmMpIHx8IGlzU3RhdGljSW1hZ2VEYXRhKHNyYykpO1xufVxuY29uc3QgeyBkZXZpY2VTaXplczogY29uZmlnRGV2aWNlU2l6ZXMgLCBpbWFnZVNpemVzOiBjb25maWdJbWFnZVNpemVzICwgbG9hZGVyOiBjb25maWdMb2FkZXIgLCBwYXRoOiBjb25maWdQYXRoICwgZG9tYWluczogY29uZmlnRG9tYWlucyAsICB9ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFMgfHwgX2ltYWdlQ29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbi8vIHNvcnQgc21hbGxlc3QgdG8gbGFyZ2VzdFxuY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgLi4uY29uZmlnRGV2aWNlU2l6ZXMsXG4gICAgLi4uY29uZmlnSW1hZ2VTaXplc1xuXTtcbmNvbmZpZ0RldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYlxuKTtcbmFsbFNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYlxuKTtcbmZ1bmN0aW9uIGdldFdpZHRocyh3aWR0aCwgbGF5b3V0LCBzaXplcykge1xuICAgIGlmIChzaXplcyAmJiAobGF5b3V0ID09PSAnZmlsbCcgfHwgbGF5b3V0ID09PSAncmVzcG9uc2l2ZScpKSB7XG4gICAgICAgIC8vIEZpbmQgYWxsIHRoZSBcInZ3XCIgcGVyY2VudCBzaXplcyB1c2VkIGluIHRoZSBzaXplcyBwcm9wXG4gICAgICAgIGNvbnN0IHZpZXdwb3J0V2lkdGhSZSA9IC8oXnxcXHMpKDE/XFxkP1xcZCl2dy9nO1xuICAgICAgICBjb25zdCBwZXJjZW50U2l6ZXMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBtYXRjaDsgbWF0Y2ggPSB2aWV3cG9ydFdpZHRoUmUuZXhlYyhzaXplcyk7IG1hdGNoKXtcbiAgICAgICAgICAgIHBlcmNlbnRTaXplcy5wdXNoKHBhcnNlSW50KG1hdGNoWzJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcmNlbnRTaXplcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNtYWxsZXN0UmF0aW8gPSBNYXRoLm1pbiguLi5wZXJjZW50U2l6ZXMpICogMC4wMTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGhzOiBhbGxTaXplcy5maWx0ZXIoKHMpPT5zID49IGNvbmZpZ0RldmljZVNpemVzWzBdICogc21hbGxlc3RSYXRpb1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAga2luZDogJ3cnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLFxuICAgICAgICAgICAga2luZDogJ3cnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICdudW1iZXInIHx8IGxheW91dCA9PT0gJ2ZpbGwnIHx8IGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGNvbmZpZ0RldmljZVNpemVzLFxuICAgICAgICAgICAga2luZDogJ3cnXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdpZHRocyA9IFtcbiAgICAgICAgLi4ubmV3IFNldCgvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcbiAgICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXG4gICAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcbiAgICAgICAgW1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovIFxuICAgICAgICBdLm1hcCgodyk9PmFsbFNpemVzLmZpbmQoKHApPT5wID49IHdcbiAgICAgICAgICAgICkgfHwgYWxsU2l6ZXNbYWxsU2l6ZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgKSksIFxuICAgIF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGhzLFxuICAgICAgICBraW5kOiAneCdcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWdBdHRycyh7IHNyYyAsIHVub3B0aW1pemVkICwgbGF5b3V0ICwgd2lkdGggLCBxdWFsaXR5ICwgc2l6ZXMgLCBsb2FkZXIgIH0pIHtcbiAgICBpZiAodW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHNyY1NldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2l6ZXM6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHdpZHRocyAsIGtpbmQgIH0gPSBnZXRXaWR0aHMod2lkdGgsIGxheW91dCwgc2l6ZXMpO1xuICAgIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplczogIXNpemVzICYmIGtpbmQgPT09ICd3JyA/ICcxMDB2dycgOiBzaXplcyxcbiAgICAgICAgc3JjU2V0OiB3aWR0aHMubWFwKCh3LCBpKT0+YCR7bG9hZGVyKHtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgcXVhbGl0eSxcbiAgICAgICAgICAgICAgICB3aWR0aDogd1xuICAgICAgICAgICAgfSl9ICR7a2luZCA9PT0gJ3cnID8gdyA6IGkgKyAxfSR7a2luZH1gXG4gICAgICAgICkuam9pbignLCAnKSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc3JjOiBsb2FkZXIoe1xuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgcXVhbGl0eSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aHNbbGFzdF1cbiAgICAgICAgfSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50KHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh4LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBkZWZhdWx0SW1hZ2VMb2FkZXIobG9hZGVyUHJvcHMpIHtcbiAgICBjb25zdCBsb2FkID0gbG9hZGVycy5nZXQoY29uZmlnTG9hZGVyKTtcbiAgICBpZiAobG9hZCkge1xuICAgICAgICByZXR1cm4gbG9hZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgIHJvb3Q6IGNvbmZpZ1BhdGhcbiAgICAgICAgfSwgbG9hZGVyUHJvcHMpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFwibG9hZGVyXCIgZm91bmQgaW4gXCJuZXh0LmNvbmZpZy5qc1wiLiBFeHBlY3RlZDogJHtfaW1hZ2VDb25maWcuVkFMSURfTE9BREVSUy5qb2luKCcsICcpfS4gUmVjZWl2ZWQ6ICR7Y29uZmlnTG9hZGVyfWApO1xufVxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTc3NzgzMy8yNjY1MzUgZm9yIHdoeSB3ZSB1c2UgdGhpcyByZWZcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmMsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlKSB7XG4gICAgaWYgKCFpbWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVMb2FkID0gKCk9PntcbiAgICAgICAgaWYgKGltZy5zcmMgIT09IGVtcHR5RGF0YVVSTCkge1xuICAgICAgICAgICAgY29uc3QgcCA9ICdkZWNvZGUnIGluIGltZyA/IGltZy5kZWNvZGUoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcC5jYXRjaCgoKT0+e1xuICAgICAgICAgICAgfSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zdHlsZS5maWx0ZXIgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9hZGVkSW1hZ2VVUkxzLmFkZChzcmMpO1xuICAgICAgICAgICAgICAgIGlmIChvbkxvYWRpbmdDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG5hdHVyYWxXaWR0aCAsIG5hdHVyYWxIZWlnaHQgIH0gPSBpbWc7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgYmFjayByZWFkLW9ubHkgcHJpbWl0aXZlIHZhbHVlcyBidXQgbm90IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlcmx5aW5nIERPTSBlbGVtZW50IGJlY2F1c2UgaXQgY291bGQgYmUgbWlzdXNlZC5cbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChyZWYgPSBpbWcucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgPT09ICdyZXNwb25zaXZlJyAmJiBwYXJlbnQuZGlzcGxheSA9PT0gJ2ZsZXgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIG1heSBub3QgcmVuZGVyIHByb3Blcmx5IGFzIGEgY2hpbGQgb2YgYSBmbGV4IGNvbnRhaW5lci4gQ29uc2lkZXIgd3JhcHBpbmcgdGhlIGltYWdlIHdpdGggYSBkaXYgdG8gY29uZmlndXJlIHRoZSB3aWR0aC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnZmlsbCcgJiYgcGFyZW50LnBvc2l0aW9uICE9PSAncmVsYXRpdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIG1heSBub3QgcmVuZGVyIHByb3Blcmx5IHdpdGggYSBwYXJlbnQgdXNpbmcgcG9zaXRpb246XCIke3BhcmVudC5wb3NpdGlvbn1cIi4gQ29uc2lkZXIgY2hhbmdpbmcgdGhlIHBhcmVudCBzdHlsZSB0byBwb3NpdGlvbjpcInJlbGF0aXZlXCIgd2l0aCBhIHdpZHRoIGFuZCBoZWlnaHQuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAvLyBJZiB0aGUgcmVhbCBpbWFnZSBmYWlscyB0byBsb2FkLCB0aGlzIHdpbGwgc3RpbGwgcmVtb3ZlIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igbm93LCBhbmQgd2lsbCBiZSByZXZpc2l0ZWQgd2hlbiBlcnJvclxuICAgICAgICAvLyBoYW5kbGluZyBpcyB3b3JrZWQgb24gZm9yIHRoZSBpbWFnZSBjb21wb25lbnQgaXRzZWxmLlxuICAgICAgICBoYW5kbGVMb2FkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW1nLm9ubG9hZCA9IGhhbmRsZUxvYWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gSW1hZ2UoX3BhcmFtKSB7XG4gICAgdmFyIHsgc3JjICwgc2l6ZXMgLCB1bm9wdGltaXplZCA9ZmFsc2UgLCBwcmlvcml0eSA9ZmFsc2UgLCBsb2FkaW5nICwgbGF6eUJvdW5kYXJ5ID0nMjAwcHgnICwgY2xhc3NOYW1lICwgcXVhbGl0eSAsIHdpZHRoICwgaGVpZ2h0ICwgb2JqZWN0Rml0ICwgb2JqZWN0UG9zaXRpb24gLCBvbkxvYWRpbmdDb21wbGV0ZSAsIGxvYWRlciA9ZGVmYXVsdEltYWdlTG9hZGVyICwgcGxhY2Vob2xkZXIgPSdlbXB0eScgLCBibHVyRGF0YVVSTCAgfSA9IF9wYXJhbSwgYWxsID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wYXJhbSwgW1wic3JjXCIsIFwic2l6ZXNcIiwgXCJ1bm9wdGltaXplZFwiLCBcInByaW9yaXR5XCIsIFwibG9hZGluZ1wiLCBcImxhenlCb3VuZGFyeVwiLCBcImNsYXNzTmFtZVwiLCBcInF1YWxpdHlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcIm9iamVjdEZpdFwiLCBcIm9iamVjdFBvc2l0aW9uXCIsIFwib25Mb2FkaW5nQ29tcGxldGVcIiwgXCJsb2FkZXJcIiwgXCJwbGFjZWhvbGRlclwiLCBcImJsdXJEYXRhVVJMXCJdKTtcbiAgICBsZXQgcmVzdCA9IGFsbDtcbiAgICBsZXQgbGF5b3V0ID0gc2l6ZXMgPyAncmVzcG9uc2l2ZScgOiAnaW50cmluc2ljJztcbiAgICBpZiAoJ2xheW91dCcgaW4gcmVzdCkge1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IGxheW91dCBpZiB0aGUgdXNlciBzcGVjaWZpZWQgb25lOlxuICAgICAgICBpZiAocmVzdC5sYXlvdXQpIGxheW91dCA9IHJlc3QubGF5b3V0O1xuICAgICAgICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIGludG8gaW1hZ2U6XG4gICAgICAgIGRlbGV0ZSByZXN0WydsYXlvdXQnXTtcbiAgICB9XG4gICAgbGV0IHN0YXRpY1NyYyA9ICcnO1xuICAgIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY0ltYWdlRGF0YSA9IGlzU3RhdGljUmVxdWlyZShzcmMpID8gc3JjLmRlZmF1bHQgOiBzcmM7XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLnNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpfWApO1xuICAgICAgICB9XG4gICAgICAgIGJsdXJEYXRhVVJMID0gYmx1ckRhdGFVUkwgfHwgc3RhdGljSW1hZ2VEYXRhLmJsdXJEYXRhVVJMO1xuICAgICAgICBzdGF0aWNTcmMgPSBzdGF0aWNJbWFnZURhdGEuc3JjO1xuICAgICAgICBpZiAoIWxheW91dCB8fCBsYXlvdXQgIT09ICdmaWxsJykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIGhlaWdodCBhbmQgd2lkdGguIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IHN0YXRpY1NyYztcbiAgICBjb25zdCB3aWR0aEludCA9IGdldEludCh3aWR0aCk7XG4gICAgY29uc3QgaGVpZ2h0SW50ID0gZ2V0SW50KGhlaWdodCk7XG4gICAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KTtcbiAgICBsZXQgaXNMYXp5ID0gIXByaW9yaXR5ICYmIChsb2FkaW5nID09PSAnbGF6eScgfHwgdHlwZW9mIGxvYWRpbmcgPT09ICd1bmRlZmluZWQnKTtcbiAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgfHwgc3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGxvYWRlZEltYWdlVVJMcy5oYXMoc3JjKSkge1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5LiBNYWtlIHN1cmUgeW91IHBhc3MgXCJzcmNcIiBpbiBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgcXVhbGl0eVxuICAgICAgICAgICAgfSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFWQUxJRF9MQVlPVVRfVkFMVUVTLmluY2x1ZGVzKGxheW91dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxheW91dFwiIHByb3BlcnR5LiBQcm92aWRlZCBcIiR7bGF5b3V0fVwiIHNob3VsZCBiZSBvbmUgb2YgJHtWQUxJRF9MQVlPVVRfVkFMVUVTLm1hcChTdHJpbmcpLmpvaW4oJywnKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aEludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYU4od2lkdGhJbnQpIHx8IHR5cGVvZiBoZWlnaHRJbnQgIT09ICd1bmRlZmluZWQnICYmIGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcIndpZHRoXCIgb3IgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gVGhlc2Ugc2hvdWxkIGJlIG51bWVyaWMgdmFsdWVzLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXlvdXQgPT09ICdmaWxsJyAmJiAod2lkdGggfHwgaGVpZ2h0KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGFuZCBcImxheW91dD0nZmlsbCdcIiBoYXMgdW51c2VkIHByb3BlcnRpZXMgYXNzaWduZWQuIFBsZWFzZSByZW1vdmUgXCJ3aWR0aFwiIGFuZCBcImhlaWdodFwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghVkFMSURfTE9BRElOR19WQUxVRVMuaW5jbHVkZXMobG9hZGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xvYWRpbmd9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChTdHJpbmcpLmpvaW4oJywnKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yaXR5ICYmIGxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPSdsYXp5J1wiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInKSB7XG4gICAgICAgICAgICBpZiAobGF5b3V0ICE9PSAnZmlsbCcgJiYgKHdpZHRoSW50IHx8IDApICogKGhlaWdodEludCB8fCAwKSA8IDE2MDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFibHVyRGF0YVVSTCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFZBTElEX0JMVVJfRVhUID0gW1xuICAgICAgICAgICAgICAgICAgICAnanBlZycsXG4gICAgICAgICAgICAgICAgICAgICdwbmcnLFxuICAgICAgICAgICAgICAgICAgICAnd2VicCcsXG4gICAgICAgICAgICAgICAgICAgICdhdmlmJ1xuICAgICAgICAgICAgICAgIF0gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSBidXQgaXMgbWlzc2luZyB0aGUgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LlxuICAgICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAgICAgICAgIC0gQWRkIGEgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LCB0aGUgY29udGVudHMgc2hvdWxkIGJlIGEgc21hbGwgRGF0YSBVUkwgdG8gcmVwcmVzZW50IHRoZSBpbWFnZVxuICAgICAgICAgICAgLSBDaGFuZ2UgdGhlIFwic3JjXCIgcHJvcGVydHkgdG8gYSBzdGF0aWMgaW1wb3J0IHdpdGggb25lIG9mIHRoZSBzdXBwb3J0ZWQgZmlsZSB0eXBlczogJHtWQUxJRF9CTFVSX0VYVC5qb2luKCcsJyl9XG4gICAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxuICAgICAgICAgIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcGxhY2Vob2xkZXItYmx1ci1kYXRhLXVybGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgncmVmJyBpbiByZXN0KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgdW5zdXBwb3J0ZWQgXCJyZWZcIiBwcm9wZXJ0eS4gQ29uc2lkZXIgdXNpbmcgdGhlIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eSBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnc3R5bGUnIGluIHJlc3QpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyB1c2luZyB1bnN1cHBvcnRlZCBcInN0eWxlXCIgcHJvcGVydHkuIFBsZWFzZSB1c2UgdGhlIFwiY2xhc3NOYW1lXCIgcHJvcGVydHkgaW5zdGVhZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5kID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCkgKyAxMDA7XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgIWxvYWRlcih7XG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICB3aWR0aDogcmFuZCxcbiAgICAgICAgICAgIHF1YWxpdHk6IDc1XG4gICAgICAgIH0pLmluY2x1ZGVzKHJhbmQudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYSBcImxvYWRlclwiIHByb3BlcnR5IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IHdpZHRoLiBQbGVhc2UgaW1wbGVtZW50IGl0IG9yIHVzZSB0aGUgXCJ1bm9wdGltaXplZFwiIHByb3BlcnR5IGluc3RlYWQuYCArIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXItd2lkdGhgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbWlzc2luZyBcIkxhcmdlc3RDb250ZW50ZnVsUGFpbnRcIiBjbGFzcyB3aXRoIFwiZWxlbWVudFwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nU3JjID0gKGVudHJ5ID09PSBudWxsIHx8IGVudHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAocmVmID0gZW50cnkuZWxlbWVudCkgPT09IG51bGwgfHwgcmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYuc3JjKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGNwSW1hZ2UgPSBhbGxJbWdzLmdldChpbWdTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGNwSW1hZ2UgJiYgIWxjcEltYWdlLnByaW9yaXR5ICYmIGxjcEltYWdlLnBsYWNlaG9sZGVyICE9PSAnYmx1cicgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdkYXRhOicpICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93ZWIuZGV2L2xjcC8jbWVhc3VyZS1sY3AtaW4tamF2YXNjcmlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbWFnZSB3aXRoIHNyYyBcIiR7bGNwSW1hZ2Uuc3JjfVwiIHdhcyBkZXRlY3RlZCBhcyB0aGUgTGFyZ2VzdCBDb250ZW50ZnVsIFBhaW50IChMQ1ApLiBQbGVhc2UgYWRkIHRoZSBcInByaW9yaXR5XCIgcHJvcGVydHkgaWYgdGhpcyBpbWFnZSBpcyBhYm92ZSB0aGUgZm9sZC5gICsgYFxcblJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3ByaW9yaXR5YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50JyxcbiAgICAgICAgICAgICAgICBidWZmZXJlZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW3NldFJlZiwgaXNJbnRlcnNlY3RlZF0gPSAoMCwgX3VzZUludGVyc2VjdGlvbikudXNlSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgcm9vdE1hcmdpbjogbGF6eUJvdW5kYXJ5LFxuICAgICAgICBkaXNhYmxlZDogIWlzTGF6eVxuICAgIH0pO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9ICFpc0xhenkgfHwgaXNJbnRlcnNlY3RlZDtcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHdpZHRoOiAnaW5pdGlhbCcsXG4gICAgICAgIGhlaWdodDogJ2luaXRpYWwnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfTtcbiAgICBjb25zdCBzaXplclN0eWxlID0ge1xuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcbiAgICAgICAgaGVpZ2h0OiAnaW5pdGlhbCcsXG4gICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuICAgIGxldCBoYXNTaXplciA9IGZhbHNlO1xuICAgIGxldCBzaXplclN2ZztcbiAgICBjb25zdCBpbWdTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICBtYXJnaW46ICdhdXRvJyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgbWluV2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWluSGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIG1heEhlaWdodDogJzEwMCUnLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfTtcbiAgICBjb25zdCBibHVyU3R5bGUgPSBwbGFjZWhvbGRlciA9PT0gJ2JsdXInID8ge1xuICAgICAgICBmaWx0ZXI6ICdibHVyKDIwcHgpJyxcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IG9iamVjdEZpdCB8fCAnY292ZXInLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoXCIke2JsdXJEYXRhVVJMfVwiKWAsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogb2JqZWN0UG9zaXRpb24gfHwgJzAlIDAlJ1xuICAgIH0gOiB7XG4gICAgfTtcbiAgICBpZiAobGF5b3V0ID09PSAnZmlsbCcpIHtcbiAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgbGF5b3V0PVwiZmlsbFwiIC8+XG4gICAgICAgIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgd3JhcHBlclN0eWxlLnRvcCA9IDA7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgd3JhcHBlclN0eWxlLmJvdHRvbSA9IDA7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5yaWdodCA9IDA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2lkdGhJbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBoZWlnaHRJbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgLz5cbiAgICAgICAgY29uc3QgcXVvdGllbnQgPSBoZWlnaHRJbnQgLyB3aWR0aEludDtcbiAgICAgICAgY29uc3QgcGFkZGluZ1RvcCA9IGlzTmFOKHF1b3RpZW50KSA/ICcxMDAlJyA6IGAke3F1b3RpZW50ICogMTAwfSVgO1xuICAgICAgICBpZiAobGF5b3V0ID09PSAncmVzcG9uc2l2ZScpIHtcbiAgICAgICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgbGF5b3V0PVwicmVzcG9uc2l2ZVwiIC8+XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgaGFzU2l6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgc2l6ZXJTdHlsZS5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcbiAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09ICdpbnRyaW5zaWMnKSB7XG4gICAgICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cImludHJpbnNpY1wiIC8+XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5tYXhXaWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIGhhc1NpemVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHNpemVyU3R5bGUubWF4V2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICBzaXplclN2ZyA9IGA8c3ZnIHdpZHRoPVwiJHt3aWR0aEludH1cIiBoZWlnaHQ9XCIke2hlaWdodEludH1cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiLz5gO1xuICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJmaXhlZFwiIC8+XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS53aWR0aCA9IHdpZHRoSW50O1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmhlaWdodCA9IGhlaWdodEludDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIC8+XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgbXVzdCB1c2UgXCJ3aWR0aFwiIGFuZCBcImhlaWdodFwiIHByb3BlcnRpZXMgb3IgXCJsYXlvdXQ9J2ZpbGwnXCIgcHJvcGVydHkuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGltZ0F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHNyYzogZW1wdHlEYXRhVVJMLFxuICAgICAgICBzcmNTZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZXM6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICBpbWdBdHRyaWJ1dGVzID0gZ2VuZXJhdGVJbWdBdHRycyh7XG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQsXG4gICAgICAgICAgICBzaXplcyxcbiAgICAgICAgICAgIGxvYWRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHNyY1N0cmluZyA9IHNyYztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxldCBmdWxsVXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbEltZ3Muc2V0KGZ1bGxVcmwuaHJlZiwge1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuKC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBzdHlsZTogd3JhcHBlclN0eWxlXG4gICAgfSwgaGFzU2l6ZXIgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgc3R5bGU6IHNpemVyU3R5bGVcbiAgICB9LCBzaXplclN2ZyA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIHdpZHRoOiAnaW5pdGlhbCcsXG4gICAgICAgICAgICBoZWlnaHQ6ICdpbml0aWFsJyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGFsdDogXCJcIixcbiAgICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgICBzcmM6IGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCR7KDAsIF90b0Jhc2U2NCkudG9CYXNlNjQoc2l6ZXJTdmcpfWBcbiAgICB9KSA6IG51bGwpIDogbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIH0sIHJlc3QsIGltZ0F0dHJpYnV0ZXMsIHtcbiAgICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAgICAgXCJkYXRhLW5pbWdcIjogbGF5b3V0LFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgcmVmOiAoaW1nKT0+e1xuICAgICAgICAgICAgc2V0UmVmKGltZyk7XG4gICAgICAgICAgICBoYW5kbGVMb2FkaW5nKGltZywgc3JjU3RyaW5nLCBsYXlvdXQsIHBsYWNlaG9sZGVyLCBvbkxvYWRpbmdDb21wbGV0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgfSwgaW1nU3R5bGUsIGJsdXJTdHlsZSlcbiAgICB9KSksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm5vc2NyaXB0XCIsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImltZ1wiLCBPYmplY3QuYXNzaWduKHtcbiAgICB9LCByZXN0LCBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgICAgICAgc3JjLFxuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQsXG4gICAgICAgIHNpemVzLFxuICAgICAgICBsb2FkZXJcbiAgICB9KSwge1xuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBsYXlvdXQsXG4gICAgICAgIHN0eWxlOiBpbWdTdHlsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3RAMTdgXG4gICAgICAgIGxvYWRpbmc6IGxvYWRpbmcgfHwgJ2xhenknXG4gICAgfSkpKSwgcHJpb3JpdHkgPyAvLyBOb3RlIGhvdyB3ZSBvbWl0IHRoZSBgaHJlZmAgYXR0cmlidXRlLCBhcyBpdCB3b3VsZCBvbmx5IGJlIHJlbGV2YW50XG4gICAgLy8gZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYGltYWdlc3Jjc2V0YCwgYW5kIGluIHRob3NlIGNhc2VzXG4gICAgLy8gaXQgd291bGQgbGlrZWx5IGNhdXNlIHRoZSBpbmNvcnJlY3QgaW1hZ2UgdG8gYmUgcHJlbG9hZGVkLlxuICAgIC8vXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjYXR0ci1saW5rLWltYWdlc3Jjc2V0XG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkLmRlZmF1bHQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImxpbmtcIiwge1xuICAgICAgICBrZXk6ICdfX25pbWctJyArIGltZ0F0dHJpYnV0ZXMuc3JjICsgaW1nQXR0cmlidXRlcy5zcmNTZXQgKyBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJpbWFnZVwiLFxuICAgICAgICBocmVmOiBpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjLFxuICAgICAgICAvLyBAdHMtaWdub3JlOiBpbWFnZXNyY3NldCBpcyBub3QgeWV0IGluIHRoZSBsaW5rIGVsZW1lbnQgdHlwZS5cbiAgICAgICAgaW1hZ2VzcmNzZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICAvLyBAdHMtaWdub3JlOiBpbWFnZXNpemVzIGlzIG5vdCB5ZXQgaW4gdGhlIGxpbmsgZWxlbWVudCB0eXBlLlxuICAgICAgICBpbWFnZXNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzXG4gICAgfSkpIDogbnVsbCkpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3JjKHNyYykge1xuICAgIHJldHVybiBzcmNbMF0gPT09ICcvJyA/IHNyYy5zbGljZSgxKSA6IHNyYztcbn1cbmZ1bmN0aW9uIGltZ2l4TG9hZGVyKHsgcm9vdCAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xuICAgIC8vIERlbW86IGh0dHBzOi8vc3RhdGljLmltZ2l4Lm5ldC9kYWlzeS5wbmc/YXV0bz1mb3JtYXQmZml0PW1heCZ3PTMwMFxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7cm9vdH0ke25vcm1hbGl6ZVNyYyhzcmMpfWApO1xuICAgIGNvbnN0IHBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gICAgcGFyYW1zLnNldCgnYXV0bycsIHBhcmFtcy5nZXQoJ2F1dG8nKSB8fCAnZm9ybWF0Jyk7XG4gICAgcGFyYW1zLnNldCgnZml0JywgcGFyYW1zLmdldCgnZml0JykgfHwgJ21heCcpO1xuICAgIHBhcmFtcy5zZXQoJ3cnLCBwYXJhbXMuZ2V0KCd3JykgfHwgd2lkdGgudG9TdHJpbmcoKSk7XG4gICAgaWYgKHF1YWxpdHkpIHtcbiAgICAgICAgcGFyYW1zLnNldCgncScsIHF1YWxpdHkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmwuaHJlZjtcbn1cbmZ1bmN0aW9uIGFrYW1haUxvYWRlcih7IHJvb3QgLCBzcmMgLCB3aWR0aCAgfSkge1xuICAgIHJldHVybiBgJHtyb290fSR7bm9ybWFsaXplU3JjKHNyYyl9P2ltd2lkdGg9JHt3aWR0aH1gO1xufVxuZnVuY3Rpb24gY2xvdWRpbmFyeUxvYWRlcih7IHJvb3QgLCBzcmMgLCB3aWR0aCAsIHF1YWxpdHkgIH0pIHtcbiAgICAvLyBEZW1vOiBodHRwczovL3Jlcy5jbG91ZGluYXJ5LmNvbS9kZW1vL2ltYWdlL3VwbG9hZC93XzMwMCxjX2xpbWl0LHFfYXV0by90dXJ0bGVzLmpwZ1xuICAgIGNvbnN0IHBhcmFtcyA9IFtcbiAgICAgICAgJ2ZfYXV0bycsXG4gICAgICAgICdjX2xpbWl0JyxcbiAgICAgICAgJ3dfJyArIHdpZHRoLFxuICAgICAgICAncV8nICsgKHF1YWxpdHkgfHwgJ2F1dG8nKVxuICAgIF07XG4gICAgbGV0IHBhcmFtc1N0cmluZyA9IHBhcmFtcy5qb2luKCcsJykgKyAnLyc7XG4gICAgcmV0dXJuIGAke3Jvb3R9JHtwYXJhbXNTdHJpbmd9JHtub3JtYWxpemVTcmMoc3JjKX1gO1xufVxuZnVuY3Rpb24gY3VzdG9tTG9hZGVyKHsgc3JjICB9KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgXCJsb2FkZXJcIiBwcm9wLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyYCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHsgcm9vdCAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdWYWx1ZXMgPSBbXTtcbiAgICAgICAgLy8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBwcm92aWRlZCBidXQgbWFrZSBzdXJlIHRoZXkgYXJlXG4gICAgICAgIGlmICghc3JjKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3NyYycpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3dpZHRoJyk7XG4gICAgICAgIGlmIChtaXNzaW5nVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgJHttaXNzaW5nVmFsdWVzLmpvaW4oJywgJyl9IHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgcXVhbGl0eVxuICAgICAgICAgICAgfSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzcmMgXCIke3NyY31cIiBvbiBcXGBuZXh0L2ltYWdlXFxgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoJy8nKSAmJiBjb25maWdEb21haW5zKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkU3JjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgaWYgdXNpbmcgcmVsYXRpdmUgaW1hZ2UgaXQgbXVzdCBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaCBcIi9cIiBvciBiZSBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiAhY29uZmlnRG9tYWlucy5pbmNsdWRlcyhwYXJzZWRTcmMuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNyYyBwcm9wICgke3NyY30pIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGhvc3RuYW1lIFwiJHtwYXJzZWRTcmMuaG9zdG5hbWV9XCIgaXMgbm90IGNvbmZpZ3VyZWQgdW5kZXIgaW1hZ2VzIGluIHlvdXIgXFxgbmV4dC5jb25maWcuanNcXGBcXG5gICsgYFNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdW5jb25maWd1cmVkLWhvc3RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7cm9vdH0/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNyYyl9Jnc9JHt3aWR0aH0mcT0ke3F1YWxpdHkgfHwgNzV9YDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIkltYWdlIiwiX3JlYWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfaGVhZCIsIl90b0Jhc2U2NCIsIl9pbWFnZUNvbmZpZyIsIl91c2VJbnRlcnNlY3Rpb24iLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX2VzTW9kdWxlIiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZvckVhY2giLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJleGNsdWRlZCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlU3ltYm9sS2V5cyIsImluZGV4T2YiLCJwcm90b3R5cGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiLCJzb3VyY2VLZXlzIiwibG9hZGVkSW1hZ2VVUkxzIiwiU2V0IiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImVtcHR5RGF0YVVSTCIsImdsb2JhbCIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsIlZBTElEX0xPQURJTkdfVkFMVUVTIiwidW5kZWZpbmVkIiwibG9hZGVycyIsImRlZmF1bHRMb2FkZXIiLCJpbWdpeExvYWRlciIsImNsb3VkaW5hcnlMb2FkZXIiLCJha2FtYWlMb2FkZXIiLCJjdXN0b21Mb2FkZXIiLCJWQUxJRF9MQVlPVVRfVkFMVUVTIiwiaXNTdGF0aWNSZXF1aXJlIiwic3JjIiwiaXNTdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY0ltcG9ydCIsImRldmljZVNpemVzIiwiY29uZmlnRGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwiY29uZmlnSW1hZ2VTaXplcyIsImxvYWRlciIsImNvbmZpZ0xvYWRlciIsInBhdGgiLCJjb25maWdQYXRoIiwiZG9tYWlucyIsImNvbmZpZ0RvbWFpbnMiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsInNvcnQiLCJhIiwiYiIsImdldFdpZHRocyIsIndpZHRoIiwibGF5b3V0Iiwic2l6ZXMiLCJ2aWV3cG9ydFdpZHRoUmUiLCJwZXJjZW50U2l6ZXMiLCJtYXRjaCIsImV4ZWMiLCJwdXNoIiwicGFyc2VJbnQiLCJzbWFsbGVzdFJhdGlvIiwiTWF0aCIsIm1pbiIsIndpZHRocyIsInMiLCJraW5kIiwibWFwIiwidyIsImZpbmQiLCJwIiwiZ2VuZXJhdGVJbWdBdHRycyIsInVub3B0aW1pemVkIiwicXVhbGl0eSIsInNyY1NldCIsImxhc3QiLCJqb2luIiwiZ2V0SW50IiwieCIsImRlZmF1bHRJbWFnZUxvYWRlciIsImxvYWRlclByb3BzIiwibG9hZCIsImdldCIsInJvb3QiLCJFcnJvciIsIlZBTElEX0xPQURFUlMiLCJoYW5kbGVMb2FkaW5nIiwiaW1nIiwicGxhY2Vob2xkZXIiLCJvbkxvYWRpbmdDb21wbGV0ZSIsImhhbmRsZUxvYWQiLCJkZWNvZGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNhdGNoIiwidGhlbiIsInN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJhZGQiLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwicmVmIiwicGFyZW50RWxlbWVudCIsInBhcmVudCIsImdldENvbXB1dGVkU3R5bGUiLCJkaXNwbGF5IiwiY29uc29sZSIsIndhcm4iLCJwb3NpdGlvbiIsImNvbXBsZXRlIiwib25sb2FkIiwiX3BhcmFtIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwibGF6eUJvdW5kYXJ5IiwiY2xhc3NOYW1lIiwiaGVpZ2h0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJibHVyRGF0YVVSTCIsImFsbCIsInJlc3QiLCJzdGF0aWNTcmMiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5Iiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJxdWFsaXR5SW50IiwiaXNMYXp5Iiwic3RhcnRzV2l0aCIsImhhcyIsImluY2x1ZGVzIiwiU3RyaW5nIiwiaXNOYU4iLCJWQUxJRF9CTFVSX0VYVCIsInJhbmQiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwid2luZG93IiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsImVudHJ5TGlzdCIsImVudHJ5IiwiZ2V0RW50cmllcyIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJzZXRSZWYiLCJpc0ludGVyc2VjdGVkIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdE1hcmdpbiIsImRpc2FibGVkIiwiaXNWaXNpYmxlIiwid3JhcHBlclN0eWxlIiwiYm94U2l6aW5nIiwib3ZlcmZsb3ciLCJiYWNrZ3JvdW5kIiwib3BhY2l0eSIsImJvcmRlciIsIm1hcmdpbiIsInBhZGRpbmciLCJzaXplclN0eWxlIiwiaGFzU2l6ZXIiLCJzaXplclN2ZyIsImltZ1N0eWxlIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0IiwibWluV2lkdGgiLCJtYXhXaWR0aCIsIm1pbkhlaWdodCIsIm1heEhlaWdodCIsImJsdXJTdHlsZSIsImJhY2tncm91bmRQb3NpdGlvbiIsInF1b3RpZW50IiwicGFkZGluZ1RvcCIsImltZ0F0dHJpYnV0ZXMiLCJzcmNTdHJpbmciLCJmdWxsVXJsIiwiVVJMIiwiZSIsImxvY2F0aW9uIiwiaHJlZiIsInNldCIsImNyZWF0ZUVsZW1lbnQiLCJhbHQiLCJ0b0Jhc2U2NCIsImFzc2lnbiIsImRlY29kaW5nIiwicmVsIiwiYXMiLCJpbWFnZXNyY3NldCIsImltYWdlc2l6ZXMiLCJub3JtYWxpemVTcmMiLCJzbGljZSIsInVybCIsInBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInBhcmFtc1N0cmluZyIsIm1pc3NpbmdWYWx1ZXMiLCJwYXJzZWRTcmMiLCJlcnIiLCJlcnJvciIsImhvc3RuYW1lIiwiZW5jb2RlVVJJQ29tcG9uZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.cancelIdleCallback = exports.requestIdleCallback = void 0;\nconst requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nexports.requestIdleCallback = requestIdleCallback;\nconst cancelIdleCallback = typeof self !== 'undefined' && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nexports.cancelIdleCallback = cancelIdleCallback; //# sourceMappingURL=request-idle-callback.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWkEsOENBQTZDLENBQUM7SUFDMUNHLEtBQUssRUFBRSxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHQSwyQkFBMkIsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUNqRSxLQUFLLENBQUNHLG1CQUFtQixHQUFHLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLENBQVcsY0FBSUEsSUFBSSxDQUFDRCxtQkFBbUIsSUFBSUMsSUFBSSxDQUFDRCxtQkFBbUIsQ0FBQ0UsSUFBSSxDQUFDQyxNQUFNLEtBQUssUUFBUSxDQUFDQyxFQUFFLEVBQUUsQ0FBQztJQUMxSSxHQUFHLENBQUNDLEtBQUssR0FBR0MsSUFBSSxDQUFDQyxHQUFHO0lBQ3BCLE1BQU0sQ0FBQ0MsVUFBVSxDQUFDLFFBQVEsR0FBRyxDQUFDO1FBQzFCSixFQUFFLENBQUMsQ0FBQztZQUNBSyxVQUFVLEVBQUUsS0FBSztZQUNqQkMsYUFBYSxFQUFFLFFBQVEsR0FBRyxDQUFDO2dCQUN2QixNQUFNLENBQUNDLElBQUksQ0FBQ0MsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUlOLElBQUksQ0FBQ0MsR0FBRyxLQUFLRixLQUFLO1lBQy9DLENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQyxFQUFFLENBQUM7QUFDUixDQUFDO0FBQ0RSLDJCQUEyQixHQUFHRyxtQkFBbUI7QUFDakQsS0FBSyxDQUFDRCxrQkFBa0IsR0FBRyxNQUFNLENBQUNFLElBQUksS0FBSyxDQUFXLGNBQUlBLElBQUksQ0FBQ0Ysa0JBQWtCLElBQUlFLElBQUksQ0FBQ0Ysa0JBQWtCLENBQUNHLElBQUksQ0FBQ0MsTUFBTSxLQUFLLFFBQVEsQ0FBQ1UsRUFBRSxFQUFFLENBQUM7SUFDdkksTUFBTSxDQUFDQyxZQUFZLENBQUNELEVBQUU7QUFDMUIsQ0FBQztBQUNEaEIsMEJBQTBCLEdBQUdFLGtCQUFrQixDQUUvQyxDQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcz8xZTIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBleHBvcnRzLnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB2b2lkIDA7XG5jb25zdCByZXF1ZXN0SWRsZUNhbGxiYWNrID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYucmVxdWVzdElkbGVDYWxsYmFjayAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2suYmluZCh3aW5kb3cpIHx8IGZ1bmN0aW9uKGNiKSB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgY2Ioe1xuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgNTAgLSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIDEpO1xufTtcbmV4cG9ydHMucmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVlc3RJZGxlQ2FsbGJhY2s7XG5jb25zdCBjYW5jZWxJZGxlQ2FsbGJhY2sgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5jYW5jZWxJZGxlQ2FsbGJhY2sgJiYgc2VsZi5jYW5jZWxJZGxlQ2FsbGJhY2suYmluZCh3aW5kb3cpIHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChpZCk7XG59O1xuZXhwb3J0cy5jYW5jZWxJZGxlQ2FsbGJhY2sgPSBjYW5jZWxJZGxlQ2FsbGJhY2s7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3QtaWRsZS1jYWxsYmFjay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2VsZiIsImJpbmQiLCJ3aW5kb3ciLCJjYiIsInN0YXJ0IiwiRGF0ZSIsIm5vdyIsInNldFRpbWVvdXQiLCJkaWRUaW1lb3V0IiwidGltZVJlbWFpbmluZyIsIk1hdGgiLCJtYXgiLCJpZCIsImNsZWFyVGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/request-idle-callback.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useIntersection = useIntersection;\nvar _react = __webpack_require__(/*! react */ \"react\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\nfunction useIntersection({ rootMargin , disabled  }) {\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const unobserve = (0, _react).useRef();\n    const [visible, setVisible] = (0, _react).useState(false);\n    const setRef = (0, _react).useCallback((el)=>{\n        if (unobserve.current) {\n            unobserve.current();\n            unobserve.current = undefined;\n        }\n        if (isDisabled || visible) return;\n        if (el && el.tagName) {\n            unobserve.current = observe(el, (isVisible)=>isVisible && setVisible(isVisible)\n            , {\n                rootMargin\n            });\n        }\n    }, [\n        isDisabled,\n        rootMargin,\n        visible\n    ]);\n    (0, _react).useEffect(()=>{\n        if (!hasIntersectionObserver) {\n            if (!visible) {\n                const idleCallback = (0, _requestIdleCallback).requestIdleCallback(()=>setVisible(true)\n                );\n                return ()=>(0, _requestIdleCallback).cancelIdleCallback(idleCallback)\n                ;\n            }\n        }\n    }, [\n        visible\n    ]);\n    return [\n        setRef,\n        visible\n    ];\n}\nfunction observe(element, callback, options) {\n    const { id , observer , elements  } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n        }\n    };\n}\nconst observers = new Map();\nfunction createObserver(options) {\n    const id = options.rootMargin || '';\n    let instance = observers.get(id);\n    if (instance) {\n        return instance;\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    observers.set(id, instance = {\n        id,\n        observer,\n        elements\n    });\n    return instance;\n} //# sourceMappingURL=use-intersection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1pBLDhDQUE2QyxDQUFDO0lBQzFDRyxLQUFLLEVBQUUsSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0UsZUFBZTtBQUN6QyxHQUFHLENBQUNDLE1BQU0sR0FBR0MsbUJBQU8sQ0FBQyxvQkFBTztBQUM1QixHQUFHLENBQUNDLG9CQUFvQixHQUFHRCxtQkFBTyxDQUFDLHlGQUF5QjtBQUM1RCxLQUFLLENBQUNFLHVCQUF1QixHQUFHLE1BQU0sQ0FBQ0Msb0JBQW9CLEtBQUssQ0FBVztTQUNsRUwsZUFBZSxDQUFDLENBQUMsQ0FBQ00sVUFBVSxHQUFHQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDbEQsS0FBSyxDQUFDQyxVQUFVLEdBQUdELFFBQVEsS0FBS0gsdUJBQXVCO0lBQ3ZELEtBQUssQ0FBQ0ssU0FBUyxJQUFJLENBQUMsRUFBRVIsTUFBTSxFQUFFUyxNQUFNO0lBQ3BDLEtBQUssRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEtBQUssQ0FBQyxFQUFFWCxNQUFNLEVBQUVZLFFBQVEsQ0FBQyxLQUFLO0lBQ3hELEtBQUssQ0FBQ0MsTUFBTSxJQUFJLENBQUMsRUFBRWIsTUFBTSxFQUFFYyxXQUFXLEVBQUVDLEVBQUUsR0FBRyxDQUFDO1FBQzFDLEVBQUUsRUFBRVAsU0FBUyxDQUFDUSxPQUFPLEVBQUUsQ0FBQztZQUNwQlIsU0FBUyxDQUFDUSxPQUFPO1lBQ2pCUixTQUFTLENBQUNRLE9BQU8sR0FBR0MsU0FBUztRQUNqQyxDQUFDO1FBQ0QsRUFBRSxFQUFFVixVQUFVLElBQUlHLE9BQU8sRUFBRSxNQUFNO1FBQ2pDLEVBQUUsRUFBRUssRUFBRSxJQUFJQSxFQUFFLENBQUNHLE9BQU8sRUFBRSxDQUFDO1lBQ25CVixTQUFTLENBQUNRLE9BQU8sR0FBR0csT0FBTyxDQUFDSixFQUFFLEdBQUdLLFNBQVMsR0FBR0EsU0FBUyxJQUFJVCxVQUFVLENBQUNTLFNBQVM7Y0FDNUUsQ0FBQztnQkFDQ2YsVUFBVTtZQUNkLENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQyxFQUFFLENBQUM7UUFDQUUsVUFBVTtRQUNWRixVQUFVO1FBQ1ZLLE9BQU87SUFDWCxDQUFDO0tBQ0EsQ0FBQyxFQUFFVixNQUFNLEVBQUVxQixTQUFTLEtBQUssQ0FBQztRQUN2QixFQUFFLEdBQUdsQix1QkFBdUIsRUFBRSxDQUFDO1lBQzNCLEVBQUUsR0FBR08sT0FBTyxFQUFFLENBQUM7Z0JBQ1gsS0FBSyxDQUFDWSxZQUFZLElBQUksQ0FBQyxFQUFFcEIsb0JBQW9CLEVBQUVxQixtQkFBbUIsS0FBS1osVUFBVSxDQUFDLElBQUk7O2dCQUV0RixNQUFNLE1BQU0sQ0FBQyxFQUFFVCxvQkFBb0IsRUFBRXNCLGtCQUFrQixDQUFDRixZQUFZOztZQUV4RSxDQUFDO1FBQ0wsQ0FBQztJQUNMLENBQUMsRUFBRSxDQUFDO1FBQ0FaLE9BQU87SUFDWCxDQUFDO0lBQ0QsTUFBTSxDQUFDLENBQUM7UUFDSkcsTUFBTTtRQUNOSCxPQUFPO0lBQ1gsQ0FBQztBQUNMLENBQUM7U0FDUVMsT0FBTyxDQUFDTSxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFLENBQUM7SUFDMUMsS0FBSyxDQUFDLENBQUMsQ0FBQ0MsRUFBRSxHQUFHQyxRQUFRLEdBQUdDLFFBQVEsRUFBRSxDQUFDLEdBQUdDLGNBQWMsQ0FBQ0osT0FBTztJQUM1REcsUUFBUSxDQUFDRSxHQUFHLENBQUNQLE9BQU8sRUFBRUMsUUFBUTtJQUM5QkcsUUFBUSxDQUFDVixPQUFPLENBQUNNLE9BQU87SUFDeEIsTUFBTSxDQUFDLFFBQVEsQ0FBQ2pCLFNBQVMsR0FBRyxDQUFDO1FBQ3pCc0IsUUFBUSxDQUFDRyxNQUFNLENBQUNSLE9BQU87UUFDdkJJLFFBQVEsQ0FBQ3JCLFNBQVMsQ0FBQ2lCLE9BQU87UUFDMUIsRUFBdUQ7UUFDdkQsRUFBRSxFQUFFSyxRQUFRLENBQUNJLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUN0QkwsUUFBUSxDQUFDTSxVQUFVO1lBQ25CQyxTQUFTLENBQUNILE1BQU0sQ0FBQ0wsRUFBRTtRQUN2QixDQUFDO0lBQ0wsQ0FBQztBQUNMLENBQUM7QUFDRCxLQUFLLENBQUNRLFNBQVMsR0FBRyxHQUFHLENBQUNDLEdBQUc7U0FDaEJOLGNBQWMsQ0FBQ0osT0FBTyxFQUFFLENBQUM7SUFDOUIsS0FBSyxDQUFDQyxFQUFFLEdBQUdELE9BQU8sQ0FBQ3RCLFVBQVUsSUFBSSxDQUFFO0lBQ25DLEdBQUcsQ0FBQ2lDLFFBQVEsR0FBR0YsU0FBUyxDQUFDRyxHQUFHLENBQUNYLEVBQUU7SUFDL0IsRUFBRSxFQUFFVSxRQUFRLEVBQUUsQ0FBQztRQUNYLE1BQU0sQ0FBQ0EsUUFBUTtJQUNuQixDQUFDO0lBQ0QsS0FBSyxDQUFDUixRQUFRLEdBQUcsR0FBRyxDQUFDTyxHQUFHO0lBQ3hCLEtBQUssQ0FBQ1IsUUFBUSxHQUFHLEdBQUcsQ0FBQ3pCLG9CQUFvQixFQUFFb0MsT0FBTyxHQUFHLENBQUM7UUFDbERBLE9BQU8sQ0FBQ0MsT0FBTyxFQUFFQyxLQUFLLEdBQUcsQ0FBQztZQUN0QixLQUFLLENBQUNoQixRQUFRLEdBQUdJLFFBQVEsQ0FBQ1MsR0FBRyxDQUFDRyxLQUFLLENBQUNDLE1BQU07WUFDMUMsS0FBSyxDQUFDdkIsU0FBUyxHQUFHc0IsS0FBSyxDQUFDRSxjQUFjLElBQUlGLEtBQUssQ0FBQ0csaUJBQWlCLEdBQUcsQ0FBQztZQUNyRSxFQUFFLEVBQUVuQixRQUFRLElBQUlOLFNBQVMsRUFBRSxDQUFDO2dCQUN4Qk0sUUFBUSxDQUFDTixTQUFTO1lBQ3RCLENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQyxFQUFFTyxPQUFPO0lBQ1ZTLFNBQVMsQ0FBQ0osR0FBRyxDQUFDSixFQUFFLEVBQUVVLFFBQVEsR0FBRyxDQUFDO1FBQzFCVixFQUFFO1FBQ0ZDLFFBQVE7UUFDUkMsUUFBUTtJQUNaLENBQUM7SUFDRCxNQUFNLENBQUNRLFFBQVE7QUFDbkIsQ0FBQyxDQUUyQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlSW50ZXJzZWN0aW9uID0gdXNlSW50ZXJzZWN0aW9uO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBfcmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbih7IHJvb3RNYXJnaW4gLCBkaXNhYmxlZCAgfSkge1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSBkaXNhYmxlZCB8fCAhaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gICAgY29uc3QgdW5vYnNlcnZlID0gKDAsIF9yZWFjdCkudXNlUmVmKCk7XG4gICAgY29uc3QgW3Zpc2libGUsIHNldFZpc2libGVdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHNldFJlZiA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKChlbCk9PntcbiAgICAgICAgaWYgKHVub2JzZXJ2ZS5jdXJyZW50KSB7XG4gICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCgpO1xuICAgICAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuO1xuICAgICAgICBpZiAoZWwgJiYgZWwudGFnTmFtZSkge1xuICAgICAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSBvYnNlcnZlKGVsLCAoaXNWaXNpYmxlKT0+aXNWaXNpYmxlICYmIHNldFZpc2libGUoaXNWaXNpYmxlKVxuICAgICAgICAgICAgLCB7XG4gICAgICAgICAgICAgICAgcm9vdE1hcmdpblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgIHZpc2libGVcbiAgICBdKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKCFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRsZUNhbGxiYWNrID0gKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5zZXRWaXNpYmxlKHRydWUpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCk9PigwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykuY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGVDYWxsYmFjaylcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHZpc2libGVcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZXRSZWYsXG4gICAgICAgIHZpc2libGVcbiAgICBdO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZShlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgaWQgLCBvYnNlcnZlciAsIGVsZW1lbnRzICB9ID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucyk7XG4gICAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKSB7XG4gICAgICAgIGVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAvLyBEZXN0cm95IG9ic2VydmVyIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gd2F0Y2g6XG4gICAgICAgIGlmIChlbGVtZW50cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBvYnNlcnZlcnMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gICAgY29uc3QgaWQgPSBvcHRpb25zLnJvb3RNYXJnaW4gfHwgJyc7XG4gICAgbGV0IGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChpZCk7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpPT57XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgfHwgZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGlzVmlzaWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIG9ic2VydmVycy5zZXQoaWQsIGluc3RhbmNlID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgb2JzZXJ2ZXIsXG4gICAgICAgIGVsZW1lbnRzXG4gICAgfSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtaW50ZXJzZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVzZUludGVyc2VjdGlvbiIsIl9yZWFjdCIsInJlcXVpcmUiLCJfcmVxdWVzdElkbGVDYWxsYmFjayIsImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyb290TWFyZ2luIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwidW5vYnNlcnZlIiwidXNlUmVmIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJ1c2VTdGF0ZSIsInNldFJlZiIsInVzZUNhbGxiYWNrIiwiZWwiLCJjdXJyZW50IiwidW5kZWZpbmVkIiwidGFnTmFtZSIsIm9ic2VydmUiLCJpc1Zpc2libGUiLCJ1c2VFZmZlY3QiLCJpZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwiZWxlbWVudCIsImNhbGxiYWNrIiwib3B0aW9ucyIsImlkIiwib2JzZXJ2ZXIiLCJlbGVtZW50cyIsImNyZWF0ZU9ic2VydmVyIiwic2V0IiwiZGVsZXRlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJvYnNlcnZlcnMiLCJNYXAiLCJpbnN0YW5jZSIsImdldCIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJ0YXJnZXQiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n");

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"react/jsx-runtime\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"next/head\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/Header */ \"./components/Header.js\");\n/* harmony import */ var _components_Feed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Feed */ \"./components/Feed.js\");\n/* harmony import */ var _components_Modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Modal */ \"./components/Modal.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_components_Modal__WEBPACK_IMPORTED_MODULE_4__, _components_Feed__WEBPACK_IMPORTED_MODULE_3__]);\n([_components_Modal__WEBPACK_IMPORTED_MODULE_4__, _components_Feed__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__);\n\n\n\n\n\n// import Feed from \"../components/Feed\";\n// import Modal from \"../components/Modal\";\nfunction Home() {\n    return(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"bg-red-50 h-screen overflow-y-scroll scrollbar-hide\",\n        __source: {\n            fileName: \"/Users/alexoh/Documents/Projects/photo-app/pages/index.js\",\n            lineNumber: 10\n        },\n        __self: this,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/pages/index.js\",\n                    lineNumber: 11\n                },\n                __self: this,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/pages/index.js\",\n                            lineNumber: 12\n                        },\n                        __self: this,\n                        children: \"Photo App\"\n                    }),\n                    /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\",\n                        __source: {\n                            fileName: \"/Users/alexoh/Documents/Projects/photo-app/pages/index.js\",\n                            lineNumber: 13\n                        },\n                        __self: this\n                    })\n                ]\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Header__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/pages/index.js\",\n                    lineNumber: 15\n                },\n                __self: this\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Feed__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/pages/index.js\",\n                    lineNumber: 16\n                },\n                __self: this\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Modal__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                __source: {\n                    fileName: \"/Users/alexoh/Documents/Projects/photo-app/pages/index.js\",\n                    lineNumber: 17\n                },\n                __self: this\n            })\n        ]\n    }));\n};\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNEI7QUFDYTtBQUNKO0FBQ0U7QUFFdkMsRUFBeUM7QUFDekMsRUFBMkM7QUFDNUIsUUFBUSxDQUFDSSxJQUFJLEdBQUcsQ0FBQztJQUM5QixNQUFNLHVFQUNIQyxDQUFHO1FBQUNDLFNBQVMsRUFBQyxDQUFxRDs7Ozs7OztrRkFDakVOLGtEQUFJOzs7Ozs7O3lGQUNGTyxDQUFLOzs7Ozs7a0NBQUMsQ0FBUzs7eUZBQ2ZDLENBQUk7d0JBQUNDLEdBQUcsRUFBQyxDQUFNO3dCQUFDQyxJQUFJLEVBQUMsQ0FBYzs7Ozs7Ozs7O2lGQUVyQ1QsMERBQU07Ozs7Ozs7aUZBQ05DLHdEQUFJOzs7Ozs7O2lGQUNKQyx5REFBSzs7Ozs7Ozs7O0FBR1osQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3BhZ2VzL2luZGV4LmpzP2JlZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhlYWQgZnJvbSBcIm5leHQvaGVhZFwiO1xuaW1wb3J0IEhlYWRlciBmcm9tIFwiLi4vY29tcG9uZW50cy9IZWFkZXJcIjtcbmltcG9ydCBGZWVkIGZyb20gXCIuLi9jb21wb25lbnRzL0ZlZWRcIjtcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vY29tcG9uZW50cy9Nb2RhbFwiO1xuXG4vLyBpbXBvcnQgRmVlZCBmcm9tIFwiLi4vY29tcG9uZW50cy9GZWVkXCI7XG4vLyBpbXBvcnQgTW9kYWwgZnJvbSBcIi4uL2NvbXBvbmVudHMvTW9kYWxcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJiZy1yZWQtNTAgaC1zY3JlZW4gb3ZlcmZsb3cteS1zY3JvbGwgc2Nyb2xsYmFyLWhpZGVcIj5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8dGl0bGU+UGhvdG8gQXBwPC90aXRsZT5cbiAgICAgICAgPGxpbmsgcmVsPVwiaWNvblwiIGhyZWY9XCIvZmF2aWNvbi5pY29cIiAvPlxuICAgICAgPC9IZWFkPlxuICAgICAgPEhlYWRlciAvPlxuICAgICAgPEZlZWQgLz5cbiAgICAgIDxNb2RhbCAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIkhlYWQiLCJIZWFkZXIiLCJGZWVkIiwiTW9kYWwiLCJIb21lIiwiZGl2IiwiY2xhc3NOYW1lIiwidGl0bGUiLCJsaW5rIiwicmVsIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/index.js\n");

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./dist/client/image */ \"./node_modules/next/dist/client/image.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyR0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcz8wNTM1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9pbWFnZScpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n");

/***/ }),

/***/ "@grpc/grpc-js":
/*!********************************!*\
  !*** external "@grpc/grpc-js" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@grpc/grpc-js");

/***/ }),

/***/ "@grpc/proto-loader":
/*!*************************************!*\
  !*** external "@grpc/proto-loader" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@grpc/proto-loader");

/***/ }),

/***/ "@heroicons/react/outline":
/*!*******************************************!*\
  !*** external "@heroicons/react/outline" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@heroicons/react/outline");

/***/ }),

/***/ "@heroicons/react/solid":
/*!*****************************************!*\
  !*** external "@heroicons/react/solid" ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@heroicons/react/solid");

/***/ }),

/***/ "next-auth/react":
/*!**********************************!*\
  !*** external "next-auth/react" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("next-auth/react");

/***/ }),

/***/ "../server/image-config":
/*!***************************************************!*\
  !*** external "next/dist/server/image-config.js" ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/image-config.js");

/***/ }),

/***/ "../shared/lib/head":
/*!***********************************************!*\
  !*** external "next/dist/shared/lib/head.js" ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/head.js");

/***/ }),

/***/ "../shared/lib/to-base-64":
/*!*****************************************************!*\
  !*** external "next/dist/shared/lib/to-base-64.js" ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/to-base-64.js");

/***/ }),

/***/ "next/head":
/*!****************************!*\
  !*** external "next/head" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/head");

/***/ }),

/***/ "next/router":
/*!******************************!*\
  !*** external "next/router" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/router");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react-moment":
/*!*******************************!*\
  !*** external "react-moment" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-moment");

/***/ }),

/***/ "react/jsx-runtime":
/*!************************************!*\
  !*** external "react/jsx-runtime" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-runtime");

/***/ }),

/***/ "recoil":
/*!*************************!*\
  !*** external "recoil" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("recoil");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "@firebase/app":
/*!********************************!*\
  !*** external "@firebase/app" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = import("@firebase/app");;

/***/ }),

/***/ "@firebase/component":
/*!**************************************!*\
  !*** external "@firebase/component" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = import("@firebase/component");;

/***/ }),

/***/ "@firebase/logger":
/*!***********************************!*\
  !*** external "@firebase/logger" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = import("@firebase/logger");;

/***/ }),

/***/ "@firebase/storage":
/*!************************************!*\
  !*** external "@firebase/storage" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = import("@firebase/storage");;

/***/ }),

/***/ "@firebase/util":
/*!*********************************!*\
  !*** external "@firebase/util" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = import("@firebase/util");;

/***/ }),

/***/ "@headlessui/react":
/*!************************************!*\
  !*** external "@headlessui/react" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = import("@headlessui/react");;

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "./node_modules/@firebase/firestore/dist/index.node.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/firestore/dist/index.node.mjs ***!
  \**************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractUserDataWriter\": () => (/* binding */ AbstractUserDataWriter),\n/* harmony export */   \"Bytes\": () => (/* binding */ Bytes),\n/* harmony export */   \"CACHE_SIZE_UNLIMITED\": () => (/* binding */ CACHE_SIZE_UNLIMITED),\n/* harmony export */   \"CollectionReference\": () => (/* binding */ CollectionReference),\n/* harmony export */   \"DocumentReference\": () => (/* binding */ DocumentReference),\n/* harmony export */   \"DocumentSnapshot\": () => (/* binding */ DocumentSnapshot),\n/* harmony export */   \"FieldPath\": () => (/* binding */ FieldPath),\n/* harmony export */   \"FieldValue\": () => (/* binding */ FieldValue),\n/* harmony export */   \"Firestore\": () => (/* binding */ Firestore),\n/* harmony export */   \"FirestoreError\": () => (/* binding */ FirestoreError),\n/* harmony export */   \"GeoPoint\": () => (/* binding */ GeoPoint),\n/* harmony export */   \"LoadBundleTask\": () => (/* binding */ LoadBundleTask),\n/* harmony export */   \"Query\": () => (/* binding */ Query),\n/* harmony export */   \"QueryConstraint\": () => (/* binding */ QueryConstraint),\n/* harmony export */   \"QueryDocumentSnapshot\": () => (/* binding */ QueryDocumentSnapshot),\n/* harmony export */   \"QuerySnapshot\": () => (/* binding */ QuerySnapshot),\n/* harmony export */   \"SnapshotMetadata\": () => (/* binding */ SnapshotMetadata),\n/* harmony export */   \"Timestamp\": () => (/* binding */ Timestamp),\n/* harmony export */   \"Transaction\": () => (/* binding */ Transaction),\n/* harmony export */   \"WriteBatch\": () => (/* binding */ WriteBatch),\n/* harmony export */   \"_DatabaseId\": () => (/* binding */ DatabaseId),\n/* harmony export */   \"_DocumentKey\": () => (/* binding */ DocumentKey),\n/* harmony export */   \"_EmptyAppCheckTokenProvider\": () => (/* binding */ EmptyAppCheckTokenProvider),\n/* harmony export */   \"_EmptyAuthCredentialsProvider\": () => (/* binding */ EmptyAuthCredentialsProvider),\n/* harmony export */   \"_FieldPath\": () => (/* binding */ FieldPath$1),\n/* harmony export */   \"_cast\": () => (/* binding */ cast),\n/* harmony export */   \"_debugAssert\": () => (/* binding */ debugAssert),\n/* harmony export */   \"_isBase64Available\": () => (/* binding */ isBase64Available),\n/* harmony export */   \"_logWarn\": () => (/* binding */ logWarn),\n/* harmony export */   \"_setIndexConfiguration\": () => (/* binding */ setIndexConfiguration),\n/* harmony export */   \"_validateIsNotUsedTogether\": () => (/* binding */ validateIsNotUsedTogether),\n/* harmony export */   \"addDoc\": () => (/* binding */ addDoc),\n/* harmony export */   \"arrayRemove\": () => (/* binding */ arrayRemove),\n/* harmony export */   \"arrayUnion\": () => (/* binding */ arrayUnion),\n/* harmony export */   \"clearIndexedDbPersistence\": () => (/* binding */ clearIndexedDbPersistence),\n/* harmony export */   \"collection\": () => (/* binding */ collection),\n/* harmony export */   \"collectionGroup\": () => (/* binding */ collectionGroup),\n/* harmony export */   \"connectFirestoreEmulator\": () => (/* binding */ connectFirestoreEmulator),\n/* harmony export */   \"deleteDoc\": () => (/* binding */ deleteDoc),\n/* harmony export */   \"deleteField\": () => (/* binding */ deleteField),\n/* harmony export */   \"disableNetwork\": () => (/* binding */ disableNetwork),\n/* harmony export */   \"doc\": () => (/* binding */ doc),\n/* harmony export */   \"documentId\": () => (/* binding */ documentId),\n/* harmony export */   \"enableIndexedDbPersistence\": () => (/* binding */ enableIndexedDbPersistence),\n/* harmony export */   \"enableMultiTabIndexedDbPersistence\": () => (/* binding */ enableMultiTabIndexedDbPersistence),\n/* harmony export */   \"enableNetwork\": () => (/* binding */ enableNetwork),\n/* harmony export */   \"endAt\": () => (/* binding */ endAt),\n/* harmony export */   \"endBefore\": () => (/* binding */ endBefore),\n/* harmony export */   \"ensureFirestoreConfigured\": () => (/* binding */ ensureFirestoreConfigured),\n/* harmony export */   \"executeWrite\": () => (/* binding */ executeWrite),\n/* harmony export */   \"getDoc\": () => (/* binding */ getDoc),\n/* harmony export */   \"getDocFromCache\": () => (/* binding */ getDocFromCache),\n/* harmony export */   \"getDocFromServer\": () => (/* binding */ getDocFromServer),\n/* harmony export */   \"getDocs\": () => (/* binding */ getDocs),\n/* harmony export */   \"getDocsFromCache\": () => (/* binding */ getDocsFromCache),\n/* harmony export */   \"getDocsFromServer\": () => (/* binding */ getDocsFromServer),\n/* harmony export */   \"getFirestore\": () => (/* binding */ getFirestore),\n/* harmony export */   \"increment\": () => (/* binding */ increment),\n/* harmony export */   \"initializeFirestore\": () => (/* binding */ initializeFirestore),\n/* harmony export */   \"limit\": () => (/* binding */ limit),\n/* harmony export */   \"limitToLast\": () => (/* binding */ limitToLast),\n/* harmony export */   \"loadBundle\": () => (/* binding */ loadBundle),\n/* harmony export */   \"namedQuery\": () => (/* binding */ namedQuery),\n/* harmony export */   \"onSnapshot\": () => (/* binding */ onSnapshot),\n/* harmony export */   \"onSnapshotsInSync\": () => (/* binding */ onSnapshotsInSync),\n/* harmony export */   \"orderBy\": () => (/* binding */ orderBy),\n/* harmony export */   \"query\": () => (/* binding */ query),\n/* harmony export */   \"queryEqual\": () => (/* binding */ queryEqual),\n/* harmony export */   \"refEqual\": () => (/* binding */ refEqual),\n/* harmony export */   \"runTransaction\": () => (/* binding */ runTransaction),\n/* harmony export */   \"serverTimestamp\": () => (/* binding */ serverTimestamp),\n/* harmony export */   \"setDoc\": () => (/* binding */ setDoc),\n/* harmony export */   \"setLogLevel\": () => (/* binding */ setLogLevel),\n/* harmony export */   \"snapshotEqual\": () => (/* binding */ snapshotEqual),\n/* harmony export */   \"startAfter\": () => (/* binding */ startAfter),\n/* harmony export */   \"startAt\": () => (/* binding */ startAt),\n/* harmony export */   \"terminate\": () => (/* binding */ terminate),\n/* harmony export */   \"updateDoc\": () => (/* binding */ updateDoc),\n/* harmony export */   \"waitForPendingWrites\": () => (/* binding */ waitForPendingWrites),\n/* harmony export */   \"where\": () => (/* binding */ where),\n/* harmony export */   \"writeBatch\": () => (/* binding */ writeBatch)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"@firebase/app\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"@firebase/component\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/logger */ \"@firebase/logger\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/util */ \"@firebase/util\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @grpc/grpc-js */ \"@grpc/grpc-js\");\n/* harmony import */ var _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @grpc/proto-loader */ \"@grpc/proto-loader\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_firebase_util__WEBPACK_IMPORTED_MODULE_4__, _firebase_app__WEBPACK_IMPORTED_MODULE_0__, _firebase_component__WEBPACK_IMPORTED_MODULE_1__, _firebase_logger__WEBPACK_IMPORTED_MODULE_2__]);\n([_firebase_util__WEBPACK_IMPORTED_MODULE_4__, _firebase_app__WEBPACK_IMPORTED_MODULE_0__, _firebase_component__WEBPACK_IMPORTED_MODULE_1__, _firebase_logger__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\nconst name = \"@firebase/firestore\";\nconst version$1 = \"3.4.5\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Simple wrapper around a nullable UID. Mostly exists to make code more\r\n * readable.\r\n */\r\nclass User {\r\n    constructor(uid) {\r\n        this.uid = uid;\r\n    }\r\n    isAuthenticated() {\r\n        return this.uid != null;\r\n    }\r\n    /**\r\n     * Returns a key representing this user, suitable for inclusion in a\r\n     * dictionary.\r\n     */\r\n    toKey() {\r\n        if (this.isAuthenticated()) {\r\n            return 'uid:' + this.uid;\r\n        }\r\n        else {\r\n            return 'anonymous-user';\r\n        }\r\n    }\r\n    isEqual(otherUser) {\r\n        return otherUser.uid === this.uid;\r\n    }\r\n}\r\n/** A user with a null UID. */\r\nUser.UNAUTHENTICATED = new User(null);\r\n// TODO(mikelehen): Look into getting a proper uid-equivalent for\r\n// non-FirebaseAuth providers.\r\nUser.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\r\nUser.FIRST_PARTY = new User('first-party-uid');\r\nUser.MOCK_USER = new User('mock-user');\n\nconst version = \"9.6.7\";\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet SDK_VERSION = version;\r\nfunction setSDKVersion(version) {\r\n    SDK_VERSION = version;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Formats an object as a JSON string, suitable for logging. */\r\nfunction formatJSON(value) {\r\n    // util.inspect() results in much more readable output than JSON.stringify()\r\n    return (0,util__WEBPACK_IMPORTED_MODULE_3__.inspect)(value, { depth: 100 });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.Logger('@firebase/firestore');\r\n// Helper methods are needed because variables can't be exported as read/write\r\nfunction getLogLevel() {\r\n    return logClient.logLevel;\r\n}\r\n/**\r\n * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).\r\n *\r\n * @param logLevel - The verbosity you set for activity and error logging. Can\r\n *   be any of the following values:\r\n *\r\n *   <ul>\r\n *     <li>`debug` for the most verbose logging level, primarily for\r\n *     debugging.</li>\r\n *     <li>`error` to log errors only.</li>\r\n *     <li><code>`silent` to turn off logging.</li>\r\n *   </ul>\r\n */\r\nfunction setLogLevel(logLevel) {\r\n    logClient.setLogLevel(logLevel);\r\n}\r\nfunction logDebug(msg, ...obj) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n        const args = obj.map(argToString);\r\n        logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\nfunction logError(msg, ...obj) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.ERROR) {\r\n        const args = obj.map(argToString);\r\n        logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction logWarn(msg, ...obj) {\r\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.WARN) {\r\n        const args = obj.map(argToString);\r\n        logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\r\n    }\r\n}\r\n/**\r\n * Converts an additional log parameter to a string representation.\r\n */\r\nfunction argToString(obj) {\r\n    if (typeof obj === 'string') {\r\n        return obj;\r\n    }\r\n    else {\r\n        try {\r\n            return formatJSON(obj);\r\n        }\r\n        catch (e) {\r\n            // Converting to JSON failed, just log the object directly\r\n            return obj;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Unconditionally fails, throwing an Error with the given message.\r\n * Messages are stripped in production builds.\r\n *\r\n * Returns `never` and can be used in expressions:\r\n * @example\r\n * let futureVar = fail('not implemented yet');\r\n */\r\nfunction fail(failure = 'Unexpected state') {\r\n    // Log the failure in addition to throw an exception, just in case the\r\n    // exception is swallowed.\r\n    const message = `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ` + failure;\r\n    logError(message);\r\n    // NOTE: We don't use FirestoreError here because these are internal failures\r\n    // that cannot be handled by the user. (Also it would create a circular\r\n    // dependency between the error and assert modules which doesn't work.)\r\n    throw new Error(message);\r\n}\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * Messages are stripped in production builds.\r\n */\r\nfunction hardAssert(assertion, message) {\r\n    if (!assertion) {\r\n        fail();\r\n    }\r\n}\r\n/**\r\n * Fails if the given assertion condition is false, throwing an Error with the\r\n * given message if it did.\r\n *\r\n * The code of callsites invoking this function are stripped out in production\r\n * builds. Any side-effects of code within the debugAssert() invocation will not\r\n * happen in this case.\r\n *\r\n * @internal\r\n */\r\nfunction debugAssert(assertion, message) {\r\n    if (!assertion) {\r\n        fail();\r\n    }\r\n}\r\n/**\r\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\r\n * instance of `T` before casting.\r\n */\r\nfunction debugCast(obj, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconstructor) {\r\n    return obj;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst Code = {\r\n    // Causes are copied from:\r\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\r\n    /** Not an error; returned on success. */\r\n    OK: 'ok',\r\n    /** The operation was cancelled (typically by the caller). */\r\n    CANCELLED: 'cancelled',\r\n    /** Unknown error or an error from a different error domain. */\r\n    UNKNOWN: 'unknown',\r\n    /**\r\n     * Client specified an invalid argument. Note that this differs from\r\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\r\n     * problematic regardless of the state of the system (e.g., a malformed file\r\n     * name).\r\n     */\r\n    INVALID_ARGUMENT: 'invalid-argument',\r\n    /**\r\n     * Deadline expired before operation could complete. For operations that\r\n     * change the state of the system, this error may be returned even if the\r\n     * operation has completed successfully. For example, a successful response\r\n     * from a server could have been delayed long enough for the deadline to\r\n     * expire.\r\n     */\r\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\r\n    /** Some requested entity (e.g., file or directory) was not found. */\r\n    NOT_FOUND: 'not-found',\r\n    /**\r\n     * Some entity that we attempted to create (e.g., file or directory) already\r\n     * exists.\r\n     */\r\n    ALREADY_EXISTS: 'already-exists',\r\n    /**\r\n     * The caller does not have permission to execute the specified operation.\r\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\r\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\r\n     * PERMISSION_DENIED must not be used if the caller can not be identified\r\n     * (use UNAUTHENTICATED instead for those errors).\r\n     */\r\n    PERMISSION_DENIED: 'permission-denied',\r\n    /**\r\n     * The request does not have valid authentication credentials for the\r\n     * operation.\r\n     */\r\n    UNAUTHENTICATED: 'unauthenticated',\r\n    /**\r\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\r\n     * entire file system is out of space.\r\n     */\r\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\r\n    /**\r\n     * Operation was rejected because the system is not in a state required for\r\n     * the operation's execution. For example, directory to be deleted may be\r\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\r\n     *\r\n     * A litmus test that may help a service implementor in deciding\r\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\r\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\r\n     *  (b) Use ABORTED if the client should retry at a higher-level\r\n     *      (e.g., restarting a read-modify-write sequence).\r\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\r\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\r\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\r\n     *      should be returned since the client should not retry unless\r\n     *      they have first fixed up the directory by deleting files from it.\r\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\r\n     *      REST Get/Update/Delete on a resource and the resource on the\r\n     *      server does not match the condition. E.g., conflicting\r\n     *      read-modify-write on the same resource.\r\n     */\r\n    FAILED_PRECONDITION: 'failed-precondition',\r\n    /**\r\n     * The operation was aborted, typically due to a concurrency issue like\r\n     * sequencer check failures, transaction aborts, etc.\r\n     *\r\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\r\n     * and UNAVAILABLE.\r\n     */\r\n    ABORTED: 'aborted',\r\n    /**\r\n     * Operation was attempted past the valid range. E.g., seeking or reading\r\n     * past end of file.\r\n     *\r\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\r\n     * if the system state changes. For example, a 32-bit file system will\r\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\r\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\r\n     * an offset past the current file size.\r\n     *\r\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\r\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\r\n     * when it applies so that callers who are iterating through a space can\r\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\r\n     */\r\n    OUT_OF_RANGE: 'out-of-range',\r\n    /** Operation is not implemented or not supported/enabled in this service. */\r\n    UNIMPLEMENTED: 'unimplemented',\r\n    /**\r\n     * Internal errors. Means some invariants expected by underlying System has\r\n     * been broken. If you see one of these errors, Something is very broken.\r\n     */\r\n    INTERNAL: 'internal',\r\n    /**\r\n     * The service is currently unavailable. This is a most likely a transient\r\n     * condition and may be corrected by retrying with a backoff.\r\n     *\r\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\r\n     * and UNAVAILABLE.\r\n     */\r\n    UNAVAILABLE: 'unavailable',\r\n    /** Unrecoverable data loss or corruption. */\r\n    DATA_LOSS: 'data-loss'\r\n};\r\n/** An error returned by a Firestore operation. */\r\nclass FirestoreError extends _firebase_util__WEBPACK_IMPORTED_MODULE_4__.FirebaseError {\r\n    /** @hideconstructor */\r\n    constructor(\r\n    /**\r\n     * The backend error code associated with this error.\r\n     */\r\n    code, \r\n    /**\r\n     * A custom error description.\r\n     */\r\n    message) {\r\n        super(code, message);\r\n        this.code = code;\r\n        this.message = message;\r\n        // HACK: We write a toString property directly because Error is not a real\r\n        // class and so inheritance does not work correctly. We could alternatively\r\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\r\n        this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Deferred {\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass OAuthToken {\r\n    constructor(value, user) {\r\n        this.user = user;\r\n        this.type = 'OAuth';\r\n        this.headers = new Map();\r\n        this.headers.set('Authorization', `Bearer ${value}`);\r\n    }\r\n}\r\n/**\r\n * A CredentialsProvider that always yields an empty token.\r\n * @internal\r\n */\r\nclass EmptyAuthCredentialsProvider {\r\n    getToken() {\r\n        return Promise.resolve(null);\r\n    }\r\n    invalidateToken() { }\r\n    start(asyncQueue, changeListener) {\r\n        // Fire with initial user.\r\n        asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));\r\n    }\r\n    shutdown() { }\r\n}\r\n/**\r\n * A CredentialsProvider that always returns a constant token. Used for\r\n * emulator token mocking.\r\n */\r\nclass EmulatorAuthCredentialsProvider {\r\n    constructor(token) {\r\n        this.token = token;\r\n        /**\r\n         * Stores the listener registered with setChangeListener()\r\n         * This isn't actually necessary since the UID never changes, but we use this\r\n         * to verify the listen contract is adhered to in tests.\r\n         */\r\n        this.changeListener = null;\r\n    }\r\n    getToken() {\r\n        return Promise.resolve(this.token);\r\n    }\r\n    invalidateToken() { }\r\n    start(asyncQueue, changeListener) {\r\n        this.changeListener = changeListener;\r\n        // Fire with initial user.\r\n        asyncQueue.enqueueRetryable(() => changeListener(this.token.user));\r\n    }\r\n    shutdown() {\r\n        this.changeListener = null;\r\n    }\r\n}\r\nclass FirebaseAuthCredentialsProvider {\r\n    constructor(authProvider) {\r\n        this.authProvider = authProvider;\r\n        /** Tracks the current User. */\r\n        this.currentUser = User.UNAUTHENTICATED;\r\n        /**\r\n         * Counter used to detect if the token changed while a getToken request was\r\n         * outstanding.\r\n         */\r\n        this.tokenCounter = 0;\r\n        this.forceRefresh = false;\r\n        this.auth = null;\r\n    }\r\n    start(asyncQueue, changeListener) {\r\n        let lastTokenId = this.tokenCounter;\r\n        // A change listener that prevents double-firing for the same token change.\r\n        const guardedChangeListener = user => {\r\n            if (this.tokenCounter !== lastTokenId) {\r\n                lastTokenId = this.tokenCounter;\r\n                return changeListener(user);\r\n            }\r\n            else {\r\n                return Promise.resolve();\r\n            }\r\n        };\r\n        // A promise that can be waited on to block on the next token change.\r\n        // This promise is re-created after each change.\r\n        let nextToken = new Deferred();\r\n        this.tokenListener = () => {\r\n            this.tokenCounter++;\r\n            this.currentUser = this.getUser();\r\n            nextToken.resolve();\r\n            nextToken = new Deferred();\r\n            asyncQueue.enqueueRetryable(() => guardedChangeListener(this.currentUser));\r\n        };\r\n        const awaitNextToken = () => {\r\n            const currentTokenAttempt = nextToken;\r\n            asyncQueue.enqueueRetryable(async () => {\r\n                await currentTokenAttempt.promise;\r\n                await guardedChangeListener(this.currentUser);\r\n            });\r\n        };\r\n        const registerAuth = (auth) => {\r\n            logDebug('FirebaseAuthCredentialsProvider', 'Auth detected');\r\n            this.auth = auth;\r\n            this.auth.addAuthTokenListener(this.tokenListener);\r\n            awaitNextToken();\r\n        };\r\n        this.authProvider.onInit(auth => registerAuth(auth));\r\n        // Our users can initialize Auth right after Firestore, so we give it\r\n        // a chance to register itself with the component framework before we\r\n        // determine whether to start up in unauthenticated mode.\r\n        setTimeout(() => {\r\n            if (!this.auth) {\r\n                const auth = this.authProvider.getImmediate({ optional: true });\r\n                if (auth) {\r\n                    registerAuth(auth);\r\n                }\r\n                else {\r\n                    // If auth is still not available, proceed with `null` user\r\n                    logDebug('FirebaseAuthCredentialsProvider', 'Auth not yet detected');\r\n                    nextToken.resolve();\r\n                    nextToken = new Deferred();\r\n                }\r\n            }\r\n        }, 0);\r\n        awaitNextToken();\r\n    }\r\n    getToken() {\r\n        // Take note of the current value of the tokenCounter so that this method\r\n        // can fail (with an ABORTED error) if there is a token change while the\r\n        // request is outstanding.\r\n        const initialTokenCounter = this.tokenCounter;\r\n        const forceRefresh = this.forceRefresh;\r\n        this.forceRefresh = false;\r\n        if (!this.auth) {\r\n            return Promise.resolve(null);\r\n        }\r\n        return this.auth.getToken(forceRefresh).then(tokenData => {\r\n            // Cancel the request since the token changed while the request was\r\n            // outstanding so the response is potentially for a previous user (which\r\n            // user, we can't be sure).\r\n            if (this.tokenCounter !== initialTokenCounter) {\r\n                logDebug('FirebaseAuthCredentialsProvider', 'getToken aborted due to token change.');\r\n                return this.getToken();\r\n            }\r\n            else {\r\n                if (tokenData) {\r\n                    hardAssert(typeof tokenData.accessToken === 'string');\r\n                    return new OAuthToken(tokenData.accessToken, this.currentUser);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    invalidateToken() {\r\n        this.forceRefresh = true;\r\n    }\r\n    shutdown() {\r\n        if (this.auth) {\r\n            this.auth.removeAuthTokenListener(this.tokenListener);\r\n        }\r\n    }\r\n    // Auth.getUid() can return null even with a user logged in. It is because\r\n    // getUid() is synchronous, but the auth code populating Uid is asynchronous.\r\n    // This method should only be called in the AuthTokenListener callback\r\n    // to guarantee to get the actual user.\r\n    getUser() {\r\n        const currentUid = this.auth && this.auth.getUid();\r\n        hardAssert(currentUid === null || typeof currentUid === 'string');\r\n        return new User(currentUid);\r\n    }\r\n}\r\n/*\r\n * FirstPartyToken provides a fresh token each time its value\r\n * is requested, because if the token is too old, requests will be rejected.\r\n * Technically this may no longer be necessary since the SDK should gracefully\r\n * recover from unauthenticated errors (see b/33147818 for context), but it's\r\n * safer to keep the implementation as-is.\r\n */\r\nclass FirstPartyToken {\r\n    constructor(gapi, sessionIndex, iamToken) {\r\n        this.type = 'FirstParty';\r\n        this.user = User.FIRST_PARTY;\r\n        this.headers = new Map();\r\n        this.headers.set('X-Goog-AuthUser', sessionIndex);\r\n        const authHeader = gapi['auth']['getAuthHeaderValueForFirstParty']([]);\r\n        if (authHeader) {\r\n            this.headers.set('Authorization', authHeader);\r\n        }\r\n        if (iamToken) {\r\n            this.headers.set('X-Goog-Iam-Authorization-Token', iamToken);\r\n        }\r\n    }\r\n}\r\n/*\r\n * Provides user credentials required for the Firestore JavaScript SDK\r\n * to authenticate the user, using technique that is only available\r\n * to applications hosted by Google.\r\n */\r\nclass FirstPartyAuthCredentialsProvider {\r\n    constructor(gapi, sessionIndex, iamToken) {\r\n        this.gapi = gapi;\r\n        this.sessionIndex = sessionIndex;\r\n        this.iamToken = iamToken;\r\n    }\r\n    getToken() {\r\n        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex, this.iamToken));\r\n    }\r\n    start(asyncQueue, changeListener) {\r\n        // Fire with initial uid.\r\n        asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));\r\n    }\r\n    shutdown() { }\r\n    invalidateToken() { }\r\n}\r\nclass AppCheckToken {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.type = 'AppCheck';\r\n        this.headers = new Map();\r\n        if (value && value.length > 0) {\r\n            this.headers.set('x-firebase-appcheck', this.value);\r\n        }\r\n    }\r\n}\r\nclass FirebaseAppCheckTokenProvider {\r\n    constructor(appCheckProvider) {\r\n        this.appCheckProvider = appCheckProvider;\r\n        this.forceRefresh = false;\r\n        this.appCheck = null;\r\n        this.latestAppCheckToken = null;\r\n    }\r\n    start(asyncQueue, changeListener) {\r\n        const onTokenChanged = tokenResult => {\r\n            if (tokenResult.error != null) {\r\n                logDebug('FirebaseAppCheckTokenProvider', `Error getting App Check token; using placeholder token instead. Error: ${tokenResult.error.message}`);\r\n            }\r\n            const tokenUpdated = tokenResult.token !== this.latestAppCheckToken;\r\n            this.latestAppCheckToken = tokenResult.token;\r\n            logDebug('FirebaseAppCheckTokenProvider', `Received ${tokenUpdated ? 'new' : 'existing'} token.`);\r\n            return tokenUpdated\r\n                ? changeListener(tokenResult.token)\r\n                : Promise.resolve();\r\n        };\r\n        this.tokenListener = (tokenResult) => {\r\n            asyncQueue.enqueueRetryable(() => onTokenChanged(tokenResult));\r\n        };\r\n        const registerAppCheck = (appCheck) => {\r\n            logDebug('FirebaseAppCheckTokenProvider', 'AppCheck detected');\r\n            this.appCheck = appCheck;\r\n            this.appCheck.addTokenListener(this.tokenListener);\r\n        };\r\n        this.appCheckProvider.onInit(appCheck => registerAppCheck(appCheck));\r\n        // Our users can initialize AppCheck after Firestore, so we give it\r\n        // a chance to register itself with the component framework.\r\n        setTimeout(() => {\r\n            if (!this.appCheck) {\r\n                const appCheck = this.appCheckProvider.getImmediate({ optional: true });\r\n                if (appCheck) {\r\n                    registerAppCheck(appCheck);\r\n                }\r\n                else {\r\n                    // If AppCheck is still not available, proceed without it.\r\n                    logDebug('FirebaseAppCheckTokenProvider', 'AppCheck not yet detected');\r\n                }\r\n            }\r\n        }, 0);\r\n    }\r\n    getToken() {\r\n        const forceRefresh = this.forceRefresh;\r\n        this.forceRefresh = false;\r\n        if (!this.appCheck) {\r\n            return Promise.resolve(null);\r\n        }\r\n        return this.appCheck.getToken(forceRefresh).then(tokenResult => {\r\n            if (tokenResult) {\r\n                hardAssert(typeof tokenResult.token === 'string');\r\n                this.latestAppCheckToken = tokenResult.token;\r\n                return new AppCheckToken(tokenResult.token);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n    invalidateToken() {\r\n        this.forceRefresh = true;\r\n    }\r\n    shutdown() {\r\n        if (this.appCheck) {\r\n            this.appCheck.removeTokenListener(this.tokenListener);\r\n        }\r\n    }\r\n}\r\n/**\r\n * An AppCheck token provider that always yields an empty token.\r\n * @internal\r\n */\r\nclass EmptyAppCheckTokenProvider {\r\n    getToken() {\r\n        return Promise.resolve(new AppCheckToken(''));\r\n    }\r\n    invalidateToken() { }\r\n    start(asyncQueue, changeListener) { }\r\n    shutdown() { }\r\n}\r\n/**\r\n * Builds a CredentialsProvider depending on the type of\r\n * the credentials passed in.\r\n */\r\nfunction makeAuthCredentialsProvider(credentials) {\r\n    if (!credentials) {\r\n        return new EmptyAuthCredentialsProvider();\r\n    }\r\n    switch (credentials['type']) {\r\n        case 'gapi':\r\n            const client = credentials['client'];\r\n            // Make sure this really is a Gapi client.\r\n            hardAssert(!!(typeof client === 'object' &&\r\n                client !== null &&\r\n                client['auth'] &&\r\n                client['auth']['getAuthHeaderValueForFirstParty']));\r\n            return new FirstPartyAuthCredentialsProvider(client, credentials['sessionIndex'] || '0', credentials['iamToken'] || null);\r\n        case 'provider':\r\n            return credentials['client'];\r\n        default:\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to\r\n * exceed. All subsequent calls to next will return increasing values. If provided with a\r\n * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as\r\n * well as write out sequence numbers that it produces via `next()`.\r\n */\r\nclass ListenSequence {\r\n    constructor(previousValue, sequenceNumberSyncer) {\r\n        this.previousValue = previousValue;\r\n        if (sequenceNumberSyncer) {\r\n            sequenceNumberSyncer.sequenceNumberHandler = sequenceNumber => this.setPreviousValue(sequenceNumber);\r\n            this.writeNewSequenceNumber = sequenceNumber => sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);\r\n        }\r\n    }\r\n    setPreviousValue(externalPreviousValue) {\r\n        this.previousValue = Math.max(externalPreviousValue, this.previousValue);\r\n        return this.previousValue;\r\n    }\r\n    next() {\r\n        const nextValue = ++this.previousValue;\r\n        if (this.writeNewSequenceNumber) {\r\n            this.writeNewSequenceNumber(nextValue);\r\n        }\r\n        return nextValue;\r\n    }\r\n}\r\nListenSequence.INVALID = -1;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DOCUMENT_KEY_NAME = '__name__';\r\n/**\r\n * Path represents an ordered sequence of string segments.\r\n */\r\nclass BasePath {\r\n    constructor(segments, offset, length) {\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n        else if (offset > segments.length) {\r\n            fail();\r\n        }\r\n        if (length === undefined) {\r\n            length = segments.length - offset;\r\n        }\r\n        else if (length > segments.length - offset) {\r\n            fail();\r\n        }\r\n        this.segments = segments;\r\n        this.offset = offset;\r\n        this.len = length;\r\n    }\r\n    get length() {\r\n        return this.len;\r\n    }\r\n    isEqual(other) {\r\n        return BasePath.comparator(this, other) === 0;\r\n    }\r\n    child(nameOrPath) {\r\n        const segments = this.segments.slice(this.offset, this.limit());\r\n        if (nameOrPath instanceof BasePath) {\r\n            nameOrPath.forEach(segment => {\r\n                segments.push(segment);\r\n            });\r\n        }\r\n        else {\r\n            segments.push(nameOrPath);\r\n        }\r\n        return this.construct(segments);\r\n    }\r\n    /** The index of one past the last segment of the path. */\r\n    limit() {\r\n        return this.offset + this.length;\r\n    }\r\n    popFirst(size) {\r\n        size = size === undefined ? 1 : size;\r\n        return this.construct(this.segments, this.offset + size, this.length - size);\r\n    }\r\n    popLast() {\r\n        return this.construct(this.segments, this.offset, this.length - 1);\r\n    }\r\n    firstSegment() {\r\n        return this.segments[this.offset];\r\n    }\r\n    lastSegment() {\r\n        return this.get(this.length - 1);\r\n    }\r\n    get(index) {\r\n        return this.segments[this.offset + index];\r\n    }\r\n    isEmpty() {\r\n        return this.length === 0;\r\n    }\r\n    isPrefixOf(other) {\r\n        if (other.length < this.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.length; i++) {\r\n            if (this.get(i) !== other.get(i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    isImmediateParentOf(potentialChild) {\r\n        if (this.length + 1 !== potentialChild.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < this.length; i++) {\r\n            if (this.get(i) !== potentialChild.get(i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    forEach(fn) {\r\n        for (let i = this.offset, end = this.limit(); i < end; i++) {\r\n            fn(this.segments[i]);\r\n        }\r\n    }\r\n    toArray() {\r\n        return this.segments.slice(this.offset, this.limit());\r\n    }\r\n    static comparator(p1, p2) {\r\n        const len = Math.min(p1.length, p2.length);\r\n        for (let i = 0; i < len; i++) {\r\n            const left = p1.get(i);\r\n            const right = p2.get(i);\r\n            if (left < right) {\r\n                return -1;\r\n            }\r\n            if (left > right) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (p1.length < p2.length) {\r\n            return -1;\r\n        }\r\n        if (p1.length > p2.length) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n/**\r\n * A slash-separated path for navigating resources (documents and collections)\r\n * within Firestore.\r\n *\r\n * @internal\r\n */\r\nclass ResourcePath extends BasePath {\r\n    construct(segments, offset, length) {\r\n        return new ResourcePath(segments, offset, length);\r\n    }\r\n    canonicalString() {\r\n        // NOTE: The client is ignorant of any path segments containing escape\r\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\r\n        // for legacy reasons and should not be used frequently).\r\n        return this.toArray().join('/');\r\n    }\r\n    toString() {\r\n        return this.canonicalString();\r\n    }\r\n    /**\r\n     * Creates a resource path from the given slash-delimited string. If multiple\r\n     * arguments are provided, all components are combined. Leading and trailing\r\n     * slashes from all components are ignored.\r\n     */\r\n    static fromString(...pathComponents) {\r\n        // NOTE: The client is ignorant of any path segments containing escape\r\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\r\n        // for legacy reasons and should not be used frequently).\r\n        const segments = [];\r\n        for (const path of pathComponents) {\r\n            if (path.indexOf('//') >= 0) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment (${path}). Paths must not contain // in them.`);\r\n            }\r\n            // Strip leading and traling slashed.\r\n            segments.push(...path.split('/').filter(segment => segment.length > 0));\r\n        }\r\n        return new ResourcePath(segments);\r\n    }\r\n    static emptyPath() {\r\n        return new ResourcePath([]);\r\n    }\r\n}\r\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\r\n/**\r\n * A dot-separated path for navigating sub-objects within a document.\r\n * @internal\r\n */\r\nclass FieldPath$1 extends BasePath {\r\n    construct(segments, offset, length) {\r\n        return new FieldPath$1(segments, offset, length);\r\n    }\r\n    /**\r\n     * Returns true if the string could be used as a segment in a field path\r\n     * without escaping.\r\n     */\r\n    static isValidIdentifier(segment) {\r\n        return identifierRegExp.test(segment);\r\n    }\r\n    canonicalString() {\r\n        return this.toArray()\r\n            .map(str => {\r\n            str = str.replace(/\\\\/g, '\\\\\\\\').replace(/`/g, '\\\\`');\r\n            if (!FieldPath$1.isValidIdentifier(str)) {\r\n                str = '`' + str + '`';\r\n            }\r\n            return str;\r\n        })\r\n            .join('.');\r\n    }\r\n    toString() {\r\n        return this.canonicalString();\r\n    }\r\n    /**\r\n     * Returns true if this field references the key of a document.\r\n     */\r\n    isKeyField() {\r\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\r\n    }\r\n    /**\r\n     * The field designating the key of a document.\r\n     */\r\n    static keyField() {\r\n        return new FieldPath$1([DOCUMENT_KEY_NAME]);\r\n    }\r\n    /**\r\n     * Parses a field string from the given server-formatted string.\r\n     *\r\n     * - Splitting the empty string is not allowed (for now at least).\r\n     * - Empty segments within the string (e.g. if there are two consecutive\r\n     *   separators) are not allowed.\r\n     *\r\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\r\n     * non-identifier path components, even if they aren't escaped.\r\n     */\r\n    static fromServerFormat(path) {\r\n        const segments = [];\r\n        let current = '';\r\n        let i = 0;\r\n        const addCurrentSegment = () => {\r\n            if (current.length === 0) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path (${path}). Paths must not be empty, begin ` +\r\n                    `with '.', end with '.', or contain '..'`);\r\n            }\r\n            segments.push(current);\r\n            current = '';\r\n        };\r\n        let inBackticks = false;\r\n        while (i < path.length) {\r\n            const c = path[i];\r\n            if (c === '\\\\') {\r\n                if (i + 1 === path.length) {\r\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\r\n                }\r\n                const next = path[i + 1];\r\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\r\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\r\n                }\r\n                current += next;\r\n                i += 2;\r\n            }\r\n            else if (c === '`') {\r\n                inBackticks = !inBackticks;\r\n                i++;\r\n            }\r\n            else if (c === '.' && !inBackticks) {\r\n                addCurrentSegment();\r\n                i++;\r\n            }\r\n            else {\r\n                current += c;\r\n                i++;\r\n            }\r\n        }\r\n        addCurrentSegment();\r\n        if (inBackticks) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\r\n        }\r\n        return new FieldPath$1(segments);\r\n    }\r\n    static emptyPath() {\r\n        return new FieldPath$1([]);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst escapeChar = '\\u0001';\r\nconst encodedSeparatorChar = '\\u0001';\r\nconst encodedNul = '\\u0010';\r\nconst encodedEscape = '\\u0011';\r\n/**\r\n * Encodes a resource path into a IndexedDb-compatible string form.\r\n */\r\nfunction encodeResourcePath(path) {\r\n    let result = '';\r\n    for (let i = 0; i < path.length; i++) {\r\n        if (result.length > 0) {\r\n            result = encodeSeparator(result);\r\n        }\r\n        result = encodeSegment(path.get(i), result);\r\n    }\r\n    return encodeSeparator(result);\r\n}\r\n/** Encodes a single segment of a resource path into the given result */\r\nfunction encodeSegment(segment, resultBuf) {\r\n    let result = resultBuf;\r\n    const length = segment.length;\r\n    for (let i = 0; i < length; i++) {\r\n        const c = segment.charAt(i);\r\n        switch (c) {\r\n            case '\\0':\r\n                result += escapeChar + encodedNul;\r\n                break;\r\n            case escapeChar:\r\n                result += escapeChar + encodedEscape;\r\n                break;\r\n            default:\r\n                result += c;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/** Encodes a path separator into the given result */\r\nfunction encodeSeparator(result) {\r\n    return result + escapeChar + encodedSeparatorChar;\r\n}\r\n/**\r\n * Decodes the given IndexedDb-compatible string form of a resource path into\r\n * a ResourcePath instance. Note that this method is not suitable for use with\r\n * decoding resource names from the server; those are One Platform format\r\n * strings.\r\n */\r\nfunction decodeResourcePath(path) {\r\n    // Event the empty path must encode as a path of at least length 2. A path\r\n    // with exactly 2 must be the empty path.\r\n    const length = path.length;\r\n    hardAssert(length >= 2);\r\n    if (length === 2) {\r\n        hardAssert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar);\r\n        return ResourcePath.emptyPath();\r\n    }\r\n    // Escape characters cannot exist past the second-to-last position in the\r\n    // source value.\r\n    const lastReasonableEscapeIndex = length - 2;\r\n    const segments = [];\r\n    let segmentBuilder = '';\r\n    for (let start = 0; start < length;) {\r\n        // The last two characters of a valid encoded path must be a separator, so\r\n        // there must be an end to this segment.\r\n        const end = path.indexOf(escapeChar, start);\r\n        if (end < 0 || end > lastReasonableEscapeIndex) {\r\n            fail();\r\n        }\r\n        const next = path.charAt(end + 1);\r\n        switch (next) {\r\n            case encodedSeparatorChar:\r\n                const currentPiece = path.substring(start, end);\r\n                let segment;\r\n                if (segmentBuilder.length === 0) {\r\n                    // Avoid copying for the common case of a segment that excludes \\0\r\n                    // and \\001\r\n                    segment = currentPiece;\r\n                }\r\n                else {\r\n                    segmentBuilder += currentPiece;\r\n                    segment = segmentBuilder;\r\n                    segmentBuilder = '';\r\n                }\r\n                segments.push(segment);\r\n                break;\r\n            case encodedNul:\r\n                segmentBuilder += path.substring(start, end);\r\n                segmentBuilder += '\\0';\r\n                break;\r\n            case encodedEscape:\r\n                // The escape character can be used in the output to encode itself.\r\n                segmentBuilder += path.substring(start, end + 1);\r\n                break;\r\n            default:\r\n                fail();\r\n        }\r\n        start = end + 2;\r\n    }\r\n    return new ResourcePath(segments);\r\n}\n/**\r\n * Schema Version for the Web client:\r\n * 1.  Initial version including Mutation Queue, Query Cache, and Remote\r\n *     Document Cache\r\n * 2.  Used to ensure a targetGlobal object exists and add targetCount to it. No\r\n *     longer required because migration 3 unconditionally clears it.\r\n * 3.  Dropped and re-created Query Cache to deal with cache corruption related\r\n *     to limbo resolution. Addresses\r\n *     https://github.com/firebase/firebase-ios-sdk/issues/1548\r\n * 4.  Multi-Tab Support.\r\n * 5.  Removal of held write acks.\r\n * 6.  Create document global for tracking document cache size.\r\n * 7.  Ensure every cached document has a sentinel row with a sequence number.\r\n * 8.  Add collection-parent index for Collection Group queries.\r\n * 9.  Change RemoteDocumentChanges store to be keyed by readTime rather than\r\n *     an auto-incrementing ID. This is required for Index-Free queries.\r\n * 10. Rewrite the canonical IDs to the explicit Protobuf-based format.\r\n * 11. Add bundles and named_queries for bundle support.\r\n * 12. Add document overlays.\r\n * 13. Add indexing support.\r\n */\r\nconst SCHEMA_VERSION = 12;\r\n/**\r\n * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.\r\n */\r\nclass DbTimestamp {\r\n    constructor(seconds, nanoseconds) {\r\n        this.seconds = seconds;\r\n        this.nanoseconds = nanoseconds;\r\n    }\r\n}\r\n/**\r\n * A singleton object to be stored in the 'owner' store in IndexedDb.\r\n *\r\n * A given database can have a single primary tab assigned at a given time. That\r\n * tab must validate that it is still holding the primary lease before every\r\n * operation that requires locked access. The primary tab should regularly\r\n * write an updated timestamp to this lease to prevent other tabs from\r\n * \"stealing\" the primary lease\r\n */\r\nclass DbPrimaryClient {\r\n    constructor(ownerId, \r\n    /** Whether to allow shared access from multiple tabs. */\r\n    allowTabSynchronization, leaseTimestampMs) {\r\n        this.ownerId = ownerId;\r\n        this.allowTabSynchronization = allowTabSynchronization;\r\n        this.leaseTimestampMs = leaseTimestampMs;\r\n    }\r\n}\r\n/**\r\n * Name of the IndexedDb object store.\r\n *\r\n * Note that the name 'owner' is chosen to ensure backwards compatibility with\r\n * older clients that only supported single locked access to the persistence\r\n * layer.\r\n */\r\nDbPrimaryClient.store = 'owner';\r\n/**\r\n * The key string used for the single object that exists in the\r\n * DbPrimaryClient store.\r\n */\r\nDbPrimaryClient.key = 'owner';\r\n/**\r\n * An object to be stored in the 'mutationQueues' store in IndexedDb.\r\n *\r\n * Each user gets a single queue of MutationBatches to apply to the server.\r\n * DbMutationQueue tracks the metadata about the queue.\r\n */\r\nclass DbMutationQueue {\r\n    constructor(\r\n    /**\r\n     * The normalized user ID to which this queue belongs.\r\n     */\r\n    userId, \r\n    /**\r\n     * An identifier for the highest numbered batch that has been acknowledged\r\n     * by the server. All MutationBatches in this queue with batchIds less\r\n     * than or equal to this value are considered to have been acknowledged by\r\n     * the server.\r\n     *\r\n     * NOTE: this is deprecated and no longer used by the code.\r\n     */\r\n    lastAcknowledgedBatchId, \r\n    /**\r\n     * A stream token that was previously sent by the server.\r\n     *\r\n     * See StreamingWriteRequest in datastore.proto for more details about\r\n     * usage.\r\n     *\r\n     * After sending this token, earlier tokens may not be used anymore so\r\n     * only a single stream token is retained.\r\n     *\r\n     * NOTE: this is deprecated and no longer used by the code.\r\n     */\r\n    lastStreamToken) {\r\n        this.userId = userId;\r\n        this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;\r\n        this.lastStreamToken = lastStreamToken;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store.  */\r\nDbMutationQueue.store = 'mutationQueues';\r\n/** Keys are automatically assigned via the userId property. */\r\nDbMutationQueue.keyPath = 'userId';\r\n/**\r\n * An object to be stored in the 'mutations' store in IndexedDb.\r\n *\r\n * Represents a batch of user-level mutations intended to be sent to the server\r\n * in a single write. Each user-level batch gets a separate DbMutationBatch\r\n * with a new batchId.\r\n */\r\nclass DbMutationBatch {\r\n    constructor(\r\n    /**\r\n     * The normalized user ID to which this batch belongs.\r\n     */\r\n    userId, \r\n    /**\r\n     * An identifier for this batch, allocated using an auto-generated key.\r\n     */\r\n    batchId, \r\n    /**\r\n     * The local write time of the batch, stored as milliseconds since the\r\n     * epoch.\r\n     */\r\n    localWriteTimeMs, \r\n    /**\r\n     * A list of \"mutations\" that represent a partial base state from when this\r\n     * write batch was initially created. During local application of the write\r\n     * batch, these baseMutations are applied prior to the real writes in order\r\n     * to override certain document fields from the remote document cache. This\r\n     * is necessary in the case of non-idempotent writes (e.g. `increment()`\r\n     * transforms) to make sure that the local view of the modified documents\r\n     * doesn't flicker if the remote document cache receives the result of the\r\n     * non-idempotent write before the write is removed from the queue.\r\n     *\r\n     * These mutations are never sent to the backend.\r\n     */\r\n    baseMutations, \r\n    /**\r\n     * A list of mutations to apply. All mutations will be applied atomically.\r\n     *\r\n     * Mutations are serialized via toMutation().\r\n     */\r\n    mutations) {\r\n        this.userId = userId;\r\n        this.batchId = batchId;\r\n        this.localWriteTimeMs = localWriteTimeMs;\r\n        this.baseMutations = baseMutations;\r\n        this.mutations = mutations;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store.  */\r\nDbMutationBatch.store = 'mutations';\r\n/** Keys are automatically assigned via the userId, batchId properties. */\r\nDbMutationBatch.keyPath = 'batchId';\r\n/** The index name for lookup of mutations by user. */\r\nDbMutationBatch.userMutationsIndex = 'userMutationsIndex';\r\n/** The user mutations index is keyed by [userId, batchId] pairs. */\r\nDbMutationBatch.userMutationsKeyPath = ['userId', 'batchId'];\r\n/**\r\n * An object to be stored in the 'documentMutations' store in IndexedDb.\r\n *\r\n * A manually maintained index of all the mutation batches that affect a given\r\n * document key. The rows in this table are references based on the contents of\r\n * DbMutationBatch.mutations.\r\n */\r\nclass DbDocumentMutation {\r\n    constructor() { }\r\n    /**\r\n     * Creates a [userId] key for use in the DbDocumentMutations index to iterate\r\n     * over all of a user's document mutations.\r\n     */\r\n    static prefixForUser(userId) {\r\n        return [userId];\r\n    }\r\n    /**\r\n     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\r\n     * index to iterate over all at document mutations for a given path or lower.\r\n     */\r\n    static prefixForPath(userId, path) {\r\n        return [userId, encodeResourcePath(path)];\r\n    }\r\n    /**\r\n     * Creates a full index key of [userId, encodedPath, batchId] for inserting\r\n     * and deleting into the DbDocumentMutations index.\r\n     */\r\n    static key(userId, path, batchId) {\r\n        return [userId, encodeResourcePath(path), batchId];\r\n    }\r\n}\r\nDbDocumentMutation.store = 'documentMutations';\r\n/**\r\n * Because we store all the useful information for this store in the key,\r\n * there is no useful information to store as the value. The raw (unencoded)\r\n * path cannot be stored because IndexedDb doesn't store prototype\r\n * information.\r\n */\r\nDbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();\r\n/**\r\n * Represents the known absence of a document at a particular version.\r\n * Stored in IndexedDb as part of a DbRemoteDocument object.\r\n */\r\nclass DbNoDocument {\r\n    constructor(path, readTime) {\r\n        this.path = path;\r\n        this.readTime = readTime;\r\n    }\r\n}\r\n/**\r\n * Represents a document that is known to exist but whose data is unknown.\r\n * Stored in IndexedDb as part of a DbRemoteDocument object.\r\n */\r\nclass DbUnknownDocument {\r\n    constructor(path, version) {\r\n        this.path = path;\r\n        this.version = version;\r\n    }\r\n}\r\n/**\r\n * An object to be stored in the 'remoteDocuments' store in IndexedDb.\r\n * It represents either:\r\n *\r\n * - A complete document.\r\n * - A \"no document\" representing a document that is known not to exist (at\r\n * some version).\r\n * - An \"unknown document\" representing a document that is known to exist (at\r\n * some version) but whose contents are unknown.\r\n *\r\n * Note: This is the persisted equivalent of a MaybeDocument and could perhaps\r\n * be made more general if necessary.\r\n */\r\nclass DbRemoteDocument {\r\n    // TODO: We are currently storing full document keys almost three times\r\n    // (once as part of the primary key, once - partly - as `parentPath` and once\r\n    // inside the encoded documents). During our next migration, we should\r\n    // rewrite the primary key as parentPath + document ID which would allow us\r\n    // to drop one value.\r\n    constructor(\r\n    /**\r\n     * Set to an instance of DbUnknownDocument if the data for a document is\r\n     * not known, but it is known that a document exists at the specified\r\n     * version (e.g. it had a successful update applied to it)\r\n     */\r\n    unknownDocument, \r\n    /**\r\n     * Set to an instance of a DbNoDocument if it is known that no document\r\n     * exists.\r\n     */\r\n    noDocument, \r\n    /**\r\n     * Set to an instance of a Document if there's a cached version of the\r\n     * document.\r\n     */\r\n    document, \r\n    /**\r\n     * Documents that were written to the remote document store based on\r\n     * a write acknowledgment are marked with `hasCommittedMutations`. These\r\n     * documents are potentially inconsistent with the backend's copy and use\r\n     * the write's commit version as their document version.\r\n     */\r\n    hasCommittedMutations, \r\n    /**\r\n     * When the document was read from the backend. Undefined for data written\r\n     * prior to schema version 9.\r\n     */\r\n    readTime, \r\n    /**\r\n     * The path of the collection this document is part of. Undefined for data\r\n     * written prior to schema version 9.\r\n     */\r\n    parentPath) {\r\n        this.unknownDocument = unknownDocument;\r\n        this.noDocument = noDocument;\r\n        this.document = document;\r\n        this.hasCommittedMutations = hasCommittedMutations;\r\n        this.readTime = readTime;\r\n        this.parentPath = parentPath;\r\n    }\r\n}\r\nDbRemoteDocument.store = 'remoteDocuments';\r\n/**\r\n * An index that provides access to all entries sorted by read time (which\r\n * corresponds to the last modification time of each row).\r\n *\r\n * This index is used to provide a changelog for Multi-Tab.\r\n */\r\nDbRemoteDocument.readTimeIndex = 'readTimeIndex';\r\nDbRemoteDocument.readTimeIndexPath = 'readTime';\r\n/**\r\n * An index that provides access to documents in a collection sorted by read\r\n * time.\r\n *\r\n * This index is used to allow the RemoteDocumentCache to fetch newly changed\r\n * documents in a collection.\r\n */\r\nDbRemoteDocument.collectionReadTimeIndex = 'collectionReadTimeIndex';\r\nDbRemoteDocument.collectionReadTimeIndexPath = ['parentPath', 'readTime'];\r\n/**\r\n * Contains a single entry that has metadata about the remote document cache.\r\n */\r\nclass DbRemoteDocumentGlobal {\r\n    /**\r\n     * @param byteSize - Approximately the total size in bytes of all the\r\n     * documents in the document cache.\r\n     */\r\n    constructor(byteSize) {\r\n        this.byteSize = byteSize;\r\n    }\r\n}\r\nDbRemoteDocumentGlobal.store = 'remoteDocumentGlobal';\r\nDbRemoteDocumentGlobal.key = 'remoteDocumentGlobalKey';\r\n/**\r\n * An object to be stored in the 'targets' store in IndexedDb.\r\n *\r\n * This is based on and should be kept in sync with the proto used in the iOS\r\n * client.\r\n *\r\n * Each query the client listens to against the server is tracked on disk so\r\n * that the query can be efficiently resumed on restart.\r\n */\r\nclass DbTarget {\r\n    constructor(\r\n    /**\r\n     * An auto-generated sequential numeric identifier for the query.\r\n     *\r\n     * Queries are stored using their canonicalId as the key, but these\r\n     * canonicalIds can be quite long so we additionally assign a unique\r\n     * queryId which can be used by referenced data structures (e.g.\r\n     * indexes) to minimize the on-disk cost.\r\n     */\r\n    targetId, \r\n    /**\r\n     * The canonical string representing this query. This is not unique.\r\n     */\r\n    canonicalId, \r\n    /**\r\n     * The last readTime received from the Watch Service for this query.\r\n     *\r\n     * This is the same value as TargetChange.read_time in the protos.\r\n     */\r\n    readTime, \r\n    /**\r\n     * An opaque, server-assigned token that allows watching a query to be\r\n     * resumed after disconnecting without retransmitting all the data\r\n     * that matches the query. The resume token essentially identifies a\r\n     * point in time from which the server should resume sending results.\r\n     *\r\n     * This is related to the snapshotVersion in that the resumeToken\r\n     * effectively also encodes that value, but the resumeToken is opaque\r\n     * and sometimes encodes additional information.\r\n     *\r\n     * A consequence of this is that the resumeToken should be used when\r\n     * asking the server to reason about where this client is in the watch\r\n     * stream, but the client should use the snapshotVersion for its own\r\n     * purposes.\r\n     *\r\n     * This is the same value as TargetChange.resume_token in the protos.\r\n     */\r\n    resumeToken, \r\n    /**\r\n     * A sequence number representing the last time this query was\r\n     * listened to, used for garbage collection purposes.\r\n     *\r\n     * Conventionally this would be a timestamp value, but device-local\r\n     * clocks are unreliable and they must be able to create new listens\r\n     * even while disconnected. Instead this should be a monotonically\r\n     * increasing number that's incremented on each listen call.\r\n     *\r\n     * This is different from the queryId since the queryId is an\r\n     * immutable identifier assigned to the Query on first use while\r\n     * lastListenSequenceNumber is updated every time the query is\r\n     * listened to.\r\n     */\r\n    lastListenSequenceNumber, \r\n    /**\r\n     * Denotes the maximum snapshot version at which the associated query view\r\n     * contained no limbo documents.  Undefined for data written prior to\r\n     * schema version 9.\r\n     */\r\n    lastLimboFreeSnapshotVersion, \r\n    /**\r\n     * The query for this target.\r\n     *\r\n     * Because canonical ids are not unique we must store the actual query. We\r\n     * use the proto to have an object we can persist without having to\r\n     * duplicate translation logic to and from a `Query` object.\r\n     */\r\n    query) {\r\n        this.targetId = targetId;\r\n        this.canonicalId = canonicalId;\r\n        this.readTime = readTime;\r\n        this.resumeToken = resumeToken;\r\n        this.lastListenSequenceNumber = lastListenSequenceNumber;\r\n        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;\r\n        this.query = query;\r\n    }\r\n}\r\nDbTarget.store = 'targets';\r\n/** Keys are automatically assigned via the targetId property. */\r\nDbTarget.keyPath = 'targetId';\r\n/** The name of the queryTargets index. */\r\nDbTarget.queryTargetsIndexName = 'queryTargetsIndex';\r\n/**\r\n * The index of all canonicalIds to the targets that they match. This is not\r\n * a unique mapping because canonicalId does not promise a unique name for all\r\n * possible queries, so we append the targetId to make the mapping unique.\r\n */\r\nDbTarget.queryTargetsKeyPath = ['canonicalId', 'targetId'];\r\n/**\r\n * An object representing an association between a target and a document, or a\r\n * sentinel row marking the last sequence number at which a document was used.\r\n * Each document cached must have a corresponding sentinel row before lru\r\n * garbage collection is enabled.\r\n *\r\n * The target associations and sentinel rows are co-located so that orphaned\r\n * documents and their sequence numbers can be identified efficiently via a scan\r\n * of this store.\r\n */\r\nclass DbTargetDocument {\r\n    constructor(\r\n    /**\r\n     * The targetId identifying a target or 0 for a sentinel row.\r\n     */\r\n    targetId, \r\n    /**\r\n     * The path to the document, as encoded in the key.\r\n     */\r\n    path, \r\n    /**\r\n     * If this is a sentinel row, this should be the sequence number of the last\r\n     * time the document specified by `path` was used. Otherwise, it should be\r\n     * `undefined`.\r\n     */\r\n    sequenceNumber) {\r\n        this.targetId = targetId;\r\n        this.path = path;\r\n        this.sequenceNumber = sequenceNumber;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store.  */\r\nDbTargetDocument.store = 'targetDocuments';\r\n/** Keys are automatically assigned via the targetId, path properties. */\r\nDbTargetDocument.keyPath = ['targetId', 'path'];\r\n/** The index name for the reverse index. */\r\nDbTargetDocument.documentTargetsIndex = 'documentTargetsIndex';\r\n/** We also need to create the reverse index for these properties. */\r\nDbTargetDocument.documentTargetsKeyPath = ['path', 'targetId'];\r\n/**\r\n * A record of global state tracked across all Targets, tracked separately\r\n * to avoid the need for extra indexes.\r\n *\r\n * This should be kept in-sync with the proto used in the iOS client.\r\n */\r\nclass DbTargetGlobal {\r\n    constructor(\r\n    /**\r\n     * The highest numbered target id across all targets.\r\n     *\r\n     * See DbTarget.targetId.\r\n     */\r\n    highestTargetId, \r\n    /**\r\n     * The highest numbered lastListenSequenceNumber across all targets.\r\n     *\r\n     * See DbTarget.lastListenSequenceNumber.\r\n     */\r\n    highestListenSequenceNumber, \r\n    /**\r\n     * A global snapshot version representing the last consistent snapshot we\r\n     * received from the backend. This is monotonically increasing and any\r\n     * snapshots received from the backend prior to this version (e.g. for\r\n     * targets resumed with a resumeToken) should be suppressed (buffered)\r\n     * until the backend has caught up to this snapshot version again. This\r\n     * prevents our cache from ever going backwards in time.\r\n     */\r\n    lastRemoteSnapshotVersion, \r\n    /**\r\n     * The number of targets persisted.\r\n     */\r\n    targetCount) {\r\n        this.highestTargetId = highestTargetId;\r\n        this.highestListenSequenceNumber = highestListenSequenceNumber;\r\n        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\r\n        this.targetCount = targetCount;\r\n    }\r\n}\r\n/**\r\n * The key string used for the single object that exists in the\r\n * DbTargetGlobal store.\r\n */\r\nDbTargetGlobal.key = 'targetGlobalKey';\r\nDbTargetGlobal.store = 'targetGlobal';\r\n/**\r\n * An object representing an association between a Collection id (e.g. 'messages')\r\n * to a parent path (e.g. '/chats/123') that contains it as a (sub)collection.\r\n * This is used to efficiently find all collections to query when performing\r\n * a Collection Group query.\r\n */\r\nclass DbCollectionParent {\r\n    constructor(\r\n    /**\r\n     * The collectionId (e.g. 'messages')\r\n     */\r\n    collectionId, \r\n    /**\r\n     * The path to the parent (either a document location or an empty path for\r\n     * a root-level collection).\r\n     */\r\n    parent) {\r\n        this.collectionId = collectionId;\r\n        this.parent = parent;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store. */\r\nDbCollectionParent.store = 'collectionParents';\r\n/** Keys are automatically assigned via the collectionId, parent properties. */\r\nDbCollectionParent.keyPath = ['collectionId', 'parent'];\r\n/**\r\n * A record of the metadata state of each client.\r\n *\r\n * PORTING NOTE: This is used to synchronize multi-tab state and does not need\r\n * to be ported to iOS or Android.\r\n */\r\nclass DbClientMetadata {\r\n    constructor(\r\n    // Note: Previous schema versions included a field\r\n    // \"lastProcessedDocumentChangeId\". Don't use anymore.\r\n    /** The auto-generated client id assigned at client startup. */\r\n    clientId, \r\n    /** The last time this state was updated. */\r\n    updateTimeMs, \r\n    /** Whether the client's network connection is enabled. */\r\n    networkEnabled, \r\n    /** Whether this client is running in a foreground tab. */\r\n    inForeground) {\r\n        this.clientId = clientId;\r\n        this.updateTimeMs = updateTimeMs;\r\n        this.networkEnabled = networkEnabled;\r\n        this.inForeground = inForeground;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store. */\r\nDbClientMetadata.store = 'clientMetadata';\r\n/** Keys are automatically assigned via the clientId properties. */\r\nDbClientMetadata.keyPath = 'clientId';\r\n/** An object representing a bundle loaded by the SDK. */\r\nclass DbBundle {\r\n    constructor(\r\n    /** The ID of the loaded bundle. */\r\n    bundleId, \r\n    /** The create time of the loaded bundle. */\r\n    createTime, \r\n    /** The schema version of the loaded bundle. */\r\n    version) {\r\n        this.bundleId = bundleId;\r\n        this.createTime = createTime;\r\n        this.version = version;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store. */\r\nDbBundle.store = 'bundles';\r\nDbBundle.keyPath = 'bundleId';\r\n/** An object representing a named query loaded by the SDK via a bundle. */\r\nclass DbNamedQuery {\r\n    constructor(\r\n    /** The name of the query. */\r\n    name, \r\n    /** The read time of the results saved in the bundle from the named query. */\r\n    readTime, \r\n    /** The query saved in the bundle. */\r\n    bundledQuery) {\r\n        this.name = name;\r\n        this.readTime = readTime;\r\n        this.bundledQuery = bundledQuery;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store. */\r\nDbNamedQuery.store = 'namedQueries';\r\nDbNamedQuery.keyPath = 'name';\r\n/** An object representing the global configuration for a field index. */\r\nclass DbIndexConfiguration {\r\n    constructor(\r\n    /**\r\n     * The index id for this entry. Undefined for indexes that are not yet\r\n     * persisted.\r\n     */\r\n    indexId, \r\n    /** The collection group this index belongs to. */\r\n    collectionGroup, \r\n    /** The fields to index for this index. */\r\n    fields) {\r\n        this.indexId = indexId;\r\n        this.collectionGroup = collectionGroup;\r\n        this.fields = fields;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store. */\r\nDbIndexConfiguration.store = 'indexConfiguration';\r\nDbIndexConfiguration.keyPath = 'indexId';\r\n/**\r\n * An index that provides access to the index configurations by collection\r\n * group.\r\n *\r\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\r\n * not possible here as the Web client supports concurrent access to\r\n * persistence via multi-tab.\r\n */\r\nDbIndexConfiguration.collectionGroupIndex = 'collectionGroupIndex';\r\nDbIndexConfiguration.collectionGroupIndexPath = 'collectionGroup';\r\n/**\r\n * An object describing how up-to-date the index backfill is for each user and\r\n * index.\r\n */\r\nclass DbIndexState {\r\n    constructor(\r\n    /** The index id for this entry. */\r\n    indexId, \r\n    /** The user id for this entry. */\r\n    uid, \r\n    /**\r\n     * A number that indicates when the index was last updated (relative to\r\n     * other indexes).\r\n     */\r\n    sequenceNumber, \r\n    /**\r\n     * The latest read time that has been indexed by Firestore for this field\r\n     * index. Set to `{seconds: 0, nanos: 0}` if no documents have been indexed.\r\n     */\r\n    readTime, \r\n    /**\r\n     * The last document that has been indexed for this field index. Empty if\r\n     * no documents have been indexed.\r\n     */\r\n    documentKey, \r\n    /**\r\n     * The largest mutation batch id that has been processed for this index. -1\r\n     * if no mutations have been indexed.\r\n     */\r\n    largestBatchId) {\r\n        this.indexId = indexId;\r\n        this.uid = uid;\r\n        this.sequenceNumber = sequenceNumber;\r\n        this.readTime = readTime;\r\n        this.documentKey = documentKey;\r\n        this.largestBatchId = largestBatchId;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store. */\r\nDbIndexState.store = 'indexState';\r\nDbIndexState.keyPath = ['indexId', 'uid'];\r\n/**\r\n * An index that provides access to documents in a collection sorted by last\r\n * update time. Used by the backfiller.\r\n *\r\n * PORTING NOTE: iOS and Android maintain this index in-memory, but this is\r\n * not possible here as the Web client supports concurrent access to\r\n * persistence via multi-tab.\r\n */\r\nDbIndexState.sequenceNumberIndex = 'sequenceNumberIndex';\r\nDbIndexState.sequenceNumberIndexPath = ['uid', 'sequenceNumber'];\r\n/** An object that stores the encoded entries for all documents and fields. */\r\nclass DbIndexEntry {\r\n    constructor(\r\n    /** The index id for this entry. */\r\n    indexId, \r\n    /** The user id for this entry. */\r\n    uid, \r\n    /** The encoded array index value for this entry. */\r\n    arrayValue, \r\n    /** The encoded directional value for equality and inequality filters. */\r\n    directionalValue, \r\n    /** The document key this entry points to. */\r\n    documentKey) {\r\n        this.indexId = indexId;\r\n        this.uid = uid;\r\n        this.arrayValue = arrayValue;\r\n        this.directionalValue = directionalValue;\r\n        this.documentKey = documentKey;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store. */\r\nDbIndexEntry.store = 'indexEntries';\r\nDbIndexEntry.keyPath = [\r\n    'indexId',\r\n    'uid',\r\n    'arrayValue',\r\n    'directionalValue',\r\n    'documentKey'\r\n];\r\nDbIndexEntry.documentKeyIndex = 'documentKeyIndex';\r\nDbIndexEntry.documentKeyIndexPath = ['indexId', 'uid', 'documentKey'];\r\n/**\r\n * An object representing a document overlay.\r\n */\r\nclass DbDocumentOverlay {\r\n    constructor(\r\n    /** The user ID to whom this overlay belongs. */\r\n    userId, \r\n    /** The path to the collection that contains the document. */\r\n    collectionPath, \r\n    /** The ID (key) of the document within the collection. */\r\n    documentId, \r\n    /** The collection group to which the document belongs. */\r\n    collectionGroup, \r\n    /** The largest batch ID that's been applied for this overlay. */\r\n    largestBatchId, \r\n    /** The overlay mutation. */\r\n    overlayMutation) {\r\n        this.userId = userId;\r\n        this.collectionPath = collectionPath;\r\n        this.documentId = documentId;\r\n        this.collectionGroup = collectionGroup;\r\n        this.largestBatchId = largestBatchId;\r\n        this.overlayMutation = overlayMutation;\r\n    }\r\n}\r\n/** Name of the IndexedDb object store. */\r\nDbDocumentOverlay.store = 'documentOverlays';\r\nDbDocumentOverlay.keyPath = ['userId', 'collectionPath', 'documentId'];\r\nDbDocumentOverlay.collectionPathOverlayIndex = 'collectionPathOverlayIndex';\r\nDbDocumentOverlay.collectionPathOverlayIndexPath = [\r\n    'userId',\r\n    'collectionPath',\r\n    'largestBatchId'\r\n];\r\nDbDocumentOverlay.collectionGroupOverlayIndex = 'collectionGroupOverlayIndex';\r\nDbDocumentOverlay.collectionGroupOverlayIndexPath = [\r\n    'userId',\r\n    'collectionGroup',\r\n    'largestBatchId'\r\n];\r\n// Visible for testing\r\nconst V1_STORES = [\r\n    DbMutationQueue.store,\r\n    DbMutationBatch.store,\r\n    DbDocumentMutation.store,\r\n    DbRemoteDocument.store,\r\n    DbTarget.store,\r\n    DbPrimaryClient.store,\r\n    DbTargetGlobal.store,\r\n    DbTargetDocument.store\r\n];\r\n// V2 is no longer usable (see comment at top of file)\r\n// Visible for testing\r\nconst V3_STORES = V1_STORES;\r\n// Note: DbRemoteDocumentChanges is no longer used and dropped with v9.\r\nconst V4_STORES = [...V3_STORES, DbClientMetadata.store];\r\n// V5 does not change the set of stores.\r\nconst V6_STORES = [...V4_STORES, DbRemoteDocumentGlobal.store];\r\n// V7 does not change the set of stores.\r\nconst V8_STORES = [...V6_STORES, DbCollectionParent.store];\r\n// V9 does not change the set of stores.\r\n// V10 does not change the set of stores.\r\nconst V11_STORES = [...V8_STORES, DbBundle.store, DbNamedQuery.store];\r\nconst V12_STORES = [...V11_STORES, DbDocumentOverlay.store];\r\nconst V13_STORES = [\r\n    ...V12_STORES,\r\n    DbIndexConfiguration.store,\r\n    DbIndexState.store,\r\n    DbIndexEntry.store\r\n];\r\n/** Returns the object stores for the provided schema. */\r\nfunction getObjectStores(schemaVersion) {\r\n    if (schemaVersion === 13) {\r\n        return V13_STORES;\r\n    }\r\n    else if (schemaVersion === 12) {\r\n        return V12_STORES;\r\n    }\r\n    else if (schemaVersion === 11) {\r\n        return V11_STORES;\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PRIMARY_LEASE_LOST_ERROR_MSG = 'The current tab is not in the required state to perform this operation. ' +\r\n    'It might be necessary to refresh the browser tab.';\r\n/**\r\n * A base class representing a persistence transaction, encapsulating both the\r\n * transaction's sequence numbers as well as a list of onCommitted listeners.\r\n *\r\n * When you call Persistence.runTransaction(), it will create a transaction and\r\n * pass it to your callback. You then pass it to any method that operates\r\n * on persistence.\r\n */\r\nclass PersistenceTransaction {\r\n    constructor() {\r\n        this.onCommittedListeners = [];\r\n    }\r\n    addOnCommittedListener(listener) {\r\n        this.onCommittedListeners.push(listener);\r\n    }\r\n    raiseOnCommittedEvent() {\r\n        this.onCommittedListeners.forEach(listener => listener());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * PersistencePromise is essentially a re-implementation of Promise except\r\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\r\n * are executed synchronously when a PersistencePromise resolves rather than\r\n * asynchronously (Promise implementations use setImmediate() or similar).\r\n *\r\n * This is necessary to interoperate with IndexedDB which will automatically\r\n * commit transactions if control is returned to the event loop without\r\n * synchronously initiating another operation on the transaction.\r\n *\r\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\r\n * Promises.\r\n */\r\nclass PersistencePromise {\r\n    constructor(callback) {\r\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\r\n        // not the user's raw next() or catch() callbacks.\r\n        this.nextCallback = null;\r\n        this.catchCallback = null;\r\n        // When the operation resolves, we'll set result or error and mark isDone.\r\n        this.result = undefined;\r\n        this.error = undefined;\r\n        this.isDone = false;\r\n        // Set to true when .then() or .catch() are called and prevents additional\r\n        // chaining.\r\n        this.callbackAttached = false;\r\n        callback(value => {\r\n            this.isDone = true;\r\n            this.result = value;\r\n            if (this.nextCallback) {\r\n                // value should be defined unless T is Void, but we can't express\r\n                // that in the type system.\r\n                this.nextCallback(value);\r\n            }\r\n        }, error => {\r\n            this.isDone = true;\r\n            this.error = error;\r\n            if (this.catchCallback) {\r\n                this.catchCallback(error);\r\n            }\r\n        });\r\n    }\r\n    catch(fn) {\r\n        return this.next(undefined, fn);\r\n    }\r\n    next(nextFn, catchFn) {\r\n        if (this.callbackAttached) {\r\n            fail();\r\n        }\r\n        this.callbackAttached = true;\r\n        if (this.isDone) {\r\n            if (!this.error) {\r\n                return this.wrapSuccess(nextFn, this.result);\r\n            }\r\n            else {\r\n                return this.wrapFailure(catchFn, this.error);\r\n            }\r\n        }\r\n        else {\r\n            return new PersistencePromise((resolve, reject) => {\r\n                this.nextCallback = (value) => {\r\n                    this.wrapSuccess(nextFn, value).next(resolve, reject);\r\n                };\r\n                this.catchCallback = (error) => {\r\n                    this.wrapFailure(catchFn, error).next(resolve, reject);\r\n                };\r\n            });\r\n        }\r\n    }\r\n    toPromise() {\r\n        return new Promise((resolve, reject) => {\r\n            this.next(resolve, reject);\r\n        });\r\n    }\r\n    wrapUserFunction(fn) {\r\n        try {\r\n            const result = fn();\r\n            if (result instanceof PersistencePromise) {\r\n                return result;\r\n            }\r\n            else {\r\n                return PersistencePromise.resolve(result);\r\n            }\r\n        }\r\n        catch (e) {\r\n            return PersistencePromise.reject(e);\r\n        }\r\n    }\r\n    wrapSuccess(nextFn, value) {\r\n        if (nextFn) {\r\n            return this.wrapUserFunction(() => nextFn(value));\r\n        }\r\n        else {\r\n            // If there's no nextFn, then R must be the same as T\r\n            return PersistencePromise.resolve(value);\r\n        }\r\n    }\r\n    wrapFailure(catchFn, error) {\r\n        if (catchFn) {\r\n            return this.wrapUserFunction(() => catchFn(error));\r\n        }\r\n        else {\r\n            return PersistencePromise.reject(error);\r\n        }\r\n    }\r\n    static resolve(result) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            resolve(result);\r\n        });\r\n    }\r\n    static reject(error) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            reject(error);\r\n        });\r\n    }\r\n    static waitFor(\r\n    // Accept all Promise types in waitFor().\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    all) {\r\n        return new PersistencePromise((resolve, reject) => {\r\n            let expectedCount = 0;\r\n            let resolvedCount = 0;\r\n            let done = false;\r\n            all.forEach(element => {\r\n                ++expectedCount;\r\n                element.next(() => {\r\n                    ++resolvedCount;\r\n                    if (done && resolvedCount === expectedCount) {\r\n                        resolve();\r\n                    }\r\n                }, err => reject(err));\r\n            });\r\n            done = true;\r\n            if (resolvedCount === expectedCount) {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Given an array of predicate functions that asynchronously evaluate to a\r\n     * boolean, implements a short-circuiting `or` between the results. Predicates\r\n     * will be evaluated until one of them returns `true`, then stop. The final\r\n     * result will be whether any of them returned `true`.\r\n     */\r\n    static or(predicates) {\r\n        let p = PersistencePromise.resolve(false);\r\n        for (const predicate of predicates) {\r\n            p = p.next(isTrue => {\r\n                if (isTrue) {\r\n                    return PersistencePromise.resolve(isTrue);\r\n                }\r\n                else {\r\n                    return predicate();\r\n                }\r\n            });\r\n        }\r\n        return p;\r\n    }\r\n    static forEach(collection, f) {\r\n        const promises = [];\r\n        collection.forEach((r, s) => {\r\n            promises.push(f.call(this, r, s));\r\n        });\r\n        return this.waitFor(promises);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// References to `window` are guarded by SimpleDb.isAvailable()\r\n/* eslint-disable no-restricted-globals */\r\nconst LOG_TAG$h = 'SimpleDb';\r\n/**\r\n * The maximum number of retry attempts for an IndexedDb transaction that fails\r\n * with a DOMException.\r\n */\r\nconst TRANSACTION_RETRY_COUNT = 3;\r\n/**\r\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\r\n * specific object store.\r\n */\r\nclass SimpleDbTransaction {\r\n    constructor(action, transaction) {\r\n        this.action = action;\r\n        this.transaction = transaction;\r\n        this.aborted = false;\r\n        /**\r\n         * A `Promise` that resolves with the result of the IndexedDb transaction.\r\n         */\r\n        this.completionDeferred = new Deferred();\r\n        this.transaction.oncomplete = () => {\r\n            this.completionDeferred.resolve();\r\n        };\r\n        this.transaction.onabort = () => {\r\n            if (transaction.error) {\r\n                this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));\r\n            }\r\n            else {\r\n                this.completionDeferred.resolve();\r\n            }\r\n        };\r\n        this.transaction.onerror = (event) => {\r\n            const error = checkForAndReportiOSError(event.target.error);\r\n            this.completionDeferred.reject(new IndexedDbTransactionError(action, error));\r\n        };\r\n    }\r\n    static open(db, action, mode, objectStoreNames) {\r\n        try {\r\n            return new SimpleDbTransaction(action, db.transaction(objectStoreNames, mode));\r\n        }\r\n        catch (e) {\r\n            throw new IndexedDbTransactionError(action, e);\r\n        }\r\n    }\r\n    get completionPromise() {\r\n        return this.completionDeferred.promise;\r\n    }\r\n    abort(error) {\r\n        if (error) {\r\n            this.completionDeferred.reject(error);\r\n        }\r\n        if (!this.aborted) {\r\n            logDebug(LOG_TAG$h, 'Aborting transaction:', error ? error.message : 'Client-initiated abort');\r\n            this.aborted = true;\r\n            this.transaction.abort();\r\n        }\r\n    }\r\n    maybeCommit() {\r\n        // If the browser supports V3 IndexedDB, we invoke commit() explicitly to\r\n        // speed up index DB processing if the event loop remains blocks.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const maybeV3IndexedDb = this.transaction;\r\n        if (!this.aborted && typeof maybeV3IndexedDb.commit === 'function') {\r\n            maybeV3IndexedDb.commit();\r\n        }\r\n    }\r\n    /**\r\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\r\n     * operations performed on the SimpleDbStore happen within the context of this\r\n     * transaction and it cannot be used anymore once the transaction is\r\n     * completed.\r\n     *\r\n     * Note that we can't actually enforce that the KeyType and ValueType are\r\n     * correct, but they allow type safety through the rest of the consuming code.\r\n     */\r\n    store(storeName) {\r\n        const store = this.transaction.objectStore(storeName);\r\n        return new SimpleDbStore(store);\r\n    }\r\n}\r\n/**\r\n * Provides a wrapper around IndexedDb with a simplified interface that uses\r\n * Promise-like return values to chain operations. Real promises cannot be used\r\n * since .then() continuations are executed asynchronously (e.g. via\r\n * .setImmediate), which would cause IndexedDB to end the transaction.\r\n * See PersistencePromise for more details.\r\n */\r\nclass SimpleDb {\r\n    /*\r\n     * Creates a new SimpleDb wrapper for IndexedDb database `name`.\r\n     *\r\n     * Note that `version` must not be a downgrade. IndexedDB does not support\r\n     * downgrading the schema version. We currently do not support any way to do\r\n     * versioning outside of IndexedDB's versioning mechanism, as only\r\n     * version-upgrade transactions are allowed to do things like create\r\n     * objectstores.\r\n     */\r\n    constructor(name, version, schemaConverter) {\r\n        this.name = name;\r\n        this.version = version;\r\n        this.schemaConverter = schemaConverter;\r\n        const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\r\n        // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the\r\n        // bug we're checking for should exist in iOS >= 12.2 and < 13, but for\r\n        // whatever reason it's much harder to hit after 12.2 so we only proactively\r\n        // log on 12.2.\r\n        if (iOSVersion === 12.2) {\r\n            logError('Firestore persistence suffers from a bug in iOS 12.2 ' +\r\n                'Safari that may cause your app to stop working. See ' +\r\n                'https://stackoverflow.com/q/56496296/110915 for details ' +\r\n                'and a potential workaround.');\r\n        }\r\n    }\r\n    /** Deletes the specified database. */\r\n    static delete(name) {\r\n        logDebug(LOG_TAG$h, 'Removing database:', name);\r\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\r\n    }\r\n    /** Returns true if IndexedDB is available in the current environment. */\r\n    static isAvailable() {\r\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isIndexedDBAvailable)()) {\r\n            return false;\r\n        }\r\n        if (SimpleDb.isMockPersistence()) {\r\n            return true;\r\n        }\r\n        // We extensively use indexed array values and compound keys,\r\n        // which IE and Edge do not support. However, they still have indexedDB\r\n        // defined on the window, so we need to check for them here and make sure\r\n        // to return that persistence is not enabled for those browsers.\r\n        // For tracking support of this feature, see here:\r\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\r\n        // Check the UA string to find out the browser.\r\n        const ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)();\r\n        // IE 10\r\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\r\n        // IE 11\r\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\r\n        // Edge\r\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\r\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\r\n        // iOS Safari: Disable for users running iOS version < 10.\r\n        const iOSVersion = SimpleDb.getIOSVersion(ua);\r\n        const isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;\r\n        // Android browser: Disable for userse running version < 4.5.\r\n        const androidVersion = SimpleDb.getAndroidVersion(ua);\r\n        const isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;\r\n        if (ua.indexOf('MSIE ') > 0 ||\r\n            ua.indexOf('Trident/') > 0 ||\r\n            ua.indexOf('Edge/') > 0 ||\r\n            isUnsupportedIOS ||\r\n            isUnsupportedAndroid) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if the backing IndexedDB store is the Node IndexedDBShim\r\n     * (see https://github.com/axemclion/IndexedDBShim).\r\n     */\r\n    static isMockPersistence() {\r\n        var _a;\r\n        return (typeof process !== 'undefined' &&\r\n            ((_a = process.env) === null || _a === void 0 ? void 0 : _a.USE_MOCK_PERSISTENCE) === 'YES');\r\n    }\r\n    /** Helper to get a typed SimpleDbStore from a transaction. */\r\n    static getStore(txn, store) {\r\n        return txn.store(store);\r\n    }\r\n    // visible for testing\r\n    /** Parse User Agent to determine iOS version. Returns -1 if not found. */\r\n    static getIOSVersion(ua) {\r\n        const iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\\d_]+)/i);\r\n        const version = iOSVersionRegex\r\n            ? iOSVersionRegex[1].split('_').slice(0, 2).join('.')\r\n            : '-1';\r\n        return Number(version);\r\n    }\r\n    // visible for testing\r\n    /** Parse User Agent to determine Android version. Returns -1 if not found. */\r\n    static getAndroidVersion(ua) {\r\n        const androidVersionRegex = ua.match(/Android ([\\d.]+)/i);\r\n        const version = androidVersionRegex\r\n            ? androidVersionRegex[1].split('.').slice(0, 2).join('.')\r\n            : '-1';\r\n        return Number(version);\r\n    }\r\n    /**\r\n     * Opens the specified database, creating or upgrading it if necessary.\r\n     */\r\n    async ensureDb(action) {\r\n        if (!this.db) {\r\n            logDebug(LOG_TAG$h, 'Opening database:', this.name);\r\n            this.db = await new Promise((resolve, reject) => {\r\n                // TODO(mikelehen): Investigate browser compatibility.\r\n                // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\r\n                // suggests IE9 and older WebKit browsers handle upgrade\r\n                // differently. They expect setVersion, as described here:\r\n                // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\r\n                const request = indexedDB.open(this.name, this.version);\r\n                request.onsuccess = (event) => {\r\n                    const db = event.target.result;\r\n                    resolve(db);\r\n                };\r\n                request.onblocked = () => {\r\n                    reject(new IndexedDbTransactionError(action, 'Cannot upgrade IndexedDB schema while another tab is open. ' +\r\n                        'Close all tabs that access Firestore and reload this page to proceed.'));\r\n                };\r\n                request.onerror = (event) => {\r\n                    const error = event.target.error;\r\n                    if (error.name === 'VersionError') {\r\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'A newer version of the Firestore SDK was previously used and so the persisted ' +\r\n                            'data is not compatible with the version of the SDK you are now using. The SDK ' +\r\n                            'will operate with persistence disabled. If you need persistence, please ' +\r\n                            're-upgrade to a newer version of the SDK or else clear the persisted IndexedDB ' +\r\n                            'data for your app to start fresh.'));\r\n                    }\r\n                    else if (error.name === 'InvalidStateError') {\r\n                        reject(new FirestoreError(Code.FAILED_PRECONDITION, 'Unable to open an IndexedDB connection. This could be due to running in a ' +\r\n                            'private browsing session on a browser whose private browsing sessions do not ' +\r\n                            'support IndexedDB: ' +\r\n                            error));\r\n                    }\r\n                    else {\r\n                        reject(new IndexedDbTransactionError(action, error));\r\n                    }\r\n                };\r\n                request.onupgradeneeded = (event) => {\r\n                    logDebug(LOG_TAG$h, 'Database \"' + this.name + '\" requires upgrade from version:', event.oldVersion);\r\n                    const db = event.target.result;\r\n                    this.schemaConverter\r\n                        .createOrUpgrade(db, request.transaction, event.oldVersion, this.version)\r\n                        .next(() => {\r\n                        logDebug(LOG_TAG$h, 'Database upgrade to version ' + this.version + ' complete');\r\n                    });\r\n                };\r\n            });\r\n        }\r\n        if (this.versionchangelistener) {\r\n            this.db.onversionchange = event => this.versionchangelistener(event);\r\n        }\r\n        return this.db;\r\n    }\r\n    setVersionChangeListener(versionChangeListener) {\r\n        this.versionchangelistener = versionChangeListener;\r\n        if (this.db) {\r\n            this.db.onversionchange = (event) => {\r\n                return versionChangeListener(event);\r\n            };\r\n        }\r\n    }\r\n    async runTransaction(action, mode, objectStores, transactionFn) {\r\n        const readonly = mode === 'readonly';\r\n        let attemptNumber = 0;\r\n        while (true) {\r\n            ++attemptNumber;\r\n            try {\r\n                this.db = await this.ensureDb(action);\r\n                const transaction = SimpleDbTransaction.open(this.db, action, readonly ? 'readonly' : 'readwrite', objectStores);\r\n                const transactionFnResult = transactionFn(transaction)\r\n                    .next(result => {\r\n                    transaction.maybeCommit();\r\n                    return result;\r\n                })\r\n                    .catch(error => {\r\n                    // Abort the transaction if there was an error.\r\n                    transaction.abort(error);\r\n                    // We cannot actually recover, and calling `abort()` will cause the transaction's\r\n                    // completion promise to be rejected. This in turn means that we won't use\r\n                    // `transactionFnResult` below. We return a rejection here so that we don't add the\r\n                    // possibility of returning `void` to the type of `transactionFnResult`.\r\n                    return PersistencePromise.reject(error);\r\n                })\r\n                    .toPromise();\r\n                // As noted above, errors are propagated by aborting the transaction. So\r\n                // we swallow any error here to avoid the browser logging it as unhandled.\r\n                transactionFnResult.catch(() => { });\r\n                // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\r\n                // fire), but still return the original transactionFnResult back to the\r\n                // caller.\r\n                await transaction.completionPromise;\r\n                return transactionFnResult;\r\n            }\r\n            catch (error) {\r\n                // TODO(schmidt-sebastian): We could probably be smarter about this and\r\n                // not retry exceptions that are likely unrecoverable (such as quota\r\n                // exceeded errors).\r\n                // Note: We cannot use an instanceof check for FirestoreException, since the\r\n                // exception is wrapped in a generic error by our async/await handling.\r\n                const retryable = error.name !== 'FirebaseError' &&\r\n                    attemptNumber < TRANSACTION_RETRY_COUNT;\r\n                logDebug(LOG_TAG$h, 'Transaction failed with error:', error.message, 'Retrying:', retryable);\r\n                this.close();\r\n                if (!retryable) {\r\n                    return Promise.reject(error);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    close() {\r\n        if (this.db) {\r\n            this.db.close();\r\n        }\r\n        this.db = undefined;\r\n    }\r\n}\r\n/**\r\n * A controller for iterating over a key range or index. It allows an iterate\r\n * callback to delete the currently-referenced object, or jump to a new key\r\n * within the key range or index.\r\n */\r\nclass IterationController {\r\n    constructor(dbCursor) {\r\n        this.dbCursor = dbCursor;\r\n        this.shouldStop = false;\r\n        this.nextKey = null;\r\n    }\r\n    get isDone() {\r\n        return this.shouldStop;\r\n    }\r\n    get skipToKey() {\r\n        return this.nextKey;\r\n    }\r\n    set cursor(value) {\r\n        this.dbCursor = value;\r\n    }\r\n    /**\r\n     * This function can be called to stop iteration at any point.\r\n     */\r\n    done() {\r\n        this.shouldStop = true;\r\n    }\r\n    /**\r\n     * This function can be called to skip to that next key, which could be\r\n     * an index or a primary key.\r\n     */\r\n    skip(key) {\r\n        this.nextKey = key;\r\n    }\r\n    /**\r\n     * Delete the current cursor value from the object store.\r\n     *\r\n     * NOTE: You CANNOT do this with a keysOnly query.\r\n     */\r\n    delete() {\r\n        return wrapRequest(this.dbCursor.delete());\r\n    }\r\n}\r\n/** An error that wraps exceptions that thrown during IndexedDB execution. */\r\nclass IndexedDbTransactionError extends FirestoreError {\r\n    constructor(actionName, cause) {\r\n        super(Code.UNAVAILABLE, `IndexedDB transaction '${actionName}' failed: ${cause}`);\r\n        this.name = 'IndexedDbTransactionError';\r\n    }\r\n}\r\n/** Verifies whether `e` is an IndexedDbTransactionError. */\r\nfunction isIndexedDbTransactionError(e) {\r\n    // Use name equality, as instanceof checks on errors don't work with errors\r\n    // that wrap other errors.\r\n    return e.name === 'IndexedDbTransactionError';\r\n}\r\n/**\r\n * A wrapper around an IDBObjectStore providing an API that:\r\n *\r\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\r\n * methods for acting against the object store.\r\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\r\n * method return a PersistencePromise instead.\r\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\r\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\r\n */\r\nclass SimpleDbStore {\r\n    constructor(store) {\r\n        this.store = store;\r\n    }\r\n    put(keyOrValue, value) {\r\n        let request;\r\n        if (value !== undefined) {\r\n            logDebug(LOG_TAG$h, 'PUT', this.store.name, keyOrValue, value);\r\n            request = this.store.put(value, keyOrValue);\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$h, 'PUT', this.store.name, '<auto-key>', keyOrValue);\r\n            request = this.store.put(keyOrValue);\r\n        }\r\n        return wrapRequest(request);\r\n    }\r\n    /**\r\n     * Adds a new value into an Object Store and returns the new key. Similar to\r\n     * IndexedDb's `add()`, this method will fail on primary key collisions.\r\n     *\r\n     * @param value - The object to write.\r\n     * @returns The key of the value to add.\r\n     */\r\n    add(value) {\r\n        logDebug(LOG_TAG$h, 'ADD', this.store.name, value, value);\r\n        const request = this.store.add(value);\r\n        return wrapRequest(request);\r\n    }\r\n    /**\r\n     * Gets the object with the specified key from the specified store, or null\r\n     * if no object exists with the specified key.\r\n     *\r\n     * @key The key of the object to get.\r\n     * @returns The object with the specified key or null if no object exists.\r\n     */\r\n    get(key) {\r\n        const request = this.store.get(key);\r\n        // We're doing an unsafe cast to ValueType.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return wrapRequest(request).next(result => {\r\n            // Normalize nonexistence to null.\r\n            if (result === undefined) {\r\n                result = null;\r\n            }\r\n            logDebug(LOG_TAG$h, 'GET', this.store.name, key, result);\r\n            return result;\r\n        });\r\n    }\r\n    delete(key) {\r\n        logDebug(LOG_TAG$h, 'DELETE', this.store.name, key);\r\n        const request = this.store.delete(key);\r\n        return wrapRequest(request);\r\n    }\r\n    /**\r\n     * If we ever need more of the count variants, we can add overloads. For now,\r\n     * all we need is to count everything in a store.\r\n     *\r\n     * Returns the number of rows in the store.\r\n     */\r\n    count() {\r\n        logDebug(LOG_TAG$h, 'COUNT', this.store.name);\r\n        const request = this.store.count();\r\n        return wrapRequest(request);\r\n    }\r\n    loadAll(indexOrRange, range) {\r\n        const iterateOptions = this.options(indexOrRange, range);\r\n        // Use `getAll()` if the browser supports IndexedDB v3, as it is roughly\r\n        // 20% faster. Unfortunately, getAll() does not support custom indices.\r\n        if (!iterateOptions.index && typeof this.store.getAll === 'function') {\r\n            const request = this.store.getAll(iterateOptions.range);\r\n            return new PersistencePromise((resolve, reject) => {\r\n                request.onerror = (event) => {\r\n                    reject(event.target.error);\r\n                };\r\n                request.onsuccess = (event) => {\r\n                    resolve(event.target.result);\r\n                };\r\n            });\r\n        }\r\n        else {\r\n            const cursor = this.cursor(iterateOptions);\r\n            const results = [];\r\n            return this.iterateCursor(cursor, (key, value) => {\r\n                results.push(value);\r\n            }).next(() => {\r\n                return results;\r\n            });\r\n        }\r\n    }\r\n    deleteAll(indexOrRange, range) {\r\n        logDebug(LOG_TAG$h, 'DELETE ALL', this.store.name);\r\n        const options = this.options(indexOrRange, range);\r\n        options.keysOnly = false;\r\n        const cursor = this.cursor(options);\r\n        return this.iterateCursor(cursor, (key, value, control) => {\r\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\r\n            // calling delete() on an object store with a single key\r\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\r\n            // however, this requires us *not* to use a keysOnly cursor\r\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\r\n            // may want to compare the performance of each method.\r\n            return control.delete();\r\n        });\r\n    }\r\n    iterate(optionsOrCallback, callback) {\r\n        let options;\r\n        if (!callback) {\r\n            options = {};\r\n            callback = optionsOrCallback;\r\n        }\r\n        else {\r\n            options = optionsOrCallback;\r\n        }\r\n        const cursor = this.cursor(options);\r\n        return this.iterateCursor(cursor, callback);\r\n    }\r\n    /**\r\n     * Iterates over a store, but waits for the given callback to complete for\r\n     * each entry before iterating the next entry. This allows the callback to do\r\n     * asynchronous work to determine if this iteration should continue.\r\n     *\r\n     * The provided callback should return `true` to continue iteration, and\r\n     * `false` otherwise.\r\n     */\r\n    iterateSerial(callback) {\r\n        const cursorRequest = this.cursor({});\r\n        return new PersistencePromise((resolve, reject) => {\r\n            cursorRequest.onerror = (event) => {\r\n                const error = checkForAndReportiOSError(event.target.error);\r\n                reject(error);\r\n            };\r\n            cursorRequest.onsuccess = (event) => {\r\n                const cursor = event.target.result;\r\n                if (!cursor) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n                callback(cursor.primaryKey, cursor.value).next(shouldContinue => {\r\n                    if (shouldContinue) {\r\n                        cursor.continue();\r\n                    }\r\n                    else {\r\n                        resolve();\r\n                    }\r\n                });\r\n            };\r\n        });\r\n    }\r\n    iterateCursor(cursorRequest, fn) {\r\n        const results = [];\r\n        return new PersistencePromise((resolve, reject) => {\r\n            cursorRequest.onerror = (event) => {\r\n                reject(event.target.error);\r\n            };\r\n            cursorRequest.onsuccess = (event) => {\r\n                const cursor = event.target.result;\r\n                if (!cursor) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n                const controller = new IterationController(cursor);\r\n                const userResult = fn(cursor.primaryKey, cursor.value, controller);\r\n                if (userResult instanceof PersistencePromise) {\r\n                    const userPromise = userResult.catch(err => {\r\n                        controller.done();\r\n                        return PersistencePromise.reject(err);\r\n                    });\r\n                    results.push(userPromise);\r\n                }\r\n                if (controller.isDone) {\r\n                    resolve();\r\n                }\r\n                else if (controller.skipToKey === null) {\r\n                    cursor.continue();\r\n                }\r\n                else {\r\n                    cursor.continue(controller.skipToKey);\r\n                }\r\n            };\r\n        }).next(() => {\r\n            return PersistencePromise.waitFor(results);\r\n        });\r\n    }\r\n    options(indexOrRange, range) {\r\n        let indexName = undefined;\r\n        if (indexOrRange !== undefined) {\r\n            if (typeof indexOrRange === 'string') {\r\n                indexName = indexOrRange;\r\n            }\r\n            else {\r\n                range = indexOrRange;\r\n            }\r\n        }\r\n        return { index: indexName, range };\r\n    }\r\n    cursor(options) {\r\n        let direction = 'next';\r\n        if (options.reverse) {\r\n            direction = 'prev';\r\n        }\r\n        if (options.index) {\r\n            const index = this.store.index(options.index);\r\n            if (options.keysOnly) {\r\n                return index.openKeyCursor(options.range, direction);\r\n            }\r\n            else {\r\n                return index.openCursor(options.range, direction);\r\n            }\r\n        }\r\n        else {\r\n            return this.store.openCursor(options.range, direction);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\r\n * handlers to resolve / reject the PersistencePromise as appropriate.\r\n */\r\nfunction wrapRequest(request) {\r\n    return new PersistencePromise((resolve, reject) => {\r\n        request.onsuccess = (event) => {\r\n            const result = event.target.result;\r\n            resolve(result);\r\n        };\r\n        request.onerror = (event) => {\r\n            const error = checkForAndReportiOSError(event.target.error);\r\n            reject(error);\r\n        };\r\n    });\r\n}\r\n// Guard so we only report the error once.\r\nlet reportedIOSError = false;\r\nfunction checkForAndReportiOSError(error) {\r\n    const iOSVersion = SimpleDb.getIOSVersion((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getUA)());\r\n    if (iOSVersion >= 12.2 && iOSVersion < 13) {\r\n        const IOS_ERROR = 'An internal error was encountered in the Indexed Database server';\r\n        if (error.message.indexOf(IOS_ERROR) >= 0) {\r\n            // Wrap error in a more descriptive one.\r\n            const newError = new FirestoreError('internal', `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${IOS_ERROR}'. This is likely ` +\r\n                `due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 ` +\r\n                `for details and a potential workaround.`);\r\n            if (!reportedIOSError) {\r\n                reportedIOSError = true;\r\n                // Throw a global exception outside of this promise chain, for the user to\r\n                // potentially catch.\r\n                setTimeout(() => {\r\n                    throw newError;\r\n                }, 0);\r\n            }\r\n            return newError;\r\n        }\r\n    }\r\n    return error;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass IndexedDbTransaction extends PersistenceTransaction {\r\n    constructor(simpleDbTransaction, currentSequenceNumber) {\r\n        super();\r\n        this.simpleDbTransaction = simpleDbTransaction;\r\n        this.currentSequenceNumber = currentSequenceNumber;\r\n    }\r\n}\r\nfunction getStore(txn, store) {\r\n    const indexedDbTransaction = debugCast(txn);\r\n    return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Generates `nBytes` of random bytes.\r\n *\r\n * If `nBytes < 0` , an error will be thrown.\r\n */\r\nfunction randomBytes(nBytes) {\r\n    return (0,crypto__WEBPACK_IMPORTED_MODULE_5__.randomBytes)(nBytes);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass AutoId {\r\n    static newId() {\r\n        // Alphanumeric characters\r\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        // The largest byte value that is a multiple of `char.length`.\r\n        const maxMultiple = Math.floor(256 / chars.length) * chars.length;\r\n        let autoId = '';\r\n        const targetLength = 20;\r\n        while (autoId.length < targetLength) {\r\n            const bytes = randomBytes(40);\r\n            for (let i = 0; i < bytes.length; ++i) {\r\n                // Only accept values that are [0, maxMultiple), this ensures they can\r\n                // be evenly mapped to indices of `chars` via a modulo operation.\r\n                if (autoId.length < targetLength && bytes[i] < maxMultiple) {\r\n                    autoId += chars.charAt(bytes[i] % chars.length);\r\n                }\r\n            }\r\n        }\r\n        return autoId;\r\n    }\r\n}\r\nfunction primitiveComparator(left, right) {\r\n    if (left < right) {\r\n        return -1;\r\n    }\r\n    if (left > right) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n/** Helper to compare arrays using isEqual(). */\r\nfunction arrayEquals(left, right, comparator) {\r\n    if (left.length !== right.length) {\r\n        return false;\r\n    }\r\n    return left.every((value, index) => comparator(value, right[index]));\r\n}\r\n/**\r\n * Returns the immediate lexicographically-following string. This is useful to\r\n * construct an inclusive range for indexeddb iterators.\r\n */\r\nfunction immediateSuccessor(s) {\r\n    // Return the input string, with an additional NUL byte appended.\r\n    return s + '\\0';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).\r\nconst MIN_SECONDS = -62135596800;\r\n// Number of nanoseconds in a millisecond.\r\nconst MS_TO_NANOS = 1e6;\r\n/**\r\n * A `Timestamp` represents a point in time independent of any time zone or\r\n * calendar, represented as seconds and fractions of seconds at nanosecond\r\n * resolution in UTC Epoch time.\r\n *\r\n * It is encoded using the Proleptic Gregorian Calendar which extends the\r\n * Gregorian calendar backwards to year one. It is encoded assuming all minutes\r\n * are 60 seconds long, i.e. leap seconds are \"smeared\" so that no leap second\r\n * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to\r\n * 9999-12-31T23:59:59.999999999Z.\r\n *\r\n * For examples and further specifications, refer to the\r\n * {@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.\r\n */\r\nclass Timestamp {\r\n    /**\r\n     * Creates a new timestamp.\r\n     *\r\n     * @param seconds - The number of seconds of UTC time since Unix epoch\r\n     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\r\n     *     9999-12-31T23:59:59Z inclusive.\r\n     * @param nanoseconds - The non-negative fractions of a second at nanosecond\r\n     *     resolution. Negative second values with fractions must still have\r\n     *     non-negative nanoseconds values that count forward in time. Must be\r\n     *     from 0 to 999,999,999 inclusive.\r\n     */\r\n    constructor(\r\n    /**\r\n     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.\r\n     */\r\n    seconds, \r\n    /**\r\n     * The fractions of a second at nanosecond resolution.*\r\n     */\r\n    nanoseconds) {\r\n        this.seconds = seconds;\r\n        this.nanoseconds = nanoseconds;\r\n        if (nanoseconds < 0) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\r\n        }\r\n        if (nanoseconds >= 1e9) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);\r\n        }\r\n        if (seconds < MIN_SECONDS) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\r\n        }\r\n        // This will break in the year 10,000.\r\n        if (seconds >= 253402300800) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a new timestamp with the current date, with millisecond precision.\r\n     *\r\n     * @returns a new timestamp representing the current date.\r\n     */\r\n    static now() {\r\n        return Timestamp.fromMillis(Date.now());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given date.\r\n     *\r\n     * @param date - The date to initialize the `Timestamp` from.\r\n     * @returns A new `Timestamp` representing the same point in time as the given\r\n     *     date.\r\n     */\r\n    static fromDate(date) {\r\n        return Timestamp.fromMillis(date.getTime());\r\n    }\r\n    /**\r\n     * Creates a new timestamp from the given number of milliseconds.\r\n     *\r\n     * @param milliseconds - Number of milliseconds since Unix epoch\r\n     *     1970-01-01T00:00:00Z.\r\n     * @returns A new `Timestamp` representing the same point in time as the given\r\n     *     number of milliseconds.\r\n     */\r\n    static fromMillis(milliseconds) {\r\n        const seconds = Math.floor(milliseconds / 1000);\r\n        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);\r\n        return new Timestamp(seconds, nanos);\r\n    }\r\n    /**\r\n     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion\r\n     * causes a loss of precision since `Date` objects only support millisecond\r\n     * precision.\r\n     *\r\n     * @returns JavaScript `Date` object representing the same point in time as\r\n     *     this `Timestamp`, with millisecond precision.\r\n     */\r\n    toDate() {\r\n        return new Date(this.toMillis());\r\n    }\r\n    /**\r\n     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since\r\n     * epoch). This operation causes a loss of precision.\r\n     *\r\n     * @returns The point in time corresponding to this timestamp, represented as\r\n     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.\r\n     */\r\n    toMillis() {\r\n        return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;\r\n    }\r\n    _compareTo(other) {\r\n        if (this.seconds === other.seconds) {\r\n            return primitiveComparator(this.nanoseconds, other.nanoseconds);\r\n        }\r\n        return primitiveComparator(this.seconds, other.seconds);\r\n    }\r\n    /**\r\n     * Returns true if this `Timestamp` is equal to the provided one.\r\n     *\r\n     * @param other - The `Timestamp` to compare against.\r\n     * @returns true if this `Timestamp` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return (other.seconds === this.seconds && other.nanoseconds === this.nanoseconds);\r\n    }\r\n    /** Returns a textual representation of this `Timestamp`. */\r\n    toString() {\r\n        return ('Timestamp(seconds=' +\r\n            this.seconds +\r\n            ', nanoseconds=' +\r\n            this.nanoseconds +\r\n            ')');\r\n    }\r\n    /** Returns a JSON-serializable representation of this `Timestamp`. */\r\n    toJSON() {\r\n        return { seconds: this.seconds, nanoseconds: this.nanoseconds };\r\n    }\r\n    /**\r\n     * Converts this object to a primitive string, which allows `Timestamp` objects\r\n     * to be compared using the `>`, `<=`, `>=` and `>` operators.\r\n     */\r\n    valueOf() {\r\n        // This method returns a string of the form <seconds>.<nanoseconds> where\r\n        // <seconds> is translated to have a non-negative value and both <seconds>\r\n        // and <nanoseconds> are left-padded with zeroes to be a consistent length.\r\n        // Strings with this format then have a lexiographical ordering that matches\r\n        // the expected ordering. The <seconds> translation is done to avoid having\r\n        // a leading negative sign (i.e. a leading '-' character) in its string\r\n        // representation, which would affect its lexiographical ordering.\r\n        const adjustedSeconds = this.seconds - MIN_SECONDS;\r\n        // Note: Up to 12 decimal digits are required to represent all valid\r\n        // 'seconds' values.\r\n        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\r\n        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\r\n        return formattedSeconds + '.' + formattedNanoseconds;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A version of a document in Firestore. This corresponds to the version\r\n * timestamp, such as update_time or read_time.\r\n */\r\nclass SnapshotVersion {\r\n    constructor(timestamp) {\r\n        this.timestamp = timestamp;\r\n    }\r\n    static fromTimestamp(value) {\r\n        return new SnapshotVersion(value);\r\n    }\r\n    static min() {\r\n        return new SnapshotVersion(new Timestamp(0, 0));\r\n    }\r\n    compareTo(other) {\r\n        return this.timestamp._compareTo(other.timestamp);\r\n    }\r\n    isEqual(other) {\r\n        return this.timestamp.isEqual(other.timestamp);\r\n    }\r\n    /** Returns a number representation of the version for use in spec tests. */\r\n    toMicroseconds() {\r\n        // Convert to microseconds.\r\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\r\n    }\r\n    toString() {\r\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\r\n    }\r\n    toTimestamp() {\r\n        return this.timestamp;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction objectSize(obj) {\r\n    let count = 0;\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n}\r\nfunction forEach(obj, fn) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            fn(key, obj[key]);\r\n        }\r\n    }\r\n}\r\nfunction isEmpty(obj) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides a set of fields that can be used to partially patch a document.\r\n * FieldMask is used in conjunction with ObjectValue.\r\n * Examples:\r\n *   foo - Overwrites foo entirely with the provided value. If foo is not\r\n *         present in the companion ObjectValue, the field is deleted.\r\n *   foo.bar - Overwrites only the field bar of the object foo.\r\n *             If foo is not an object, foo is replaced with an object\r\n *             containing foo\r\n */\r\nclass FieldMask {\r\n    constructor(fields) {\r\n        this.fields = fields;\r\n        // TODO(dimond): validation of FieldMask\r\n        // Sort the field mask to support `FieldMask.isEqual()` and assert below.\r\n        fields.sort(FieldPath$1.comparator);\r\n    }\r\n    /**\r\n     * Verifies that `fieldPath` is included by at least one field in this field\r\n     * mask.\r\n     *\r\n     * This is an O(n) operation, where `n` is the size of the field mask.\r\n     */\r\n    covers(fieldPath) {\r\n        for (const fieldMaskPath of this.fields) {\r\n            if (fieldMaskPath.isPrefixOf(fieldPath)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isEqual(other) {\r\n        return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction decodeBase64(encoded) {\r\n    // Node actually doesn't validate base64 strings.\r\n    // A quick sanity check that is not a fool-proof validation\r\n    if (/[^-A-Za-z0-9+/=]/.test(encoded)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Not a valid Base64 string: ' + encoded);\r\n    }\r\n    return new Buffer(encoded, 'base64').toString('binary');\r\n}\r\n/** Converts a binary string to a Base64 encoded string. */\r\nfunction encodeBase64(raw) {\r\n    return new Buffer(raw, 'binary').toString('base64');\r\n}\r\n/** True if and only if the Base64 conversion functions are available. */\r\nfunction isBase64Available() {\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Immutable class that represents a \"proto\" byte string.\r\n *\r\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\r\n * sent on the wire. This class abstracts away this differentiation by holding\r\n * the proto byte string in a common class that must be converted into a string\r\n * before being sent as a proto.\r\n * @internal\r\n */\r\nclass ByteString {\r\n    constructor(binaryString) {\r\n        this.binaryString = binaryString;\r\n    }\r\n    static fromBase64String(base64) {\r\n        const binaryString = decodeBase64(base64);\r\n        return new ByteString(binaryString);\r\n    }\r\n    static fromUint8Array(array) {\r\n        const binaryString = binaryStringFromUint8Array(array);\r\n        return new ByteString(binaryString);\r\n    }\r\n    [Symbol.iterator]() {\r\n        let i = 0;\r\n        return {\r\n            next: () => {\r\n                if (i < this.binaryString.length) {\r\n                    return { value: this.binaryString.charCodeAt(i++), done: false };\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n    }\r\n    toBase64() {\r\n        return encodeBase64(this.binaryString);\r\n    }\r\n    toUint8Array() {\r\n        return uint8ArrayFromBinaryString(this.binaryString);\r\n    }\r\n    approximateByteSize() {\r\n        return this.binaryString.length * 2;\r\n    }\r\n    compareTo(other) {\r\n        return primitiveComparator(this.binaryString, other.binaryString);\r\n    }\r\n    isEqual(other) {\r\n        return this.binaryString === other.binaryString;\r\n    }\r\n}\r\nByteString.EMPTY_BYTE_STRING = new ByteString('');\r\n/**\r\n * Helper function to convert an Uint8array to a binary string.\r\n */\r\nfunction binaryStringFromUint8Array(array) {\r\n    let binaryString = '';\r\n    for (let i = 0; i < array.length; ++i) {\r\n        binaryString += String.fromCharCode(array[i]);\r\n    }\r\n    return binaryString;\r\n}\r\n/**\r\n * Helper function to convert a binary string to an Uint8Array.\r\n */\r\nfunction uint8ArrayFromBinaryString(binaryString) {\r\n    const buffer = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n        buffer[i] = binaryString.charCodeAt(i);\r\n    }\r\n    return buffer;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\r\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\r\n/**\r\n * Converts the possible Proto values for a timestamp value into a \"seconds and\r\n * nanos\" representation.\r\n */\r\nfunction normalizeTimestamp(date) {\r\n    hardAssert(!!date);\r\n    // The json interface (for the browser) will return an iso timestamp string,\r\n    // while the proto js library (for node) will return a\r\n    // google.protobuf.Timestamp instance.\r\n    if (typeof date === 'string') {\r\n        // The date string can have higher precision (nanos) than the Date class\r\n        // (millis), so we do some custom parsing here.\r\n        // Parse the nanos right out of the string.\r\n        let nanos = 0;\r\n        const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\r\n        hardAssert(!!fraction);\r\n        if (fraction[1]) {\r\n            // Pad the fraction out to 9 digits (nanos).\r\n            let nanoStr = fraction[1];\r\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\r\n            nanos = Number(nanoStr);\r\n        }\r\n        // Parse the date to get the seconds.\r\n        const parsedDate = new Date(date);\r\n        const seconds = Math.floor(parsedDate.getTime() / 1000);\r\n        return { seconds, nanos };\r\n    }\r\n    else {\r\n        // TODO(b/37282237): Use strings for Proto3 timestamps\r\n        // assert(!this.options.useProto3Json,\r\n        //   'The timestamp instance format requires Proto JS.');\r\n        const seconds = normalizeNumber(date.seconds);\r\n        const nanos = normalizeNumber(date.nanos);\r\n        return { seconds, nanos };\r\n    }\r\n}\r\n/**\r\n * Converts the possible Proto types for numbers into a JavaScript number.\r\n * Returns 0 if the value is not numeric.\r\n */\r\nfunction normalizeNumber(value) {\r\n    // TODO(bjornick): Handle int64 greater than 53 bits.\r\n    if (typeof value === 'number') {\r\n        return value;\r\n    }\r\n    else if (typeof value === 'string') {\r\n        return Number(value);\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\n/** Converts the possible Proto types for Blobs into a ByteString. */\r\nfunction normalizeByteString(blob) {\r\n    if (typeof blob === 'string') {\r\n        return ByteString.fromBase64String(blob);\r\n    }\r\n    else {\r\n        return ByteString.fromUint8Array(blob);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a locally-applied ServerTimestamp.\r\n *\r\n * Server Timestamps are backed by MapValues that contain an internal field\r\n * `__type__` with a value of `server_timestamp`. The previous value and local\r\n * write time are stored in its `__previous_value__` and `__local_write_time__`\r\n * fields respectively.\r\n *\r\n * Notes:\r\n * - ServerTimestampValue instances are created as the result of applying a\r\n *   transform. They can only exist in the local view of a document. Therefore\r\n *   they do not need to be parsed or serialized.\r\n * - When evaluated locally (e.g. for snapshot.data()), they by default\r\n *   evaluate to `null`. This behavior can be configured by passing custom\r\n *   FieldValueOptions to value().\r\n * - With respect to other ServerTimestampValues, they sort by their\r\n *   localWriteTime.\r\n */\r\nconst SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';\r\nconst TYPE_KEY = '__type__';\r\nconst PREVIOUS_VALUE_KEY = '__previous_value__';\r\nconst LOCAL_WRITE_TIME_KEY = '__local_write_time__';\r\nfunction isServerTimestamp(value) {\r\n    var _a, _b;\r\n    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;\r\n    return type === SERVER_TIMESTAMP_SENTINEL;\r\n}\r\n/**\r\n * Creates a new ServerTimestamp proto value (using the internal format).\r\n */\r\nfunction serverTimestamp$1(localWriteTime, previousValue) {\r\n    const mapValue = {\r\n        fields: {\r\n            [TYPE_KEY]: {\r\n                stringValue: SERVER_TIMESTAMP_SENTINEL\r\n            },\r\n            [LOCAL_WRITE_TIME_KEY]: {\r\n                timestampValue: {\r\n                    seconds: localWriteTime.seconds,\r\n                    nanos: localWriteTime.nanoseconds\r\n                }\r\n            }\r\n        }\r\n    };\r\n    if (previousValue) {\r\n        mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;\r\n    }\r\n    return { mapValue };\r\n}\r\n/**\r\n * Returns the value of the field before this ServerTimestamp was set.\r\n *\r\n * Preserving the previous values allows the user to display the last resoled\r\n * value until the backend responds with the timestamp.\r\n */\r\nfunction getPreviousValue(value) {\r\n    const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];\r\n    if (isServerTimestamp(previousValue)) {\r\n        return getPreviousValue(previousValue);\r\n    }\r\n    return previousValue;\r\n}\r\n/**\r\n * Returns the local time at which this timestamp was first set.\r\n */\r\nfunction getLocalWriteTime(value) {\r\n    const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);\r\n    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass DatabaseInfo {\r\n    /**\r\n     * Constructs a DatabaseInfo using the provided host, databaseId and\r\n     * persistenceKey.\r\n     *\r\n     * @param databaseId - The database to use.\r\n     * @param appId - The Firebase App Id.\r\n     * @param persistenceKey - A unique identifier for this Firestore's local\r\n     * storage (used in conjunction with the databaseId).\r\n     * @param host - The Firestore backend host to connect to.\r\n     * @param ssl - Whether to use SSL when connecting.\r\n     * @param forceLongPolling - Whether to use the forceLongPolling option\r\n     * when using WebChannel as the network transport.\r\n     * @param autoDetectLongPolling - Whether to use the detectBufferingProxy\r\n     * option when using WebChannel as the network transport.\r\n     * @param useFetchStreams Whether to use the Fetch API instead of\r\n     * XMLHTTPRequest\r\n     */\r\n    constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, useFetchStreams) {\r\n        this.databaseId = databaseId;\r\n        this.appId = appId;\r\n        this.persistenceKey = persistenceKey;\r\n        this.host = host;\r\n        this.ssl = ssl;\r\n        this.forceLongPolling = forceLongPolling;\r\n        this.autoDetectLongPolling = autoDetectLongPolling;\r\n        this.useFetchStreams = useFetchStreams;\r\n    }\r\n}\r\n/** The default database name for a project. */\r\nconst DEFAULT_DATABASE_NAME = '(default)';\r\n/**\r\n * Represents the database ID a Firestore client is associated with.\r\n * @internal\r\n */\r\nclass DatabaseId {\r\n    constructor(projectId, database) {\r\n        this.projectId = projectId;\r\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\r\n    }\r\n    static empty() {\r\n        return new DatabaseId('', '');\r\n    }\r\n    get isDefaultDatabase() {\r\n        return this.database === DEFAULT_DATABASE_NAME;\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof DatabaseId &&\r\n            other.projectId === this.projectId &&\r\n            other.database === this.database);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Sentinel value that sorts before any Mutation Batch ID. */\r\nconst BATCHID_UNKNOWN = -1;\r\n/**\r\n * Returns whether a variable is either undefined or null.\r\n */\r\nfunction isNullOrUndefined(value) {\r\n    return value === null || value === undefined;\r\n}\r\n/** Returns whether the value represents -0. */\r\nfunction isNegativeZero(value) {\r\n    // Detect if the value is -0.0. Based on polyfill from\r\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n    return value === 0 && 1 / value === 1 / -0;\r\n}\r\n/**\r\n * Returns whether a value is an integer and in the safe integer range\r\n * @param value - The value to test for being an integer and in the safe range\r\n */\r\nfunction isSafeInteger(value) {\r\n    return (typeof value === 'number' &&\r\n        Number.isInteger(value) &&\r\n        !isNegativeZero(value) &&\r\n        value <= Number.MAX_SAFE_INTEGER &&\r\n        value >= Number.MIN_SAFE_INTEGER);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n */\r\nclass DocumentKey {\r\n    constructor(path) {\r\n        this.path = path;\r\n    }\r\n    static fromPath(path) {\r\n        return new DocumentKey(ResourcePath.fromString(path));\r\n    }\r\n    static fromName(name) {\r\n        return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\r\n    }\r\n    static empty() {\r\n        return new DocumentKey(ResourcePath.emptyPath());\r\n    }\r\n    get collectionGroup() {\r\n        return this.path.popLast().lastSegment();\r\n    }\r\n    /** Returns true if the document is in the specified collectionId. */\r\n    hasCollectionId(collectionId) {\r\n        return (this.path.length >= 2 &&\r\n            this.path.get(this.path.length - 2) === collectionId);\r\n    }\r\n    /** Returns the collection group (i.e. the name of the parent collection) for this key. */\r\n    getCollectionGroup() {\r\n        return this.path.get(this.path.length - 2);\r\n    }\r\n    /** Returns the fully qualified path to the parent collection. */\r\n    getCollectionPath() {\r\n        return this.path.popLast();\r\n    }\r\n    isEqual(other) {\r\n        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);\r\n    }\r\n    toString() {\r\n        return this.path.toString();\r\n    }\r\n    static comparator(k1, k2) {\r\n        return ResourcePath.comparator(k1.path, k2.path);\r\n    }\r\n    static isDocumentKey(path) {\r\n        return path.length % 2 === 0;\r\n    }\r\n    /**\r\n     * Creates and returns a new document key with the given segments.\r\n     *\r\n     * @param segments - The segments of the path to the document\r\n     * @returns A new instance of DocumentKey\r\n     */\r\n    static fromSegments(segments) {\r\n        return new DocumentKey(new ResourcePath(segments.slice()));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst MAX_VALUE = {\r\n    mapValue: {\r\n        fields: {\r\n            '__type__': { stringValue: '__max___' }\r\n        }\r\n    }\r\n};\r\n/** Extracts the backend's type order for the provided value. */\r\nfunction typeOrder(value) {\r\n    if ('nullValue' in value) {\r\n        return 0 /* NullValue */;\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return 1 /* BooleanValue */;\r\n    }\r\n    else if ('integerValue' in value || 'doubleValue' in value) {\r\n        return 2 /* NumberValue */;\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return 3 /* TimestampValue */;\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return 5 /* StringValue */;\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return 6 /* BlobValue */;\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return 7 /* RefValue */;\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return 8 /* GeoPointValue */;\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return 9 /* ArrayValue */;\r\n    }\r\n    else if ('mapValue' in value) {\r\n        if (isServerTimestamp(value)) {\r\n            return 4 /* ServerTimestampValue */;\r\n        }\r\n        return 10 /* ObjectValue */;\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\n/** Tests `left` and `right` for equality based on the backend semantics. */\r\nfunction valueEquals(left, right) {\r\n    if (left === right) {\r\n        return true;\r\n    }\r\n    const leftType = typeOrder(left);\r\n    const rightType = typeOrder(right);\r\n    if (leftType !== rightType) {\r\n        return false;\r\n    }\r\n    switch (leftType) {\r\n        case 0 /* NullValue */:\r\n            return true;\r\n        case 1 /* BooleanValue */:\r\n            return left.booleanValue === right.booleanValue;\r\n        case 4 /* ServerTimestampValue */:\r\n            return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\r\n        case 3 /* TimestampValue */:\r\n            return timestampEquals(left, right);\r\n        case 5 /* StringValue */:\r\n            return left.stringValue === right.stringValue;\r\n        case 6 /* BlobValue */:\r\n            return blobEquals(left, right);\r\n        case 7 /* RefValue */:\r\n            return left.referenceValue === right.referenceValue;\r\n        case 8 /* GeoPointValue */:\r\n            return geoPointEquals(left, right);\r\n        case 2 /* NumberValue */:\r\n            return numberEquals(left, right);\r\n        case 9 /* ArrayValue */:\r\n            return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);\r\n        case 10 /* ObjectValue */:\r\n            return objectEquals(left, right);\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction timestampEquals(left, right) {\r\n    if (typeof left.timestampValue === 'string' &&\r\n        typeof right.timestampValue === 'string' &&\r\n        left.timestampValue.length === right.timestampValue.length) {\r\n        // Use string equality for ISO 8601 timestamps\r\n        return left.timestampValue === right.timestampValue;\r\n    }\r\n    const leftTimestamp = normalizeTimestamp(left.timestampValue);\r\n    const rightTimestamp = normalizeTimestamp(right.timestampValue);\r\n    return (leftTimestamp.seconds === rightTimestamp.seconds &&\r\n        leftTimestamp.nanos === rightTimestamp.nanos);\r\n}\r\nfunction geoPointEquals(left, right) {\r\n    return (normalizeNumber(left.geoPointValue.latitude) ===\r\n        normalizeNumber(right.geoPointValue.latitude) &&\r\n        normalizeNumber(left.geoPointValue.longitude) ===\r\n            normalizeNumber(right.geoPointValue.longitude));\r\n}\r\nfunction blobEquals(left, right) {\r\n    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));\r\n}\r\nfunction numberEquals(left, right) {\r\n    if ('integerValue' in left && 'integerValue' in right) {\r\n        return (normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue));\r\n    }\r\n    else if ('doubleValue' in left && 'doubleValue' in right) {\r\n        const n1 = normalizeNumber(left.doubleValue);\r\n        const n2 = normalizeNumber(right.doubleValue);\r\n        if (n1 === n2) {\r\n            return isNegativeZero(n1) === isNegativeZero(n2);\r\n        }\r\n        else {\r\n            return isNaN(n1) && isNaN(n2);\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction objectEquals(left, right) {\r\n    const leftMap = left.mapValue.fields || {};\r\n    const rightMap = right.mapValue.fields || {};\r\n    if (objectSize(leftMap) !== objectSize(rightMap)) {\r\n        return false;\r\n    }\r\n    for (const key in leftMap) {\r\n        if (leftMap.hasOwnProperty(key)) {\r\n            if (rightMap[key] === undefined ||\r\n                !valueEquals(leftMap[key], rightMap[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/** Returns true if the ArrayValue contains the specified element. */\r\nfunction arrayValueContains(haystack, needle) {\r\n    return ((haystack.values || []).find(v => valueEquals(v, needle)) !== undefined);\r\n}\r\nfunction valueCompare(left, right) {\r\n    if (left === right) {\r\n        return 0;\r\n    }\r\n    const leftType = typeOrder(left);\r\n    const rightType = typeOrder(right);\r\n    if (leftType !== rightType) {\r\n        return primitiveComparator(leftType, rightType);\r\n    }\r\n    switch (leftType) {\r\n        case 0 /* NullValue */:\r\n            return 0;\r\n        case 1 /* BooleanValue */:\r\n            return primitiveComparator(left.booleanValue, right.booleanValue);\r\n        case 2 /* NumberValue */:\r\n            return compareNumbers(left, right);\r\n        case 3 /* TimestampValue */:\r\n            return compareTimestamps(left.timestampValue, right.timestampValue);\r\n        case 4 /* ServerTimestampValue */:\r\n            return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));\r\n        case 5 /* StringValue */:\r\n            return primitiveComparator(left.stringValue, right.stringValue);\r\n        case 6 /* BlobValue */:\r\n            return compareBlobs(left.bytesValue, right.bytesValue);\r\n        case 7 /* RefValue */:\r\n            return compareReferences(left.referenceValue, right.referenceValue);\r\n        case 8 /* GeoPointValue */:\r\n            return compareGeoPoints(left.geoPointValue, right.geoPointValue);\r\n        case 9 /* ArrayValue */:\r\n            return compareArrays(left.arrayValue, right.arrayValue);\r\n        case 10 /* ObjectValue */:\r\n            return compareMaps(left.mapValue, right.mapValue);\r\n        default:\r\n            throw fail();\r\n    }\r\n}\r\nfunction compareNumbers(left, right) {\r\n    const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\r\n    const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\r\n    if (leftNumber < rightNumber) {\r\n        return -1;\r\n    }\r\n    else if (leftNumber > rightNumber) {\r\n        return 1;\r\n    }\r\n    else if (leftNumber === rightNumber) {\r\n        return 0;\r\n    }\r\n    else {\r\n        // one or both are NaN.\r\n        if (isNaN(leftNumber)) {\r\n            return isNaN(rightNumber) ? 0 : -1;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n}\r\nfunction compareTimestamps(left, right) {\r\n    if (typeof left === 'string' &&\r\n        typeof right === 'string' &&\r\n        left.length === right.length) {\r\n        return primitiveComparator(left, right);\r\n    }\r\n    const leftTimestamp = normalizeTimestamp(left);\r\n    const rightTimestamp = normalizeTimestamp(right);\r\n    const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);\r\n    if (comparison !== 0) {\r\n        return comparison;\r\n    }\r\n    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\r\n}\r\nfunction compareReferences(leftPath, rightPath) {\r\n    const leftSegments = leftPath.split('/');\r\n    const rightSegments = rightPath.split('/');\r\n    for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) {\r\n        const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\r\n        if (comparison !== 0) {\r\n            return comparison;\r\n        }\r\n    }\r\n    return primitiveComparator(leftSegments.length, rightSegments.length);\r\n}\r\nfunction compareGeoPoints(left, right) {\r\n    const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));\r\n    if (comparison !== 0) {\r\n        return comparison;\r\n    }\r\n    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));\r\n}\r\nfunction compareBlobs(left, right) {\r\n    const leftBytes = normalizeByteString(left);\r\n    const rightBytes = normalizeByteString(right);\r\n    return leftBytes.compareTo(rightBytes);\r\n}\r\nfunction compareArrays(left, right) {\r\n    const leftArray = left.values || [];\r\n    const rightArray = right.values || [];\r\n    for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) {\r\n        const compare = valueCompare(leftArray[i], rightArray[i]);\r\n        if (compare) {\r\n            return compare;\r\n        }\r\n    }\r\n    return primitiveComparator(leftArray.length, rightArray.length);\r\n}\r\nfunction compareMaps(left, right) {\r\n    const leftMap = left.fields || {};\r\n    const leftKeys = Object.keys(leftMap);\r\n    const rightMap = right.fields || {};\r\n    const rightKeys = Object.keys(rightMap);\r\n    // Even though MapValues are likely sorted correctly based on their insertion\r\n    // order (e.g. when received from the backend), local modifications can bring\r\n    // elements out of order. We need to re-sort the elements to ensure that\r\n    // canonical IDs are independent of insertion order.\r\n    leftKeys.sort();\r\n    rightKeys.sort();\r\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {\r\n        const keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);\r\n        if (keyCompare !== 0) {\r\n            return keyCompare;\r\n        }\r\n        const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\r\n        if (compare !== 0) {\r\n            return compare;\r\n        }\r\n    }\r\n    return primitiveComparator(leftKeys.length, rightKeys.length);\r\n}\r\n/**\r\n * Generates the canonical ID for the provided field value (as used in Target\r\n * serialization).\r\n */\r\nfunction canonicalId(value) {\r\n    return canonifyValue(value);\r\n}\r\nfunction canonifyValue(value) {\r\n    if ('nullValue' in value) {\r\n        return 'null';\r\n    }\r\n    else if ('booleanValue' in value) {\r\n        return '' + value.booleanValue;\r\n    }\r\n    else if ('integerValue' in value) {\r\n        return '' + value.integerValue;\r\n    }\r\n    else if ('doubleValue' in value) {\r\n        return '' + value.doubleValue;\r\n    }\r\n    else if ('timestampValue' in value) {\r\n        return canonifyTimestamp(value.timestampValue);\r\n    }\r\n    else if ('stringValue' in value) {\r\n        return value.stringValue;\r\n    }\r\n    else if ('bytesValue' in value) {\r\n        return canonifyByteString(value.bytesValue);\r\n    }\r\n    else if ('referenceValue' in value) {\r\n        return canonifyReference(value.referenceValue);\r\n    }\r\n    else if ('geoPointValue' in value) {\r\n        return canonifyGeoPoint(value.geoPointValue);\r\n    }\r\n    else if ('arrayValue' in value) {\r\n        return canonifyArray(value.arrayValue);\r\n    }\r\n    else if ('mapValue' in value) {\r\n        return canonifyMap(value.mapValue);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction canonifyByteString(byteString) {\r\n    return normalizeByteString(byteString).toBase64();\r\n}\r\nfunction canonifyTimestamp(timestamp) {\r\n    const normalizedTimestamp = normalizeTimestamp(timestamp);\r\n    return `time(${normalizedTimestamp.seconds},${normalizedTimestamp.nanos})`;\r\n}\r\nfunction canonifyGeoPoint(geoPoint) {\r\n    return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\r\n}\r\nfunction canonifyReference(referenceValue) {\r\n    return DocumentKey.fromName(referenceValue).toString();\r\n}\r\nfunction canonifyMap(mapValue) {\r\n    // Iteration order in JavaScript is not guaranteed. To ensure that we generate\r\n    // matching canonical IDs for identical maps, we need to sort the keys.\r\n    const sortedKeys = Object.keys(mapValue.fields || {}).sort();\r\n    let result = '{';\r\n    let first = true;\r\n    for (const key of sortedKeys) {\r\n        if (!first) {\r\n            result += ',';\r\n        }\r\n        else {\r\n            first = false;\r\n        }\r\n        result += `${key}:${canonifyValue(mapValue.fields[key])}`;\r\n    }\r\n    return result + '}';\r\n}\r\nfunction canonifyArray(arrayValue) {\r\n    let result = '[';\r\n    let first = true;\r\n    for (const value of arrayValue.values || []) {\r\n        if (!first) {\r\n            result += ',';\r\n        }\r\n        else {\r\n            first = false;\r\n        }\r\n        result += canonifyValue(value);\r\n    }\r\n    return result + ']';\r\n}\r\n/** Returns a reference value for the provided database and key. */\r\nfunction refValue(databaseId, key) {\r\n    return {\r\n        referenceValue: `projects/${databaseId.projectId}/databases/${databaseId.database}/documents/${key.path.canonicalString()}`\r\n    };\r\n}\r\n/** Returns true if `value` is an IntegerValue . */\r\nfunction isInteger(value) {\r\n    return !!value && 'integerValue' in value;\r\n}\r\n/** Returns true if `value` is a DoubleValue. */\r\nfunction isDouble(value) {\r\n    return !!value && 'doubleValue' in value;\r\n}\r\n/** Returns true if `value` is either an IntegerValue or a DoubleValue. */\r\nfunction isNumber(value) {\r\n    return isInteger(value) || isDouble(value);\r\n}\r\n/** Returns true if `value` is an ArrayValue. */\r\nfunction isArray(value) {\r\n    return !!value && 'arrayValue' in value;\r\n}\r\n/** Returns true if `value` is a NullValue. */\r\nfunction isNullValue(value) {\r\n    return !!value && 'nullValue' in value;\r\n}\r\n/** Returns true if `value` is NaN. */\r\nfunction isNanValue(value) {\r\n    return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));\r\n}\r\n/** Returns true if `value` is a MapValue. */\r\nfunction isMapValue(value) {\r\n    return !!value && 'mapValue' in value;\r\n}\r\n/** Creates a deep copy of `source`. */\r\nfunction deepClone(source) {\r\n    if (source.geoPointValue) {\r\n        return { geoPointValue: Object.assign({}, source.geoPointValue) };\r\n    }\r\n    else if (source.timestampValue &&\r\n        typeof source.timestampValue === 'object') {\r\n        return { timestampValue: Object.assign({}, source.timestampValue) };\r\n    }\r\n    else if (source.mapValue) {\r\n        const target = { mapValue: { fields: {} } };\r\n        forEach(source.mapValue.fields, (key, val) => (target.mapValue.fields[key] = deepClone(val)));\r\n        return target;\r\n    }\r\n    else if (source.arrayValue) {\r\n        const target = { arrayValue: { values: [] } };\r\n        for (let i = 0; i < (source.arrayValue.values || []).length; ++i) {\r\n            target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);\r\n        }\r\n        return target;\r\n    }\r\n    else {\r\n        return Object.assign({}, source);\r\n    }\r\n}\r\n/** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */\r\nfunction isMaxValue(value) {\r\n    return valueEquals(value, MAX_VALUE);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\r\n * ability to add and remove fields (via the ObjectValueBuilder).\r\n */\r\nclass ObjectValue {\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n    static empty() {\r\n        return new ObjectValue({ mapValue: {} });\r\n    }\r\n    /**\r\n     * Returns the value at the given path or null.\r\n     *\r\n     * @param path - the path to search\r\n     * @returns The value at the path or null if the path is not set.\r\n     */\r\n    field(path) {\r\n        if (path.isEmpty()) {\r\n            return this.value;\r\n        }\r\n        else {\r\n            let currentLevel = this.value;\r\n            for (let i = 0; i < path.length - 1; ++i) {\r\n                currentLevel = (currentLevel.mapValue.fields || {})[path.get(i)];\r\n                if (!isMapValue(currentLevel)) {\r\n                    return null;\r\n                }\r\n            }\r\n            currentLevel = (currentLevel.mapValue.fields || {})[path.lastSegment()];\r\n            return currentLevel || null;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the field to the provided value.\r\n     *\r\n     * @param path - The field path to set.\r\n     * @param value - The value to set.\r\n     */\r\n    set(path, value) {\r\n        const fieldsMap = this.getFieldsMap(path.popLast());\r\n        fieldsMap[path.lastSegment()] = deepClone(value);\r\n    }\r\n    /**\r\n     * Sets the provided fields to the provided values.\r\n     *\r\n     * @param data - A map of fields to values (or null for deletes).\r\n     */\r\n    setAll(data) {\r\n        let parent = FieldPath$1.emptyPath();\r\n        let upserts = {};\r\n        let deletes = [];\r\n        data.forEach((value, path) => {\r\n            if (!parent.isImmediateParentOf(path)) {\r\n                // Insert the accumulated changes at this parent location\r\n                const fieldsMap = this.getFieldsMap(parent);\r\n                this.applyChanges(fieldsMap, upserts, deletes);\r\n                upserts = {};\r\n                deletes = [];\r\n                parent = path.popLast();\r\n            }\r\n            if (value) {\r\n                upserts[path.lastSegment()] = deepClone(value);\r\n            }\r\n            else {\r\n                deletes.push(path.lastSegment());\r\n            }\r\n        });\r\n        const fieldsMap = this.getFieldsMap(parent);\r\n        this.applyChanges(fieldsMap, upserts, deletes);\r\n    }\r\n    /**\r\n     * Removes the field at the specified path. If there is no field at the\r\n     * specified path, nothing is changed.\r\n     *\r\n     * @param path - The field path to remove.\r\n     */\r\n    delete(path) {\r\n        const nestedValue = this.field(path.popLast());\r\n        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {\r\n            delete nestedValue.mapValue.fields[path.lastSegment()];\r\n        }\r\n    }\r\n    isEqual(other) {\r\n        return valueEquals(this.value, other.value);\r\n    }\r\n    /**\r\n     * Returns the map that contains the leaf element of `path`. If the parent\r\n     * entry does not yet exist, or if it is not a map, a new map will be created.\r\n     */\r\n    getFieldsMap(path) {\r\n        let current = this.value;\r\n        if (!current.mapValue.fields) {\r\n            current.mapValue = { fields: {} };\r\n        }\r\n        for (let i = 0; i < path.length; ++i) {\r\n            let next = current.mapValue.fields[path.get(i)];\r\n            if (!isMapValue(next) || !next.mapValue.fields) {\r\n                next = { mapValue: { fields: {} } };\r\n                current.mapValue.fields[path.get(i)] = next;\r\n            }\r\n            current = next;\r\n        }\r\n        return current.mapValue.fields;\r\n    }\r\n    /**\r\n     * Modifies `fieldsMap` by adding, replacing or deleting the specified\r\n     * entries.\r\n     */\r\n    applyChanges(fieldsMap, inserts, deletes) {\r\n        forEach(inserts, (key, val) => (fieldsMap[key] = val));\r\n        for (const field of deletes) {\r\n            delete fieldsMap[field];\r\n        }\r\n    }\r\n    clone() {\r\n        return new ObjectValue(deepClone(this.value));\r\n    }\r\n}\r\n/**\r\n * Returns a FieldMask built from all fields in a MapValue.\r\n */\r\nfunction extractFieldMask(value) {\r\n    const fields = [];\r\n    forEach(value.fields, (key, value) => {\r\n        const currentPath = new FieldPath$1([key]);\r\n        if (isMapValue(value)) {\r\n            const nestedMask = extractFieldMask(value.mapValue);\r\n            const nestedFields = nestedMask.fields;\r\n            if (nestedFields.length === 0) {\r\n                // Preserve the empty map by adding it to the FieldMask.\r\n                fields.push(currentPath);\r\n            }\r\n            else {\r\n                // For nested and non-empty ObjectValues, add the FieldPath of the\r\n                // leaf nodes.\r\n                for (const nestedPath of nestedFields) {\r\n                    fields.push(currentPath.child(nestedPath));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // For nested and non-empty ObjectValues, add the FieldPath of the leaf\r\n            // nodes.\r\n            fields.push(currentPath);\r\n        }\r\n    });\r\n    return new FieldMask(fields);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a document in Firestore with a key, version, data and whether it\r\n * has local mutations applied to it.\r\n *\r\n * Documents can transition between states via `convertToFoundDocument()`,\r\n * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does\r\n * not transition to one of these states even after all mutations have been\r\n * applied, `isValidDocument()` returns false and the document should be removed\r\n * from all views.\r\n */\r\nclass MutableDocument {\r\n    constructor(key, documentType, version, readTime, data, documentState) {\r\n        this.key = key;\r\n        this.documentType = documentType;\r\n        this.version = version;\r\n        this.readTime = readTime;\r\n        this.data = data;\r\n        this.documentState = documentState;\r\n    }\r\n    /**\r\n     * Creates a document with no known version or data, but which can serve as\r\n     * base document for mutations.\r\n     */\r\n    static newInvalidDocument(documentKey) {\r\n        return new MutableDocument(documentKey, 0 /* INVALID */, SnapshotVersion.min(), SnapshotVersion.min(), ObjectValue.empty(), 0 /* SYNCED */);\r\n    }\r\n    /**\r\n     * Creates a new document that is known to exist with the given data at the\r\n     * given version.\r\n     */\r\n    static newFoundDocument(documentKey, version, value) {\r\n        return new MutableDocument(documentKey, 1 /* FOUND_DOCUMENT */, version, SnapshotVersion.min(), value, 0 /* SYNCED */);\r\n    }\r\n    /** Creates a new document that is known to not exist at the given version. */\r\n    static newNoDocument(documentKey, version) {\r\n        return new MutableDocument(documentKey, 2 /* NO_DOCUMENT */, version, SnapshotVersion.min(), ObjectValue.empty(), 0 /* SYNCED */);\r\n    }\r\n    /**\r\n     * Creates a new document that is known to exist at the given version but\r\n     * whose data is not known (e.g. a document that was updated without a known\r\n     * base document).\r\n     */\r\n    static newUnknownDocument(documentKey, version) {\r\n        return new MutableDocument(documentKey, 3 /* UNKNOWN_DOCUMENT */, version, SnapshotVersion.min(), ObjectValue.empty(), 2 /* HAS_COMMITTED_MUTATIONS */);\r\n    }\r\n    /**\r\n     * Changes the document type to indicate that it exists and that its version\r\n     * and data are known.\r\n     */\r\n    convertToFoundDocument(version, value) {\r\n        this.version = version;\r\n        this.documentType = 1 /* FOUND_DOCUMENT */;\r\n        this.data = value;\r\n        this.documentState = 0 /* SYNCED */;\r\n        return this;\r\n    }\r\n    /**\r\n     * Changes the document type to indicate that it doesn't exist at the given\r\n     * version.\r\n     */\r\n    convertToNoDocument(version) {\r\n        this.version = version;\r\n        this.documentType = 2 /* NO_DOCUMENT */;\r\n        this.data = ObjectValue.empty();\r\n        this.documentState = 0 /* SYNCED */;\r\n        return this;\r\n    }\r\n    /**\r\n     * Changes the document type to indicate that it exists at a given version but\r\n     * that its data is not known (e.g. a document that was updated without a known\r\n     * base document).\r\n     */\r\n    convertToUnknownDocument(version) {\r\n        this.version = version;\r\n        this.documentType = 3 /* UNKNOWN_DOCUMENT */;\r\n        this.data = ObjectValue.empty();\r\n        this.documentState = 2 /* HAS_COMMITTED_MUTATIONS */;\r\n        return this;\r\n    }\r\n    setHasCommittedMutations() {\r\n        this.documentState = 2 /* HAS_COMMITTED_MUTATIONS */;\r\n        return this;\r\n    }\r\n    setHasLocalMutations() {\r\n        this.documentState = 1 /* HAS_LOCAL_MUTATIONS */;\r\n        return this;\r\n    }\r\n    setReadTime(readTime) {\r\n        this.readTime = readTime;\r\n        return this;\r\n    }\r\n    get hasLocalMutations() {\r\n        return this.documentState === 1 /* HAS_LOCAL_MUTATIONS */;\r\n    }\r\n    get hasCommittedMutations() {\r\n        return this.documentState === 2 /* HAS_COMMITTED_MUTATIONS */;\r\n    }\r\n    get hasPendingWrites() {\r\n        return this.hasLocalMutations || this.hasCommittedMutations;\r\n    }\r\n    isValidDocument() {\r\n        return this.documentType !== 0 /* INVALID */;\r\n    }\r\n    isFoundDocument() {\r\n        return this.documentType === 1 /* FOUND_DOCUMENT */;\r\n    }\r\n    isNoDocument() {\r\n        return this.documentType === 2 /* NO_DOCUMENT */;\r\n    }\r\n    isUnknownDocument() {\r\n        return this.documentType === 3 /* UNKNOWN_DOCUMENT */;\r\n    }\r\n    isEqual(other) {\r\n        return (other instanceof MutableDocument &&\r\n            this.key.isEqual(other.key) &&\r\n            this.version.isEqual(other.version) &&\r\n            this.documentType === other.documentType &&\r\n            this.documentState === other.documentState &&\r\n            this.data.isEqual(other.data));\r\n    }\r\n    mutableCopy() {\r\n        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);\r\n    }\r\n    toString() {\r\n        return (`Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, ` +\r\n            `{documentType: ${this.documentType}}), ` +\r\n            `{documentState: ${this.documentState}})`);\r\n    }\r\n}\r\n/**\r\n * Compares the value for field `field` in the provided documents. Throws if\r\n * the field does not exist in both documents.\r\n */\r\nfunction compareDocumentsByField(field, d1, d2) {\r\n    const v1 = d1.data.field(field);\r\n    const v2 = d2.data.field(field);\r\n    if (v1 !== null && v2 !== null) {\r\n        return valueCompare(v1, v2);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The initial mutation batch id for each index. Gets updated during index\r\n * backfill.\r\n */\r\nconst INITIAL_LARGEST_BATCH_ID = -1;\r\n/**\r\n * The initial sequence number for each index. Gets updated during index\r\n * backfill.\r\n */\r\nconst INITIAL_SEQUENCE_NUMBER = 0;\r\n/**\r\n * An index definition for field indexes in Firestore.\r\n *\r\n * Every index is associated with a collection. The definition contains a list\r\n * of fields and their index kind (which can be `ASCENDING`, `DESCENDING` or\r\n * `CONTAINS` for ArrayContains/ArrayContainsAny queries).\r\n *\r\n * Unlike the backend, the SDK does not differentiate between collection or\r\n * collection group-scoped indices. Every index can be used for both single\r\n * collection and collection group queries.\r\n */\r\nclass FieldIndex {\r\n    constructor(\r\n    /**\r\n     * The index ID. Returns -1 if the index ID is not available (e.g. the index\r\n     * has not yet been persisted).\r\n     */\r\n    indexId, \r\n    /** The collection ID this index applies to. */\r\n    collectionGroup, \r\n    /** The field segments for this index. */\r\n    fields, \r\n    /** Shows how up-to-date the index is for the current user. */\r\n    indexState) {\r\n        this.indexId = indexId;\r\n        this.collectionGroup = collectionGroup;\r\n        this.fields = fields;\r\n        this.indexState = indexState;\r\n    }\r\n}\r\n/** An ID for an index that has not yet been added to persistence.  */\r\nFieldIndex.UNKNOWN_ID = -1;\r\n/** Returns the ArrayContains/ArrayContainsAny segment for this index. */\r\nfunction fieldIndexGetArraySegment(fieldIndex) {\r\n    return fieldIndex.fields.find(s => s.kind === 2 /* CONTAINS */);\r\n}\r\n/** Returns all directional (ascending/descending) segments for this index. */\r\nfunction fieldIndexGetDirectionalSegments(fieldIndex) {\r\n    return fieldIndex.fields.filter(s => s.kind !== 2 /* CONTAINS */);\r\n}\r\n/** An index component consisting of field path and index type.  */\r\nclass IndexSegment {\r\n    constructor(\r\n    /** The field path of the component. */\r\n    fieldPath, \r\n    /** The fields sorting order. */\r\n    kind) {\r\n        this.fieldPath = fieldPath;\r\n        this.kind = kind;\r\n    }\r\n}\r\n/**\r\n * Stores the \"high water mark\" that indicates how updated the Index is for the\r\n * current user.\r\n */\r\nclass IndexState {\r\n    constructor(\r\n    /**\r\n     * Indicates when the index was last updated (relative to other indexes).\r\n     */\r\n    sequenceNumber, \r\n    /** The the latest indexed read time, document and batch id. */\r\n    offset) {\r\n        this.sequenceNumber = sequenceNumber;\r\n        this.offset = offset;\r\n    }\r\n    /** The state of an index that has not yet been backfilled. */\r\n    static empty() {\r\n        return new IndexState(INITIAL_SEQUENCE_NUMBER, IndexOffset.min());\r\n    }\r\n}\r\n/**\r\n * Stores the latest read time, document and batch ID that were processed for an\r\n * index.\r\n */\r\nclass IndexOffset {\r\n    constructor(\r\n    /**\r\n     * The latest read time version that has been indexed by Firestore for this\r\n     * field index.\r\n     */\r\n    readTime, \r\n    /**\r\n     * The key of the last document that was indexed for this query. Use\r\n     * `DocumentKey.empty()` if no document has been indexed.\r\n     */\r\n    documentKey, \r\n    /*\r\n     * The largest mutation batch id that's been processed by Firestore.\r\n     */\r\n    largestBatchId) {\r\n        this.readTime = readTime;\r\n        this.documentKey = documentKey;\r\n        this.largestBatchId = largestBatchId;\r\n    }\r\n    /** The state of an index that has not yet been backfilled. */\r\n    static min() {\r\n        return new IndexOffset(SnapshotVersion.min(), DocumentKey.empty(), INITIAL_LARGEST_BATCH_ID);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Visible for testing\r\nclass TargetImpl {\r\n    constructor(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\r\n        this.path = path;\r\n        this.collectionGroup = collectionGroup;\r\n        this.orderBy = orderBy;\r\n        this.filters = filters;\r\n        this.limit = limit;\r\n        this.startAt = startAt;\r\n        this.endAt = endAt;\r\n        this.memoizedCanonicalId = null;\r\n    }\r\n}\r\n/**\r\n * Initializes a Target with a path and optional additional query constraints.\r\n * Path must currently be empty if this is a collection group query.\r\n *\r\n * NOTE: you should always construct `Target` from `Query.toTarget` instead of\r\n * using this factory method, because `Query` provides an implicit `orderBy`\r\n * property.\r\n */\r\nfunction newTarget(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) {\r\n    return new TargetImpl(path, collectionGroup, orderBy, filters, limit, startAt, endAt);\r\n}\r\nfunction canonifyTarget(target) {\r\n    const targetImpl = debugCast(target);\r\n    if (targetImpl.memoizedCanonicalId === null) {\r\n        let str = targetImpl.path.canonicalString();\r\n        if (targetImpl.collectionGroup !== null) {\r\n            str += '|cg:' + targetImpl.collectionGroup;\r\n        }\r\n        str += '|f:';\r\n        str += targetImpl.filters.map(f => canonifyFilter(f)).join(',');\r\n        str += '|ob:';\r\n        str += targetImpl.orderBy.map(o => canonifyOrderBy(o)).join(',');\r\n        if (!isNullOrUndefined(targetImpl.limit)) {\r\n            str += '|l:';\r\n            str += targetImpl.limit;\r\n        }\r\n        if (targetImpl.startAt) {\r\n            str += '|lb:';\r\n            str += targetImpl.startAt.inclusive ? 'b:' : 'a:';\r\n            str += targetImpl.startAt.position.map(p => canonicalId(p)).join(',');\r\n        }\r\n        if (targetImpl.endAt) {\r\n            str += '|ub:';\r\n            str += targetImpl.endAt.inclusive ? 'a:' : 'b:';\r\n            str += targetImpl.endAt.position.map(p => canonicalId(p)).join(',');\r\n        }\r\n        targetImpl.memoizedCanonicalId = str;\r\n    }\r\n    return targetImpl.memoizedCanonicalId;\r\n}\r\nfunction stringifyTarget(target) {\r\n    let str = target.path.canonicalString();\r\n    if (target.collectionGroup !== null) {\r\n        str += ' collectionGroup=' + target.collectionGroup;\r\n    }\r\n    if (target.filters.length > 0) {\r\n        str += `, filters: [${target.filters\r\n            .map(f => stringifyFilter(f))\r\n            .join(', ')}]`;\r\n    }\r\n    if (!isNullOrUndefined(target.limit)) {\r\n        str += ', limit: ' + target.limit;\r\n    }\r\n    if (target.orderBy.length > 0) {\r\n        str += `, orderBy: [${target.orderBy\r\n            .map(o => stringifyOrderBy(o))\r\n            .join(', ')}]`;\r\n    }\r\n    if (target.startAt) {\r\n        str += ', startAt: ';\r\n        str += target.startAt.inclusive ? 'b:' : 'a:';\r\n        str += target.startAt.position.map(p => canonicalId(p)).join(',');\r\n    }\r\n    if (target.endAt) {\r\n        str += ', endAt: ';\r\n        str += target.endAt.inclusive ? 'a:' : 'b:';\r\n        str += target.endAt.position.map(p => canonicalId(p)).join(',');\r\n    }\r\n    return `Target(${str})`;\r\n}\r\nfunction targetEquals(left, right) {\r\n    if (left.limit !== right.limit) {\r\n        return false;\r\n    }\r\n    if (left.orderBy.length !== right.orderBy.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < left.orderBy.length; i++) {\r\n        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    if (left.filters.length !== right.filters.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < left.filters.length; i++) {\r\n        if (!filterEquals(left.filters[i], right.filters[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    if (left.collectionGroup !== right.collectionGroup) {\r\n        return false;\r\n    }\r\n    if (!left.path.isEqual(right.path)) {\r\n        return false;\r\n    }\r\n    if (!boundEquals(left.startAt, right.startAt)) {\r\n        return false;\r\n    }\r\n    return boundEquals(left.endAt, right.endAt);\r\n}\r\nfunction targetIsDocumentTarget(target) {\r\n    return (DocumentKey.isDocumentKey(target.path) &&\r\n        target.collectionGroup === null &&\r\n        target.filters.length === 0);\r\n}\r\nclass Filter {\r\n}\r\nclass FieldFilter extends Filter {\r\n    constructor(field, op, value) {\r\n        super();\r\n        this.field = field;\r\n        this.op = op;\r\n        this.value = value;\r\n    }\r\n    /**\r\n     * Creates a filter based on the provided arguments.\r\n     */\r\n    static create(field, op, value) {\r\n        if (field.isKeyField()) {\r\n            if (op === \"in\" /* IN */ || op === \"not-in\" /* NOT_IN */) {\r\n                return this.createKeyFieldInFilter(field, op, value);\r\n            }\r\n            else {\r\n                return new KeyFieldFilter(field, op, value);\r\n            }\r\n        }\r\n        else if (op === \"array-contains\" /* ARRAY_CONTAINS */) {\r\n            return new ArrayContainsFilter(field, value);\r\n        }\r\n        else if (op === \"in\" /* IN */) {\r\n            return new InFilter(field, value);\r\n        }\r\n        else if (op === \"not-in\" /* NOT_IN */) {\r\n            return new NotInFilter(field, value);\r\n        }\r\n        else if (op === \"array-contains-any\" /* ARRAY_CONTAINS_ANY */) {\r\n            return new ArrayContainsAnyFilter(field, value);\r\n        }\r\n        else {\r\n            return new FieldFilter(field, op, value);\r\n        }\r\n    }\r\n    static createKeyFieldInFilter(field, op, value) {\r\n        return op === \"in\" /* IN */\r\n            ? new KeyFieldInFilter(field, value)\r\n            : new KeyFieldNotInFilter(field, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        // Types do not have to match in NOT_EQUAL filters.\r\n        if (this.op === \"!=\" /* NOT_EQUAL */) {\r\n            return (other !== null &&\r\n                this.matchesComparison(valueCompare(other, this.value)));\r\n        }\r\n        // Only compare types with matching backend order (such as double and int).\r\n        return (other !== null &&\r\n            typeOrder(this.value) === typeOrder(other) &&\r\n            this.matchesComparison(valueCompare(other, this.value)));\r\n    }\r\n    matchesComparison(comparison) {\r\n        switch (this.op) {\r\n            case \"<\" /* LESS_THAN */:\r\n                return comparison < 0;\r\n            case \"<=\" /* LESS_THAN_OR_EQUAL */:\r\n                return comparison <= 0;\r\n            case \"==\" /* EQUAL */:\r\n                return comparison === 0;\r\n            case \"!=\" /* NOT_EQUAL */:\r\n                return comparison !== 0;\r\n            case \">\" /* GREATER_THAN */:\r\n                return comparison > 0;\r\n            case \">=\" /* GREATER_THAN_OR_EQUAL */:\r\n                return comparison >= 0;\r\n            default:\r\n                return fail();\r\n        }\r\n    }\r\n    isInequality() {\r\n        return ([\r\n            \"<\" /* LESS_THAN */,\r\n            \"<=\" /* LESS_THAN_OR_EQUAL */,\r\n            \">\" /* GREATER_THAN */,\r\n            \">=\" /* GREATER_THAN_OR_EQUAL */,\r\n            \"!=\" /* NOT_EQUAL */,\r\n            \"not-in\" /* NOT_IN */\r\n        ].indexOf(this.op) >= 0);\r\n    }\r\n}\r\nfunction canonifyFilter(filter) {\r\n    // TODO(b/29183165): Technically, this won't be unique if two values have\r\n    // the same description, such as the int 3 and the string \"3\". So we should\r\n    // add the types in here somehow, too.\r\n    return (filter.field.canonicalString() +\r\n        filter.op.toString() +\r\n        canonicalId(filter.value));\r\n}\r\nfunction filterEquals(f1, f2) {\r\n    return (f1.op === f2.op &&\r\n        f1.field.isEqual(f2.field) &&\r\n        valueEquals(f1.value, f2.value));\r\n}\r\n/** Returns a debug description for `filter`. */\r\nfunction stringifyFilter(filter) {\r\n    return `${filter.field.canonicalString()} ${filter.op} ${canonicalId(filter.value)}`;\r\n}\r\n/** Filter that matches on key fields (i.e. '__name__'). */\r\nclass KeyFieldFilter extends FieldFilter {\r\n    constructor(field, op, value) {\r\n        super(field, op, value);\r\n        this.key = DocumentKey.fromName(value.referenceValue);\r\n    }\r\n    matches(doc) {\r\n        const comparison = DocumentKey.comparator(doc.key, this.key);\r\n        return this.matchesComparison(comparison);\r\n    }\r\n}\r\n/** Filter that matches on key fields within an array. */\r\nclass KeyFieldInFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"in\" /* IN */, value);\r\n        this.keys = extractDocumentKeysFromArrayValue(\"in\" /* IN */, value);\r\n    }\r\n    matches(doc) {\r\n        return this.keys.some(key => key.isEqual(doc.key));\r\n    }\r\n}\r\n/** Filter that matches on key fields not present within an array. */\r\nclass KeyFieldNotInFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"not-in\" /* NOT_IN */, value);\r\n        this.keys = extractDocumentKeysFromArrayValue(\"not-in\" /* NOT_IN */, value);\r\n    }\r\n    matches(doc) {\r\n        return !this.keys.some(key => key.isEqual(doc.key));\r\n    }\r\n}\r\nfunction extractDocumentKeysFromArrayValue(op, value) {\r\n    var _a;\r\n    return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(v => {\r\n        return DocumentKey.fromName(v.referenceValue);\r\n    });\r\n}\r\n/** A Filter that implements the array-contains operator. */\r\nclass ArrayContainsFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"array-contains\" /* ARRAY_CONTAINS */, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        return isArray(other) && arrayValueContains(other.arrayValue, this.value);\r\n    }\r\n}\r\n/** A Filter that implements the IN operator. */\r\nclass InFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"in\" /* IN */, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        return other !== null && arrayValueContains(this.value.arrayValue, other);\r\n    }\r\n}\r\n/** A Filter that implements the not-in operator. */\r\nclass NotInFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"not-in\" /* NOT_IN */, value);\r\n    }\r\n    matches(doc) {\r\n        if (arrayValueContains(this.value.arrayValue, { nullValue: 'NULL_VALUE' })) {\r\n            return false;\r\n        }\r\n        const other = doc.data.field(this.field);\r\n        return other !== null && !arrayValueContains(this.value.arrayValue, other);\r\n    }\r\n}\r\n/** A Filter that implements the array-contains-any operator. */\r\nclass ArrayContainsAnyFilter extends FieldFilter {\r\n    constructor(field, value) {\r\n        super(field, \"array-contains-any\" /* ARRAY_CONTAINS_ANY */, value);\r\n    }\r\n    matches(doc) {\r\n        const other = doc.data.field(this.field);\r\n        if (!isArray(other) || !other.arrayValue.values) {\r\n            return false;\r\n        }\r\n        return other.arrayValue.values.some(val => arrayValueContains(this.value.arrayValue, val));\r\n    }\r\n}\r\n/**\r\n * Represents a bound of a query.\r\n *\r\n * The bound is specified with the given components representing a position and\r\n * whether it's just before or just after the position (relative to whatever the\r\n * query order is).\r\n *\r\n * The position represents a logical index position for a query. It's a prefix\r\n * of values for the (potentially implicit) order by clauses of a query.\r\n *\r\n * Bound provides a function to determine whether a document comes before or\r\n * after a bound. This is influenced by whether the position is just before or\r\n * just after the provided values.\r\n */\r\nclass Bound {\r\n    constructor(position, inclusive) {\r\n        this.position = position;\r\n        this.inclusive = inclusive;\r\n    }\r\n}\r\n/**\r\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\r\n */\r\nclass OrderBy {\r\n    constructor(field, dir = \"asc\" /* ASCENDING */) {\r\n        this.field = field;\r\n        this.dir = dir;\r\n    }\r\n}\r\nfunction canonifyOrderBy(orderBy) {\r\n    // TODO(b/29183165): Make this collision robust.\r\n    return orderBy.field.canonicalString() + orderBy.dir;\r\n}\r\nfunction stringifyOrderBy(orderBy) {\r\n    return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\r\n}\r\nfunction orderByEquals(left, right) {\r\n    return left.dir === right.dir && left.field.isEqual(right.field);\r\n}\r\nfunction boundCompareToDocument(bound, orderBy, doc) {\r\n    let comparison = 0;\r\n    for (let i = 0; i < bound.position.length; i++) {\r\n        const orderByComponent = orderBy[i];\r\n        const component = bound.position[i];\r\n        if (orderByComponent.field.isKeyField()) {\r\n            comparison = DocumentKey.comparator(DocumentKey.fromName(component.referenceValue), doc.key);\r\n        }\r\n        else {\r\n            const docValue = doc.data.field(orderByComponent.field);\r\n            comparison = valueCompare(component, docValue);\r\n        }\r\n        if (orderByComponent.dir === \"desc\" /* DESCENDING */) {\r\n            comparison = comparison * -1;\r\n        }\r\n        if (comparison !== 0) {\r\n            break;\r\n        }\r\n    }\r\n    return comparison;\r\n}\r\n/**\r\n * Returns true if a document sorts after a bound using the provided sort\r\n * order.\r\n */\r\nfunction boundSortsAfterDocument(bound, orderBy, doc) {\r\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\r\n    return bound.inclusive ? comparison >= 0 : comparison > 0;\r\n}\r\n/**\r\n * Returns true if a document sorts before a bound using the provided sort\r\n * order.\r\n */\r\nfunction boundSortsBeforeDocument(bound, orderBy, doc) {\r\n    const comparison = boundCompareToDocument(bound, orderBy, doc);\r\n    return bound.inclusive ? comparison <= 0 : comparison < 0;\r\n}\r\nfunction boundEquals(left, right) {\r\n    if (left === null) {\r\n        return right === null;\r\n    }\r\n    else if (right === null) {\r\n        return false;\r\n    }\r\n    if (left.inclusive !== right.inclusive ||\r\n        left.position.length !== right.position.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < left.position.length; i++) {\r\n        const leftPosition = left.position[i];\r\n        const rightPosition = right.position[i];\r\n        if (!valueEquals(leftPosition, rightPosition)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Query encapsulates all the query attributes we support in the SDK. It can\r\n * be run against the LocalStore, as well as be converted to a `Target` to\r\n * query the RemoteStore results.\r\n *\r\n * Visible for testing.\r\n */\r\nclass QueryImpl {\r\n    /**\r\n     * Initializes a Query with a path and optional additional query constraints.\r\n     * Path must currently be empty if this is a collection group query.\r\n     */\r\n    constructor(path, collectionGroup = null, explicitOrderBy = [], filters = [], limit = null, limitType = \"F\" /* First */, startAt = null, endAt = null) {\r\n        this.path = path;\r\n        this.collectionGroup = collectionGroup;\r\n        this.explicitOrderBy = explicitOrderBy;\r\n        this.filters = filters;\r\n        this.limit = limit;\r\n        this.limitType = limitType;\r\n        this.startAt = startAt;\r\n        this.endAt = endAt;\r\n        this.memoizedOrderBy = null;\r\n        // The corresponding `Target` of this `Query` instance.\r\n        this.memoizedTarget = null;\r\n        if (this.startAt) ;\r\n        if (this.endAt) ;\r\n    }\r\n}\r\n/** Creates a new Query instance with the options provided. */\r\nfunction newQuery(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt) {\r\n    return new QueryImpl(path, collectionGroup, explicitOrderBy, filters, limit, limitType, startAt, endAt);\r\n}\r\n/** Creates a new Query for a query that matches all documents at `path` */\r\nfunction newQueryForPath(path) {\r\n    return new QueryImpl(path);\r\n}\r\n/**\r\n * Helper to convert a collection group query into a collection query at a\r\n * specific path. This is used when executing collection group queries, since\r\n * we have to split the query into a set of collection queries at multiple\r\n * paths.\r\n */\r\nfunction asCollectionQueryAtPath(query, path) {\r\n    return new QueryImpl(path, \r\n    /*collectionGroup=*/ null, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\r\n}\r\n/**\r\n * Returns true if this query does not specify any query constraints that\r\n * could remove results.\r\n */\r\nfunction matchesAllDocuments(query) {\r\n    return (query.filters.length === 0 &&\r\n        query.limit === null &&\r\n        query.startAt == null &&\r\n        query.endAt == null &&\r\n        (query.explicitOrderBy.length === 0 ||\r\n            (query.explicitOrderBy.length === 1 &&\r\n                query.explicitOrderBy[0].field.isKeyField())));\r\n}\r\nfunction hasLimitToFirst(query) {\r\n    return !isNullOrUndefined(query.limit) && query.limitType === \"F\" /* First */;\r\n}\r\nfunction hasLimitToLast(query) {\r\n    return !isNullOrUndefined(query.limit) && query.limitType === \"L\" /* Last */;\r\n}\r\nfunction getFirstOrderByField(query) {\r\n    return query.explicitOrderBy.length > 0\r\n        ? query.explicitOrderBy[0].field\r\n        : null;\r\n}\r\nfunction getInequalityFilterField(query) {\r\n    for (const filter of query.filters) {\r\n        if (filter.isInequality()) {\r\n            return filter.field;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Checks if any of the provided Operators are included in the query and\r\n * returns the first one that is, or null if none are.\r\n */\r\nfunction findFilterOperator(query, operators) {\r\n    for (const filter of query.filters) {\r\n        if (operators.indexOf(filter.op) >= 0) {\r\n            return filter.op;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Creates a new Query for a collection group query that matches all documents\r\n * within the provided collection group.\r\n */\r\nfunction newQueryForCollectionGroup(collectionId) {\r\n    return new QueryImpl(ResourcePath.emptyPath(), collectionId);\r\n}\r\n/**\r\n * Returns whether the query matches a single document by path (rather than a\r\n * collection).\r\n */\r\nfunction isDocumentQuery$1(query) {\r\n    return (DocumentKey.isDocumentKey(query.path) &&\r\n        query.collectionGroup === null &&\r\n        query.filters.length === 0);\r\n}\r\n/**\r\n * Returns whether the query matches a collection group rather than a specific\r\n * collection.\r\n */\r\nfunction isCollectionGroupQuery(query) {\r\n    return query.collectionGroup !== null;\r\n}\r\n/**\r\n * Returns the implicit order by constraint that is used to execute the Query,\r\n * which can be different from the order by constraints the user provided (e.g.\r\n * the SDK and backend always orders by `__name__`).\r\n */\r\nfunction queryOrderBy(query) {\r\n    const queryImpl = debugCast(query);\r\n    if (queryImpl.memoizedOrderBy === null) {\r\n        queryImpl.memoizedOrderBy = [];\r\n        const inequalityField = getInequalityFilterField(queryImpl);\r\n        const firstOrderByField = getFirstOrderByField(queryImpl);\r\n        if (inequalityField !== null && firstOrderByField === null) {\r\n            // In order to implicitly add key ordering, we must also add the\r\n            // inequality filter field for it to be a valid query.\r\n            // Note that the default inequality field and key ordering is ascending.\r\n            if (!inequalityField.isKeyField()) {\r\n                queryImpl.memoizedOrderBy.push(new OrderBy(inequalityField));\r\n            }\r\n            queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), \"asc\" /* ASCENDING */));\r\n        }\r\n        else {\r\n            let foundKeyOrdering = false;\r\n            for (const orderBy of queryImpl.explicitOrderBy) {\r\n                queryImpl.memoizedOrderBy.push(orderBy);\r\n                if (orderBy.field.isKeyField()) {\r\n                    foundKeyOrdering = true;\r\n                }\r\n            }\r\n            if (!foundKeyOrdering) {\r\n                // The order of the implicit key ordering always matches the last\r\n                // explicit order by\r\n                const lastDirection = queryImpl.explicitOrderBy.length > 0\r\n                    ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1]\r\n                        .dir\r\n                    : \"asc\" /* ASCENDING */;\r\n                queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));\r\n            }\r\n        }\r\n    }\r\n    return queryImpl.memoizedOrderBy;\r\n}\r\n/**\r\n * Converts this `Query` instance to it's corresponding `Target` representation.\r\n */\r\nfunction queryToTarget(query) {\r\n    const queryImpl = debugCast(query);\r\n    if (!queryImpl.memoizedTarget) {\r\n        if (queryImpl.limitType === \"F\" /* First */) {\r\n            queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, queryOrderBy(queryImpl), queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);\r\n        }\r\n        else {\r\n            // Flip the orderBy directions since we want the last results\r\n            const orderBys = [];\r\n            for (const orderBy of queryOrderBy(queryImpl)) {\r\n                const dir = orderBy.dir === \"desc\" /* DESCENDING */\r\n                    ? \"asc\" /* ASCENDING */\r\n                    : \"desc\" /* DESCENDING */;\r\n                orderBys.push(new OrderBy(orderBy.field, dir));\r\n            }\r\n            // We need to swap the cursors to match the now-flipped query ordering.\r\n            const startAt = queryImpl.endAt\r\n                ? new Bound(queryImpl.endAt.position, !queryImpl.endAt.inclusive)\r\n                : null;\r\n            const endAt = queryImpl.startAt\r\n                ? new Bound(queryImpl.startAt.position, !queryImpl.startAt.inclusive)\r\n                : null;\r\n            // Now return as a LimitType.First query.\r\n            queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt, endAt);\r\n        }\r\n    }\r\n    return queryImpl.memoizedTarget;\r\n}\r\nfunction queryWithAddedFilter(query, filter) {\r\n    const newFilters = query.filters.concat([filter]);\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), newFilters, query.limit, query.limitType, query.startAt, query.endAt);\r\n}\r\nfunction queryWithAddedOrderBy(query, orderBy) {\r\n    // TODO(dimond): validate that orderBy does not list the same key twice.\r\n    const newOrderBy = query.explicitOrderBy.concat([orderBy]);\r\n    return new QueryImpl(query.path, query.collectionGroup, newOrderBy, query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);\r\n}\r\nfunction queryWithLimit(query, limit, limitType) {\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), limit, limitType, query.startAt, query.endAt);\r\n}\r\nfunction queryWithStartAt(query, bound) {\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, bound, query.endAt);\r\n}\r\nfunction queryWithEndAt(query, bound) {\r\n    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, bound);\r\n}\r\nfunction queryEquals(left, right) {\r\n    return (targetEquals(queryToTarget(left), queryToTarget(right)) &&\r\n        left.limitType === right.limitType);\r\n}\r\n// TODO(b/29183165): This is used to get a unique string from a query to, for\r\n// example, use as a dictionary key, but the implementation is subject to\r\n// collisions. Make it collision-free.\r\nfunction canonifyQuery(query) {\r\n    return `${canonifyTarget(queryToTarget(query))}|lt:${query.limitType}`;\r\n}\r\nfunction stringifyQuery(query) {\r\n    return `Query(target=${stringifyTarget(queryToTarget(query))}; limitType=${query.limitType})`;\r\n}\r\n/** Returns whether `doc` matches the constraints of `query`. */\r\nfunction queryMatches(query, doc) {\r\n    return (doc.isFoundDocument() &&\r\n        queryMatchesPathAndCollectionGroup(query, doc) &&\r\n        queryMatchesOrderBy(query, doc) &&\r\n        queryMatchesFilters(query, doc) &&\r\n        queryMatchesBounds(query, doc));\r\n}\r\nfunction queryMatchesPathAndCollectionGroup(query, doc) {\r\n    const docPath = doc.key.path;\r\n    if (query.collectionGroup !== null) {\r\n        // NOTE: this.path is currently always empty since we don't expose Collection\r\n        // Group queries rooted at a document path yet.\r\n        return (doc.key.hasCollectionId(query.collectionGroup) &&\r\n            query.path.isPrefixOf(docPath));\r\n    }\r\n    else if (DocumentKey.isDocumentKey(query.path)) {\r\n        // exact match for document queries\r\n        return query.path.isEqual(docPath);\r\n    }\r\n    else {\r\n        // shallow ancestor queries by default\r\n        return query.path.isImmediateParentOf(docPath);\r\n    }\r\n}\r\n/**\r\n * A document must have a value for every ordering clause in order to show up\r\n * in the results.\r\n */\r\nfunction queryMatchesOrderBy(query, doc) {\r\n    for (const orderBy of query.explicitOrderBy) {\r\n        // order by key always matches\r\n        if (!orderBy.field.isKeyField() && doc.data.field(orderBy.field) === null) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction queryMatchesFilters(query, doc) {\r\n    for (const filter of query.filters) {\r\n        if (!filter.matches(doc)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/** Makes sure a document is within the bounds, if provided. */\r\nfunction queryMatchesBounds(query, doc) {\r\n    if (query.startAt &&\r\n        !boundSortsBeforeDocument(query.startAt, queryOrderBy(query), doc)) {\r\n        return false;\r\n    }\r\n    if (query.endAt &&\r\n        !boundSortsAfterDocument(query.endAt, queryOrderBy(query), doc)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns a new comparator function that can be used to compare two documents\r\n * based on the Query's ordering constraint.\r\n */\r\nfunction newQueryComparator(query) {\r\n    return (d1, d2) => {\r\n        let comparedOnKeyField = false;\r\n        for (const orderBy of queryOrderBy(query)) {\r\n            const comp = compareDocs(orderBy, d1, d2);\r\n            if (comp !== 0) {\r\n                return comp;\r\n            }\r\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\r\n        }\r\n        return 0;\r\n    };\r\n}\r\nfunction compareDocs(orderBy, d1, d2) {\r\n    const comparison = orderBy.field.isKeyField()\r\n        ? DocumentKey.comparator(d1.key, d2.key)\r\n        : compareDocumentsByField(orderBy.field, d1, d2);\r\n    switch (orderBy.dir) {\r\n        case \"asc\" /* ASCENDING */:\r\n            return comparison;\r\n        case \"desc\" /* DESCENDING */:\r\n            return -1 * comparison;\r\n        default:\r\n            return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n// tree.\r\nclass SortedMap {\r\n    constructor(comparator, root) {\r\n        this.comparator = comparator;\r\n        this.root = root ? root : LLRBNode.EMPTY;\r\n    }\r\n    // Returns a copy of the map, with the specified key/value added or replaced.\r\n    insert(key, value) {\r\n        return new SortedMap(this.comparator, this.root\r\n            .insert(key, value, this.comparator)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    // Returns a copy of the map, with the specified key removed.\r\n    remove(key) {\r\n        return new SortedMap(this.comparator, this.root\r\n            .remove(key, this.comparator)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    // Returns the value of the node with the given key, or null.\r\n    get(key) {\r\n        let node = this.root;\r\n        while (!node.isEmpty()) {\r\n            const cmp = this.comparator(key, node.key);\r\n            if (cmp === 0) {\r\n                return node.value;\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else if (cmp > 0) {\r\n                node = node.right;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\r\n    // exist.\r\n    indexOf(key) {\r\n        // Number of nodes that were pruned when descending right\r\n        let prunedNodes = 0;\r\n        let node = this.root;\r\n        while (!node.isEmpty()) {\r\n            const cmp = this.comparator(key, node.key);\r\n            if (cmp === 0) {\r\n                return prunedNodes + node.left.size;\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else {\r\n                // Count all nodes left of the node plus the node itself\r\n                prunedNodes += node.left.size + 1;\r\n                node = node.right;\r\n            }\r\n        }\r\n        // Node not found\r\n        return -1;\r\n    }\r\n    isEmpty() {\r\n        return this.root.isEmpty();\r\n    }\r\n    // Returns the total number of nodes in the map.\r\n    get size() {\r\n        return this.root.size;\r\n    }\r\n    // Returns the minimum key in the map.\r\n    minKey() {\r\n        return this.root.minKey();\r\n    }\r\n    // Returns the maximum key in the map.\r\n    maxKey() {\r\n        return this.root.maxKey();\r\n    }\r\n    // Traverses the map in key order and calls the specified action function\r\n    // for each key/value pair. If action returns true, traversal is aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    inorderTraversal(action) {\r\n        return this.root.inorderTraversal(action);\r\n    }\r\n    forEach(fn) {\r\n        this.inorderTraversal((k, v) => {\r\n            fn(k, v);\r\n            return false;\r\n        });\r\n    }\r\n    toString() {\r\n        const descriptions = [];\r\n        this.inorderTraversal((k, v) => {\r\n            descriptions.push(`${k}:${v}`);\r\n            return false;\r\n        });\r\n        return `{${descriptions.join(', ')}}`;\r\n    }\r\n    // Traverses the map in reverse key order and calls the specified action\r\n    // function for each key/value pair. If action returns true, traversal is\r\n    // aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    reverseTraversal(action) {\r\n        return this.root.reverseTraversal(action);\r\n    }\r\n    // Returns an iterator over the SortedMap.\r\n    getIterator() {\r\n        return new SortedMapIterator(this.root, null, this.comparator, false);\r\n    }\r\n    getIteratorFrom(key) {\r\n        return new SortedMapIterator(this.root, key, this.comparator, false);\r\n    }\r\n    getReverseIterator() {\r\n        return new SortedMapIterator(this.root, null, this.comparator, true);\r\n    }\r\n    getReverseIteratorFrom(key) {\r\n        return new SortedMapIterator(this.root, key, this.comparator, true);\r\n    }\r\n} // end SortedMap\r\n// An iterator over an LLRBNode.\r\nclass SortedMapIterator {\r\n    constructor(node, startKey, comparator, isReverse) {\r\n        this.isReverse = isReverse;\r\n        this.nodeStack = [];\r\n        let cmp = 1;\r\n        while (!node.isEmpty()) {\r\n            cmp = startKey ? comparator(node.key, startKey) : 1;\r\n            // flip the comparison if we're going in reverse\r\n            if (isReverse) {\r\n                cmp *= -1;\r\n            }\r\n            if (cmp < 0) {\r\n                // This node is less than our start key. ignore it\r\n                if (this.isReverse) {\r\n                    node = node.left;\r\n                }\r\n                else {\r\n                    node = node.right;\r\n                }\r\n            }\r\n            else if (cmp === 0) {\r\n                // This node is exactly equal to our start key. Push it on the stack,\r\n                // but stop iterating;\r\n                this.nodeStack.push(node);\r\n                break;\r\n            }\r\n            else {\r\n                // This node is greater than our start key, add it to the stack and move\r\n                // to the next one\r\n                this.nodeStack.push(node);\r\n                if (this.isReverse) {\r\n                    node = node.right;\r\n                }\r\n                else {\r\n                    node = node.left;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getNext() {\r\n        let node = this.nodeStack.pop();\r\n        const result = { key: node.key, value: node.value };\r\n        if (this.isReverse) {\r\n            node = node.left;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack.push(node);\r\n                node = node.right;\r\n            }\r\n        }\r\n        else {\r\n            node = node.right;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack.push(node);\r\n                node = node.left;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    hasNext() {\r\n        return this.nodeStack.length > 0;\r\n    }\r\n    peek() {\r\n        if (this.nodeStack.length === 0) {\r\n            return null;\r\n        }\r\n        const node = this.nodeStack[this.nodeStack.length - 1];\r\n        return { key: node.key, value: node.value };\r\n    }\r\n} // end SortedMapIterator\r\n// Represents a node in a Left-leaning Red-Black tree.\r\nclass LLRBNode {\r\n    constructor(key, value, color, left, right) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.color = color != null ? color : LLRBNode.RED;\r\n        this.left = left != null ? left : LLRBNode.EMPTY;\r\n        this.right = right != null ? right : LLRBNode.EMPTY;\r\n        this.size = this.left.size + 1 + this.right.size;\r\n    }\r\n    // Returns a copy of the current node, optionally replacing pieces of it.\r\n    copy(key, value, color, left, right) {\r\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\r\n    }\r\n    isEmpty() {\r\n        return false;\r\n    }\r\n    // Traverses the tree in key order and calls the specified action function\r\n    // for each node. If action returns true, traversal is aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    inorderTraversal(action) {\r\n        return (this.left.inorderTraversal(action) ||\r\n            action(this.key, this.value) ||\r\n            this.right.inorderTraversal(action));\r\n    }\r\n    // Traverses the tree in reverse key order and calls the specified action\r\n    // function for each node. If action returns true, traversal is aborted.\r\n    // Returns the first truthy value returned by action, or the last falsey\r\n    // value returned by action.\r\n    reverseTraversal(action) {\r\n        return (this.right.reverseTraversal(action) ||\r\n            action(this.key, this.value) ||\r\n            this.left.reverseTraversal(action));\r\n    }\r\n    // Returns the minimum node in the tree.\r\n    min() {\r\n        if (this.left.isEmpty()) {\r\n            return this;\r\n        }\r\n        else {\r\n            return this.left.min();\r\n        }\r\n    }\r\n    // Returns the maximum key in the tree.\r\n    minKey() {\r\n        return this.min().key;\r\n    }\r\n    // Returns the maximum key in the tree.\r\n    maxKey() {\r\n        if (this.right.isEmpty()) {\r\n            return this.key;\r\n        }\r\n        else {\r\n            return this.right.maxKey();\r\n        }\r\n    }\r\n    // Returns new tree, with the key/value added.\r\n    insert(key, value, comparator) {\r\n        let n = this;\r\n        const cmp = comparator(key, n.key);\r\n        if (cmp < 0) {\r\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\r\n        }\r\n        else if (cmp === 0) {\r\n            n = n.copy(null, value, null, null, null);\r\n        }\r\n        else {\r\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\r\n        }\r\n        return n.fixUp();\r\n    }\r\n    removeMin() {\r\n        if (this.left.isEmpty()) {\r\n            return LLRBNode.EMPTY;\r\n        }\r\n        let n = this;\r\n        if (!n.left.isRed() && !n.left.left.isRed()) {\r\n            n = n.moveRedLeft();\r\n        }\r\n        n = n.copy(null, null, null, n.left.removeMin(), null);\r\n        return n.fixUp();\r\n    }\r\n    // Returns new tree, with the specified item removed.\r\n    remove(key, comparator) {\r\n        let smallest;\r\n        let n = this;\r\n        if (comparator(key, n.key) < 0) {\r\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\r\n                n = n.moveRedLeft();\r\n            }\r\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\r\n        }\r\n        else {\r\n            if (n.left.isRed()) {\r\n                n = n.rotateRight();\r\n            }\r\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\r\n                n = n.moveRedRight();\r\n            }\r\n            if (comparator(key, n.key) === 0) {\r\n                if (n.right.isEmpty()) {\r\n                    return LLRBNode.EMPTY;\r\n                }\r\n                else {\r\n                    smallest = n.right.min();\r\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\r\n                }\r\n            }\r\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\r\n        }\r\n        return n.fixUp();\r\n    }\r\n    isRed() {\r\n        return this.color;\r\n    }\r\n    // Returns new tree after performing any needed rotations.\r\n    fixUp() {\r\n        let n = this;\r\n        if (n.right.isRed() && !n.left.isRed()) {\r\n            n = n.rotateLeft();\r\n        }\r\n        if (n.left.isRed() && n.left.left.isRed()) {\r\n            n = n.rotateRight();\r\n        }\r\n        if (n.left.isRed() && n.right.isRed()) {\r\n            n = n.colorFlip();\r\n        }\r\n        return n;\r\n    }\r\n    moveRedLeft() {\r\n        let n = this.colorFlip();\r\n        if (n.right.left.isRed()) {\r\n            n = n.copy(null, null, null, null, n.right.rotateRight());\r\n            n = n.rotateLeft();\r\n            n = n.colorFlip();\r\n        }\r\n        return n;\r\n    }\r\n    moveRedRight() {\r\n        let n = this.colorFlip();\r\n        if (n.left.left.isRed()) {\r\n            n = n.rotateRight();\r\n            n = n.colorFlip();\r\n        }\r\n        return n;\r\n    }\r\n    rotateLeft() {\r\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\r\n        return this.right.copy(null, null, this.color, nl, null);\r\n    }\r\n    rotateRight() {\r\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\r\n        return this.left.copy(null, null, this.color, null, nr);\r\n    }\r\n    colorFlip() {\r\n        const left = this.left.copy(null, null, !this.left.color, null, null);\r\n        const right = this.right.copy(null, null, !this.right.color, null, null);\r\n        return this.copy(null, null, !this.color, left, right);\r\n    }\r\n    // For testing.\r\n    checkMaxDepth() {\r\n        const blackDepth = this.check();\r\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\r\n    // leaves is equal on both sides.  This function verifies that or asserts.\r\n    check() {\r\n        if (this.isRed() && this.left.isRed()) {\r\n            throw fail();\r\n        }\r\n        if (this.right.isRed()) {\r\n            throw fail();\r\n        }\r\n        const blackDepth = this.left.check();\r\n        if (blackDepth !== this.right.check()) {\r\n            throw fail();\r\n        }\r\n        else {\r\n            return blackDepth + (this.isRed() ? 0 : 1);\r\n        }\r\n    }\r\n} // end LLRBNode\r\n// Empty node is shared between all LLRB trees.\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nLLRBNode.EMPTY = null;\r\nLLRBNode.RED = true;\r\nLLRBNode.BLACK = false;\r\n// Represents an empty node (a leaf node in the Red-Black Tree).\r\nclass LLRBEmptyNode {\r\n    constructor() {\r\n        this.size = 0;\r\n    }\r\n    get key() {\r\n        throw fail();\r\n    }\r\n    get value() {\r\n        throw fail();\r\n    }\r\n    get color() {\r\n        throw fail();\r\n    }\r\n    get left() {\r\n        throw fail();\r\n    }\r\n    get right() {\r\n        throw fail();\r\n    }\r\n    // Returns a copy of the current node.\r\n    copy(key, value, color, left, right) {\r\n        return this;\r\n    }\r\n    // Returns a copy of the tree, with the specified key/value added.\r\n    insert(key, value, comparator) {\r\n        return new LLRBNode(key, value);\r\n    }\r\n    // Returns a copy of the tree, with the specified key removed.\r\n    remove(key, comparator) {\r\n        return this;\r\n    }\r\n    isEmpty() {\r\n        return true;\r\n    }\r\n    inorderTraversal(action) {\r\n        return false;\r\n    }\r\n    reverseTraversal(action) {\r\n        return false;\r\n    }\r\n    minKey() {\r\n        return null;\r\n    }\r\n    maxKey() {\r\n        return null;\r\n    }\r\n    isRed() {\r\n        return false;\r\n    }\r\n    // For testing.\r\n    checkMaxDepth() {\r\n        return true;\r\n    }\r\n    check() {\r\n        return 0;\r\n    }\r\n} // end LLRBEmptyNode\r\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * SortedSet is an immutable (copy-on-write) collection that holds elements\r\n * in order specified by the provided comparator.\r\n *\r\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\r\n * be equal!\r\n */\r\nclass SortedSet {\r\n    constructor(comparator) {\r\n        this.comparator = comparator;\r\n        this.data = new SortedMap(this.comparator);\r\n    }\r\n    has(elem) {\r\n        return this.data.get(elem) !== null;\r\n    }\r\n    first() {\r\n        return this.data.minKey();\r\n    }\r\n    last() {\r\n        return this.data.maxKey();\r\n    }\r\n    get size() {\r\n        return this.data.size;\r\n    }\r\n    indexOf(elem) {\r\n        return this.data.indexOf(elem);\r\n    }\r\n    /** Iterates elements in order defined by \"comparator\" */\r\n    forEach(cb) {\r\n        this.data.inorderTraversal((k, v) => {\r\n            cb(k);\r\n            return false;\r\n        });\r\n    }\r\n    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */\r\n    forEachInRange(range, cb) {\r\n        const iter = this.data.getIteratorFrom(range[0]);\r\n        while (iter.hasNext()) {\r\n            const elem = iter.getNext();\r\n            if (this.comparator(elem.key, range[1]) >= 0) {\r\n                return;\r\n            }\r\n            cb(elem.key);\r\n        }\r\n    }\r\n    /**\r\n     * Iterates over `elem`s such that: start &lt;= elem until false is returned.\r\n     */\r\n    forEachWhile(cb, start) {\r\n        let iter;\r\n        if (start !== undefined) {\r\n            iter = this.data.getIteratorFrom(start);\r\n        }\r\n        else {\r\n            iter = this.data.getIterator();\r\n        }\r\n        while (iter.hasNext()) {\r\n            const elem = iter.getNext();\r\n            const result = cb(elem.key);\r\n            if (!result) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /** Finds the least element greater than or equal to `elem`. */\r\n    firstAfterOrEqual(elem) {\r\n        const iter = this.data.getIteratorFrom(elem);\r\n        return iter.hasNext() ? iter.getNext().key : null;\r\n    }\r\n    getIterator() {\r\n        return new SortedSetIterator(this.data.getIterator());\r\n    }\r\n    getIteratorFrom(key) {\r\n        return new SortedSetIterator(this.data.getIteratorFrom(key));\r\n    }\r\n    /** Inserts or updates an element */\r\n    add(elem) {\r\n        return this.copy(this.data.remove(elem).insert(elem, true));\r\n    }\r\n    /** Deletes an element */\r\n    delete(elem) {\r\n        if (!this.has(elem)) {\r\n            return this;\r\n        }\r\n        return this.copy(this.data.remove(elem));\r\n    }\r\n    isEmpty() {\r\n        return this.data.isEmpty();\r\n    }\r\n    unionWith(other) {\r\n        let result = this;\r\n        // Make sure `result` always refers to the larger one of the two sets.\r\n        if (result.size < other.size) {\r\n            result = other;\r\n            other = this;\r\n        }\r\n        other.forEach(elem => {\r\n            result = result.add(elem);\r\n        });\r\n        return result;\r\n    }\r\n    isEqual(other) {\r\n        if (!(other instanceof SortedSet)) {\r\n            return false;\r\n        }\r\n        if (this.size !== other.size) {\r\n            return false;\r\n        }\r\n        const thisIt = this.data.getIterator();\r\n        const otherIt = other.data.getIterator();\r\n        while (thisIt.hasNext()) {\r\n            const thisElem = thisIt.getNext().key;\r\n            const otherElem = otherIt.getNext().key;\r\n            if (this.comparator(thisElem, otherElem) !== 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    toArray() {\r\n        const res = [];\r\n        this.forEach(targetId => {\r\n            res.push(targetId);\r\n        });\r\n        return res;\r\n    }\r\n    toString() {\r\n        const result = [];\r\n        this.forEach(elem => result.push(elem));\r\n        return 'SortedSet(' + result.toString() + ')';\r\n    }\r\n    copy(data) {\r\n        const result = new SortedSet(this.comparator);\r\n        result.data = data;\r\n        return result;\r\n    }\r\n}\r\nclass SortedSetIterator {\r\n    constructor(iter) {\r\n        this.iter = iter;\r\n    }\r\n    getNext() {\r\n        return this.iter.getNext().key;\r\n    }\r\n    hasNext() {\r\n        return this.iter.hasNext();\r\n    }\r\n}\r\n/**\r\n * Compares two sorted sets for equality using their natural ordering. The\r\n * method computes the intersection and invokes `onAdd` for every element that\r\n * is in `after` but not `before`. `onRemove` is invoked for every element in\r\n * `before` but missing from `after`.\r\n *\r\n * The method creates a copy of both `before` and `after` and runs in O(n log\r\n * n), where n is the size of the two lists.\r\n *\r\n * @param before - The elements that exist in the original set.\r\n * @param after - The elements to diff against the original set.\r\n * @param comparator - The comparator for the elements in before and after.\r\n * @param onAdd - A function to invoke for every element that is part of `\r\n * after` but not `before`.\r\n * @param onRemove - A function to invoke for every element that is part of\r\n * `before` but not `after`.\r\n */\r\nfunction diffSortedSets(before, after, comparator, onAdd, onRemove) {\r\n    const beforeIt = before.getIterator();\r\n    const afterIt = after.getIterator();\r\n    let beforeValue = advanceIterator(beforeIt);\r\n    let afterValue = advanceIterator(afterIt);\r\n    // Walk through the two sets at the same time, using the ordering defined by\r\n    // `comparator`.\r\n    while (beforeValue || afterValue) {\r\n        let added = false;\r\n        let removed = false;\r\n        if (beforeValue && afterValue) {\r\n            const cmp = comparator(beforeValue, afterValue);\r\n            if (cmp < 0) {\r\n                // The element was removed if the next element in our ordered\r\n                // walkthrough is only in `before`.\r\n                removed = true;\r\n            }\r\n            else if (cmp > 0) {\r\n                // The element was added if the next element in our ordered walkthrough\r\n                // is only in `after`.\r\n                added = true;\r\n            }\r\n        }\r\n        else if (beforeValue != null) {\r\n            removed = true;\r\n        }\r\n        else {\r\n            added = true;\r\n        }\r\n        if (added) {\r\n            onAdd(afterValue);\r\n            afterValue = advanceIterator(afterIt);\r\n        }\r\n        else if (removed) {\r\n            onRemove(beforeValue);\r\n            beforeValue = advanceIterator(beforeIt);\r\n        }\r\n        else {\r\n            beforeValue = advanceIterator(beforeIt);\r\n            afterValue = advanceIterator(afterIt);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns the next element from the iterator or `undefined` if none available.\r\n */\r\nfunction advanceIterator(it) {\r\n    return it.hasNext() ? it.getNext() : undefined;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\r\nfunction mutableDocumentMap() {\r\n    return EMPTY_MUTABLE_DOCUMENT_MAP;\r\n}\r\nconst EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\r\nfunction documentMap() {\r\n    return EMPTY_DOCUMENT_MAP;\r\n}\r\nconst EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);\r\nfunction documentVersionMap() {\r\n    return EMPTY_DOCUMENT_VERSION_MAP;\r\n}\r\nconst EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\r\nfunction documentKeySet(...keys) {\r\n    let set = EMPTY_DOCUMENT_KEY_SET;\r\n    for (const key of keys) {\r\n        set = set.add(key);\r\n    }\r\n    return set;\r\n}\r\nconst EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);\r\nfunction targetIdSet() {\r\n    return EMPTY_TARGET_ID_SET;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns an DoubleValue for `value` that is encoded based the serializer's\r\n * `useProto3Json` setting.\r\n */\r\nfunction toDouble(serializer, value) {\r\n    if (serializer.useProto3Json) {\r\n        if (isNaN(value)) {\r\n            return { doubleValue: 'NaN' };\r\n        }\r\n        else if (value === Infinity) {\r\n            return { doubleValue: 'Infinity' };\r\n        }\r\n        else if (value === -Infinity) {\r\n            return { doubleValue: '-Infinity' };\r\n        }\r\n    }\r\n    return { doubleValue: isNegativeZero(value) ? '-0' : value };\r\n}\r\n/**\r\n * Returns an IntegerValue for `value`.\r\n */\r\nfunction toInteger(value) {\r\n    return { integerValue: '' + value };\r\n}\r\n/**\r\n * Returns a value for a number that's appropriate to put into a proto.\r\n * The return value is an IntegerValue if it can safely represent the value,\r\n * otherwise a DoubleValue is returned.\r\n */\r\nfunction toNumber(serializer, value) {\r\n    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Used to represent a field transform on a mutation. */\r\nclass TransformOperation {\r\n    constructor() {\r\n        // Make sure that the structural type of `TransformOperation` is unique.\r\n        // See https://github.com/microsoft/TypeScript/issues/5451\r\n        this._ = undefined;\r\n    }\r\n}\r\n/**\r\n * Computes the local transform result against the provided `previousValue`,\r\n * optionally using the provided localWriteTime.\r\n */\r\nfunction applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {\r\n    if (transform instanceof ServerTimestampTransform) {\r\n        return serverTimestamp$1(localWriteTime, previousValue);\r\n    }\r\n    else if (transform instanceof ArrayUnionTransformOperation) {\r\n        return applyArrayUnionTransformOperation(transform, previousValue);\r\n    }\r\n    else if (transform instanceof ArrayRemoveTransformOperation) {\r\n        return applyArrayRemoveTransformOperation(transform, previousValue);\r\n    }\r\n    else {\r\n        return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);\r\n    }\r\n}\r\n/**\r\n * Computes a final transform result after the transform has been acknowledged\r\n * by the server, potentially using the server-provided transformResult.\r\n */\r\nfunction applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {\r\n    // The server just sends null as the transform result for array operations,\r\n    // so we have to calculate a result the same as we do for local\r\n    // applications.\r\n    if (transform instanceof ArrayUnionTransformOperation) {\r\n        return applyArrayUnionTransformOperation(transform, previousValue);\r\n    }\r\n    else if (transform instanceof ArrayRemoveTransformOperation) {\r\n        return applyArrayRemoveTransformOperation(transform, previousValue);\r\n    }\r\n    return transformResult;\r\n}\r\n/**\r\n * If this transform operation is not idempotent, returns the base value to\r\n * persist for this transform. If a base value is returned, the transform\r\n * operation is always applied to this base value, even if document has\r\n * already been updated.\r\n *\r\n * Base values provide consistent behavior for non-idempotent transforms and\r\n * allow us to return the same latency-compensated value even if the backend\r\n * has already applied the transform operation. The base value is null for\r\n * idempotent transforms, as they can be re-played even if the backend has\r\n * already applied them.\r\n *\r\n * @returns a base value to store along with the mutation, or null for\r\n * idempotent transforms.\r\n */\r\nfunction computeTransformOperationBaseValue(transform, previousValue) {\r\n    if (transform instanceof NumericIncrementTransformOperation) {\r\n        return isNumber(previousValue) ? previousValue : { integerValue: 0 };\r\n    }\r\n    return null;\r\n}\r\nfunction transformOperationEquals(left, right) {\r\n    if (left instanceof ArrayUnionTransformOperation &&\r\n        right instanceof ArrayUnionTransformOperation) {\r\n        return arrayEquals(left.elements, right.elements, valueEquals);\r\n    }\r\n    else if (left instanceof ArrayRemoveTransformOperation &&\r\n        right instanceof ArrayRemoveTransformOperation) {\r\n        return arrayEquals(left.elements, right.elements, valueEquals);\r\n    }\r\n    else if (left instanceof NumericIncrementTransformOperation &&\r\n        right instanceof NumericIncrementTransformOperation) {\r\n        return valueEquals(left.operand, right.operand);\r\n    }\r\n    return (left instanceof ServerTimestampTransform &&\r\n        right instanceof ServerTimestampTransform);\r\n}\r\n/** Transforms a value into a server-generated timestamp. */\r\nclass ServerTimestampTransform extends TransformOperation {\r\n}\r\n/** Transforms an array value via a union operation. */\r\nclass ArrayUnionTransformOperation extends TransformOperation {\r\n    constructor(elements) {\r\n        super();\r\n        this.elements = elements;\r\n    }\r\n}\r\nfunction applyArrayUnionTransformOperation(transform, previousValue) {\r\n    const values = coercedFieldValuesArray(previousValue);\r\n    for (const toUnion of transform.elements) {\r\n        if (!values.some(element => valueEquals(element, toUnion))) {\r\n            values.push(toUnion);\r\n        }\r\n    }\r\n    return { arrayValue: { values } };\r\n}\r\n/** Transforms an array value via a remove operation. */\r\nclass ArrayRemoveTransformOperation extends TransformOperation {\r\n    constructor(elements) {\r\n        super();\r\n        this.elements = elements;\r\n    }\r\n}\r\nfunction applyArrayRemoveTransformOperation(transform, previousValue) {\r\n    let values = coercedFieldValuesArray(previousValue);\r\n    for (const toRemove of transform.elements) {\r\n        values = values.filter(element => !valueEquals(element, toRemove));\r\n    }\r\n    return { arrayValue: { values } };\r\n}\r\n/**\r\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\r\n * transforms. Converts all field values to integers or doubles, but unlike the\r\n * backend does not cap integer values at 2^63. Instead, JavaScript number\r\n * arithmetic is used and precision loss can occur for values greater than 2^53.\r\n */\r\nclass NumericIncrementTransformOperation extends TransformOperation {\r\n    constructor(serializer, operand) {\r\n        super();\r\n        this.serializer = serializer;\r\n        this.operand = operand;\r\n    }\r\n}\r\nfunction applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {\r\n    // PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit\r\n    // precision and resolves overflows by reducing precision, we do not\r\n    // manually cap overflows at 2^63.\r\n    const baseValue = computeTransformOperationBaseValue(transform, previousValue);\r\n    const sum = asNumber(baseValue) + asNumber(transform.operand);\r\n    if (isInteger(baseValue) && isInteger(transform.operand)) {\r\n        return toInteger(sum);\r\n    }\r\n    else {\r\n        return toDouble(transform.serializer, sum);\r\n    }\r\n}\r\nfunction asNumber(value) {\r\n    return normalizeNumber(value.integerValue || value.doubleValue);\r\n}\r\nfunction coercedFieldValuesArray(value) {\r\n    return isArray(value) && value.arrayValue.values\r\n        ? value.arrayValue.values.slice()\r\n        : [];\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** A field path and the TransformOperation to perform upon it. */\r\nclass FieldTransform {\r\n    constructor(field, transform) {\r\n        this.field = field;\r\n        this.transform = transform;\r\n    }\r\n}\r\nfunction fieldTransformEquals(left, right) {\r\n    return (left.field.isEqual(right.field) &&\r\n        transformOperationEquals(left.transform, right.transform));\r\n}\r\nfunction fieldTransformsAreEqual(left, right) {\r\n    if (left === undefined && right === undefined) {\r\n        return true;\r\n    }\r\n    if (left && right) {\r\n        return arrayEquals(left, right, (l, r) => fieldTransformEquals(l, r));\r\n    }\r\n    return false;\r\n}\r\n/** The result of successfully applying a mutation to the backend. */\r\nclass MutationResult {\r\n    constructor(\r\n    /**\r\n     * The version at which the mutation was committed:\r\n     *\r\n     * - For most operations, this is the updateTime in the WriteResult.\r\n     * - For deletes, the commitTime of the WriteResponse (because deletes are\r\n     *   not stored and have no updateTime).\r\n     *\r\n     * Note that these versions can be different: No-op writes will not change\r\n     * the updateTime even though the commitTime advances.\r\n     */\r\n    version, \r\n    /**\r\n     * The resulting fields returned from the backend after a mutation\r\n     * containing field transforms has been committed. Contains one FieldValue\r\n     * for each FieldTransform that was in the mutation.\r\n     *\r\n     * Will be empty if the mutation did not contain any field transforms.\r\n     */\r\n    transformResults) {\r\n        this.version = version;\r\n        this.transformResults = transformResults;\r\n    }\r\n}\r\n/**\r\n * Encodes a precondition for a mutation. This follows the model that the\r\n * backend accepts with the special case of an explicit \"empty\" precondition\r\n * (meaning no precondition).\r\n */\r\nclass Precondition {\r\n    constructor(updateTime, exists) {\r\n        this.updateTime = updateTime;\r\n        this.exists = exists;\r\n    }\r\n    /** Creates a new empty Precondition. */\r\n    static none() {\r\n        return new Precondition();\r\n    }\r\n    /** Creates a new Precondition with an exists flag. */\r\n    static exists(exists) {\r\n        return new Precondition(undefined, exists);\r\n    }\r\n    /** Creates a new Precondition based on a version a document exists at. */\r\n    static updateTime(version) {\r\n        return new Precondition(version);\r\n    }\r\n    /** Returns whether this Precondition is empty. */\r\n    get isNone() {\r\n        return this.updateTime === undefined && this.exists === undefined;\r\n    }\r\n    isEqual(other) {\r\n        return (this.exists === other.exists &&\r\n            (this.updateTime\r\n                ? !!other.updateTime && this.updateTime.isEqual(other.updateTime)\r\n                : !other.updateTime));\r\n    }\r\n}\r\n/** Returns true if the preconditions is valid for the given document. */\r\nfunction preconditionIsValidForDocument(precondition, document) {\r\n    if (precondition.updateTime !== undefined) {\r\n        return (document.isFoundDocument() &&\r\n            document.version.isEqual(precondition.updateTime));\r\n    }\r\n    else if (precondition.exists !== undefined) {\r\n        return precondition.exists === document.isFoundDocument();\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\n/**\r\n * A mutation describes a self-contained change to a document. Mutations can\r\n * create, replace, delete, and update subsets of documents.\r\n *\r\n * Mutations not only act on the value of the document but also its version.\r\n *\r\n * For local mutations (mutations that haven't been committed yet), we preserve\r\n * the existing version for Set and Patch mutations. For Delete mutations, we\r\n * reset the version to 0.\r\n *\r\n * Here's the expected transition table.\r\n *\r\n * MUTATION           APPLIED TO            RESULTS IN\r\n *\r\n * SetMutation        Document(v3)          Document(v3)\r\n * SetMutation        NoDocument(v3)        Document(v0)\r\n * SetMutation        InvalidDocument(v0)   Document(v0)\r\n * PatchMutation      Document(v3)          Document(v3)\r\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\r\n * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)\r\n * DeleteMutation     Document(v3)          NoDocument(v0)\r\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\r\n * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)\r\n *\r\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\r\n * the resulting version for Set and Patch mutations. As deletes have no\r\n * explicit update time, we use the commitTime of the WriteResponse for\r\n * Delete mutations.\r\n *\r\n * If a mutation is acknowledged by the backend but fails the precondition check\r\n * locally, we transition to an `UnknownDocument` and rely on Watch to send us\r\n * the updated version.\r\n *\r\n * Field transforms are used only with Patch and Set Mutations. We use the\r\n * `updateTransforms` message to store transforms, rather than the `transforms`s\r\n * messages.\r\n *\r\n * ## Subclassing Notes\r\n *\r\n * Every type of mutation needs to implement its own applyToRemoteDocument() and\r\n * applyToLocalView() to implement the actual behavior of applying the mutation\r\n * to some source document (see `setMutationApplyToRemoteDocument()` for an\r\n * example).\r\n */\r\nclass Mutation {\r\n}\r\n/**\r\n * Applies this mutation to the given document for the purposes of computing a\r\n * new remote document. If the input document doesn't match the expected state\r\n * (e.g. it is invalid or outdated), the document type may transition to\r\n * unknown.\r\n *\r\n * @param mutation - The mutation to apply.\r\n * @param document - The document to mutate. The input document can be an\r\n *     invalid document if the client has no knowledge of the pre-mutation state\r\n *     of the document.\r\n * @param mutationResult - The result of applying the mutation from the backend.\r\n */\r\nfunction mutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    if (mutation instanceof SetMutation) {\r\n        setMutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n    }\r\n    else if (mutation instanceof PatchMutation) {\r\n        patchMutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n    }\r\n    else {\r\n        deleteMutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n    }\r\n}\r\n/**\r\n * Applies this mutation to the given document for the purposes of computing\r\n * the new local view of a document. If the input document doesn't match the\r\n * expected state, the document is not modified.\r\n *\r\n * @param mutation - The mutation to apply.\r\n * @param document - The document to mutate. The input document can be an\r\n *     invalid document if the client has no knowledge of the pre-mutation state\r\n *     of the document.\r\n * @param localWriteTime - A timestamp indicating the local write time of the\r\n *     batch this mutation is a part of.\r\n */\r\nfunction mutationApplyToLocalView(mutation, document, localWriteTime) {\r\n    if (mutation instanceof SetMutation) {\r\n        setMutationApplyToLocalView(mutation, document, localWriteTime);\r\n    }\r\n    else if (mutation instanceof PatchMutation) {\r\n        patchMutationApplyToLocalView(mutation, document, localWriteTime);\r\n    }\r\n    else {\r\n        deleteMutationApplyToLocalView(mutation, document);\r\n    }\r\n}\r\n/**\r\n * If this mutation is not idempotent, returns the base value to persist with\r\n * this mutation. If a base value is returned, the mutation is always applied\r\n * to this base value, even if document has already been updated.\r\n *\r\n * The base value is a sparse object that consists of only the document\r\n * fields for which this mutation contains a non-idempotent transformation\r\n * (e.g. a numeric increment). The provided value guarantees consistent\r\n * behavior for non-idempotent transforms and allow us to return the same\r\n * latency-compensated value even if the backend has already applied the\r\n * mutation. The base value is null for idempotent mutations, as they can be\r\n * re-played even if the backend has already applied them.\r\n *\r\n * @returns a base value to store along with the mutation, or null for\r\n * idempotent mutations.\r\n */\r\nfunction mutationExtractBaseValue(mutation, document) {\r\n    let baseObject = null;\r\n    for (const fieldTransform of mutation.fieldTransforms) {\r\n        const existingValue = document.data.field(fieldTransform.field);\r\n        const coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);\r\n        if (coercedValue != null) {\r\n            if (baseObject == null) {\r\n                baseObject = ObjectValue.empty();\r\n            }\r\n            baseObject.set(fieldTransform.field, coercedValue);\r\n        }\r\n    }\r\n    return baseObject ? baseObject : null;\r\n}\r\nfunction mutationEquals(left, right) {\r\n    if (left.type !== right.type) {\r\n        return false;\r\n    }\r\n    if (!left.key.isEqual(right.key)) {\r\n        return false;\r\n    }\r\n    if (!left.precondition.isEqual(right.precondition)) {\r\n        return false;\r\n    }\r\n    if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {\r\n        return false;\r\n    }\r\n    if (left.type === 0 /* Set */) {\r\n        return left.value.isEqual(right.value);\r\n    }\r\n    if (left.type === 1 /* Patch */) {\r\n        return (left.data.isEqual(right.data) &&\r\n            left.fieldMask.isEqual(right.fieldMask));\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Returns the version from the given document for use as the result of a\r\n * mutation. Mutations are defined to return the version of the base document\r\n * only if it is an existing document. Deleted and unknown documents have a\r\n * post-mutation version of SnapshotVersion.min().\r\n */\r\nfunction getPostMutationVersion(document) {\r\n    return document.isFoundDocument() ? document.version : SnapshotVersion.min();\r\n}\r\n/**\r\n * A mutation that creates or replaces the document at the given key with the\r\n * object value contents.\r\n */\r\nclass SetMutation extends Mutation {\r\n    constructor(key, value, precondition, fieldTransforms = []) {\r\n        super();\r\n        this.key = key;\r\n        this.value = value;\r\n        this.precondition = precondition;\r\n        this.fieldTransforms = fieldTransforms;\r\n        this.type = 0 /* Set */;\r\n    }\r\n}\r\nfunction setMutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    // Unlike setMutationApplyToLocalView, if we're applying a mutation to a\r\n    // remote document the server has accepted the mutation so the precondition\r\n    // must have held.\r\n    const newData = mutation.value.clone();\r\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(mutationResult.version, newData)\r\n        .setHasCommittedMutations();\r\n}\r\nfunction setMutationApplyToLocalView(mutation, document, localWriteTime) {\r\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        // The mutation failed to apply (e.g. a document ID created with add()\r\n        // caused a name collision).\r\n        return;\r\n    }\r\n    const newData = mutation.value.clone();\r\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(getPostMutationVersion(document), newData)\r\n        .setHasLocalMutations();\r\n}\r\n/**\r\n * A mutation that modifies fields of the document at the given key with the\r\n * given values. The values are applied through a field mask:\r\n *\r\n *  * When a field is in both the mask and the values, the corresponding field\r\n *    is updated.\r\n *  * When a field is in neither the mask nor the values, the corresponding\r\n *    field is unmodified.\r\n *  * When a field is in the mask but not in the values, the corresponding field\r\n *    is deleted.\r\n *  * When a field is not in the mask but is in the values, the values map is\r\n *    ignored.\r\n */\r\nclass PatchMutation extends Mutation {\r\n    constructor(key, data, fieldMask, precondition, fieldTransforms = []) {\r\n        super();\r\n        this.key = key;\r\n        this.data = data;\r\n        this.fieldMask = fieldMask;\r\n        this.precondition = precondition;\r\n        this.fieldTransforms = fieldTransforms;\r\n        this.type = 1 /* Patch */;\r\n    }\r\n}\r\nfunction patchMutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        // Since the mutation was not rejected, we know that the precondition\r\n        // matched on the backend. We therefore must not have the expected version\r\n        // of the document in our cache and convert to an UnknownDocument with a\r\n        // known updateTime.\r\n        document.convertToUnknownDocument(mutationResult.version);\r\n        return;\r\n    }\r\n    const transformResults = serverTransformResults(mutation.fieldTransforms, document, mutationResult.transformResults);\r\n    const newData = document.data;\r\n    newData.setAll(getPatch(mutation));\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(mutationResult.version, newData)\r\n        .setHasCommittedMutations();\r\n}\r\nfunction patchMutationApplyToLocalView(mutation, document, localWriteTime) {\r\n    if (!preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        return;\r\n    }\r\n    const transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document);\r\n    const newData = document.data;\r\n    newData.setAll(getPatch(mutation));\r\n    newData.setAll(transformResults);\r\n    document\r\n        .convertToFoundDocument(getPostMutationVersion(document), newData)\r\n        .setHasLocalMutations();\r\n}\r\n/**\r\n * Returns a FieldPath/Value map with the content of the PatchMutation.\r\n */\r\nfunction getPatch(mutation) {\r\n    const result = new Map();\r\n    mutation.fieldMask.fields.forEach(fieldPath => {\r\n        if (!fieldPath.isEmpty()) {\r\n            const newValue = mutation.data.field(fieldPath);\r\n            result.set(fieldPath, newValue);\r\n        }\r\n    });\r\n    return result;\r\n}\r\n/**\r\n * Creates a list of \"transform results\" (a transform result is a field value\r\n * representing the result of applying a transform) for use after a mutation\r\n * containing transforms has been acknowledged by the server.\r\n *\r\n * @param fieldTransforms - The field transforms to apply the result to.\r\n * @param mutableDocument - The current state of the document after applying all\r\n * previous mutations.\r\n * @param serverTransformResults - The transform results received by the server.\r\n * @returns The transform results list.\r\n */\r\nfunction serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults) {\r\n    const transformResults = new Map();\r\n    hardAssert(fieldTransforms.length === serverTransformResults.length);\r\n    for (let i = 0; i < serverTransformResults.length; i++) {\r\n        const fieldTransform = fieldTransforms[i];\r\n        const transform = fieldTransform.transform;\r\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\r\n        transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults[i]));\r\n    }\r\n    return transformResults;\r\n}\r\n/**\r\n * Creates a list of \"transform results\" (a transform result is a field value\r\n * representing the result of applying a transform) for use when applying a\r\n * transform locally.\r\n *\r\n * @param fieldTransforms - The field transforms to apply the result to.\r\n * @param localWriteTime - The local time of the mutation (used to\r\n *     generate ServerTimestampValues).\r\n * @param mutableDocument - The current state of the document after applying all\r\n *     previous mutations.\r\n * @returns The transform results list.\r\n */\r\nfunction localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {\r\n    const transformResults = new Map();\r\n    for (const fieldTransform of fieldTransforms) {\r\n        const transform = fieldTransform.transform;\r\n        const previousValue = mutableDocument.data.field(fieldTransform.field);\r\n        transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));\r\n    }\r\n    return transformResults;\r\n}\r\n/** A mutation that deletes the document at the given key. */\r\nclass DeleteMutation extends Mutation {\r\n    constructor(key, precondition) {\r\n        super();\r\n        this.key = key;\r\n        this.precondition = precondition;\r\n        this.type = 2 /* Delete */;\r\n        this.fieldTransforms = [];\r\n    }\r\n}\r\nfunction deleteMutationApplyToRemoteDocument(mutation, document, mutationResult) {\r\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\r\n    // document the server has accepted the mutation so the precondition must\r\n    // have held.\r\n    document\r\n        .convertToNoDocument(mutationResult.version)\r\n        .setHasCommittedMutations();\r\n}\r\nfunction deleteMutationApplyToLocalView(mutation, document) {\r\n    if (preconditionIsValidForDocument(mutation.precondition, document)) {\r\n        // We don't call `setHasLocalMutations()` since we want to be backwards\r\n        // compatible with the existing SDK behavior.\r\n        document.convertToNoDocument(SnapshotVersion.min());\r\n    }\r\n}\r\n/**\r\n * A mutation that verifies the existence of the document at the given key with\r\n * the provided precondition.\r\n *\r\n * The `verify` operation is only used in Transactions, and this class serves\r\n * primarily to facilitate serialization into protos.\r\n */\r\nclass VerifyMutation extends Mutation {\r\n    constructor(key, precondition) {\r\n        super();\r\n        this.key = key;\r\n        this.precondition = precondition;\r\n        this.type = 3 /* Verify */;\r\n        this.fieldTransforms = [];\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A batch of mutations that will be sent as one unit to the backend.\r\n */\r\nclass MutationBatch {\r\n    /**\r\n     * @param batchId - The unique ID of this mutation batch.\r\n     * @param localWriteTime - The original write time of this mutation.\r\n     * @param baseMutations - Mutations that are used to populate the base\r\n     * values when this mutation is applied locally. This can be used to locally\r\n     * overwrite values that are persisted in the remote document cache. Base\r\n     * mutations are never sent to the backend.\r\n     * @param mutations - The user-provided mutations in this mutation batch.\r\n     * User-provided mutations are applied both locally and remotely on the\r\n     * backend.\r\n     */\r\n    constructor(batchId, localWriteTime, baseMutations, mutations) {\r\n        this.batchId = batchId;\r\n        this.localWriteTime = localWriteTime;\r\n        this.baseMutations = baseMutations;\r\n        this.mutations = mutations;\r\n    }\r\n    /**\r\n     * Applies all the mutations in this MutationBatch to the specified document\r\n     * to compute the state of the remote document\r\n     *\r\n     * @param document - The document to apply mutations to.\r\n     * @param batchResult - The result of applying the MutationBatch to the\r\n     * backend.\r\n     */\r\n    applyToRemoteDocument(document, batchResult) {\r\n        const mutationResults = batchResult.mutationResults;\r\n        for (let i = 0; i < this.mutations.length; i++) {\r\n            const mutation = this.mutations[i];\r\n            if (mutation.key.isEqual(document.key)) {\r\n                const mutationResult = mutationResults[i];\r\n                mutationApplyToRemoteDocument(mutation, document, mutationResult);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Computes the local view of a document given all the mutations in this\r\n     * batch.\r\n     *\r\n     * @param document - The document to apply mutations to.\r\n     */\r\n    applyToLocalView(document) {\r\n        // First, apply the base state. This allows us to apply non-idempotent\r\n        // transform against a consistent set of values.\r\n        for (const mutation of this.baseMutations) {\r\n            if (mutation.key.isEqual(document.key)) {\r\n                mutationApplyToLocalView(mutation, document, this.localWriteTime);\r\n            }\r\n        }\r\n        // Second, apply all user-provided mutations.\r\n        for (const mutation of this.mutations) {\r\n            if (mutation.key.isEqual(document.key)) {\r\n                mutationApplyToLocalView(mutation, document, this.localWriteTime);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Computes the local view for all provided documents given the mutations in\r\n     * this batch.\r\n     */\r\n    applyToLocalDocumentSet(documentMap) {\r\n        // TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations\r\n        // directly (as done in `applyToLocalView()`), we can reduce the complexity\r\n        // to O(n).\r\n        this.mutations.forEach(m => {\r\n            const document = documentMap.get(m.key);\r\n            // TODO(mutabledocuments): This method should take a MutableDocumentMap\r\n            // and we should remove this cast.\r\n            const mutableDocument = document;\r\n            this.applyToLocalView(mutableDocument);\r\n            if (!document.isValidDocument()) {\r\n                mutableDocument.convertToNoDocument(SnapshotVersion.min());\r\n            }\r\n        });\r\n    }\r\n    keys() {\r\n        return this.mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\r\n    }\r\n    isEqual(other) {\r\n        return (this.batchId === other.batchId &&\r\n            arrayEquals(this.mutations, other.mutations, (l, r) => mutationEquals(l, r)) &&\r\n            arrayEquals(this.baseMutations, other.baseMutations, (l, r) => mutationEquals(l, r)));\r\n    }\r\n}\r\n/** The result of applying a mutation batch to the backend. */\r\nclass MutationBatchResult {\r\n    constructor(batch, commitVersion, mutationResults, \r\n    /**\r\n     * A pre-computed mapping from each mutated document to the resulting\r\n     * version.\r\n     */\r\n    docVersions) {\r\n        this.batch = batch;\r\n        this.commitVersion = commitVersion;\r\n        this.mutationResults = mutationResults;\r\n        this.docVersions = docVersions;\r\n    }\r\n    /**\r\n     * Creates a new MutationBatchResult for the given batch and results. There\r\n     * must be one result for each mutation in the batch. This static factory\r\n     * caches a document=&gt;version mapping (docVersions).\r\n     */\r\n    static from(batch, commitVersion, results) {\r\n        hardAssert(batch.mutations.length === results.length);\r\n        let versionMap = documentVersionMap();\r\n        const mutations = batch.mutations;\r\n        for (let i = 0; i < mutations.length; i++) {\r\n            versionMap = versionMap.insert(mutations[i].key, results[i].version);\r\n        }\r\n        return new MutationBatchResult(batch, commitVersion, results, versionMap);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Representation of an overlay computed by Firestore.\r\n *\r\n * Holds information about a mutation and the largest batch id in Firestore when\r\n * the mutation was created.\r\n */\r\nclass Overlay {\r\n    constructor(largestBatchId, mutation) {\r\n        this.largestBatchId = largestBatchId;\r\n        this.mutation = mutation;\r\n    }\r\n    getKey() {\r\n        return this.mutation.key;\r\n    }\r\n    isEqual(other) {\r\n        return other !== null && this.mutation === other.mutation;\r\n    }\r\n    toString() {\r\n        return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }`;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ExistenceFilter {\r\n    // TODO(b/33078163): just use simplest form of existence filter for now\r\n    constructor(count) {\r\n        this.count = count;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Error Codes describing the different ways GRPC can fail. These are copied\r\n * directly from GRPC's sources here:\r\n *\r\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\r\n *\r\n * Important! The names of these identifiers matter because the string forms\r\n * are used for reverse lookups from the webchannel stream. Do NOT change the\r\n * names of these identifiers or change this into a const enum.\r\n */\r\nvar RpcCode;\r\n(function (RpcCode) {\r\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\r\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\r\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\r\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\r\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\r\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\r\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\r\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\r\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\r\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\r\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\r\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\r\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\r\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\r\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\r\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\r\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\r\n})(RpcCode || (RpcCode = {}));\r\n/**\r\n * Determines whether an error code represents a permanent error when received\r\n * in response to a non-write operation.\r\n *\r\n * See isPermanentWriteError for classifying write errors.\r\n */\r\nfunction isPermanentError(code) {\r\n    switch (code) {\r\n        case Code.OK:\r\n            return fail();\r\n        case Code.CANCELLED:\r\n        case Code.UNKNOWN:\r\n        case Code.DEADLINE_EXCEEDED:\r\n        case Code.RESOURCE_EXHAUSTED:\r\n        case Code.INTERNAL:\r\n        case Code.UNAVAILABLE:\r\n        // Unauthenticated means something went wrong with our token and we need\r\n        // to retry with new credentials which will happen automatically.\r\n        case Code.UNAUTHENTICATED:\r\n            return false;\r\n        case Code.INVALID_ARGUMENT:\r\n        case Code.NOT_FOUND:\r\n        case Code.ALREADY_EXISTS:\r\n        case Code.PERMISSION_DENIED:\r\n        case Code.FAILED_PRECONDITION:\r\n        // Aborted might be retried in some scenarios, but that is dependant on\r\n        // the context and should handled individually by the calling code.\r\n        // See https://cloud.google.com/apis/design/errors.\r\n        case Code.ABORTED:\r\n        case Code.OUT_OF_RANGE:\r\n        case Code.UNIMPLEMENTED:\r\n        case Code.DATA_LOSS:\r\n            return true;\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\n/**\r\n * Determines whether an error code represents a permanent error when received\r\n * in response to a write operation.\r\n *\r\n * Write operations must be handled specially because as of b/119437764, ABORTED\r\n * errors on the write stream should be retried too (even though ABORTED errors\r\n * are not generally retryable).\r\n *\r\n * Note that during the initial handshake on the write stream an ABORTED error\r\n * signals that we should discard our stream token (i.e. it is permanent). This\r\n * means a handshake error should be classified with isPermanentError, above.\r\n */\r\nfunction isPermanentWriteError(code) {\r\n    return isPermanentError(code) && code !== Code.ABORTED;\r\n}\r\n/**\r\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\r\n * are not the same as HTTP status codes.\r\n *\r\n * @returns The Code equivalent to the given GRPC status code. Fails if there\r\n *     is no match.\r\n */\r\nfunction mapCodeFromRpcCode(code) {\r\n    if (code === undefined) {\r\n        // This shouldn't normally happen, but in certain error cases (like trying\r\n        // to send invalid proto messages) we may get an error with no GRPC code.\r\n        logError('GRPC error has no .code');\r\n        return Code.UNKNOWN;\r\n    }\r\n    switch (code) {\r\n        case RpcCode.OK:\r\n            return Code.OK;\r\n        case RpcCode.CANCELLED:\r\n            return Code.CANCELLED;\r\n        case RpcCode.UNKNOWN:\r\n            return Code.UNKNOWN;\r\n        case RpcCode.DEADLINE_EXCEEDED:\r\n            return Code.DEADLINE_EXCEEDED;\r\n        case RpcCode.RESOURCE_EXHAUSTED:\r\n            return Code.RESOURCE_EXHAUSTED;\r\n        case RpcCode.INTERNAL:\r\n            return Code.INTERNAL;\r\n        case RpcCode.UNAVAILABLE:\r\n            return Code.UNAVAILABLE;\r\n        case RpcCode.UNAUTHENTICATED:\r\n            return Code.UNAUTHENTICATED;\r\n        case RpcCode.INVALID_ARGUMENT:\r\n            return Code.INVALID_ARGUMENT;\r\n        case RpcCode.NOT_FOUND:\r\n            return Code.NOT_FOUND;\r\n        case RpcCode.ALREADY_EXISTS:\r\n            return Code.ALREADY_EXISTS;\r\n        case RpcCode.PERMISSION_DENIED:\r\n            return Code.PERMISSION_DENIED;\r\n        case RpcCode.FAILED_PRECONDITION:\r\n            return Code.FAILED_PRECONDITION;\r\n        case RpcCode.ABORTED:\r\n            return Code.ABORTED;\r\n        case RpcCode.OUT_OF_RANGE:\r\n            return Code.OUT_OF_RANGE;\r\n        case RpcCode.UNIMPLEMENTED:\r\n            return Code.UNIMPLEMENTED;\r\n        case RpcCode.DATA_LOSS:\r\n            return Code.DATA_LOSS;\r\n        default:\r\n            return fail();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An event from the RemoteStore. It is split into targetChanges (changes to the\r\n * state or the set of documents in our watched targets) and documentUpdates\r\n * (changes to the actual documents).\r\n */\r\nclass RemoteEvent {\r\n    constructor(\r\n    /**\r\n     * The snapshot version this event brings us up to, or MIN if not set.\r\n     */\r\n    snapshotVersion, \r\n    /**\r\n     * A map from target to changes to the target. See TargetChange.\r\n     */\r\n    targetChanges, \r\n    /**\r\n     * A set of targets that is known to be inconsistent. Listens for these\r\n     * targets should be re-established without resume tokens.\r\n     */\r\n    targetMismatches, \r\n    /**\r\n     * A set of which documents have changed or been deleted, along with the\r\n     * doc's new values (if not deleted).\r\n     */\r\n    documentUpdates, \r\n    /**\r\n     * A set of which document updates are due only to limbo resolution targets.\r\n     */\r\n    resolvedLimboDocuments) {\r\n        this.snapshotVersion = snapshotVersion;\r\n        this.targetChanges = targetChanges;\r\n        this.targetMismatches = targetMismatches;\r\n        this.documentUpdates = documentUpdates;\r\n        this.resolvedLimboDocuments = resolvedLimboDocuments;\r\n    }\r\n    /**\r\n     * HACK: Views require RemoteEvents in order to determine whether the view is\r\n     * CURRENT, but secondary tabs don't receive remote events. So this method is\r\n     * used to create a synthesized RemoteEvent that can be used to apply a\r\n     * CURRENT status change to a View, for queries executed in a different tab.\r\n     */\r\n    // PORTING NOTE: Multi-tab only\r\n    static createSynthesizedRemoteEventForCurrentChange(targetId, current) {\r\n        const targetChanges = new Map();\r\n        targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current));\r\n        return new RemoteEvent(SnapshotVersion.min(), targetChanges, targetIdSet(), mutableDocumentMap(), documentKeySet());\r\n    }\r\n}\r\n/**\r\n * A TargetChange specifies the set of changes for a specific target as part of\r\n * a RemoteEvent. These changes track which documents are added, modified or\r\n * removed, as well as the target's resume token and whether the target is\r\n * marked CURRENT.\r\n * The actual changes *to* documents are not part of the TargetChange since\r\n * documents may be part of multiple targets.\r\n */\r\nclass TargetChange {\r\n    constructor(\r\n    /**\r\n     * An opaque, server-assigned token that allows watching a query to be resumed\r\n     * after disconnecting without retransmitting all the data that matches the\r\n     * query. The resume token essentially identifies a point in time from which\r\n     * the server should resume sending results.\r\n     */\r\n    resumeToken, \r\n    /**\r\n     * The \"current\" (synced) status of this target. Note that \"current\"\r\n     * has special meaning in the RPC protocol that implies that a target is\r\n     * both up-to-date and consistent with the rest of the watch stream.\r\n     */\r\n    current, \r\n    /**\r\n     * The set of documents that were newly assigned to this target as part of\r\n     * this remote event.\r\n     */\r\n    addedDocuments, \r\n    /**\r\n     * The set of documents that were already assigned to this target but received\r\n     * an update during this remote event.\r\n     */\r\n    modifiedDocuments, \r\n    /**\r\n     * The set of documents that were removed from this target as part of this\r\n     * remote event.\r\n     */\r\n    removedDocuments) {\r\n        this.resumeToken = resumeToken;\r\n        this.current = current;\r\n        this.addedDocuments = addedDocuments;\r\n        this.modifiedDocuments = modifiedDocuments;\r\n        this.removedDocuments = removedDocuments;\r\n    }\r\n    /**\r\n     * This method is used to create a synthesized TargetChanges that can be used to\r\n     * apply a CURRENT status change to a View (for queries executed in a different\r\n     * tab) or for new queries (to raise snapshots with correct CURRENT status).\r\n     */\r\n    static createSynthesizedTargetChangeForCurrentChange(targetId, current) {\r\n        return new TargetChange(ByteString.EMPTY_BYTE_STRING, current, documentKeySet(), documentKeySet(), documentKeySet());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents a changed document and a list of target ids to which this change\r\n * applies.\r\n *\r\n * If document has been deleted NoDocument will be provided.\r\n */\r\nclass DocumentWatchChange {\r\n    constructor(\r\n    /** The new document applies to all of these targets. */\r\n    updatedTargetIds, \r\n    /** The new document is removed from all of these targets. */\r\n    removedTargetIds, \r\n    /** The key of the document for this change. */\r\n    key, \r\n    /**\r\n     * The new document or NoDocument if it was deleted. Is null if the\r\n     * document went out of view without the server sending a new document.\r\n     */\r\n    newDoc) {\r\n        this.updatedTargetIds = updatedTargetIds;\r\n        this.removedTargetIds = removedTargetIds;\r\n        this.key = key;\r\n        this.newDoc = newDoc;\r\n    }\r\n}\r\nclass ExistenceFilterChange {\r\n    constructor(targetId, existenceFilter) {\r\n        this.targetId = targetId;\r\n        this.existenceFilter = existenceFilter;\r\n    }\r\n}\r\nclass WatchTargetChange {\r\n    constructor(\r\n    /** What kind of change occurred to the watch target. */\r\n    state, \r\n    /** The target IDs that were added/removed/set. */\r\n    targetIds, \r\n    /**\r\n     * An opaque, server-assigned token that allows watching a target to be\r\n     * resumed after disconnecting without retransmitting all the data that\r\n     * matches the target. The resume token essentially identifies a point in\r\n     * time from which the server should resume sending results.\r\n     */\r\n    resumeToken = ByteString.EMPTY_BYTE_STRING, \r\n    /** An RPC error indicating why the watch failed. */\r\n    cause = null) {\r\n        this.state = state;\r\n        this.targetIds = targetIds;\r\n        this.resumeToken = resumeToken;\r\n        this.cause = cause;\r\n    }\r\n}\r\n/** Tracks the internal state of a Watch target. */\r\nclass TargetState {\r\n    constructor() {\r\n        /**\r\n         * The number of pending responses (adds or removes) that we are waiting on.\r\n         * We only consider targets active that have no pending responses.\r\n         */\r\n        this.pendingResponses = 0;\r\n        /**\r\n         * Keeps track of the document changes since the last raised snapshot.\r\n         *\r\n         * These changes are continuously updated as we receive document updates and\r\n         * always reflect the current set of changes against the last issued snapshot.\r\n         */\r\n        this.documentChanges = snapshotChangesMap();\r\n        /** See public getters for explanations of these fields. */\r\n        this._resumeToken = ByteString.EMPTY_BYTE_STRING;\r\n        this._current = false;\r\n        /**\r\n         * Whether this target state should be included in the next snapshot. We\r\n         * initialize to true so that newly-added targets are included in the next\r\n         * RemoteEvent.\r\n         */\r\n        this._hasPendingChanges = true;\r\n    }\r\n    /**\r\n     * Whether this target has been marked 'current'.\r\n     *\r\n     * 'Current' has special meaning in the RPC protocol: It implies that the\r\n     * Watch backend has sent us all changes up to the point at which the target\r\n     * was added and that the target is consistent with the rest of the watch\r\n     * stream.\r\n     */\r\n    get current() {\r\n        return this._current;\r\n    }\r\n    /** The last resume token sent to us for this target. */\r\n    get resumeToken() {\r\n        return this._resumeToken;\r\n    }\r\n    /** Whether this target has pending target adds or target removes. */\r\n    get isPending() {\r\n        return this.pendingResponses !== 0;\r\n    }\r\n    /** Whether we have modified any state that should trigger a snapshot. */\r\n    get hasPendingChanges() {\r\n        return this._hasPendingChanges;\r\n    }\r\n    /**\r\n     * Applies the resume token to the TargetChange, but only when it has a new\r\n     * value. Empty resumeTokens are discarded.\r\n     */\r\n    updateResumeToken(resumeToken) {\r\n        if (resumeToken.approximateByteSize() > 0) {\r\n            this._hasPendingChanges = true;\r\n            this._resumeToken = resumeToken;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a target change from the current set of changes.\r\n     *\r\n     * To reset the document changes after raising this snapshot, call\r\n     * `clearPendingChanges()`.\r\n     */\r\n    toTargetChange() {\r\n        let addedDocuments = documentKeySet();\r\n        let modifiedDocuments = documentKeySet();\r\n        let removedDocuments = documentKeySet();\r\n        this.documentChanges.forEach((key, changeType) => {\r\n            switch (changeType) {\r\n                case 0 /* Added */:\r\n                    addedDocuments = addedDocuments.add(key);\r\n                    break;\r\n                case 2 /* Modified */:\r\n                    modifiedDocuments = modifiedDocuments.add(key);\r\n                    break;\r\n                case 1 /* Removed */:\r\n                    removedDocuments = removedDocuments.add(key);\r\n                    break;\r\n                default:\r\n                    fail();\r\n            }\r\n        });\r\n        return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);\r\n    }\r\n    /**\r\n     * Resets the document changes and sets `hasPendingChanges` to false.\r\n     */\r\n    clearPendingChanges() {\r\n        this._hasPendingChanges = false;\r\n        this.documentChanges = snapshotChangesMap();\r\n    }\r\n    addDocumentChange(key, changeType) {\r\n        this._hasPendingChanges = true;\r\n        this.documentChanges = this.documentChanges.insert(key, changeType);\r\n    }\r\n    removeDocumentChange(key) {\r\n        this._hasPendingChanges = true;\r\n        this.documentChanges = this.documentChanges.remove(key);\r\n    }\r\n    recordPendingTargetRequest() {\r\n        this.pendingResponses += 1;\r\n    }\r\n    recordTargetResponse() {\r\n        this.pendingResponses -= 1;\r\n    }\r\n    markCurrent() {\r\n        this._hasPendingChanges = true;\r\n        this._current = true;\r\n    }\r\n}\r\nconst LOG_TAG$g = 'WatchChangeAggregator';\r\n/**\r\n * A helper class to accumulate watch changes into a RemoteEvent.\r\n */\r\nclass WatchChangeAggregator {\r\n    constructor(metadataProvider) {\r\n        this.metadataProvider = metadataProvider;\r\n        /** The internal state of all tracked targets. */\r\n        this.targetStates = new Map();\r\n        /** Keeps track of the documents to update since the last raised snapshot. */\r\n        this.pendingDocumentUpdates = mutableDocumentMap();\r\n        /** A mapping of document keys to their set of target IDs. */\r\n        this.pendingDocumentTargetMapping = documentTargetMap();\r\n        /**\r\n         * A list of targets with existence filter mismatches. These targets are\r\n         * known to be inconsistent and their listens needs to be re-established by\r\n         * RemoteStore.\r\n         */\r\n        this.pendingTargetResets = new SortedSet(primitiveComparator);\r\n    }\r\n    /**\r\n     * Processes and adds the DocumentWatchChange to the current set of changes.\r\n     */\r\n    handleDocumentChange(docChange) {\r\n        for (const targetId of docChange.updatedTargetIds) {\r\n            if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {\r\n                this.addDocumentToTarget(targetId, docChange.newDoc);\r\n            }\r\n            else {\r\n                this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\r\n            }\r\n        }\r\n        for (const targetId of docChange.removedTargetIds) {\r\n            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\r\n        }\r\n    }\r\n    /** Processes and adds the WatchTargetChange to the current set of changes. */\r\n    handleTargetChange(targetChange) {\r\n        this.forEachTarget(targetChange, targetId => {\r\n            const targetState = this.ensureTargetState(targetId);\r\n            switch (targetChange.state) {\r\n                case 0 /* NoChange */:\r\n                    if (this.isActiveTarget(targetId)) {\r\n                        targetState.updateResumeToken(targetChange.resumeToken);\r\n                    }\r\n                    break;\r\n                case 1 /* Added */:\r\n                    // We need to decrement the number of pending acks needed from watch\r\n                    // for this targetId.\r\n                    targetState.recordTargetResponse();\r\n                    if (!targetState.isPending) {\r\n                        // We have a freshly added target, so we need to reset any state\r\n                        // that we had previously. This can happen e.g. when remove and add\r\n                        // back a target for existence filter mismatches.\r\n                        targetState.clearPendingChanges();\r\n                    }\r\n                    targetState.updateResumeToken(targetChange.resumeToken);\r\n                    break;\r\n                case 2 /* Removed */:\r\n                    // We need to keep track of removed targets to we can post-filter and\r\n                    // remove any target changes.\r\n                    // We need to decrement the number of pending acks needed from watch\r\n                    // for this targetId.\r\n                    targetState.recordTargetResponse();\r\n                    if (!targetState.isPending) {\r\n                        this.removeTarget(targetId);\r\n                    }\r\n                    break;\r\n                case 3 /* Current */:\r\n                    if (this.isActiveTarget(targetId)) {\r\n                        targetState.markCurrent();\r\n                        targetState.updateResumeToken(targetChange.resumeToken);\r\n                    }\r\n                    break;\r\n                case 4 /* Reset */:\r\n                    if (this.isActiveTarget(targetId)) {\r\n                        // Reset the target and synthesizes removes for all existing\r\n                        // documents. The backend will re-add any documents that still\r\n                        // match the target before it sends the next global snapshot.\r\n                        this.resetTarget(targetId);\r\n                        targetState.updateResumeToken(targetChange.resumeToken);\r\n                    }\r\n                    break;\r\n                default:\r\n                    fail();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Iterates over all targetIds that the watch change applies to: either the\r\n     * targetIds explicitly listed in the change or the targetIds of all currently\r\n     * active targets.\r\n     */\r\n    forEachTarget(targetChange, fn) {\r\n        if (targetChange.targetIds.length > 0) {\r\n            targetChange.targetIds.forEach(fn);\r\n        }\r\n        else {\r\n            this.targetStates.forEach((_, targetId) => {\r\n                if (this.isActiveTarget(targetId)) {\r\n                    fn(targetId);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Handles existence filters and synthesizes deletes for filter mismatches.\r\n     * Targets that are invalidated by filter mismatches are added to\r\n     * `pendingTargetResets`.\r\n     */\r\n    handleExistenceFilter(watchChange) {\r\n        const targetId = watchChange.targetId;\r\n        const expectedCount = watchChange.existenceFilter.count;\r\n        const targetData = this.targetDataForActiveTarget(targetId);\r\n        if (targetData) {\r\n            const target = targetData.target;\r\n            if (targetIsDocumentTarget(target)) {\r\n                if (expectedCount === 0) {\r\n                    // The existence filter told us the document does not exist. We deduce\r\n                    // that this document does not exist and apply a deleted document to\r\n                    // our updates. Without applying this deleted document there might be\r\n                    // another query that will raise this document as part of a snapshot\r\n                    // until it is resolved, essentially exposing inconsistency between\r\n                    // queries.\r\n                    const key = new DocumentKey(target.path);\r\n                    this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));\r\n                }\r\n                else {\r\n                    hardAssert(expectedCount === 1);\r\n                }\r\n            }\r\n            else {\r\n                const currentSize = this.getCurrentDocumentCountForTarget(targetId);\r\n                if (currentSize !== expectedCount) {\r\n                    // Existence filter mismatch: We reset the mapping and raise a new\r\n                    // snapshot with `isFromCache:true`.\r\n                    this.resetTarget(targetId);\r\n                    this.pendingTargetResets = this.pendingTargetResets.add(targetId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Converts the currently accumulated state into a remote event at the\r\n     * provided snapshot version. Resets the accumulated changes before returning.\r\n     */\r\n    createRemoteEvent(snapshotVersion) {\r\n        const targetChanges = new Map();\r\n        this.targetStates.forEach((targetState, targetId) => {\r\n            const targetData = this.targetDataForActiveTarget(targetId);\r\n            if (targetData) {\r\n                if (targetState.current && targetIsDocumentTarget(targetData.target)) {\r\n                    // Document queries for document that don't exist can produce an empty\r\n                    // result set. To update our local cache, we synthesize a document\r\n                    // delete if we have not previously received the document. This\r\n                    // resolves the limbo state of the document, removing it from\r\n                    // limboDocumentRefs.\r\n                    //\r\n                    // TODO(dimond): Ideally we would have an explicit lookup target\r\n                    // instead resulting in an explicit delete message and we could\r\n                    // remove this special logic.\r\n                    const key = new DocumentKey(targetData.target.path);\r\n                    if (this.pendingDocumentUpdates.get(key) === null &&\r\n                        !this.targetContainsDocument(targetId, key)) {\r\n                        this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));\r\n                    }\r\n                }\r\n                if (targetState.hasPendingChanges) {\r\n                    targetChanges.set(targetId, targetState.toTargetChange());\r\n                    targetState.clearPendingChanges();\r\n                }\r\n            }\r\n        });\r\n        let resolvedLimboDocuments = documentKeySet();\r\n        // We extract the set of limbo-only document updates as the GC logic\r\n        // special-cases documents that do not appear in the target cache.\r\n        //\r\n        // TODO(gsoltis): Expand on this comment once GC is available in the JS\r\n        // client.\r\n        this.pendingDocumentTargetMapping.forEach((key, targets) => {\r\n            let isOnlyLimboTarget = true;\r\n            targets.forEachWhile(targetId => {\r\n                const targetData = this.targetDataForActiveTarget(targetId);\r\n                if (targetData &&\r\n                    targetData.purpose !== 2 /* LimboResolution */) {\r\n                    isOnlyLimboTarget = false;\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            if (isOnlyLimboTarget) {\r\n                resolvedLimboDocuments = resolvedLimboDocuments.add(key);\r\n            }\r\n        });\r\n        this.pendingDocumentUpdates.forEach((_, doc) => doc.setReadTime(snapshotVersion));\r\n        const remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);\r\n        this.pendingDocumentUpdates = mutableDocumentMap();\r\n        this.pendingDocumentTargetMapping = documentTargetMap();\r\n        this.pendingTargetResets = new SortedSet(primitiveComparator);\r\n        return remoteEvent;\r\n    }\r\n    /**\r\n     * Adds the provided document to the internal list of document updates and\r\n     * its document key to the given target's mapping.\r\n     */\r\n    // Visible for testing.\r\n    addDocumentToTarget(targetId, document) {\r\n        if (!this.isActiveTarget(targetId)) {\r\n            return;\r\n        }\r\n        const changeType = this.targetContainsDocument(targetId, document.key)\r\n            ? 2 /* Modified */\r\n            : 0 /* Added */;\r\n        const targetState = this.ensureTargetState(targetId);\r\n        targetState.addDocumentChange(document.key, changeType);\r\n        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document.key, document);\r\n        this.pendingDocumentTargetMapping =\r\n            this.pendingDocumentTargetMapping.insert(document.key, this.ensureDocumentTargetMapping(document.key).add(targetId));\r\n    }\r\n    /**\r\n     * Removes the provided document from the target mapping. If the\r\n     * document no longer matches the target, but the document's state is still\r\n     * known (e.g. we know that the document was deleted or we received the change\r\n     * that caused the filter mismatch), the new document can be provided\r\n     * to update the remote document cache.\r\n     */\r\n    // Visible for testing.\r\n    removeDocumentFromTarget(targetId, key, updatedDocument) {\r\n        if (!this.isActiveTarget(targetId)) {\r\n            return;\r\n        }\r\n        const targetState = this.ensureTargetState(targetId);\r\n        if (this.targetContainsDocument(targetId, key)) {\r\n            targetState.addDocumentChange(key, 1 /* Removed */);\r\n        }\r\n        else {\r\n            // The document may have entered and left the target before we raised a\r\n            // snapshot, so we can just ignore the change.\r\n            targetState.removeDocumentChange(key);\r\n        }\r\n        this.pendingDocumentTargetMapping =\r\n            this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));\r\n        if (updatedDocument) {\r\n            this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);\r\n        }\r\n    }\r\n    removeTarget(targetId) {\r\n        this.targetStates.delete(targetId);\r\n    }\r\n    /**\r\n     * Returns the current count of documents in the target. This includes both\r\n     * the number of documents that the LocalStore considers to be part of the\r\n     * target as well as any accumulated changes.\r\n     */\r\n    getCurrentDocumentCountForTarget(targetId) {\r\n        const targetState = this.ensureTargetState(targetId);\r\n        const targetChange = targetState.toTargetChange();\r\n        return (this.metadataProvider.getRemoteKeysForTarget(targetId).size +\r\n            targetChange.addedDocuments.size -\r\n            targetChange.removedDocuments.size);\r\n    }\r\n    /**\r\n     * Increment the number of acks needed from watch before we can consider the\r\n     * server to be 'in-sync' with the client's active targets.\r\n     */\r\n    recordPendingTargetRequest(targetId) {\r\n        // For each request we get we need to record we need a response for it.\r\n        const targetState = this.ensureTargetState(targetId);\r\n        targetState.recordPendingTargetRequest();\r\n    }\r\n    ensureTargetState(targetId) {\r\n        let result = this.targetStates.get(targetId);\r\n        if (!result) {\r\n            result = new TargetState();\r\n            this.targetStates.set(targetId, result);\r\n        }\r\n        return result;\r\n    }\r\n    ensureDocumentTargetMapping(key) {\r\n        let targetMapping = this.pendingDocumentTargetMapping.get(key);\r\n        if (!targetMapping) {\r\n            targetMapping = new SortedSet(primitiveComparator);\r\n            this.pendingDocumentTargetMapping =\r\n                this.pendingDocumentTargetMapping.insert(key, targetMapping);\r\n        }\r\n        return targetMapping;\r\n    }\r\n    /**\r\n     * Verifies that the user is still interested in this target (by calling\r\n     * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs\r\n     * from watch.\r\n     */\r\n    isActiveTarget(targetId) {\r\n        const targetActive = this.targetDataForActiveTarget(targetId) !== null;\r\n        if (!targetActive) {\r\n            logDebug(LOG_TAG$g, 'Detected inactive target', targetId);\r\n        }\r\n        return targetActive;\r\n    }\r\n    /**\r\n     * Returns the TargetData for an active target (i.e. a target that the user\r\n     * is still interested in that has no outstanding target change requests).\r\n     */\r\n    targetDataForActiveTarget(targetId) {\r\n        const targetState = this.targetStates.get(targetId);\r\n        return targetState && targetState.isPending\r\n            ? null\r\n            : this.metadataProvider.getTargetDataForTarget(targetId);\r\n    }\r\n    /**\r\n     * Resets the state of a Watch target to its initial state (e.g. sets\r\n     * 'current' to false, clears the resume token and removes its target mapping\r\n     * from all documents).\r\n     */\r\n    resetTarget(targetId) {\r\n        this.targetStates.set(targetId, new TargetState());\r\n        // Trigger removal for any documents currently mapped to this target.\r\n        // These removals will be part of the initial snapshot if Watch does not\r\n        // resend these documents.\r\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\r\n        existingKeys.forEach(key => {\r\n            this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\r\n        });\r\n    }\r\n    /**\r\n     * Returns whether the LocalStore considers the document to be part of the\r\n     * specified target.\r\n     */\r\n    targetContainsDocument(targetId, key) {\r\n        const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\r\n        return existingKeys.has(key);\r\n    }\r\n}\r\nfunction documentTargetMap() {\r\n    return new SortedMap(DocumentKey.comparator);\r\n}\r\nfunction snapshotChangesMap() {\r\n    return new SortedMap(DocumentKey.comparator);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DIRECTIONS = (() => {\r\n    const dirs = {};\r\n    dirs[\"asc\" /* ASCENDING */] = 'ASCENDING';\r\n    dirs[\"desc\" /* DESCENDING */] = 'DESCENDING';\r\n    return dirs;\r\n})();\r\nconst OPERATORS = (() => {\r\n    const ops = {};\r\n    ops[\"<\" /* LESS_THAN */] = 'LESS_THAN';\r\n    ops[\"<=\" /* LESS_THAN_OR_EQUAL */] = 'LESS_THAN_OR_EQUAL';\r\n    ops[\">\" /* GREATER_THAN */] = 'GREATER_THAN';\r\n    ops[\">=\" /* GREATER_THAN_OR_EQUAL */] = 'GREATER_THAN_OR_EQUAL';\r\n    ops[\"==\" /* EQUAL */] = 'EQUAL';\r\n    ops[\"!=\" /* NOT_EQUAL */] = 'NOT_EQUAL';\r\n    ops[\"array-contains\" /* ARRAY_CONTAINS */] = 'ARRAY_CONTAINS';\r\n    ops[\"in\" /* IN */] = 'IN';\r\n    ops[\"not-in\" /* NOT_IN */] = 'NOT_IN';\r\n    ops[\"array-contains-any\" /* ARRAY_CONTAINS_ANY */] = 'ARRAY_CONTAINS_ANY';\r\n    return ops;\r\n})();\r\nfunction assertPresent(value, description) {\r\n}\r\n/**\r\n * This class generates JsonObject values for the Datastore API suitable for\r\n * sending to either GRPC stub methods or via the JSON/HTTP REST API.\r\n *\r\n * The serializer supports both Protobuf.js and Proto3 JSON formats. By\r\n * setting `useProto3Json` to true, the serializer will use the Proto3 JSON\r\n * format.\r\n *\r\n * For a description of the Proto3 JSON format check\r\n * https://developers.google.com/protocol-buffers/docs/proto3#json\r\n *\r\n * TODO(klimt): We can remove the databaseId argument if we keep the full\r\n * resource name in documents.\r\n */\r\nclass JsonProtoSerializer {\r\n    constructor(databaseId, useProto3Json) {\r\n        this.databaseId = databaseId;\r\n        this.useProto3Json = useProto3Json;\r\n    }\r\n}\r\nfunction fromRpcStatus(status) {\r\n    const code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);\r\n    return new FirestoreError(code, status.message || '');\r\n}\r\n/**\r\n * Returns a value for a number (or null) that's appropriate to put into\r\n * a google.protobuf.Int32Value proto.\r\n * DO NOT USE THIS FOR ANYTHING ELSE.\r\n * This method cheats. It's typed as returning \"number\" because that's what\r\n * our generated proto interfaces say Int32Value must be. But GRPC actually\r\n * expects a { value: <number> } struct.\r\n */\r\nfunction toInt32Proto(serializer, val) {\r\n    if (serializer.useProto3Json || isNullOrUndefined(val)) {\r\n        return val;\r\n    }\r\n    else {\r\n        return { value: val };\r\n    }\r\n}\r\n/**\r\n * Returns a number (or null) from a google.protobuf.Int32Value proto.\r\n */\r\nfunction fromInt32Proto(val) {\r\n    let result;\r\n    if (typeof val === 'object') {\r\n        result = val.value;\r\n    }\r\n    else {\r\n        result = val;\r\n    }\r\n    return isNullOrUndefined(result) ? null : result;\r\n}\r\n/**\r\n * Returns a value for a Date that's appropriate to put into a proto.\r\n */\r\nfunction toTimestamp(serializer, timestamp) {\r\n    if (serializer.useProto3Json) {\r\n        // Serialize to ISO-8601 date format, but with full nano resolution.\r\n        // Since JS Date has only millis, let's only use it for the seconds and\r\n        // then manually add the fractions to the end.\r\n        const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();\r\n        // Remove .xxx frac part and Z in the end.\r\n        const strUntilSeconds = jsDateStr.replace(/\\.\\d*/, '').replace('Z', '');\r\n        // Pad the fraction out to 9 digits (nanos).\r\n        const nanoStr = ('000000000' + timestamp.nanoseconds).slice(-9);\r\n        return `${strUntilSeconds}.${nanoStr}Z`;\r\n    }\r\n    else {\r\n        return {\r\n            seconds: '' + timestamp.seconds,\r\n            nanos: timestamp.nanoseconds\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        };\r\n    }\r\n}\r\nfunction fromTimestamp(date) {\r\n    const timestamp = normalizeTimestamp(date);\r\n    return new Timestamp(timestamp.seconds, timestamp.nanos);\r\n}\r\n/**\r\n * Returns a value for bytes that's appropriate to put in a proto.\r\n *\r\n * Visible for testing.\r\n */\r\nfunction toBytes(serializer, bytes) {\r\n    if (serializer.useProto3Json) {\r\n        return bytes.toBase64();\r\n    }\r\n    else {\r\n        return bytes.toUint8Array();\r\n    }\r\n}\r\n/**\r\n * Returns a ByteString based on the proto string value.\r\n */\r\nfunction fromBytes(serializer, value) {\r\n    if (serializer.useProto3Json) {\r\n        hardAssert(value === undefined || typeof value === 'string');\r\n        return ByteString.fromBase64String(value ? value : '');\r\n    }\r\n    else {\r\n        hardAssert(value === undefined || value instanceof Uint8Array);\r\n        return ByteString.fromUint8Array(value ? value : new Uint8Array());\r\n    }\r\n}\r\nfunction toVersion(serializer, version) {\r\n    return toTimestamp(serializer, version.toTimestamp());\r\n}\r\nfunction fromVersion(version) {\r\n    hardAssert(!!version);\r\n    return SnapshotVersion.fromTimestamp(fromTimestamp(version));\r\n}\r\nfunction toResourceName(databaseId, path) {\r\n    return fullyQualifiedPrefixPath(databaseId)\r\n        .child('documents')\r\n        .child(path)\r\n        .canonicalString();\r\n}\r\nfunction fromResourceName(name) {\r\n    const resource = ResourcePath.fromString(name);\r\n    hardAssert(isValidResourceName(resource));\r\n    return resource;\r\n}\r\nfunction toName(serializer, key) {\r\n    return toResourceName(serializer.databaseId, key.path);\r\n}\r\nfunction fromName(serializer, name) {\r\n    const resource = fromResourceName(name);\r\n    if (resource.get(1) !== serializer.databaseId.projectId) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' +\r\n            resource.get(1) +\r\n            ' vs ' +\r\n            serializer.databaseId.projectId);\r\n    }\r\n    if (resource.get(3) !== serializer.databaseId.database) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' +\r\n            resource.get(3) +\r\n            ' vs ' +\r\n            serializer.databaseId.database);\r\n    }\r\n    return new DocumentKey(extractLocalPathFromResourceName(resource));\r\n}\r\nfunction toQueryPath(serializer, path) {\r\n    return toResourceName(serializer.databaseId, path);\r\n}\r\nfunction fromQueryPath(name) {\r\n    const resourceName = fromResourceName(name);\r\n    // In v1beta1 queries for collections at the root did not have a trailing\r\n    // \"/documents\". In v1 all resource paths contain \"/documents\". Preserve the\r\n    // ability to read the v1beta1 form for compatibility with queries persisted\r\n    // in the local target cache.\r\n    if (resourceName.length === 4) {\r\n        return ResourcePath.emptyPath();\r\n    }\r\n    return extractLocalPathFromResourceName(resourceName);\r\n}\r\nfunction getEncodedDatabaseId(serializer) {\r\n    const path = new ResourcePath([\r\n        'projects',\r\n        serializer.databaseId.projectId,\r\n        'databases',\r\n        serializer.databaseId.database\r\n    ]);\r\n    return path.canonicalString();\r\n}\r\nfunction fullyQualifiedPrefixPath(databaseId) {\r\n    return new ResourcePath([\r\n        'projects',\r\n        databaseId.projectId,\r\n        'databases',\r\n        databaseId.database\r\n    ]);\r\n}\r\nfunction extractLocalPathFromResourceName(resourceName) {\r\n    hardAssert(resourceName.length > 4 && resourceName.get(4) === 'documents');\r\n    return resourceName.popFirst(5);\r\n}\r\n/** Creates a Document proto from key and fields (but no create/update time) */\r\nfunction toMutationDocument(serializer, key, fields) {\r\n    return {\r\n        name: toName(serializer, key),\r\n        fields: fields.value.mapValue.fields\r\n    };\r\n}\r\nfunction toDocument(serializer, document) {\r\n    return {\r\n        name: toName(serializer, document.key),\r\n        fields: document.data.value.mapValue.fields,\r\n        updateTime: toTimestamp(serializer, document.version.toTimestamp())\r\n    };\r\n}\r\nfunction fromDocument(serializer, document, hasCommittedMutations) {\r\n    const key = fromName(serializer, document.name);\r\n    const version = fromVersion(document.updateTime);\r\n    const data = new ObjectValue({ mapValue: { fields: document.fields } });\r\n    const result = MutableDocument.newFoundDocument(key, version, data);\r\n    if (hasCommittedMutations) {\r\n        result.setHasCommittedMutations();\r\n    }\r\n    return hasCommittedMutations ? result.setHasCommittedMutations() : result;\r\n}\r\nfunction fromFound(serializer, doc) {\r\n    hardAssert(!!doc.found);\r\n    assertPresent(doc.found.name);\r\n    assertPresent(doc.found.updateTime);\r\n    const key = fromName(serializer, doc.found.name);\r\n    const version = fromVersion(doc.found.updateTime);\r\n    const data = new ObjectValue({ mapValue: { fields: doc.found.fields } });\r\n    return MutableDocument.newFoundDocument(key, version, data);\r\n}\r\nfunction fromMissing(serializer, result) {\r\n    hardAssert(!!result.missing);\r\n    hardAssert(!!result.readTime);\r\n    const key = fromName(serializer, result.missing);\r\n    const version = fromVersion(result.readTime);\r\n    return MutableDocument.newNoDocument(key, version);\r\n}\r\nfunction fromBatchGetDocumentsResponse(serializer, result) {\r\n    if ('found' in result) {\r\n        return fromFound(serializer, result);\r\n    }\r\n    else if ('missing' in result) {\r\n        return fromMissing(serializer, result);\r\n    }\r\n    return fail();\r\n}\r\nfunction fromWatchChange(serializer, change) {\r\n    let watchChange;\r\n    if ('targetChange' in change) {\r\n        assertPresent(change.targetChange);\r\n        // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\r\n        // if unset\r\n        const state = fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\r\n        const targetIds = change.targetChange.targetIds || [];\r\n        const resumeToken = fromBytes(serializer, change.targetChange.resumeToken);\r\n        const causeProto = change.targetChange.cause;\r\n        const cause = causeProto && fromRpcStatus(causeProto);\r\n        watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\r\n    }\r\n    else if ('documentChange' in change) {\r\n        assertPresent(change.documentChange);\r\n        const entityChange = change.documentChange;\r\n        assertPresent(entityChange.document);\r\n        assertPresent(entityChange.document.name);\r\n        assertPresent(entityChange.document.updateTime);\r\n        const key = fromName(serializer, entityChange.document.name);\r\n        const version = fromVersion(entityChange.document.updateTime);\r\n        const data = new ObjectValue({\r\n            mapValue: { fields: entityChange.document.fields }\r\n        });\r\n        const doc = MutableDocument.newFoundDocument(key, version, data);\r\n        const updatedTargetIds = entityChange.targetIds || [];\r\n        const removedTargetIds = entityChange.removedTargetIds || [];\r\n        watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\r\n    }\r\n    else if ('documentDelete' in change) {\r\n        assertPresent(change.documentDelete);\r\n        const docDelete = change.documentDelete;\r\n        assertPresent(docDelete.document);\r\n        const key = fromName(serializer, docDelete.document);\r\n        const version = docDelete.readTime\r\n            ? fromVersion(docDelete.readTime)\r\n            : SnapshotVersion.min();\r\n        const doc = MutableDocument.newNoDocument(key, version);\r\n        const removedTargetIds = docDelete.removedTargetIds || [];\r\n        watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\r\n    }\r\n    else if ('documentRemove' in change) {\r\n        assertPresent(change.documentRemove);\r\n        const docRemove = change.documentRemove;\r\n        assertPresent(docRemove.document);\r\n        const key = fromName(serializer, docRemove.document);\r\n        const removedTargetIds = docRemove.removedTargetIds || [];\r\n        watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\r\n    }\r\n    else if ('filter' in change) {\r\n        // TODO(dimond): implement existence filter parsing with strategy.\r\n        assertPresent(change.filter);\r\n        const filter = change.filter;\r\n        assertPresent(filter.targetId);\r\n        const count = filter.count || 0;\r\n        const existenceFilter = new ExistenceFilter(count);\r\n        const targetId = filter.targetId;\r\n        watchChange = new ExistenceFilterChange(targetId, existenceFilter);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    return watchChange;\r\n}\r\nfunction fromWatchTargetChangeState(state) {\r\n    if (state === 'NO_CHANGE') {\r\n        return 0 /* NoChange */;\r\n    }\r\n    else if (state === 'ADD') {\r\n        return 1 /* Added */;\r\n    }\r\n    else if (state === 'REMOVE') {\r\n        return 2 /* Removed */;\r\n    }\r\n    else if (state === 'CURRENT') {\r\n        return 3 /* Current */;\r\n    }\r\n    else if (state === 'RESET') {\r\n        return 4 /* Reset */;\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction versionFromListenResponse(change) {\r\n    // We have only reached a consistent snapshot for the entire stream if there\r\n    // is a read_time set and it applies to all targets (i.e. the list of\r\n    // targets is empty). The backend is guaranteed to send such responses.\r\n    if (!('targetChange' in change)) {\r\n        return SnapshotVersion.min();\r\n    }\r\n    const targetChange = change.targetChange;\r\n    if (targetChange.targetIds && targetChange.targetIds.length) {\r\n        return SnapshotVersion.min();\r\n    }\r\n    if (!targetChange.readTime) {\r\n        return SnapshotVersion.min();\r\n    }\r\n    return fromVersion(targetChange.readTime);\r\n}\r\nfunction toMutation(serializer, mutation) {\r\n    let result;\r\n    if (mutation instanceof SetMutation) {\r\n        result = {\r\n            update: toMutationDocument(serializer, mutation.key, mutation.value)\r\n        };\r\n    }\r\n    else if (mutation instanceof DeleteMutation) {\r\n        result = { delete: toName(serializer, mutation.key) };\r\n    }\r\n    else if (mutation instanceof PatchMutation) {\r\n        result = {\r\n            update: toMutationDocument(serializer, mutation.key, mutation.data),\r\n            updateMask: toDocumentMask(mutation.fieldMask)\r\n        };\r\n    }\r\n    else if (mutation instanceof VerifyMutation) {\r\n        result = {\r\n            verify: toName(serializer, mutation.key)\r\n        };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    if (mutation.fieldTransforms.length > 0) {\r\n        result.updateTransforms = mutation.fieldTransforms.map(transform => toFieldTransform(serializer, transform));\r\n    }\r\n    if (!mutation.precondition.isNone) {\r\n        result.currentDocument = toPrecondition(serializer, mutation.precondition);\r\n    }\r\n    return result;\r\n}\r\nfunction fromMutation(serializer, proto) {\r\n    const precondition = proto.currentDocument\r\n        ? fromPrecondition(proto.currentDocument)\r\n        : Precondition.none();\r\n    const fieldTransforms = proto.updateTransforms\r\n        ? proto.updateTransforms.map(transform => fromFieldTransform(serializer, transform))\r\n        : [];\r\n    if (proto.update) {\r\n        assertPresent(proto.update.name);\r\n        const key = fromName(serializer, proto.update.name);\r\n        const value = new ObjectValue({\r\n            mapValue: { fields: proto.update.fields }\r\n        });\r\n        if (proto.updateMask) {\r\n            const fieldMask = fromDocumentMask(proto.updateMask);\r\n            return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);\r\n        }\r\n        else {\r\n            return new SetMutation(key, value, precondition, fieldTransforms);\r\n        }\r\n    }\r\n    else if (proto.delete) {\r\n        const key = fromName(serializer, proto.delete);\r\n        return new DeleteMutation(key, precondition);\r\n    }\r\n    else if (proto.verify) {\r\n        const key = fromName(serializer, proto.verify);\r\n        return new VerifyMutation(key, precondition);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction toPrecondition(serializer, precondition) {\r\n    if (precondition.updateTime !== undefined) {\r\n        return {\r\n            updateTime: toVersion(serializer, precondition.updateTime)\r\n        };\r\n    }\r\n    else if (precondition.exists !== undefined) {\r\n        return { exists: precondition.exists };\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction fromPrecondition(precondition) {\r\n    if (precondition.updateTime !== undefined) {\r\n        return Precondition.updateTime(fromVersion(precondition.updateTime));\r\n    }\r\n    else if (precondition.exists !== undefined) {\r\n        return Precondition.exists(precondition.exists);\r\n    }\r\n    else {\r\n        return Precondition.none();\r\n    }\r\n}\r\nfunction fromWriteResult(proto, commitTime) {\r\n    // NOTE: Deletes don't have an updateTime.\r\n    let version = proto.updateTime\r\n        ? fromVersion(proto.updateTime)\r\n        : fromVersion(commitTime);\r\n    if (version.isEqual(SnapshotVersion.min())) {\r\n        // The Firestore Emulator currently returns an update time of 0 for\r\n        // deletes of non-existing documents (rather than null). This breaks the\r\n        // test \"get deleted doc while offline with source=cache\" as NoDocuments\r\n        // with version 0 are filtered by IndexedDb's RemoteDocumentCache.\r\n        // TODO(#2149): Remove this when Emulator is fixed\r\n        version = fromVersion(commitTime);\r\n    }\r\n    return new MutationResult(version, proto.transformResults || []);\r\n}\r\nfunction fromWriteResults(protos, commitTime) {\r\n    if (protos && protos.length > 0) {\r\n        hardAssert(commitTime !== undefined);\r\n        return protos.map(proto => fromWriteResult(proto, commitTime));\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\nfunction toFieldTransform(serializer, fieldTransform) {\r\n    const transform = fieldTransform.transform;\r\n    if (transform instanceof ServerTimestampTransform) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            setToServerValue: 'REQUEST_TIME'\r\n        };\r\n    }\r\n    else if (transform instanceof ArrayUnionTransformOperation) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            appendMissingElements: {\r\n                values: transform.elements\r\n            }\r\n        };\r\n    }\r\n    else if (transform instanceof ArrayRemoveTransformOperation) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            removeAllFromArray: {\r\n                values: transform.elements\r\n            }\r\n        };\r\n    }\r\n    else if (transform instanceof NumericIncrementTransformOperation) {\r\n        return {\r\n            fieldPath: fieldTransform.field.canonicalString(),\r\n            increment: transform.operand\r\n        };\r\n    }\r\n    else {\r\n        throw fail();\r\n    }\r\n}\r\nfunction fromFieldTransform(serializer, proto) {\r\n    let transform = null;\r\n    if ('setToServerValue' in proto) {\r\n        hardAssert(proto.setToServerValue === 'REQUEST_TIME');\r\n        transform = new ServerTimestampTransform();\r\n    }\r\n    else if ('appendMissingElements' in proto) {\r\n        const values = proto.appendMissingElements.values || [];\r\n        transform = new ArrayUnionTransformOperation(values);\r\n    }\r\n    else if ('removeAllFromArray' in proto) {\r\n        const values = proto.removeAllFromArray.values || [];\r\n        transform = new ArrayRemoveTransformOperation(values);\r\n    }\r\n    else if ('increment' in proto) {\r\n        transform = new NumericIncrementTransformOperation(serializer, proto.increment);\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n    const fieldPath = FieldPath$1.fromServerFormat(proto.fieldPath);\r\n    return new FieldTransform(fieldPath, transform);\r\n}\r\nfunction toDocumentsTarget(serializer, target) {\r\n    return { documents: [toQueryPath(serializer, target.path)] };\r\n}\r\nfunction fromDocumentsTarget(documentsTarget) {\r\n    const count = documentsTarget.documents.length;\r\n    hardAssert(count === 1);\r\n    const name = documentsTarget.documents[0];\r\n    return queryToTarget(newQueryForPath(fromQueryPath(name)));\r\n}\r\nfunction toQueryTarget(serializer, target) {\r\n    // Dissect the path into parent, collectionId, and optional key filter.\r\n    const result = { structuredQuery: {} };\r\n    const path = target.path;\r\n    if (target.collectionGroup !== null) {\r\n        result.parent = toQueryPath(serializer, path);\r\n        result.structuredQuery.from = [\r\n            {\r\n                collectionId: target.collectionGroup,\r\n                allDescendants: true\r\n            }\r\n        ];\r\n    }\r\n    else {\r\n        result.parent = toQueryPath(serializer, path.popLast());\r\n        result.structuredQuery.from = [{ collectionId: path.lastSegment() }];\r\n    }\r\n    const where = toFilter(target.filters);\r\n    if (where) {\r\n        result.structuredQuery.where = where;\r\n    }\r\n    const orderBy = toOrder(target.orderBy);\r\n    if (orderBy) {\r\n        result.structuredQuery.orderBy = orderBy;\r\n    }\r\n    const limit = toInt32Proto(serializer, target.limit);\r\n    if (limit !== null) {\r\n        result.structuredQuery.limit = limit;\r\n    }\r\n    if (target.startAt) {\r\n        result.structuredQuery.startAt = toStartAtCursor(target.startAt);\r\n    }\r\n    if (target.endAt) {\r\n        result.structuredQuery.endAt = toEndAtCursor(target.endAt);\r\n    }\r\n    return result;\r\n}\r\nfunction convertQueryTargetToQuery(target) {\r\n    let path = fromQueryPath(target.parent);\r\n    const query = target.structuredQuery;\r\n    const fromCount = query.from ? query.from.length : 0;\r\n    let collectionGroup = null;\r\n    if (fromCount > 0) {\r\n        hardAssert(fromCount === 1);\r\n        const from = query.from[0];\r\n        if (from.allDescendants) {\r\n            collectionGroup = from.collectionId;\r\n        }\r\n        else {\r\n            path = path.child(from.collectionId);\r\n        }\r\n    }\r\n    let filterBy = [];\r\n    if (query.where) {\r\n        filterBy = fromFilter(query.where);\r\n    }\r\n    let orderBy = [];\r\n    if (query.orderBy) {\r\n        orderBy = fromOrder(query.orderBy);\r\n    }\r\n    let limit = null;\r\n    if (query.limit) {\r\n        limit = fromInt32Proto(query.limit);\r\n    }\r\n    let startAt = null;\r\n    if (query.startAt) {\r\n        startAt = fromStartAtCursor(query.startAt);\r\n    }\r\n    let endAt = null;\r\n    if (query.endAt) {\r\n        endAt = fromEndAtCursor(query.endAt);\r\n    }\r\n    return newQuery(path, collectionGroup, orderBy, filterBy, limit, \"F\" /* First */, startAt, endAt);\r\n}\r\nfunction fromQueryTarget(target) {\r\n    return queryToTarget(convertQueryTargetToQuery(target));\r\n}\r\nfunction toListenRequestLabels(serializer, targetData) {\r\n    const value = toLabel(serializer, targetData.purpose);\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    else {\r\n        return {\r\n            'goog-listen-tags': value\r\n        };\r\n    }\r\n}\r\nfunction toLabel(serializer, purpose) {\r\n    switch (purpose) {\r\n        case 0 /* Listen */:\r\n            return null;\r\n        case 1 /* ExistenceFilterMismatch */:\r\n            return 'existence-filter-mismatch';\r\n        case 2 /* LimboResolution */:\r\n            return 'limbo-document';\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction toTarget(serializer, targetData) {\r\n    let result;\r\n    const target = targetData.target;\r\n    if (targetIsDocumentTarget(target)) {\r\n        result = { documents: toDocumentsTarget(serializer, target) };\r\n    }\r\n    else {\r\n        result = { query: toQueryTarget(serializer, target) };\r\n    }\r\n    result.targetId = targetData.targetId;\r\n    if (targetData.resumeToken.approximateByteSize() > 0) {\r\n        result.resumeToken = toBytes(serializer, targetData.resumeToken);\r\n    }\r\n    else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {\r\n        // TODO(wuandy): Consider removing above check because it is most likely true.\r\n        // Right now, many tests depend on this behaviour though (leaving min() out\r\n        // of serialization).\r\n        result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());\r\n    }\r\n    return result;\r\n}\r\nfunction toFilter(filters) {\r\n    if (filters.length === 0) {\r\n        return;\r\n    }\r\n    const protos = filters.map(filter => {\r\n        return toUnaryOrFieldFilter(filter);\r\n    });\r\n    if (protos.length === 1) {\r\n        return protos[0];\r\n    }\r\n    return { compositeFilter: { op: 'AND', filters: protos } };\r\n}\r\nfunction fromFilter(filter) {\r\n    if (!filter) {\r\n        return [];\r\n    }\r\n    else if (filter.unaryFilter !== undefined) {\r\n        return [fromUnaryFilter(filter)];\r\n    }\r\n    else if (filter.fieldFilter !== undefined) {\r\n        return [fromFieldFilter(filter)];\r\n    }\r\n    else if (filter.compositeFilter !== undefined) {\r\n        return filter.compositeFilter\r\n            .filters.map(f => fromFilter(f))\r\n            .reduce((accum, current) => accum.concat(current));\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction toOrder(orderBys) {\r\n    if (orderBys.length === 0) {\r\n        return;\r\n    }\r\n    return orderBys.map(order => toPropertyOrder(order));\r\n}\r\nfunction fromOrder(orderBys) {\r\n    return orderBys.map(order => fromPropertyOrder(order));\r\n}\r\nfunction toStartAtCursor(cursor) {\r\n    return {\r\n        before: cursor.inclusive,\r\n        values: cursor.position\r\n    };\r\n}\r\nfunction toEndAtCursor(cursor) {\r\n    return {\r\n        before: !cursor.inclusive,\r\n        values: cursor.position\r\n    };\r\n}\r\nfunction fromStartAtCursor(cursor) {\r\n    const inclusive = !!cursor.before;\r\n    const position = cursor.values || [];\r\n    return new Bound(position, inclusive);\r\n}\r\nfunction fromEndAtCursor(cursor) {\r\n    const inclusive = !cursor.before;\r\n    const position = cursor.values || [];\r\n    return new Bound(position, inclusive);\r\n}\r\n// visible for testing\r\nfunction toDirection(dir) {\r\n    return DIRECTIONS[dir];\r\n}\r\n// visible for testing\r\nfunction fromDirection(dir) {\r\n    switch (dir) {\r\n        case 'ASCENDING':\r\n            return \"asc\" /* ASCENDING */;\r\n        case 'DESCENDING':\r\n            return \"desc\" /* DESCENDING */;\r\n        default:\r\n            return undefined;\r\n    }\r\n}\r\n// visible for testing\r\nfunction toOperatorName(op) {\r\n    return OPERATORS[op];\r\n}\r\nfunction fromOperatorName(op) {\r\n    switch (op) {\r\n        case 'EQUAL':\r\n            return \"==\" /* EQUAL */;\r\n        case 'NOT_EQUAL':\r\n            return \"!=\" /* NOT_EQUAL */;\r\n        case 'GREATER_THAN':\r\n            return \">\" /* GREATER_THAN */;\r\n        case 'GREATER_THAN_OR_EQUAL':\r\n            return \">=\" /* GREATER_THAN_OR_EQUAL */;\r\n        case 'LESS_THAN':\r\n            return \"<\" /* LESS_THAN */;\r\n        case 'LESS_THAN_OR_EQUAL':\r\n            return \"<=\" /* LESS_THAN_OR_EQUAL */;\r\n        case 'ARRAY_CONTAINS':\r\n            return \"array-contains\" /* ARRAY_CONTAINS */;\r\n        case 'IN':\r\n            return \"in\" /* IN */;\r\n        case 'NOT_IN':\r\n            return \"not-in\" /* NOT_IN */;\r\n        case 'ARRAY_CONTAINS_ANY':\r\n            return \"array-contains-any\" /* ARRAY_CONTAINS_ANY */;\r\n        case 'OPERATOR_UNSPECIFIED':\r\n            return fail();\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction toFieldPathReference(path) {\r\n    return { fieldPath: path.canonicalString() };\r\n}\r\nfunction fromFieldPathReference(fieldReference) {\r\n    return FieldPath$1.fromServerFormat(fieldReference.fieldPath);\r\n}\r\n// visible for testing\r\nfunction toPropertyOrder(orderBy) {\r\n    return {\r\n        field: toFieldPathReference(orderBy.field),\r\n        direction: toDirection(orderBy.dir)\r\n    };\r\n}\r\nfunction fromPropertyOrder(orderBy) {\r\n    return new OrderBy(fromFieldPathReference(orderBy.field), fromDirection(orderBy.direction));\r\n}\r\nfunction fromFieldFilter(filter) {\r\n    return FieldFilter.create(fromFieldPathReference(filter.fieldFilter.field), fromOperatorName(filter.fieldFilter.op), filter.fieldFilter.value);\r\n}\r\n// visible for testing\r\nfunction toUnaryOrFieldFilter(filter) {\r\n    if (filter.op === \"==\" /* EQUAL */) {\r\n        if (isNanValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NAN'\r\n                }\r\n            };\r\n        }\r\n        else if (isNullValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NULL'\r\n                }\r\n            };\r\n        }\r\n    }\r\n    else if (filter.op === \"!=\" /* NOT_EQUAL */) {\r\n        if (isNanValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NOT_NAN'\r\n                }\r\n            };\r\n        }\r\n        else if (isNullValue(filter.value)) {\r\n            return {\r\n                unaryFilter: {\r\n                    field: toFieldPathReference(filter.field),\r\n                    op: 'IS_NOT_NULL'\r\n                }\r\n            };\r\n        }\r\n    }\r\n    return {\r\n        fieldFilter: {\r\n            field: toFieldPathReference(filter.field),\r\n            op: toOperatorName(filter.op),\r\n            value: filter.value\r\n        }\r\n    };\r\n}\r\nfunction fromUnaryFilter(filter) {\r\n    switch (filter.unaryFilter.op) {\r\n        case 'IS_NAN':\r\n            const nanField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(nanField, \"==\" /* EQUAL */, {\r\n                doubleValue: NaN\r\n            });\r\n        case 'IS_NULL':\r\n            const nullField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(nullField, \"==\" /* EQUAL */, {\r\n                nullValue: 'NULL_VALUE'\r\n            });\r\n        case 'IS_NOT_NAN':\r\n            const notNanField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(notNanField, \"!=\" /* NOT_EQUAL */, {\r\n                doubleValue: NaN\r\n            });\r\n        case 'IS_NOT_NULL':\r\n            const notNullField = fromFieldPathReference(filter.unaryFilter.field);\r\n            return FieldFilter.create(notNullField, \"!=\" /* NOT_EQUAL */, {\r\n                nullValue: 'NULL_VALUE'\r\n            });\r\n        case 'OPERATOR_UNSPECIFIED':\r\n            return fail();\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\nfunction toDocumentMask(fieldMask) {\r\n    const canonicalFields = [];\r\n    fieldMask.fields.forEach(field => canonicalFields.push(field.canonicalString()));\r\n    return {\r\n        fieldPaths: canonicalFields\r\n    };\r\n}\r\nfunction fromDocumentMask(proto) {\r\n    const paths = proto.fieldPaths || [];\r\n    return new FieldMask(paths.map(path => FieldPath$1.fromServerFormat(path)));\r\n}\r\nfunction isValidResourceName(path) {\r\n    // Resource names have at least 4 components (project ID, database ID)\r\n    return (path.length >= 4 &&\r\n        path.get(0) === 'projects' &&\r\n        path.get(2) === 'databases');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable set of metadata that the local store tracks for each target.\r\n */\r\nclass TargetData {\r\n    constructor(\r\n    /** The target being listened to. */\r\n    target, \r\n    /**\r\n     * The target ID to which the target corresponds; Assigned by the\r\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\r\n     */\r\n    targetId, \r\n    /** The purpose of the target. */\r\n    purpose, \r\n    /**\r\n     * The sequence number of the last transaction during which this target data\r\n     * was modified.\r\n     */\r\n    sequenceNumber, \r\n    /** The latest snapshot version seen for this target. */\r\n    snapshotVersion = SnapshotVersion.min(), \r\n    /**\r\n     * The maximum snapshot version at which the associated view\r\n     * contained no limbo documents.\r\n     */\r\n    lastLimboFreeSnapshotVersion = SnapshotVersion.min(), \r\n    /**\r\n     * An opaque, server-assigned token that allows watching a target to be\r\n     * resumed after disconnecting without retransmitting all the data that\r\n     * matches the target. The resume token essentially identifies a point in\r\n     * time from which the server should resume sending results.\r\n     */\r\n    resumeToken = ByteString.EMPTY_BYTE_STRING) {\r\n        this.target = target;\r\n        this.targetId = targetId;\r\n        this.purpose = purpose;\r\n        this.sequenceNumber = sequenceNumber;\r\n        this.snapshotVersion = snapshotVersion;\r\n        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;\r\n        this.resumeToken = resumeToken;\r\n    }\r\n    /** Creates a new target data instance with an updated sequence number. */\r\n    withSequenceNumber(sequenceNumber) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);\r\n    }\r\n    /**\r\n     * Creates a new target data instance with an updated resume token and\r\n     * snapshot version.\r\n     */\r\n    withResumeToken(resumeToken, snapshotVersion) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken);\r\n    }\r\n    /**\r\n     * Creates a new target data instance with an updated last limbo free\r\n     * snapshot version number.\r\n     */\r\n    withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion) {\r\n        return new TargetData(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Serializer for values stored in the LocalStore. */\r\nclass LocalSerializer {\r\n    constructor(remoteSerializer) {\r\n        this.remoteSerializer = remoteSerializer;\r\n    }\r\n}\r\n/** Decodes a remote document from storage locally to a Document. */\r\nfunction fromDbRemoteDocument(localSerializer, remoteDoc) {\r\n    let doc;\r\n    if (remoteDoc.document) {\r\n        doc = fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);\r\n    }\r\n    else if (remoteDoc.noDocument) {\r\n        const key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\r\n        const version = fromDbTimestamp(remoteDoc.noDocument.readTime);\r\n        doc = MutableDocument.newNoDocument(key, version);\r\n        if (remoteDoc.hasCommittedMutations) {\r\n            doc.setHasCommittedMutations();\r\n        }\r\n    }\r\n    else if (remoteDoc.unknownDocument) {\r\n        const key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);\r\n        const version = fromDbTimestamp(remoteDoc.unknownDocument.version);\r\n        doc = MutableDocument.newUnknownDocument(key, version);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n    if (remoteDoc.readTime) {\r\n        doc.setReadTime(fromDbTimestampKey(remoteDoc.readTime));\r\n    }\r\n    return doc;\r\n}\r\n/** Encodes a document for storage locally. */\r\nfunction toDbRemoteDocument(localSerializer, document) {\r\n    const dbReadTime = toDbTimestampKey(document.readTime);\r\n    const parentPath = document.key.path.popLast().toArray();\r\n    if (document.isFoundDocument()) {\r\n        const doc = toDocument(localSerializer.remoteSerializer, document);\r\n        const hasCommittedMutations = document.hasCommittedMutations;\r\n        return new DbRemoteDocument(\r\n        /* unknownDocument= */ null, \r\n        /* noDocument= */ null, doc, hasCommittedMutations, dbReadTime, parentPath);\r\n    }\r\n    else if (document.isNoDocument()) {\r\n        const path = document.key.path.toArray();\r\n        const version = toDbTimestamp(document.version);\r\n        const hasCommittedMutations = document.hasCommittedMutations;\r\n        return new DbRemoteDocument(\r\n        /* unknownDocument= */ null, new DbNoDocument(path, version), \r\n        /* document= */ null, hasCommittedMutations, dbReadTime, parentPath);\r\n    }\r\n    else if (document.isUnknownDocument()) {\r\n        const path = document.key.path.toArray();\r\n        const readTime = toDbTimestamp(document.version);\r\n        return new DbRemoteDocument(new DbUnknownDocument(path, readTime), \r\n        /* noDocument= */ null, \r\n        /* document= */ null, \r\n        /* hasCommittedMutations= */ true, dbReadTime, parentPath);\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\nfunction toDbTimestampKey(snapshotVersion) {\r\n    const timestamp = snapshotVersion.toTimestamp();\r\n    return [timestamp.seconds, timestamp.nanoseconds];\r\n}\r\nfunction fromDbTimestampKey(dbTimestampKey) {\r\n    const timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);\r\n    return SnapshotVersion.fromTimestamp(timestamp);\r\n}\r\nfunction toDbTimestamp(snapshotVersion) {\r\n    const timestamp = snapshotVersion.toTimestamp();\r\n    return new DbTimestamp(timestamp.seconds, timestamp.nanoseconds);\r\n}\r\nfunction fromDbTimestamp(dbTimestamp) {\r\n    const timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);\r\n    return SnapshotVersion.fromTimestamp(timestamp);\r\n}\r\n/** Encodes a batch of mutations into a DbMutationBatch for local storage. */\r\nfunction toDbMutationBatch(localSerializer, userId, batch) {\r\n    const serializedBaseMutations = batch.baseMutations.map(m => toMutation(localSerializer.remoteSerializer, m));\r\n    const serializedMutations = batch.mutations.map(m => toMutation(localSerializer.remoteSerializer, m));\r\n    return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toMillis(), serializedBaseMutations, serializedMutations);\r\n}\r\n/** Decodes a DbMutationBatch into a MutationBatch */\r\nfunction fromDbMutationBatch(localSerializer, dbBatch) {\r\n    const baseMutations = (dbBatch.baseMutations || []).map(m => fromMutation(localSerializer.remoteSerializer, m));\r\n    // Squash old transform mutations into existing patch or set mutations.\r\n    // The replacement of representing `transforms` with `update_transforms`\r\n    // on the SDK means that old `transform` mutations stored in IndexedDB need\r\n    // to be updated to `update_transforms`.\r\n    // TODO(b/174608374): Remove this code once we perform a schema migration.\r\n    for (let i = 0; i < dbBatch.mutations.length - 1; ++i) {\r\n        const currentMutation = dbBatch.mutations[i];\r\n        const hasTransform = i + 1 < dbBatch.mutations.length &&\r\n            dbBatch.mutations[i + 1].transform !== undefined;\r\n        if (hasTransform) {\r\n            const transformMutation = dbBatch.mutations[i + 1];\r\n            currentMutation.updateTransforms =\r\n                transformMutation.transform.fieldTransforms;\r\n            dbBatch.mutations.splice(i + 1, 1);\r\n            ++i;\r\n        }\r\n    }\r\n    const mutations = dbBatch.mutations.map(m => fromMutation(localSerializer.remoteSerializer, m));\r\n    const timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);\r\n    return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);\r\n}\r\n/** Decodes a DbTarget into TargetData */\r\nfunction fromDbTarget(dbTarget) {\r\n    const version = fromDbTimestamp(dbTarget.readTime);\r\n    const lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== undefined\r\n        ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion)\r\n        : SnapshotVersion.min();\r\n    let target;\r\n    if (isDocumentQuery(dbTarget.query)) {\r\n        target = fromDocumentsTarget(dbTarget.query);\r\n    }\r\n    else {\r\n        target = fromQueryTarget(dbTarget.query);\r\n    }\r\n    return new TargetData(target, dbTarget.targetId, 0 /* Listen */, dbTarget.lastListenSequenceNumber, version, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));\r\n}\r\n/** Encodes TargetData into a DbTarget for storage locally. */\r\nfunction toDbTarget(localSerializer, targetData) {\r\n    const dbTimestamp = toDbTimestamp(targetData.snapshotVersion);\r\n    const dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);\r\n    let queryProto;\r\n    if (targetIsDocumentTarget(targetData.target)) {\r\n        queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);\r\n    }\r\n    else {\r\n        queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target);\r\n    }\r\n    // We can't store the resumeToken as a ByteString in IndexedDb, so we\r\n    // convert it to a base64 string for storage.\r\n    const resumeToken = targetData.resumeToken.toBase64();\r\n    // lastListenSequenceNumber is always 0 until we do real GC.\r\n    return new DbTarget(targetData.targetId, canonifyTarget(targetData.target), dbTimestamp, resumeToken, targetData.sequenceNumber, dbLastLimboFreeTimestamp, queryProto);\r\n}\r\n/**\r\n * A helper function for figuring out what kind of query has been stored.\r\n */\r\nfunction isDocumentQuery(dbQuery) {\r\n    return dbQuery.documents !== undefined;\r\n}\r\n/** Encodes a DbBundle to a BundleMetadata object. */\r\nfunction fromDbBundle(dbBundle) {\r\n    return {\r\n        id: dbBundle.bundleId,\r\n        createTime: fromDbTimestamp(dbBundle.createTime),\r\n        version: dbBundle.version\r\n    };\r\n}\r\n/** Encodes a BundleMetadata to a DbBundle. */\r\nfunction toDbBundle(metadata) {\r\n    return {\r\n        bundleId: metadata.id,\r\n        createTime: toDbTimestamp(fromVersion(metadata.createTime)),\r\n        version: metadata.version\r\n    };\r\n}\r\n/** Encodes a DbNamedQuery to a NamedQuery. */\r\nfunction fromDbNamedQuery(dbNamedQuery) {\r\n    return {\r\n        name: dbNamedQuery.name,\r\n        query: fromBundledQuery(dbNamedQuery.bundledQuery),\r\n        readTime: fromDbTimestamp(dbNamedQuery.readTime)\r\n    };\r\n}\r\n/** Encodes a NamedQuery from a bundle proto to a DbNamedQuery. */\r\nfunction toDbNamedQuery(query) {\r\n    return {\r\n        name: query.name,\r\n        readTime: toDbTimestamp(fromVersion(query.readTime)),\r\n        bundledQuery: query.bundledQuery\r\n    };\r\n}\r\n/**\r\n * Encodes a `BundledQuery` from bundle proto to a Query object.\r\n *\r\n * This reconstructs the original query used to build the bundle being loaded,\r\n * including features exists only in SDKs (for example: limit-to-last).\r\n */\r\nfunction fromBundledQuery(bundledQuery) {\r\n    const query = convertQueryTargetToQuery({\r\n        parent: bundledQuery.parent,\r\n        structuredQuery: bundledQuery.structuredQuery\r\n    });\r\n    if (bundledQuery.limitType === 'LAST') {\r\n        return queryWithLimit(query, query.limit, \"L\" /* Last */);\r\n    }\r\n    return query;\r\n}\r\n/** Encodes a NamedQuery proto object to a NamedQuery model object. */\r\nfunction fromProtoNamedQuery(namedQuery) {\r\n    return {\r\n        name: namedQuery.name,\r\n        query: fromBundledQuery(namedQuery.bundledQuery),\r\n        readTime: fromVersion(namedQuery.readTime)\r\n    };\r\n}\r\n/** Decodes a BundleMetadata proto into a BundleMetadata object. */\r\nfunction fromBundleMetadata(metadata) {\r\n    return {\r\n        id: metadata.id,\r\n        version: metadata.version,\r\n        createTime: fromVersion(metadata.createTime)\r\n    };\r\n}\r\n/** Encodes a DbDocumentOverlay object to an Overlay model object. */\r\nfunction fromDbDocumentOverlay(localSerializer, dbDocumentOverlay) {\r\n    return new Overlay(dbDocumentOverlay.largestBatchId, fromMutation(localSerializer.remoteSerializer, dbDocumentOverlay.overlayMutation));\r\n}\r\n/** Decodes an Overlay model object into a DbDocumentOverlay object. */\r\nfunction toDbDocumentOverlay(localSerializer, userId, overlay) {\r\n    const [_, collectionPath, documentId] = toDbDocumentOverlayKey(userId, overlay.mutation.key);\r\n    return new DbDocumentOverlay(userId, collectionPath, documentId, overlay.mutation.key.getCollectionGroup(), overlay.largestBatchId, toMutation(localSerializer.remoteSerializer, overlay.mutation));\r\n}\r\n/**\r\n * Returns the DbDocumentOverlayKey corresponding to the given user and\r\n * document key.\r\n */\r\nfunction toDbDocumentOverlayKey(userId, docKey) {\r\n    const docId = docKey.path.lastSegment();\r\n    const collectionPath = encodeResourcePath(docKey.path.popLast());\r\n    return [userId, collectionPath, docId];\r\n}\r\nfunction toDbIndexConfiguration(index) {\r\n    return new DbIndexConfiguration(index.indexId, index.collectionGroup, index.fields.map(s => [s.fieldPath.canonicalString(), s.kind]));\r\n}\r\nfunction fromDbIndexConfiguration(index, state) {\r\n    const decodedState = state\r\n        ? new IndexState(state.sequenceNumber, new IndexOffset(fromDbTimestamp(state.readTime), new DocumentKey(decodeResourcePath(state.documentKey)), state.largestBatchId))\r\n        : IndexState.empty();\r\n    const decodedSegments = index.fields.map(([fieldPath, kind]) => new IndexSegment(FieldPath$1.fromServerFormat(fieldPath), kind));\r\n    return new FieldIndex(index.indexId, index.collectionGroup, decodedSegments, decodedState);\r\n}\r\nfunction toDbIndexState(indexId, user, sequenceNumber, offset) {\r\n    return new DbIndexState(indexId, user.uid || '', sequenceNumber, toDbTimestamp(offset.readTime), encodeResourcePath(offset.documentKey.path), offset.largestBatchId);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass IndexedDbBundleCache {\r\n    getBundleMetadata(transaction, bundleId) {\r\n        return bundlesStore(transaction)\r\n            .get(bundleId)\r\n            .next(bundle => {\r\n            if (bundle) {\r\n                return fromDbBundle(bundle);\r\n            }\r\n            return undefined;\r\n        });\r\n    }\r\n    saveBundleMetadata(transaction, bundleMetadata) {\r\n        return bundlesStore(transaction).put(toDbBundle(bundleMetadata));\r\n    }\r\n    getNamedQuery(transaction, queryName) {\r\n        return namedQueriesStore(transaction)\r\n            .get(queryName)\r\n            .next(query => {\r\n            if (query) {\r\n                return fromDbNamedQuery(query);\r\n            }\r\n            return undefined;\r\n        });\r\n    }\r\n    saveNamedQuery(transaction, query) {\r\n        return namedQueriesStore(transaction).put(toDbNamedQuery(query));\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the bundles object store.\r\n */\r\nfunction bundlesStore(txn) {\r\n    return getStore(txn, DbBundle.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the namedQueries object store.\r\n */\r\nfunction namedQueriesStore(txn) {\r\n    return getStore(txn, DbNamedQuery.store);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Implementation of DocumentOverlayCache using IndexedDb.\r\n */\r\nclass IndexedDbDocumentOverlayCache {\r\n    /**\r\n     * @param serializer - The document serializer.\r\n     * @param userId - The userId for which we are accessing overlays.\r\n     */\r\n    constructor(serializer, userId) {\r\n        this.serializer = serializer;\r\n        this.userId = userId;\r\n    }\r\n    static forUser(serializer, user) {\r\n        const userId = user.uid || '';\r\n        return new IndexedDbDocumentOverlayCache(serializer, userId);\r\n    }\r\n    getOverlay(transaction, key) {\r\n        return documentOverlayStore(transaction)\r\n            .get(toDbDocumentOverlayKey(this.userId, key))\r\n            .next(dbOverlay => {\r\n            if (dbOverlay) {\r\n                return fromDbDocumentOverlay(this.serializer, dbOverlay);\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    saveOverlays(transaction, largestBatchId, overlays) {\r\n        const promises = [];\r\n        overlays.forEach(mutation => {\r\n            const overlay = new Overlay(largestBatchId, mutation);\r\n            promises.push(this.saveOverlay(transaction, overlay));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\r\n        const collectionPaths = new Set();\r\n        // Get the set of unique collection paths.\r\n        documentKeys.forEach(key => collectionPaths.add(encodeResourcePath(key.getCollectionPath())));\r\n        const promises = [];\r\n        collectionPaths.forEach(collectionPath => {\r\n            const range = IDBKeyRange.bound([this.userId, collectionPath, batchId], [this.userId, collectionPath, batchId + 1], \r\n            /*lowerOpen=*/ false, \r\n            /*upperOpen=*/ true);\r\n            promises.push(documentOverlayStore(transaction).deleteAll(DbDocumentOverlay.collectionPathOverlayIndex, range));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\r\n        const result = new Map();\r\n        const collectionPath = encodeResourcePath(collection);\r\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\r\n        // is not inclusive.\r\n        const range = IDBKeyRange.bound([this.userId, collectionPath, sinceBatchId], [this.userId, collectionPath, Number.POSITIVE_INFINITY], \r\n        /*lowerOpen=*/ true);\r\n        return documentOverlayStore(transaction)\r\n            .loadAll(DbDocumentOverlay.collectionPathOverlayIndex, range)\r\n            .next(dbOverlays => {\r\n            for (const dbOverlay of dbOverlays) {\r\n                const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\r\n                result.set(overlay.getKey(), overlay);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\r\n        const result = new Map();\r\n        let currentBatchId = undefined;\r\n        // We want batch IDs larger than `sinceBatchId`, and so the lower bound\r\n        // is not inclusive.\r\n        const range = IDBKeyRange.bound([this.userId, collectionGroup, sinceBatchId], [this.userId, collectionGroup, Number.POSITIVE_INFINITY], \r\n        /*lowerOpen=*/ true);\r\n        return documentOverlayStore(transaction)\r\n            .iterate({\r\n            index: DbDocumentOverlay.collectionGroupOverlayIndex,\r\n            range\r\n        }, (_, dbOverlay, control) => {\r\n            // We do not want to return partial batch overlays, even if the size\r\n            // of the result set exceeds the given `count` argument. Therefore, we\r\n            // continue to aggregate results even after the result size exceeds\r\n            // `count` if there are more overlays from the `currentBatchId`.\r\n            const overlay = fromDbDocumentOverlay(this.serializer, dbOverlay);\r\n            if (result.size < count ||\r\n                overlay.largestBatchId === currentBatchId) {\r\n                result.set(overlay.getKey(), overlay);\r\n                currentBatchId = overlay.largestBatchId;\r\n            }\r\n            else {\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => result);\r\n    }\r\n    saveOverlay(transaction, overlay) {\r\n        return documentOverlayStore(transaction).put(toDbDocumentOverlay(this.serializer, this.userId, overlay));\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the document overlay object store.\r\n */\r\nfunction documentOverlayStore(txn) {\r\n    return getStore(txn, DbDocumentOverlay.store);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Note: This code is copied from the backend. Code that is not used by\r\n// Firestore was removed.\r\nconst INDEX_TYPE_NULL = 5;\r\nconst INDEX_TYPE_BOOLEAN = 10;\r\nconst INDEX_TYPE_NAN = 13;\r\nconst INDEX_TYPE_NUMBER = 15;\r\nconst INDEX_TYPE_TIMESTAMP = 20;\r\nconst INDEX_TYPE_STRING = 25;\r\nconst INDEX_TYPE_BLOB = 30;\r\nconst INDEX_TYPE_REFERENCE = 37;\r\nconst INDEX_TYPE_GEOPOINT = 45;\r\nconst INDEX_TYPE_ARRAY = 50;\r\nconst INDEX_TYPE_MAP = 55;\r\nconst INDEX_TYPE_REFERENCE_SEGMENT = 60;\r\n// A terminator that indicates that a truncatable value was not truncated.\r\n// This must be smaller than all other type labels.\r\nconst NOT_TRUNCATED = 2;\r\n/** Firestore index value writer.  */\r\nclass FirestoreIndexValueWriter {\r\n    constructor() { }\r\n    // The write methods below short-circuit writing terminators for values\r\n    // containing a (terminating) truncated value.\r\n    //\r\n    // As an example, consider the resulting encoding for:\r\n    //\r\n    // [\"bar\", [2, \"foo\"]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TERM, TERM, TERM)\r\n    // [\"bar\", [2, truncated(\"foo\")]] -> (STRING, \"bar\", TERM, ARRAY, NUMBER, 2, STRING, \"foo\", TRUNC)\r\n    // [\"bar\", truncated([\"foo\"])] -> (STRING, \"bar\", TERM, ARRAY. STRING, \"foo\", TERM, TRUNC)\r\n    /** Writes an index value.  */\r\n    writeIndexValue(value, encoder) {\r\n        this.writeIndexValueAux(value, encoder);\r\n        // Write separator to split index values\r\n        // (see go/firestore-storage-format#encodings).\r\n        encoder.writeInfinity();\r\n    }\r\n    writeIndexValueAux(indexValue, encoder) {\r\n        if ('nullValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NULL);\r\n        }\r\n        else if ('booleanValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BOOLEAN);\r\n            encoder.writeNumber(indexValue.booleanValue ? 1 : 0);\r\n        }\r\n        else if ('integerValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\r\n            encoder.writeNumber(normalizeNumber(indexValue.integerValue));\r\n        }\r\n        else if ('doubleValue' in indexValue) {\r\n            const n = normalizeNumber(indexValue.doubleValue);\r\n            if (isNaN(n)) {\r\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NAN);\r\n            }\r\n            else {\r\n                this.writeValueTypeLabel(encoder, INDEX_TYPE_NUMBER);\r\n                if (isNegativeZero(n)) {\r\n                    // -0.0, 0 and 0.0 are all considered the same\r\n                    encoder.writeNumber(0.0);\r\n                }\r\n                else {\r\n                    encoder.writeNumber(n);\r\n                }\r\n            }\r\n        }\r\n        else if ('timestampValue' in indexValue) {\r\n            const timestamp = indexValue.timestampValue;\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_TIMESTAMP);\r\n            if (typeof timestamp === 'string') {\r\n                encoder.writeString(timestamp);\r\n            }\r\n            else {\r\n                encoder.writeString(`${timestamp.seconds || ''}`);\r\n                encoder.writeNumber(timestamp.nanos || 0);\r\n            }\r\n        }\r\n        else if ('stringValue' in indexValue) {\r\n            this.writeIndexString(indexValue.stringValue, encoder);\r\n            this.writeTruncationMarker(encoder);\r\n        }\r\n        else if ('bytesValue' in indexValue) {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_BLOB);\r\n            encoder.writeBytes(normalizeByteString(indexValue.bytesValue));\r\n            this.writeTruncationMarker(encoder);\r\n        }\r\n        else if ('referenceValue' in indexValue) {\r\n            this.writeIndexEntityRef(indexValue.referenceValue, encoder);\r\n        }\r\n        else if ('geoPointValue' in indexValue) {\r\n            const geoPoint = indexValue.geoPointValue;\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_GEOPOINT);\r\n            encoder.writeNumber(geoPoint.latitude || 0);\r\n            encoder.writeNumber(geoPoint.longitude || 0);\r\n        }\r\n        else if ('mapValue' in indexValue) {\r\n            if (isMaxValue(indexValue)) {\r\n                this.writeValueTypeLabel(encoder, Number.MAX_SAFE_INTEGER);\r\n            }\r\n            else {\r\n                this.writeIndexMap(indexValue.mapValue, encoder);\r\n                this.writeTruncationMarker(encoder);\r\n            }\r\n        }\r\n        else if ('arrayValue' in indexValue) {\r\n            this.writeIndexArray(indexValue.arrayValue, encoder);\r\n            this.writeTruncationMarker(encoder);\r\n        }\r\n        else {\r\n            fail();\r\n        }\r\n    }\r\n    writeIndexString(stringIndexValue, encoder) {\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_STRING);\r\n        this.writeUnlabeledIndexString(stringIndexValue, encoder);\r\n    }\r\n    writeUnlabeledIndexString(stringIndexValue, encoder) {\r\n        encoder.writeString(stringIndexValue);\r\n    }\r\n    writeIndexMap(mapIndexValue, encoder) {\r\n        const map = mapIndexValue.fields || {};\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_MAP);\r\n        for (const key of Object.keys(map)) {\r\n            this.writeIndexString(key, encoder);\r\n            this.writeIndexValueAux(map[key], encoder);\r\n        }\r\n    }\r\n    writeIndexArray(arrayIndexValue, encoder) {\r\n        const values = arrayIndexValue.values || [];\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_ARRAY);\r\n        for (const element of values) {\r\n            this.writeIndexValueAux(element, encoder);\r\n        }\r\n    }\r\n    writeIndexEntityRef(referenceValue, encoder) {\r\n        this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE);\r\n        const path = DocumentKey.fromName(referenceValue).path;\r\n        path.forEach(segment => {\r\n            this.writeValueTypeLabel(encoder, INDEX_TYPE_REFERENCE_SEGMENT);\r\n            this.writeUnlabeledIndexString(segment, encoder);\r\n        });\r\n    }\r\n    writeValueTypeLabel(encoder, typeOrder) {\r\n        encoder.writeNumber(typeOrder);\r\n    }\r\n    writeTruncationMarker(encoder) {\r\n        // While the SDK does not implement truncation, the truncation marker is\r\n        // used to terminate all variable length values (which are strings, bytes,\r\n        // references, arrays and maps).\r\n        encoder.writeNumber(NOT_TRUNCATED);\r\n    }\r\n}\r\nFirestoreIndexValueWriter.INSTANCE = new FirestoreIndexValueWriter();\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law | agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES | CONDITIONS OF ANY KIND, either express | implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** These constants are taken from the backend. */\r\nconst MIN_SURROGATE = '\\uD800';\r\nconst MAX_SURROGATE = '\\uDBFF';\r\nconst ESCAPE1 = 0x00;\r\nconst NULL_BYTE = 0xff; // Combined with ESCAPE1\r\nconst SEPARATOR = 0x01; // Combined with ESCAPE1\r\nconst ESCAPE2 = 0xff;\r\nconst INFINITY = 0xff; // Combined with ESCAPE2\r\nconst FF_BYTE = 0x00; // Combined with ESCAPE2\r\nconst LONG_SIZE = 64;\r\nconst BYTE_SIZE = 8;\r\n/**\r\n * The default size of the buffer. This is arbitrary, but likely larger than\r\n * most index values so that less copies of the underlying buffer will be made.\r\n * For large values, a single copy will made to double the buffer length.\r\n */\r\nconst DEFAULT_BUFFER_SIZE = 1024;\r\n/** Converts a JavaScript number to a byte array (using big endian encoding). */\r\nfunction doubleToLongBits(value) {\r\n    const dv = new DataView(new ArrayBuffer(8));\r\n    dv.setFloat64(0, value, /* littleEndian= */ false);\r\n    return new Uint8Array(dv.buffer);\r\n}\r\n/**\r\n * Counts the number of zeros in a byte.\r\n *\r\n * Visible for testing.\r\n */\r\nfunction numberOfLeadingZerosInByte(x) {\r\n    if (x === 0) {\r\n        return 8;\r\n    }\r\n    let zeros = 0;\r\n    if (x >> 4 === 0) {\r\n        // Test if the first four bits are zero.\r\n        zeros += 4;\r\n        x = x << 4;\r\n    }\r\n    if (x >> 6 === 0) {\r\n        // Test if the first two (or next two) bits are zero.\r\n        zeros += 2;\r\n        x = x << 2;\r\n    }\r\n    if (x >> 7 === 0) {\r\n        // Test if the remaining bit is zero.\r\n        zeros += 1;\r\n    }\r\n    return zeros;\r\n}\r\n/** Counts the number of leading zeros in the given byte array. */\r\nfunction numberOfLeadingZeros(bytes) {\r\n    let leadingZeros = 0;\r\n    for (let i = 0; i < 8; ++i) {\r\n        const zeros = numberOfLeadingZerosInByte(bytes[i] & 0xff);\r\n        leadingZeros += zeros;\r\n        if (zeros !== 8) {\r\n            break;\r\n        }\r\n    }\r\n    return leadingZeros;\r\n}\r\n/**\r\n * Returns the number of bytes required to store \"value\". Leading zero bytes\r\n * are skipped.\r\n */\r\nfunction unsignedNumLength(value) {\r\n    // This is just the number of bytes for the unsigned representation of the number.\r\n    const numBits = LONG_SIZE - numberOfLeadingZeros(value);\r\n    return Math.ceil(numBits / BYTE_SIZE);\r\n}\r\n/**\r\n * OrderedCodeWriter is a minimal-allocation implementation of the writing\r\n * behavior defined by the backend.\r\n *\r\n * The code is ported from its Java counterpart.\r\n */\r\nclass OrderedCodeWriter {\r\n    constructor() {\r\n        this.buffer = new Uint8Array(DEFAULT_BUFFER_SIZE);\r\n        this.position = 0;\r\n    }\r\n    writeBytesAscending(value) {\r\n        const it = value[Symbol.iterator]();\r\n        let byte = it.next();\r\n        while (!byte.done) {\r\n            this.writeByteAscending(byte.value);\r\n            byte = it.next();\r\n        }\r\n        this.writeSeparatorAscending();\r\n    }\r\n    writeBytesDescending(value) {\r\n        const it = value[Symbol.iterator]();\r\n        let byte = it.next();\r\n        while (!byte.done) {\r\n            this.writeByteDescending(byte.value);\r\n            byte = it.next();\r\n        }\r\n        this.writeSeparatorDescending();\r\n    }\r\n    /** Writes utf8 bytes into this byte sequence, ascending. */\r\n    writeUtf8Ascending(sequence) {\r\n        for (const c of sequence) {\r\n            const charCode = c.charCodeAt(0);\r\n            if (charCode < 0x80) {\r\n                this.writeByteAscending(charCode);\r\n            }\r\n            else if (charCode < 0x800) {\r\n                this.writeByteAscending((0x0f << 6) | (charCode >>> 6));\r\n                this.writeByteAscending(0x80 | (0x3f & charCode));\r\n            }\r\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\r\n                this.writeByteAscending((0x0f << 5) | (charCode >>> 12));\r\n                this.writeByteAscending(0x80 | (0x3f & (charCode >>> 6)));\r\n                this.writeByteAscending(0x80 | (0x3f & charCode));\r\n            }\r\n            else {\r\n                const codePoint = c.codePointAt(0);\r\n                this.writeByteAscending((0x0f << 4) | (codePoint >>> 18));\r\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 12)));\r\n                this.writeByteAscending(0x80 | (0x3f & (codePoint >>> 6)));\r\n                this.writeByteAscending(0x80 | (0x3f & codePoint));\r\n            }\r\n        }\r\n        this.writeSeparatorAscending();\r\n    }\r\n    /** Writes utf8 bytes into this byte sequence, descending */\r\n    writeUtf8Descending(sequence) {\r\n        for (const c of sequence) {\r\n            const charCode = c.charCodeAt(0);\r\n            if (charCode < 0x80) {\r\n                this.writeByteDescending(charCode);\r\n            }\r\n            else if (charCode < 0x800) {\r\n                this.writeByteDescending((0x0f << 6) | (charCode >>> 6));\r\n                this.writeByteDescending(0x80 | (0x3f & charCode));\r\n            }\r\n            else if (c < MIN_SURROGATE || MAX_SURROGATE < c) {\r\n                this.writeByteDescending((0x0f << 5) | (charCode >>> 12));\r\n                this.writeByteDescending(0x80 | (0x3f & (charCode >>> 6)));\r\n                this.writeByteDescending(0x80 | (0x3f & charCode));\r\n            }\r\n            else {\r\n                const codePoint = c.codePointAt(0);\r\n                this.writeByteDescending((0x0f << 4) | (codePoint >>> 18));\r\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 12)));\r\n                this.writeByteDescending(0x80 | (0x3f & (codePoint >>> 6)));\r\n                this.writeByteDescending(0x80 | (0x3f & codePoint));\r\n            }\r\n        }\r\n        this.writeSeparatorDescending();\r\n    }\r\n    writeNumberAscending(val) {\r\n        // Values are encoded with a single byte length prefix, followed by the\r\n        // actual value in big-endian format with leading 0 bytes dropped.\r\n        const value = this.toOrderedBits(val);\r\n        const len = unsignedNumLength(value);\r\n        this.ensureAvailable(1 + len);\r\n        this.buffer[this.position++] = len & 0xff; // Write the length\r\n        for (let i = value.length - len; i < value.length; ++i) {\r\n            this.buffer[this.position++] = value[i] & 0xff;\r\n        }\r\n    }\r\n    writeNumberDescending(val) {\r\n        // Values are encoded with a single byte length prefix, followed by the\r\n        // inverted value in big-endian format with leading 0 bytes dropped.\r\n        const value = this.toOrderedBits(val);\r\n        const len = unsignedNumLength(value);\r\n        this.ensureAvailable(1 + len);\r\n        this.buffer[this.position++] = ~(len & 0xff); // Write the length\r\n        for (let i = value.length - len; i < value.length; ++i) {\r\n            this.buffer[this.position++] = ~(value[i] & 0xff);\r\n        }\r\n    }\r\n    /**\r\n     * Writes the \"infinity\" byte sequence that sorts after all other byte\r\n     * sequences written in ascending order.\r\n     */\r\n    writeInfinityAscending() {\r\n        this.writeEscapedByteAscending(ESCAPE2);\r\n        this.writeEscapedByteAscending(INFINITY);\r\n    }\r\n    /**\r\n     * Writes the \"infinity\" byte sequence that sorts before all other byte\r\n     * sequences written in descending order.\r\n     */\r\n    writeInfinityDescending() {\r\n        this.writeEscapedByteDescending(ESCAPE2);\r\n        this.writeEscapedByteDescending(INFINITY);\r\n    }\r\n    /**\r\n     * Resets the buffer such that it is the same as when it was newly\r\n     * constructed.\r\n     */\r\n    reset() {\r\n        this.position = 0;\r\n    }\r\n    seed(encodedBytes) {\r\n        this.ensureAvailable(encodedBytes.length);\r\n        this.buffer.set(encodedBytes, this.position);\r\n        this.position += encodedBytes.length;\r\n    }\r\n    /** Makes a copy of the encoded bytes in this buffer.  */\r\n    encodedBytes() {\r\n        return this.buffer.slice(0, this.position);\r\n    }\r\n    /**\r\n     * Encodes `val` into an encoding so that the order matches the IEEE 754\r\n     * floating-point comparison results with the following exceptions:\r\n     *   -0.0 < 0.0\r\n     *   all non-NaN < NaN\r\n     *   NaN = NaN\r\n     */\r\n    toOrderedBits(val) {\r\n        const value = doubleToLongBits(val);\r\n        // Check if the first bit is set. We use a bit mask since value[0] is\r\n        // encoded as a number from 0 to 255.\r\n        const isNegative = (value[0] & 0x80) !== 0;\r\n        // Revert the two complement to get natural ordering\r\n        value[0] ^= isNegative ? 0xff : 0x80;\r\n        for (let i = 1; i < value.length; ++i) {\r\n            value[i] ^= isNegative ? 0xff : 0x00;\r\n        }\r\n        return value;\r\n    }\r\n    /** Writes a single byte ascending to the buffer. */\r\n    writeByteAscending(b) {\r\n        const masked = b & 0xff;\r\n        if (masked === ESCAPE1) {\r\n            this.writeEscapedByteAscending(ESCAPE1);\r\n            this.writeEscapedByteAscending(NULL_BYTE);\r\n        }\r\n        else if (masked === ESCAPE2) {\r\n            this.writeEscapedByteAscending(ESCAPE2);\r\n            this.writeEscapedByteAscending(FF_BYTE);\r\n        }\r\n        else {\r\n            this.writeEscapedByteAscending(masked);\r\n        }\r\n    }\r\n    /** Writes a single byte descending to the buffer.  */\r\n    writeByteDescending(b) {\r\n        const masked = b & 0xff;\r\n        if (masked === ESCAPE1) {\r\n            this.writeEscapedByteDescending(ESCAPE1);\r\n            this.writeEscapedByteDescending(NULL_BYTE);\r\n        }\r\n        else if (masked === ESCAPE2) {\r\n            this.writeEscapedByteDescending(ESCAPE2);\r\n            this.writeEscapedByteDescending(FF_BYTE);\r\n        }\r\n        else {\r\n            this.writeEscapedByteDescending(b);\r\n        }\r\n    }\r\n    writeSeparatorAscending() {\r\n        this.writeEscapedByteAscending(ESCAPE1);\r\n        this.writeEscapedByteAscending(SEPARATOR);\r\n    }\r\n    writeSeparatorDescending() {\r\n        this.writeEscapedByteDescending(ESCAPE1);\r\n        this.writeEscapedByteDescending(SEPARATOR);\r\n    }\r\n    writeEscapedByteAscending(b) {\r\n        this.ensureAvailable(1);\r\n        this.buffer[this.position++] = b;\r\n    }\r\n    writeEscapedByteDescending(b) {\r\n        this.ensureAvailable(1);\r\n        this.buffer[this.position++] = ~b;\r\n    }\r\n    ensureAvailable(bytes) {\r\n        const minCapacity = bytes + this.position;\r\n        if (minCapacity <= this.buffer.length) {\r\n            return;\r\n        }\r\n        // Try doubling.\r\n        let newLength = this.buffer.length * 2;\r\n        // Still not big enough? Just allocate the right size.\r\n        if (newLength < minCapacity) {\r\n            newLength = minCapacity;\r\n        }\r\n        // Create the new buffer.\r\n        const newBuffer = new Uint8Array(newLength);\r\n        newBuffer.set(this.buffer); // copy old data\r\n        this.buffer = newBuffer;\r\n    }\r\n}\n\nclass AscendingIndexByteEncoder {\r\n    constructor(orderedCode) {\r\n        this.orderedCode = orderedCode;\r\n    }\r\n    writeBytes(value) {\r\n        this.orderedCode.writeBytesAscending(value);\r\n    }\r\n    writeString(value) {\r\n        this.orderedCode.writeUtf8Ascending(value);\r\n    }\r\n    writeNumber(value) {\r\n        this.orderedCode.writeNumberAscending(value);\r\n    }\r\n    writeInfinity() {\r\n        this.orderedCode.writeInfinityAscending();\r\n    }\r\n}\r\nclass DescendingIndexByteEncoder {\r\n    constructor(orderedCode) {\r\n        this.orderedCode = orderedCode;\r\n    }\r\n    writeBytes(value) {\r\n        this.orderedCode.writeBytesDescending(value);\r\n    }\r\n    writeString(value) {\r\n        this.orderedCode.writeUtf8Descending(value);\r\n    }\r\n    writeNumber(value) {\r\n        this.orderedCode.writeNumberDescending(value);\r\n    }\r\n    writeInfinity() {\r\n        this.orderedCode.writeInfinityDescending();\r\n    }\r\n}\r\n/**\r\n * Implements `DirectionalIndexByteEncoder` using `OrderedCodeWriter` for the\r\n * actual encoding.\r\n */\r\nclass IndexByteEncoder {\r\n    constructor() {\r\n        this.orderedCode = new OrderedCodeWriter();\r\n        this.ascending = new AscendingIndexByteEncoder(this.orderedCode);\r\n        this.descending = new DescendingIndexByteEncoder(this.orderedCode);\r\n    }\r\n    seed(encodedBytes) {\r\n        this.orderedCode.seed(encodedBytes);\r\n    }\r\n    forKind(kind) {\r\n        return kind === 0 /* ASCENDING */ ? this.ascending : this.descending;\r\n    }\r\n    encodedBytes() {\r\n        return this.orderedCode.encodedBytes();\r\n    }\r\n    reset() {\r\n        this.orderedCode.reset();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Represents an index entry saved by the SDK in persisted storage. */\r\nclass IndexEntry {\r\n    constructor(indexId, documentKey, arrayValue, directionalValue) {\r\n        this.indexId = indexId;\r\n        this.documentKey = documentKey;\r\n        this.arrayValue = arrayValue;\r\n        this.directionalValue = directionalValue;\r\n    }\r\n}\r\nfunction indexEntryComparator(left, right) {\r\n    let cmp = left.indexId - right.indexId;\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    cmp = DocumentKey.comparator(left.documentKey, right.documentKey);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    cmp = compareByteArrays(left.arrayValue, right.arrayValue);\r\n    if (cmp !== 0) {\r\n        return cmp;\r\n    }\r\n    return compareByteArrays(left.directionalValue, right.directionalValue);\r\n}\r\nfunction compareByteArrays(left, right) {\r\n    for (let i = 0; i < left.length && i < right.length; ++i) {\r\n        const compare = left[i] - right[i];\r\n        if (compare !== 0) {\r\n            return compare;\r\n        }\r\n    }\r\n    return left.length - right.length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory implementation of IndexManager.\r\n */\r\nclass MemoryIndexManager {\r\n    constructor() {\r\n        this.collectionParentIndex = new MemoryCollectionParentIndex();\r\n    }\r\n    addToCollectionParentIndex(transaction, collectionPath) {\r\n        this.collectionParentIndex.add(collectionPath);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getCollectionParents(transaction, collectionId) {\r\n        return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));\r\n    }\r\n    addFieldIndex(transaction, index) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    deleteFieldIndex(transaction, index) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getDocumentsMatchingTarget(transaction, fieldIndex, target) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve(documentKeySet());\r\n    }\r\n    getFieldIndex(transaction, target) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve(null);\r\n    }\r\n    getFieldIndexes(transaction, collectionGroup) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve([]);\r\n    }\r\n    getNextCollectionGroupToUpdate(transaction) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve(null);\r\n    }\r\n    updateCollectionGroup(transaction, collectionGroup, offset) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n    updateIndexEntries(transaction, documents) {\r\n        // Field indices are not supported with memory persistence.\r\n        return PersistencePromise.resolve();\r\n    }\r\n}\r\n/**\r\n * Internal implementation of the collection-parent index exposed by MemoryIndexManager.\r\n * Also used for in-memory caching by IndexedDbIndexManager and initial index population\r\n * in indexeddb_schema.ts\r\n */\r\nclass MemoryCollectionParentIndex {\r\n    constructor() {\r\n        this.index = {};\r\n    }\r\n    // Returns false if the entry already existed.\r\n    add(collectionPath) {\r\n        const collectionId = collectionPath.lastSegment();\r\n        const parentPath = collectionPath.popLast();\r\n        const existingParents = this.index[collectionId] ||\r\n            new SortedSet(ResourcePath.comparator);\r\n        const added = !existingParents.has(parentPath);\r\n        this.index[collectionId] = existingParents.add(parentPath);\r\n        return added;\r\n    }\r\n    has(collectionPath) {\r\n        const collectionId = collectionPath.lastSegment();\r\n        const parentPath = collectionPath.popLast();\r\n        const existingParents = this.index[collectionId];\r\n        return existingParents && existingParents.has(parentPath);\r\n    }\r\n    getEntries(collectionId) {\r\n        const parentPaths = this.index[collectionId] ||\r\n            new SortedSet(ResourcePath.comparator);\r\n        return parentPaths.toArray();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$f = 'IndexedDbIndexManager';\r\n/**\r\n * A persisted implementation of IndexManager.\r\n *\r\n * PORTING NOTE: Unlike iOS and Android, the Web SDK does not memoize index\r\n * data as it supports multi-tab access.\r\n */\r\nclass IndexedDbIndexManager {\r\n    constructor(user) {\r\n        this.user = user;\r\n        /**\r\n         * An in-memory copy of the index entries we've already written since the SDK\r\n         * launched. Used to avoid re-writing the same entry repeatedly.\r\n         *\r\n         * This is *NOT* a complete cache of what's in persistence and so can never be\r\n         * used to satisfy reads.\r\n         */\r\n        this.collectionParentsCache = new MemoryCollectionParentIndex();\r\n        this.uid = user.uid || '';\r\n    }\r\n    /**\r\n     * Adds a new entry to the collection parent index.\r\n     *\r\n     * Repeated calls for the same collectionPath should be avoided within a\r\n     * transaction as IndexedDbIndexManager only caches writes once a transaction\r\n     * has been committed.\r\n     */\r\n    addToCollectionParentIndex(transaction, collectionPath) {\r\n        if (!this.collectionParentsCache.has(collectionPath)) {\r\n            const collectionId = collectionPath.lastSegment();\r\n            const parentPath = collectionPath.popLast();\r\n            transaction.addOnCommittedListener(() => {\r\n                // Add the collection to the in memory cache only if the transaction was\r\n                // successfully committed.\r\n                this.collectionParentsCache.add(collectionPath);\r\n            });\r\n            const collectionParent = {\r\n                collectionId,\r\n                parent: encodeResourcePath(parentPath)\r\n            };\r\n            return collectionParentsStore(transaction).put(collectionParent);\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getCollectionParents(transaction, collectionId) {\r\n        const parentPaths = [];\r\n        const range = IDBKeyRange.bound([collectionId, ''], [immediateSuccessor(collectionId), ''], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        return collectionParentsStore(transaction)\r\n            .loadAll(range)\r\n            .next(entries => {\r\n            for (const entry of entries) {\r\n                // This collectionId guard shouldn't be necessary (and isn't as long\r\n                // as we're running in a real browser), but there's a bug in\r\n                // indexeddbshim that breaks our range in our tests running in node:\r\n                // https://github.com/axemclion/IndexedDBShim/issues/334\r\n                if (entry.collectionId !== collectionId) {\r\n                    break;\r\n                }\r\n                parentPaths.push(decodeResourcePath(entry.parent));\r\n            }\r\n            return parentPaths;\r\n        });\r\n    }\r\n    addFieldIndex(transaction, index) {\r\n        // TODO(indexing): Verify that the auto-incrementing index ID works in\r\n        // Safari & Firefox.\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const dbIndex = toDbIndexConfiguration(index);\r\n        delete dbIndex.indexId; // `indexId` is auto-populated by IndexedDb\r\n        return indexes.add(dbIndex).next();\r\n    }\r\n    deleteFieldIndex(transaction, index) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        const entries = indexEntriesStore(transaction);\r\n        return indexes\r\n            .delete(index.indexId)\r\n            .next(() => states.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true)))\r\n            .next(() => entries.delete(IDBKeyRange.bound([index.indexId], [index.indexId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true)));\r\n    }\r\n    getDocumentsMatchingTarget(transaction, fieldIndex, target) {\r\n        // TODO(indexing): Implement\r\n        return PersistencePromise.resolve(documentKeySet());\r\n    }\r\n    getFieldIndex(transaction, target) {\r\n        // TODO(indexing): Implement\r\n        return PersistencePromise.resolve(null);\r\n    }\r\n    /**\r\n     * Returns the byte encoded form of the directional values in the field index.\r\n     * Returns `null` if the document does not have all fields specified in the\r\n     * index.\r\n     */\r\n    encodeDirectionalElements(fieldIndex, document) {\r\n        const encoder = new IndexByteEncoder();\r\n        for (const segment of fieldIndexGetDirectionalSegments(fieldIndex)) {\r\n            const field = document.data.field(segment.fieldPath);\r\n            if (field == null) {\r\n                return null;\r\n            }\r\n            const directionalEncoder = encoder.forKind(segment.kind);\r\n            FirestoreIndexValueWriter.INSTANCE.writeIndexValue(field, directionalEncoder);\r\n        }\r\n        return encoder.encodedBytes();\r\n    }\r\n    /** Encodes a single value to the ascending index format. */\r\n    encodeSingleElement(value) {\r\n        const encoder = new IndexByteEncoder();\r\n        FirestoreIndexValueWriter.INSTANCE.writeIndexValue(value, encoder.forKind(0 /* ASCENDING */));\r\n        return encoder.encodedBytes();\r\n    }\r\n    getFieldIndexes(transaction, collectionGroup) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        return (collectionGroup\r\n            ? indexes.loadAll(DbIndexConfiguration.collectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\r\n            : indexes.loadAll()).next(indexConfigs => {\r\n            const result = [];\r\n            return PersistencePromise.forEach(indexConfigs, (indexConfig) => {\r\n                return states\r\n                    .get([indexConfig.indexId, this.uid])\r\n                    .next(indexState => {\r\n                    result.push(fromDbIndexConfiguration(indexConfig, indexState));\r\n                });\r\n            }).next(() => result);\r\n        });\r\n    }\r\n    getNextCollectionGroupToUpdate(transaction) {\r\n        return this.getFieldIndexes(transaction).next(indexes => {\r\n            if (indexes.length === 0) {\r\n                return null;\r\n            }\r\n            indexes.sort((l, r) => l.indexState.sequenceNumber - r.indexState.sequenceNumber);\r\n            return indexes[0].collectionGroup;\r\n        });\r\n    }\r\n    updateCollectionGroup(transaction, collectionGroup, offset) {\r\n        const indexes = indexConfigurationStore(transaction);\r\n        const states = indexStateStore(transaction);\r\n        return this.getNextSequenceNumber(transaction).next(nextSequenceNumber => indexes\r\n            .loadAll(DbIndexConfiguration.collectionGroupIndex, IDBKeyRange.bound(collectionGroup, collectionGroup))\r\n            .next(configs => PersistencePromise.forEach(configs, (config) => states.put(toDbIndexState(config.indexId, this.user, nextSequenceNumber, offset)))));\r\n    }\r\n    updateIndexEntries(transaction, documents) {\r\n        // Porting Note: `getFieldIndexes()` on Web does not cache index lookups as\r\n        // it could be used across different IndexedDB transactions. As any cached\r\n        // data might be invalidated by other multi-tab clients, we can only trust\r\n        // data within a single IndexedDB transaction. We therefore add a cache\r\n        // here.\r\n        const memoizedIndexes = new Map();\r\n        return PersistencePromise.forEach(documents, (key, doc) => {\r\n            const memoizedCollectionIndexes = memoizedIndexes.get(key.collectionGroup);\r\n            const fieldIndexes = memoizedCollectionIndexes\r\n                ? PersistencePromise.resolve(memoizedCollectionIndexes)\r\n                : this.getFieldIndexes(transaction, key.collectionGroup);\r\n            return fieldIndexes.next(fieldIndexes => {\r\n                memoizedIndexes.set(key.collectionGroup, fieldIndexes);\r\n                return PersistencePromise.forEach(fieldIndexes, (fieldIndex) => {\r\n                    return this.getExistingIndexEntries(transaction, key, fieldIndex).next(existingEntries => {\r\n                        const newEntries = this.computeIndexEntries(doc, fieldIndex);\r\n                        if (!existingEntries.isEqual(newEntries)) {\r\n                            return this.updateEntries(transaction, doc, existingEntries, newEntries);\r\n                        }\r\n                        return PersistencePromise.resolve();\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    addIndexEntry(transaction, document, indexEntry) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        return indexEntries.put(new DbIndexEntry(indexEntry.indexId, this.uid, indexEntry.arrayValue, indexEntry.directionalValue, encodeResourcePath(document.key.path)));\r\n    }\r\n    deleteIndexEntry(transaction, document, indexEntry) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        return indexEntries.delete([\r\n            indexEntry.indexId,\r\n            this.uid,\r\n            indexEntry.arrayValue,\r\n            indexEntry.directionalValue,\r\n            encodeResourcePath(document.key.path)\r\n        ]);\r\n    }\r\n    getExistingIndexEntries(transaction, documentKey, fieldIndex) {\r\n        const indexEntries = indexEntriesStore(transaction);\r\n        let results = new SortedSet(indexEntryComparator);\r\n        return indexEntries\r\n            .iterate({\r\n            index: DbIndexEntry.documentKeyIndex,\r\n            range: IDBKeyRange.only([\r\n                fieldIndex.indexId,\r\n                this.uid,\r\n                encodeResourcePath(documentKey.path)\r\n            ])\r\n        }, (_, entry) => {\r\n            results = results.add(new IndexEntry(fieldIndex.indexId, documentKey, entry.arrayValue, entry.directionalValue));\r\n        })\r\n            .next(() => results);\r\n    }\r\n    /** Creates the index entries for the given document. */\r\n    computeIndexEntries(document, fieldIndex) {\r\n        let results = new SortedSet(indexEntryComparator);\r\n        const directionalValue = this.encodeDirectionalElements(fieldIndex, document);\r\n        if (directionalValue == null) {\r\n            return results;\r\n        }\r\n        const arraySegment = fieldIndexGetArraySegment(fieldIndex);\r\n        if (arraySegment != null) {\r\n            const value = document.data.field(arraySegment.fieldPath);\r\n            if (isArray(value)) {\r\n                for (const arrayValue of value.arrayValue.values || []) {\r\n                    results = results.add(new IndexEntry(fieldIndex.indexId, document.key, this.encodeSingleElement(arrayValue), directionalValue));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            results = results.add(new IndexEntry(fieldIndex.indexId, document.key, new Uint8Array(), directionalValue));\r\n        }\r\n        return results;\r\n    }\r\n    /**\r\n     * Updates the index entries for the provided document by deleting entries\r\n     * that are no longer referenced in `newEntries` and adding all newly added\r\n     * entries.\r\n     */\r\n    updateEntries(transaction, document, existingEntries, newEntries) {\r\n        logDebug(LOG_TAG$f, \"Updating index entries for document '%s'\", document.key);\r\n        const promises = [];\r\n        diffSortedSets(existingEntries, newEntries, indexEntryComparator, \r\n        /* onAdd= */ entry => {\r\n            promises.push(this.addIndexEntry(transaction, document, entry));\r\n        }, \r\n        /* onRemove= */ entry => {\r\n            promises.push(this.deleteIndexEntry(transaction, document, entry));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getNextSequenceNumber(transaction) {\r\n        let nextSequenceNumber = 1;\r\n        const states = indexStateStore(transaction);\r\n        return states\r\n            .iterate({\r\n            index: DbIndexState.sequenceNumberIndex,\r\n            reverse: true,\r\n            range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])\r\n        }, (_, state, controller) => {\r\n            controller.done();\r\n            nextSequenceNumber = state.sequenceNumber + 1;\r\n        })\r\n            .next(() => nextSequenceNumber);\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the collectionParents\r\n * document store.\r\n */\r\nfunction collectionParentsStore(txn) {\r\n    return getStore(txn, DbCollectionParent.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the index entry object store.\r\n */\r\nfunction indexEntriesStore(txn) {\r\n    return getStore(txn, DbIndexEntry.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the index configuration object store.\r\n */\r\nfunction indexConfigurationStore(txn) {\r\n    return getStore(txn, DbIndexConfiguration.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the index state object store.\r\n */\r\nfunction indexStateStore(txn) {\r\n    return getStore(txn, DbIndexState.store);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Delete a mutation batch and the associated document mutations.\r\n * @returns A PersistencePromise of the document mutations that were removed.\r\n */\r\nfunction removeMutationBatch(txn, userId, batch) {\r\n    const mutationStore = txn.store(DbMutationBatch.store);\r\n    const indexTxn = txn.store(DbDocumentMutation.store);\r\n    const promises = [];\r\n    const range = IDBKeyRange.only(batch.batchId);\r\n    let numDeleted = 0;\r\n    const removePromise = mutationStore.iterate({ range }, (key, value, control) => {\r\n        numDeleted++;\r\n        return control.delete();\r\n    });\r\n    promises.push(removePromise.next(() => {\r\n        hardAssert(numDeleted === 1);\r\n    }));\r\n    const removedDocuments = [];\r\n    for (const mutation of batch.mutations) {\r\n        const indexKey = DbDocumentMutation.key(userId, mutation.key.path, batch.batchId);\r\n        promises.push(indexTxn.delete(indexKey));\r\n        removedDocuments.push(mutation.key);\r\n    }\r\n    return PersistencePromise.waitFor(promises).next(() => removedDocuments);\r\n}\r\n/**\r\n * Returns an approximate size for the given document.\r\n */\r\nfunction dbDocumentSize(doc) {\r\n    if (!doc) {\r\n        return 0;\r\n    }\r\n    let value;\r\n    if (doc.document) {\r\n        value = doc.document;\r\n    }\r\n    else if (doc.unknownDocument) {\r\n        value = doc.unknownDocument;\r\n    }\r\n    else if (doc.noDocument) {\r\n        value = doc.noDocument;\r\n    }\r\n    else {\r\n        throw fail();\r\n    }\r\n    return JSON.stringify(value).length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** A mutation queue for a specific user, backed by IndexedDB. */\r\nclass IndexedDbMutationQueue {\r\n    constructor(\r\n    /**\r\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\r\n     * retrieve mutations.\r\n     */\r\n    userId, serializer, indexManager, referenceDelegate) {\r\n        this.userId = userId;\r\n        this.serializer = serializer;\r\n        this.indexManager = indexManager;\r\n        this.referenceDelegate = referenceDelegate;\r\n        /**\r\n         * Caches the document keys for pending mutation batches. If the mutation\r\n         * has been removed from IndexedDb, the cached value may continue to\r\n         * be used to retrieve the batch's document keys. To remove a cached value\r\n         * locally, `removeCachedMutationKeys()` should be invoked either directly\r\n         * or through `removeMutationBatches()`.\r\n         *\r\n         * With multi-tab, when the primary client acknowledges or rejects a mutation,\r\n         * this cache is used by secondary clients to invalidate the local\r\n         * view of the documents that were previously affected by the mutation.\r\n         */\r\n        // PORTING NOTE: Multi-tab only.\r\n        this.documentKeysByBatchId = {};\r\n    }\r\n    /**\r\n     * Creates a new mutation queue for the given user.\r\n     * @param user - The user for which to create a mutation queue.\r\n     * @param serializer - The serializer to use when persisting to IndexedDb.\r\n     */\r\n    static forUser(user, serializer, indexManager, referenceDelegate) {\r\n        // TODO(mcg): Figure out what constraints there are on userIDs\r\n        // In particular, are there any reserved characters? are empty ids allowed?\r\n        // For the moment store these together in the same mutations table assuming\r\n        // that empty userIDs aren't allowed.\r\n        hardAssert(user.uid !== '');\r\n        const userId = user.isAuthenticated() ? user.uid : '';\r\n        return new IndexedDbMutationQueue(userId, serializer, indexManager, referenceDelegate);\r\n    }\r\n    checkEmpty(transaction) {\r\n        let empty = true;\r\n        const range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\r\n        return mutationsStore(transaction)\r\n            .iterate({ index: DbMutationBatch.userMutationsIndex, range }, (key, value, control) => {\r\n            empty = false;\r\n            control.done();\r\n        })\r\n            .next(() => empty);\r\n    }\r\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\r\n        const documentStore = documentMutationsStore(transaction);\r\n        const mutationStore = mutationsStore(transaction);\r\n        // The IndexedDb implementation in Chrome (and Firefox) does not handle\r\n        // compound indices that include auto-generated keys correctly. To ensure\r\n        // that the index entry is added correctly in all browsers, we perform two\r\n        // writes: The first write is used to retrieve the next auto-generated Batch\r\n        // ID, and the second write populates the index and stores the actual\r\n        // mutation batch.\r\n        // See: https://bugs.chromium.org/p/chromium/issues/detail?id=701972\r\n        // We write an empty object to obtain key\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return mutationStore.add({}).next(batchId => {\r\n            hardAssert(typeof batchId === 'number');\r\n            const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\r\n            const dbBatch = toDbMutationBatch(this.serializer, this.userId, batch);\r\n            const promises = [];\r\n            let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\r\n            for (const mutation of mutations) {\r\n                const indexKey = DbDocumentMutation.key(this.userId, mutation.key.path, batchId);\r\n                collectionParents = collectionParents.add(mutation.key.path.popLast());\r\n                promises.push(mutationStore.put(dbBatch));\r\n                promises.push(documentStore.put(indexKey, DbDocumentMutation.PLACEHOLDER));\r\n            }\r\n            collectionParents.forEach(parent => {\r\n                promises.push(this.indexManager.addToCollectionParentIndex(transaction, parent));\r\n            });\r\n            transaction.addOnCommittedListener(() => {\r\n                this.documentKeysByBatchId[batchId] = batch.keys();\r\n            });\r\n            return PersistencePromise.waitFor(promises).next(() => batch);\r\n        });\r\n    }\r\n    lookupMutationBatch(transaction, batchId) {\r\n        return mutationsStore(transaction)\r\n            .get(batchId)\r\n            .next(dbBatch => {\r\n            if (dbBatch) {\r\n                hardAssert(dbBatch.userId === this.userId);\r\n                return fromDbMutationBatch(this.serializer, dbBatch);\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the document keys for the mutation batch with the given batchId.\r\n     * For primary clients, this method returns `null` after\r\n     * `removeMutationBatches()` has been called. Secondary clients return a\r\n     * cached result until `removeCachedMutationKeys()` is invoked.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    lookupMutationKeys(transaction, batchId) {\r\n        if (this.documentKeysByBatchId[batchId]) {\r\n            return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);\r\n        }\r\n        else {\r\n            return this.lookupMutationBatch(transaction, batchId).next(batch => {\r\n                if (batch) {\r\n                    const keys = batch.keys();\r\n                    this.documentKeysByBatchId[batchId] = keys;\r\n                    return keys;\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\r\n        const nextBatchId = batchId + 1;\r\n        const range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);\r\n        let foundBatch = null;\r\n        return mutationsStore(transaction)\r\n            .iterate({ index: DbMutationBatch.userMutationsIndex, range }, (key, dbBatch, control) => {\r\n            if (dbBatch.userId === this.userId) {\r\n                hardAssert(dbBatch.batchId >= nextBatchId);\r\n                foundBatch = fromDbMutationBatch(this.serializer, dbBatch);\r\n            }\r\n            control.done();\r\n        })\r\n            .next(() => foundBatch);\r\n    }\r\n    getHighestUnacknowledgedBatchId(transaction) {\r\n        const range = IDBKeyRange.upperBound([\r\n            this.userId,\r\n            Number.POSITIVE_INFINITY\r\n        ]);\r\n        let batchId = BATCHID_UNKNOWN;\r\n        return mutationsStore(transaction)\r\n            .iterate({ index: DbMutationBatch.userMutationsIndex, range, reverse: true }, (key, dbBatch, control) => {\r\n            batchId = dbBatch.batchId;\r\n            control.done();\r\n        })\r\n            .next(() => batchId);\r\n    }\r\n    getAllMutationBatches(transaction) {\r\n        const range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);\r\n        return mutationsStore(transaction)\r\n            .loadAll(DbMutationBatch.userMutationsIndex, range)\r\n            .next(dbBatches => dbBatches.map(dbBatch => fromDbMutationBatch(this.serializer, dbBatch)));\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\r\n        // Scan the document-mutation index starting with a prefix starting with\r\n        // the given documentKey.\r\n        const indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);\r\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\r\n        const results = [];\r\n        return documentMutationsStore(transaction)\r\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\r\n            const [userID, encodedPath, batchId] = indexKey;\r\n            // Only consider rows matching exactly the specific key of\r\n            // interest. Note that because we order by path first, and we\r\n            // order terminators before path separators, we'll encounter all\r\n            // the index rows for documentKey contiguously. In particular, all\r\n            // the rows for documentKey will occur before any rows for\r\n            // documents nested in a subcollection beneath documentKey so we\r\n            // can stop as soon as we hit any such row.\r\n            const path = decodeResourcePath(encodedPath);\r\n            if (userID !== this.userId || !documentKey.path.isEqual(path)) {\r\n                control.done();\r\n                return;\r\n            }\r\n            // Look up the mutation batch in the store.\r\n            return mutationsStore(transaction)\r\n                .get(batchId)\r\n                .next(mutation => {\r\n                if (!mutation) {\r\n                    throw fail();\r\n                }\r\n                hardAssert(mutation.userId === this.userId);\r\n                results.push(fromDbMutationBatch(this.serializer, mutation));\r\n            });\r\n        })\r\n            .next(() => results);\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        const promises = [];\r\n        documentKeys.forEach(documentKey => {\r\n            const indexStart = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);\r\n            const range = IDBKeyRange.lowerBound(indexStart);\r\n            const promise = documentMutationsStore(transaction).iterate({ range }, (indexKey, _, control) => {\r\n                const [userID, encodedPath, batchID] = indexKey;\r\n                // Only consider rows matching exactly the specific key of\r\n                // interest. Note that because we order by path first, and we\r\n                // order terminators before path separators, we'll encounter all\r\n                // the index rows for documentKey contiguously. In particular, all\r\n                // the rows for documentKey will occur before any rows for\r\n                // documents nested in a subcollection beneath documentKey so we\r\n                // can stop as soon as we hit any such row.\r\n                const path = decodeResourcePath(encodedPath);\r\n                if (userID !== this.userId || !documentKey.path.isEqual(path)) {\r\n                    control.done();\r\n                    return;\r\n                }\r\n                uniqueBatchIDs = uniqueBatchIDs.add(batchID);\r\n            });\r\n            promises.push(promise);\r\n        });\r\n        return PersistencePromise.waitFor(promises).next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\r\n    }\r\n    getAllMutationBatchesAffectingQuery(transaction, query) {\r\n        const queryPath = query.path;\r\n        const immediateChildrenLength = queryPath.length + 1;\r\n        // TODO(mcg): Actually implement a single-collection query\r\n        //\r\n        // This is actually executing an ancestor query, traversing the whole\r\n        // subtree below the collection which can be horrifically inefficient for\r\n        // some structures. The right way to solve this is to implement the full\r\n        // value index, but that's not in the cards in the near future so this is\r\n        // the best we can do for the moment.\r\n        //\r\n        // Since we don't yet index the actual properties in the mutations, our\r\n        // current approach is to just return all mutation batches that affect\r\n        // documents in the collection being queried.\r\n        const indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);\r\n        const indexStart = IDBKeyRange.lowerBound(indexPrefix);\r\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\r\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\r\n        // scan of the main table.\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        return documentMutationsStore(transaction)\r\n            .iterate({ range: indexStart }, (indexKey, _, control) => {\r\n            const [userID, encodedPath, batchID] = indexKey;\r\n            const path = decodeResourcePath(encodedPath);\r\n            if (userID !== this.userId || !queryPath.isPrefixOf(path)) {\r\n                control.done();\r\n                return;\r\n            }\r\n            // Rows with document keys more than one segment longer than the\r\n            // query path can't be matches. For example, a query on 'rooms'\r\n            // can't match the document /rooms/abc/messages/xyx.\r\n            // TODO(mcg): we'll need a different scanner when we implement\r\n            // ancestor queries.\r\n            if (path.length !== immediateChildrenLength) {\r\n                return;\r\n            }\r\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\r\n        })\r\n            .next(() => this.lookupMutationBatches(transaction, uniqueBatchIDs));\r\n    }\r\n    lookupMutationBatches(transaction, batchIDs) {\r\n        const results = [];\r\n        const promises = [];\r\n        // TODO(rockwood): Implement this using iterate.\r\n        batchIDs.forEach(batchId => {\r\n            promises.push(mutationsStore(transaction)\r\n                .get(batchId)\r\n                .next(mutation => {\r\n                if (mutation === null) {\r\n                    throw fail();\r\n                }\r\n                hardAssert(mutation.userId === this.userId);\r\n                results.push(fromDbMutationBatch(this.serializer, mutation));\r\n            }));\r\n        });\r\n        return PersistencePromise.waitFor(promises).next(() => results);\r\n    }\r\n    removeMutationBatch(transaction, batch) {\r\n        return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(removedDocuments => {\r\n            transaction.addOnCommittedListener(() => {\r\n                this.removeCachedMutationKeys(batch.batchId);\r\n            });\r\n            return PersistencePromise.forEach(removedDocuments, (key) => {\r\n                return this.referenceDelegate.markPotentiallyOrphaned(transaction, key);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Clears the cached keys for a mutation batch. This method should be\r\n     * called by secondary clients after they process mutation updates.\r\n     *\r\n     * Note that this method does not have to be called from primary clients as\r\n     * the corresponding cache entries are cleared when an acknowledged or\r\n     * rejected batch is removed from the mutation queue.\r\n     */\r\n    // PORTING NOTE: Multi-tab only\r\n    removeCachedMutationKeys(batchId) {\r\n        delete this.documentKeysByBatchId[batchId];\r\n    }\r\n    performConsistencyCheck(txn) {\r\n        return this.checkEmpty(txn).next(empty => {\r\n            if (!empty) {\r\n                return PersistencePromise.resolve();\r\n            }\r\n            // Verify that there are no entries in the documentMutations index if\r\n            // the queue is empty.\r\n            const startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(this.userId));\r\n            const danglingMutationReferences = [];\r\n            return documentMutationsStore(txn)\r\n                .iterate({ range: startRange }, (key, _, control) => {\r\n                const userID = key[0];\r\n                if (userID !== this.userId) {\r\n                    control.done();\r\n                    return;\r\n                }\r\n                else {\r\n                    const path = decodeResourcePath(key[1]);\r\n                    danglingMutationReferences.push(path);\r\n                }\r\n            })\r\n                .next(() => {\r\n                hardAssert(danglingMutationReferences.length === 0);\r\n            });\r\n        });\r\n    }\r\n    containsKey(txn, key) {\r\n        return mutationQueueContainsKey(txn, this.userId, key);\r\n    }\r\n    // PORTING NOTE: Multi-tab only (state is held in memory in other clients).\r\n    /** Returns the mutation queue's metadata from IndexedDb. */\r\n    getMutationQueueMetadata(transaction) {\r\n        return mutationQueuesStore(transaction)\r\n            .get(this.userId)\r\n            .next((metadata) => {\r\n            return (metadata ||\r\n                new DbMutationQueue(this.userId, BATCHID_UNKNOWN, \r\n                /*lastStreamToken=*/ ''));\r\n        });\r\n    }\r\n}\r\n/**\r\n * @returns true if the mutation queue for the given user contains a pending\r\n *         mutation for the given key.\r\n */\r\nfunction mutationQueueContainsKey(txn, userId, key) {\r\n    const indexKey = DbDocumentMutation.prefixForPath(userId, key.path);\r\n    const encodedPath = indexKey[1];\r\n    const startRange = IDBKeyRange.lowerBound(indexKey);\r\n    let containsKey = false;\r\n    return documentMutationsStore(txn)\r\n        .iterate({ range: startRange, keysOnly: true }, (key, value, control) => {\r\n        const [userID, keyPath, /*batchID*/ _] = key;\r\n        if (userID === userId && keyPath === encodedPath) {\r\n            containsKey = true;\r\n        }\r\n        control.done();\r\n    })\r\n        .next(() => containsKey);\r\n}\r\n/** Returns true if any mutation queue contains the given document. */\r\nfunction mutationQueuesContainKey(txn, docKey) {\r\n    let found = false;\r\n    return mutationQueuesStore(txn)\r\n        .iterateSerial(userId => {\r\n        return mutationQueueContainsKey(txn, userId, docKey).next(containsKey => {\r\n            if (containsKey) {\r\n                found = true;\r\n            }\r\n            return PersistencePromise.resolve(!containsKey);\r\n        });\r\n    })\r\n        .next(() => found);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the mutations object store.\r\n */\r\nfunction mutationsStore(txn) {\r\n    return getStore(txn, DbMutationBatch.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\r\n */\r\nfunction documentMutationsStore(txn) {\r\n    return getStore(txn, DbDocumentMutation.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\r\n */\r\nfunction mutationQueuesStore(txn) {\r\n    return getStore(txn, DbMutationQueue.store);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Offset to ensure non-overlapping target ids. */\r\nconst OFFSET = 2;\r\n/**\r\n * Generates monotonically increasing target IDs for sending targets to the\r\n * watch stream.\r\n *\r\n * The client constructs two generators, one for the target cache, and one for\r\n * for the sync engine (to generate limbo documents targets). These\r\n * generators produce non-overlapping IDs (by using even and odd IDs\r\n * respectively).\r\n *\r\n * By separating the target ID space, the query cache can generate target IDs\r\n * that persist across client restarts, while sync engine can independently\r\n * generate in-memory target IDs that are transient and can be reused after a\r\n * restart.\r\n */\r\nclass TargetIdGenerator {\r\n    constructor(lastId) {\r\n        this.lastId = lastId;\r\n    }\r\n    next() {\r\n        this.lastId += OFFSET;\r\n        return this.lastId;\r\n    }\r\n    static forTargetCache() {\r\n        // The target cache generator must return '2' in its first call to `next()`\r\n        // as there is no differentiation in the protocol layer between an unset\r\n        // number and the number '0'. If we were to sent a target with target ID\r\n        // '0', the backend would consider it unset and replace it with its own ID.\r\n        return new TargetIdGenerator(2 - OFFSET);\r\n    }\r\n    static forSyncEngine() {\r\n        // Sync engine assigns target IDs for limbo document detection.\r\n        return new TargetIdGenerator(1 - OFFSET);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass IndexedDbTargetCache {\r\n    constructor(referenceDelegate, serializer) {\r\n        this.referenceDelegate = referenceDelegate;\r\n        this.serializer = serializer;\r\n    }\r\n    // PORTING NOTE: We don't cache global metadata for the target cache, since\r\n    // some of it (in particular `highestTargetId`) can be modified by secondary\r\n    // tabs. We could perhaps be more granular (and e.g. still cache\r\n    // `lastRemoteSnapshotVersion` in memory) but for simplicity we currently go\r\n    // to IndexedDb whenever we need to read metadata. We can revisit if it turns\r\n    // out to have a meaningful performance impact.\r\n    allocateTargetId(transaction) {\r\n        return this.retrieveMetadata(transaction).next(metadata => {\r\n            const targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);\r\n            metadata.highestTargetId = targetIdGenerator.next();\r\n            return this.saveMetadata(transaction, metadata).next(() => metadata.highestTargetId);\r\n        });\r\n    }\r\n    getLastRemoteSnapshotVersion(transaction) {\r\n        return this.retrieveMetadata(transaction).next(metadata => {\r\n            return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));\r\n        });\r\n    }\r\n    getHighestSequenceNumber(transaction) {\r\n        return this.retrieveMetadata(transaction).next(targetGlobal => targetGlobal.highestListenSequenceNumber);\r\n    }\r\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\r\n        return this.retrieveMetadata(transaction).next(metadata => {\r\n            metadata.highestListenSequenceNumber = highestListenSequenceNumber;\r\n            if (lastRemoteSnapshotVersion) {\r\n                metadata.lastRemoteSnapshotVersion =\r\n                    lastRemoteSnapshotVersion.toTimestamp();\r\n            }\r\n            if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {\r\n                metadata.highestListenSequenceNumber = highestListenSequenceNumber;\r\n            }\r\n            return this.saveMetadata(transaction, metadata);\r\n        });\r\n    }\r\n    addTargetData(transaction, targetData) {\r\n        return this.saveTargetData(transaction, targetData).next(() => {\r\n            return this.retrieveMetadata(transaction).next(metadata => {\r\n                metadata.targetCount += 1;\r\n                this.updateMetadataFromTargetData(targetData, metadata);\r\n                return this.saveMetadata(transaction, metadata);\r\n            });\r\n        });\r\n    }\r\n    updateTargetData(transaction, targetData) {\r\n        return this.saveTargetData(transaction, targetData);\r\n    }\r\n    removeTargetData(transaction, targetData) {\r\n        return this.removeMatchingKeysForTargetId(transaction, targetData.targetId)\r\n            .next(() => targetsStore(transaction).delete(targetData.targetId))\r\n            .next(() => this.retrieveMetadata(transaction))\r\n            .next(metadata => {\r\n            hardAssert(metadata.targetCount > 0);\r\n            metadata.targetCount -= 1;\r\n            return this.saveMetadata(transaction, metadata);\r\n        });\r\n    }\r\n    /**\r\n     * Drops any targets with sequence number less than or equal to the upper bound, excepting those\r\n     * present in `activeTargetIds`. Document associations for the removed targets are also removed.\r\n     * Returns the number of targets removed.\r\n     */\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        let count = 0;\r\n        const promises = [];\r\n        return targetsStore(txn)\r\n            .iterate((key, value) => {\r\n            const targetData = fromDbTarget(value);\r\n            if (targetData.sequenceNumber <= upperBound &&\r\n                activeTargetIds.get(targetData.targetId) === null) {\r\n                count++;\r\n                promises.push(this.removeTargetData(txn, targetData));\r\n            }\r\n        })\r\n            .next(() => PersistencePromise.waitFor(promises))\r\n            .next(() => count);\r\n    }\r\n    /**\r\n     * Call provided function with each `TargetData` that we have cached.\r\n     */\r\n    forEachTarget(txn, f) {\r\n        return targetsStore(txn).iterate((key, value) => {\r\n            const targetData = fromDbTarget(value);\r\n            f(targetData);\r\n        });\r\n    }\r\n    retrieveMetadata(transaction) {\r\n        return globalTargetStore(transaction)\r\n            .get(DbTargetGlobal.key)\r\n            .next(metadata => {\r\n            hardAssert(metadata !== null);\r\n            return metadata;\r\n        });\r\n    }\r\n    saveMetadata(transaction, metadata) {\r\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, metadata);\r\n    }\r\n    saveTargetData(transaction, targetData) {\r\n        return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));\r\n    }\r\n    /**\r\n     * In-place updates the provided metadata to account for values in the given\r\n     * TargetData. Saving is done separately. Returns true if there were any\r\n     * changes to the metadata.\r\n     */\r\n    updateMetadataFromTargetData(targetData, metadata) {\r\n        let updated = false;\r\n        if (targetData.targetId > metadata.highestTargetId) {\r\n            metadata.highestTargetId = targetData.targetId;\r\n            updated = true;\r\n        }\r\n        if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {\r\n            metadata.highestListenSequenceNumber = targetData.sequenceNumber;\r\n            updated = true;\r\n        }\r\n        return updated;\r\n    }\r\n    getTargetCount(transaction) {\r\n        return this.retrieveMetadata(transaction).next(metadata => metadata.targetCount);\r\n    }\r\n    getTargetData(transaction, target) {\r\n        // Iterating by the canonicalId may yield more than one result because\r\n        // canonicalId values are not required to be unique per target. This query\r\n        // depends on the queryTargets index to be efficient.\r\n        const canonicalId = canonifyTarget(target);\r\n        const range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\r\n        let result = null;\r\n        return targetsStore(transaction)\r\n            .iterate({ range, index: DbTarget.queryTargetsIndexName }, (key, value, control) => {\r\n            const found = fromDbTarget(value);\r\n            // After finding a potential match, check that the target is\r\n            // actually equal to the requested target.\r\n            if (targetEquals(target, found.target)) {\r\n                result = found;\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => result);\r\n    }\r\n    addMatchingKeys(txn, keys, targetId) {\r\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\r\n        // IndexedDb.\r\n        const promises = [];\r\n        const store = documentTargetStore(txn);\r\n        keys.forEach(key => {\r\n            const path = encodeResourcePath(key.path);\r\n            promises.push(store.put(new DbTargetDocument(targetId, path)));\r\n            promises.push(this.referenceDelegate.addReference(txn, targetId, key));\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    removeMatchingKeys(txn, keys, targetId) {\r\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\r\n        // IndexedDb.\r\n        const store = documentTargetStore(txn);\r\n        return PersistencePromise.forEach(keys, (key) => {\r\n            const path = encodeResourcePath(key.path);\r\n            return PersistencePromise.waitFor([\r\n                store.delete([targetId, path]),\r\n                this.referenceDelegate.removeReference(txn, targetId, key)\r\n            ]);\r\n        });\r\n    }\r\n    removeMatchingKeysForTargetId(txn, targetId) {\r\n        const store = documentTargetStore(txn);\r\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        return store.delete(range);\r\n    }\r\n    getMatchingKeysForTargetId(txn, targetId) {\r\n        const range = IDBKeyRange.bound([targetId], [targetId + 1], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        const store = documentTargetStore(txn);\r\n        let result = documentKeySet();\r\n        return store\r\n            .iterate({ range, keysOnly: true }, (key, _, control) => {\r\n            const path = decodeResourcePath(key[1]);\r\n            const docKey = new DocumentKey(path);\r\n            result = result.add(docKey);\r\n        })\r\n            .next(() => result);\r\n    }\r\n    containsKey(txn, key) {\r\n        const path = encodeResourcePath(key.path);\r\n        const range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \r\n        /*lowerOpen=*/ false, \r\n        /*upperOpen=*/ true);\r\n        let count = 0;\r\n        return documentTargetStore(txn)\r\n            .iterate({\r\n            index: DbTargetDocument.documentTargetsIndex,\r\n            keysOnly: true,\r\n            range\r\n        }, ([targetId, path], _, control) => {\r\n            // Having a sentinel row for a document does not count as containing that document;\r\n            // For the target cache, containing the document means the document is part of some\r\n            // target.\r\n            if (targetId !== 0) {\r\n                count++;\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => count > 0);\r\n    }\r\n    /**\r\n     * Looks up a TargetData entry by target ID.\r\n     *\r\n     * @param targetId - The target ID of the TargetData entry to look up.\r\n     * @returns The cached TargetData entry, or null if the cache has no entry for\r\n     * the target.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    getTargetDataForTarget(transaction, targetId) {\r\n        return targetsStore(transaction)\r\n            .get(targetId)\r\n            .next(found => {\r\n            if (found) {\r\n                return fromDbTarget(found);\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the queries object store.\r\n */\r\nfunction targetsStore(txn) {\r\n    return getStore(txn, DbTarget.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the target globals object store.\r\n */\r\nfunction globalTargetStore(txn) {\r\n    return getStore(txn, DbTargetGlobal.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the document target object store.\r\n */\r\nfunction documentTargetStore(txn) {\r\n    return getStore(txn, DbTargetDocument.store);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Verifies the error thrown by a LocalStore operation. If a LocalStore\r\n * operation fails because the primary lease has been taken by another client,\r\n * we ignore the error (the persistence layer will immediately call\r\n * `applyPrimaryLease` to propagate the primary state change). All other errors\r\n * are re-thrown.\r\n *\r\n * @param err - An error returned by a LocalStore operation.\r\n * @returns A Promise that resolves after we recovered, or the original error.\r\n */\r\nasync function ignoreIfPrimaryLeaseLoss(err) {\r\n    if (err.code === Code.FAILED_PRECONDITION &&\r\n        err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {\r\n        logDebug('LocalStore', 'Unexpectedly lost primary lease');\r\n    }\r\n    else {\r\n        throw err;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst GC_DID_NOT_RUN = {\r\n    didRun: false,\r\n    sequenceNumbersCollected: 0,\r\n    targetsRemoved: 0,\r\n    documentsRemoved: 0\r\n};\r\nconst LRU_COLLECTION_DISABLED = -1;\r\nconst LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;\r\nclass LruParams {\r\n    constructor(\r\n    // When we attempt to collect, we will only do so if the cache size is greater than this\r\n    // threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.\r\n    cacheSizeCollectionThreshold, \r\n    // The percentage of sequence numbers that we will attempt to collect\r\n    percentileToCollect, \r\n    // A cap on the total number of sequence numbers that will be collected. This prevents\r\n    // us from collecting a huge number of sequence numbers if the cache has grown very large.\r\n    maximumSequenceNumbersToCollect) {\r\n        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;\r\n        this.percentileToCollect = percentileToCollect;\r\n        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;\r\n    }\r\n    static withCacheSize(cacheSize) {\r\n        return new LruParams(cacheSize, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\r\n    }\r\n}\r\nLruParams.DEFAULT_COLLECTION_PERCENTILE = 10;\r\nLruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1000;\r\nLruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\r\nLruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$e = 'LruGarbageCollector';\r\nconst LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;\r\n/** How long we wait to try running LRU GC after SDK initialization. */\r\nconst INITIAL_GC_DELAY_MS = 1 * 60 * 1000;\r\n/** Minimum amount of time between GC checks, after the first one. */\r\nconst REGULAR_GC_DELAY_MS = 5 * 60 * 1000;\r\nfunction bufferEntryComparator([aSequence, aIndex], [bSequence, bIndex]) {\r\n    const seqCmp = primitiveComparator(aSequence, bSequence);\r\n    if (seqCmp === 0) {\r\n        // This order doesn't matter, but we can bias against churn by sorting\r\n        // entries created earlier as less than newer entries.\r\n        return primitiveComparator(aIndex, bIndex);\r\n    }\r\n    else {\r\n        return seqCmp;\r\n    }\r\n}\r\n/**\r\n * Used to calculate the nth sequence number. Keeps a rolling buffer of the\r\n * lowest n values passed to `addElement`, and finally reports the largest of\r\n * them in `maxValue`.\r\n */\r\nclass RollingSequenceNumberBuffer {\r\n    constructor(maxElements) {\r\n        this.maxElements = maxElements;\r\n        this.buffer = new SortedSet(bufferEntryComparator);\r\n        this.previousIndex = 0;\r\n    }\r\n    nextIndex() {\r\n        return ++this.previousIndex;\r\n    }\r\n    addElement(sequenceNumber) {\r\n        const entry = [sequenceNumber, this.nextIndex()];\r\n        if (this.buffer.size < this.maxElements) {\r\n            this.buffer = this.buffer.add(entry);\r\n        }\r\n        else {\r\n            const highestValue = this.buffer.last();\r\n            if (bufferEntryComparator(entry, highestValue) < 0) {\r\n                this.buffer = this.buffer.delete(highestValue).add(entry);\r\n            }\r\n        }\r\n    }\r\n    get maxValue() {\r\n        // Guaranteed to be non-empty. If we decide we are not collecting any\r\n        // sequence numbers, nthSequenceNumber below short-circuits. If we have\r\n        // decided that we are collecting n sequence numbers, it's because n is some\r\n        // percentage of the existing sequence numbers. That means we should never\r\n        // be in a situation where we are collecting sequence numbers but don't\r\n        // actually have any.\r\n        return this.buffer.last()[0];\r\n    }\r\n}\r\n/**\r\n * This class is responsible for the scheduling of LRU garbage collection. It handles checking\r\n * whether or not GC is enabled, as well as which delay to use before the next run.\r\n */\r\nclass LruScheduler {\r\n    constructor(garbageCollector, asyncQueue) {\r\n        this.garbageCollector = garbageCollector;\r\n        this.asyncQueue = asyncQueue;\r\n        this.hasRun = false;\r\n        this.gcTask = null;\r\n    }\r\n    start(localStore) {\r\n        if (this.garbageCollector.params.cacheSizeCollectionThreshold !==\r\n            LRU_COLLECTION_DISABLED) {\r\n            this.scheduleGC(localStore);\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.gcTask) {\r\n            this.gcTask.cancel();\r\n            this.gcTask = null;\r\n        }\r\n    }\r\n    get started() {\r\n        return this.gcTask !== null;\r\n    }\r\n    scheduleGC(localStore) {\r\n        const delay = this.hasRun ? REGULAR_GC_DELAY_MS : INITIAL_GC_DELAY_MS;\r\n        logDebug('LruGarbageCollector', `Garbage collection scheduled in ${delay}ms`);\r\n        this.gcTask = this.asyncQueue.enqueueAfterDelay(\"lru_garbage_collection\" /* LruGarbageCollection */, delay, async () => {\r\n            this.gcTask = null;\r\n            this.hasRun = true;\r\n            try {\r\n                await localStore.collectGarbage(this.garbageCollector);\r\n            }\r\n            catch (e) {\r\n                if (isIndexedDbTransactionError(e)) {\r\n                    logDebug(LOG_TAG$e, 'Ignoring IndexedDB error during garbage collection: ', e);\r\n                }\r\n                else {\r\n                    await ignoreIfPrimaryLeaseLoss(e);\r\n                }\r\n            }\r\n            await this.scheduleGC(localStore);\r\n        });\r\n    }\r\n}\r\n/** Implements the steps for LRU garbage collection. */\r\nclass LruGarbageCollectorImpl {\r\n    constructor(delegate, params) {\r\n        this.delegate = delegate;\r\n        this.params = params;\r\n    }\r\n    calculateTargetCount(txn, percentile) {\r\n        return this.delegate.getSequenceNumberCount(txn).next(targetCount => {\r\n            return Math.floor((percentile / 100.0) * targetCount);\r\n        });\r\n    }\r\n    nthSequenceNumber(txn, n) {\r\n        if (n === 0) {\r\n            return PersistencePromise.resolve(ListenSequence.INVALID);\r\n        }\r\n        const buffer = new RollingSequenceNumberBuffer(n);\r\n        return this.delegate\r\n            .forEachTarget(txn, target => buffer.addElement(target.sequenceNumber))\r\n            .next(() => {\r\n            return this.delegate.forEachOrphanedDocumentSequenceNumber(txn, sequenceNumber => buffer.addElement(sequenceNumber));\r\n        })\r\n            .next(() => buffer.maxValue);\r\n    }\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        return this.delegate.removeTargets(txn, upperBound, activeTargetIds);\r\n    }\r\n    removeOrphanedDocuments(txn, upperBound) {\r\n        return this.delegate.removeOrphanedDocuments(txn, upperBound);\r\n    }\r\n    collect(txn, activeTargetIds) {\r\n        if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {\r\n            logDebug('LruGarbageCollector', 'Garbage collection skipped; disabled');\r\n            return PersistencePromise.resolve(GC_DID_NOT_RUN);\r\n        }\r\n        return this.getCacheSize(txn).next(cacheSize => {\r\n            if (cacheSize < this.params.cacheSizeCollectionThreshold) {\r\n                logDebug('LruGarbageCollector', `Garbage collection skipped; Cache size ${cacheSize} ` +\r\n                    `is lower than threshold ${this.params.cacheSizeCollectionThreshold}`);\r\n                return GC_DID_NOT_RUN;\r\n            }\r\n            else {\r\n                return this.runGarbageCollection(txn, activeTargetIds);\r\n            }\r\n        });\r\n    }\r\n    getCacheSize(txn) {\r\n        return this.delegate.getCacheSize(txn);\r\n    }\r\n    runGarbageCollection(txn, activeTargetIds) {\r\n        let upperBoundSequenceNumber;\r\n        let sequenceNumbersToCollect, targetsRemoved;\r\n        // Timestamps for various pieces of the process\r\n        let countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;\r\n        const startTs = Date.now();\r\n        return this.calculateTargetCount(txn, this.params.percentileToCollect)\r\n            .next(sequenceNumbers => {\r\n            // Cap at the configured max\r\n            if (sequenceNumbers > this.params.maximumSequenceNumbersToCollect) {\r\n                logDebug('LruGarbageCollector', 'Capping sequence numbers to collect down ' +\r\n                    `to the maximum of ${this.params.maximumSequenceNumbersToCollect} ` +\r\n                    `from ${sequenceNumbers}`);\r\n                sequenceNumbersToCollect =\r\n                    this.params.maximumSequenceNumbersToCollect;\r\n            }\r\n            else {\r\n                sequenceNumbersToCollect = sequenceNumbers;\r\n            }\r\n            countedTargetsTs = Date.now();\r\n            return this.nthSequenceNumber(txn, sequenceNumbersToCollect);\r\n        })\r\n            .next(upperBound => {\r\n            upperBoundSequenceNumber = upperBound;\r\n            foundUpperBoundTs = Date.now();\r\n            return this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);\r\n        })\r\n            .next(numTargetsRemoved => {\r\n            targetsRemoved = numTargetsRemoved;\r\n            removedTargetsTs = Date.now();\r\n            return this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);\r\n        })\r\n            .next(documentsRemoved => {\r\n            removedDocumentsTs = Date.now();\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                const desc = 'LRU Garbage Collection\\n' +\r\n                    `\\tCounted targets in ${countedTargetsTs - startTs}ms\\n` +\r\n                    `\\tDetermined least recently used ${sequenceNumbersToCollect} in ` +\r\n                    `${foundUpperBoundTs - countedTargetsTs}ms\\n` +\r\n                    `\\tRemoved ${targetsRemoved} targets in ` +\r\n                    `${removedTargetsTs - foundUpperBoundTs}ms\\n` +\r\n                    `\\tRemoved ${documentsRemoved} documents in ` +\r\n                    `${removedDocumentsTs - removedTargetsTs}ms\\n` +\r\n                    `Total Duration: ${removedDocumentsTs - startTs}ms`;\r\n                logDebug('LruGarbageCollector', desc);\r\n            }\r\n            return PersistencePromise.resolve({\r\n                didRun: true,\r\n                sequenceNumbersCollected: sequenceNumbersToCollect,\r\n                targetsRemoved,\r\n                documentsRemoved\r\n            });\r\n        });\r\n    }\r\n}\r\nfunction newLruGarbageCollector(delegate, params) {\r\n    return new LruGarbageCollectorImpl(delegate, params);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Provides LRU functionality for IndexedDB persistence. */\r\nclass IndexedDbLruDelegateImpl {\r\n    constructor(db, params) {\r\n        this.db = db;\r\n        this.garbageCollector = newLruGarbageCollector(this, params);\r\n    }\r\n    getSequenceNumberCount(txn) {\r\n        const docCountPromise = this.orphanedDocumentCount(txn);\r\n        const targetCountPromise = this.db.getTargetCache().getTargetCount(txn);\r\n        return targetCountPromise.next(targetCount => docCountPromise.next(docCount => targetCount + docCount));\r\n    }\r\n    orphanedDocumentCount(txn) {\r\n        let orphanedCount = 0;\r\n        return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\r\n            orphanedCount++;\r\n        }).next(() => orphanedCount);\r\n    }\r\n    forEachTarget(txn, f) {\r\n        return this.db.getTargetCache().forEachTarget(txn, f);\r\n    }\r\n    forEachOrphanedDocumentSequenceNumber(txn, f) {\r\n        return this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => f(sequenceNumber));\r\n    }\r\n    addReference(txn, targetId, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    removeReference(txn, targetId, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    removeTargets(txn, upperBound, activeTargetIds) {\r\n        return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);\r\n    }\r\n    markPotentiallyOrphaned(txn, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    /**\r\n     * Returns true if anything would prevent this document from being garbage\r\n     * collected, given that the document in question is not present in any\r\n     * targets and has a sequence number less than or equal to the upper bound for\r\n     * the collection run.\r\n     */\r\n    isPinned(txn, docKey) {\r\n        return mutationQueuesContainKey(txn, docKey);\r\n    }\r\n    removeOrphanedDocuments(txn, upperBound) {\r\n        const documentCache = this.db.getRemoteDocumentCache();\r\n        const changeBuffer = documentCache.newChangeBuffer();\r\n        const promises = [];\r\n        let documentCount = 0;\r\n        const iteration = this.forEachOrphanedDocument(txn, (docKey, sequenceNumber) => {\r\n            if (sequenceNumber <= upperBound) {\r\n                const p = this.isPinned(txn, docKey).next(isPinned => {\r\n                    if (!isPinned) {\r\n                        documentCount++;\r\n                        // Our size accounting requires us to read all documents before\r\n                        // removing them.\r\n                        return changeBuffer.getEntry(txn, docKey).next(() => {\r\n                            changeBuffer.removeEntry(docKey, SnapshotVersion.min());\r\n                            return documentTargetStore(txn).delete(sentinelKey$1(docKey));\r\n                        });\r\n                    }\r\n                });\r\n                promises.push(p);\r\n            }\r\n        });\r\n        return iteration\r\n            .next(() => PersistencePromise.waitFor(promises))\r\n            .next(() => changeBuffer.apply(txn))\r\n            .next(() => documentCount);\r\n    }\r\n    removeTarget(txn, targetData) {\r\n        const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\r\n        return this.db.getTargetCache().updateTargetData(txn, updated);\r\n    }\r\n    updateLimboDocument(txn, key) {\r\n        return writeSentinelKey(txn, key);\r\n    }\r\n    /**\r\n     * Call provided function for each document in the cache that is 'orphaned'. Orphaned\r\n     * means not a part of any target, so the only entry in the target-document index for\r\n     * that document will be the sentinel row (targetId 0), which will also have the sequence\r\n     * number for the last time the document was accessed.\r\n     */\r\n    forEachOrphanedDocument(txn, f) {\r\n        const store = documentTargetStore(txn);\r\n        let nextToReport = ListenSequence.INVALID;\r\n        let nextPath;\r\n        return store\r\n            .iterate({\r\n            index: DbTargetDocument.documentTargetsIndex\r\n        }, ([targetId, docKey], { path, sequenceNumber }) => {\r\n            if (targetId === 0) {\r\n                // if nextToReport is valid, report it, this is a new key so the\r\n                // last one must not be a member of any targets.\r\n                if (nextToReport !== ListenSequence.INVALID) {\r\n                    f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\r\n                }\r\n                // set nextToReport to be this sequence number. It's the next one we\r\n                // might report, if we don't find any targets for this document.\r\n                // Note that the sequence number must be defined when the targetId\r\n                // is 0.\r\n                nextToReport = sequenceNumber;\r\n                nextPath = path;\r\n            }\r\n            else {\r\n                // set nextToReport to be invalid, we know we don't need to report\r\n                // this one since we found a target for it.\r\n                nextToReport = ListenSequence.INVALID;\r\n            }\r\n        })\r\n            .next(() => {\r\n            // Since we report sequence numbers after getting to the next key, we\r\n            // need to check if the last key we iterated over was an orphaned\r\n            // document and report it.\r\n            if (nextToReport !== ListenSequence.INVALID) {\r\n                f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);\r\n            }\r\n        });\r\n    }\r\n    getCacheSize(txn) {\r\n        return this.db.getRemoteDocumentCache().getSize(txn);\r\n    }\r\n}\r\nfunction sentinelKey$1(key) {\r\n    return [0, encodeResourcePath(key.path)];\r\n}\r\n/**\r\n * @returns A value suitable for writing a sentinel row in the target-document\r\n * store.\r\n */\r\nfunction sentinelRow(key, sequenceNumber) {\r\n    return new DbTargetDocument(0, encodeResourcePath(key.path), sequenceNumber);\r\n}\r\nfunction writeSentinelKey(txn, key) {\r\n    return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A map implementation that uses objects as keys. Objects must have an\r\n * associated equals function and must be immutable. Entries in the map are\r\n * stored together with the key being produced from the mapKeyFn. This map\r\n * automatically handles collisions of keys.\r\n */\r\nclass ObjectMap {\r\n    constructor(mapKeyFn, equalsFn) {\r\n        this.mapKeyFn = mapKeyFn;\r\n        this.equalsFn = equalsFn;\r\n        /**\r\n         * The inner map for a key/value pair. Due to the possibility of collisions we\r\n         * keep a list of entries that we do a linear search through to find an actual\r\n         * match. Note that collisions should be rare, so we still expect near\r\n         * constant time lookups in practice.\r\n         */\r\n        this.inner = {};\r\n    }\r\n    /** Get a value for this key, or undefined if it does not exist. */\r\n    get(key) {\r\n        const id = this.mapKeyFn(key);\r\n        const matches = this.inner[id];\r\n        if (matches === undefined) {\r\n            return undefined;\r\n        }\r\n        for (const [otherKey, value] of matches) {\r\n            if (this.equalsFn(otherKey, key)) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    has(key) {\r\n        return this.get(key) !== undefined;\r\n    }\r\n    /** Put this key and value in the map. */\r\n    set(key, value) {\r\n        const id = this.mapKeyFn(key);\r\n        const matches = this.inner[id];\r\n        if (matches === undefined) {\r\n            this.inner[id] = [[key, value]];\r\n            return;\r\n        }\r\n        for (let i = 0; i < matches.length; i++) {\r\n            if (this.equalsFn(matches[i][0], key)) {\r\n                matches[i] = [key, value];\r\n                return;\r\n            }\r\n        }\r\n        matches.push([key, value]);\r\n    }\r\n    /**\r\n     * Remove this key from the map. Returns a boolean if anything was deleted.\r\n     */\r\n    delete(key) {\r\n        const id = this.mapKeyFn(key);\r\n        const matches = this.inner[id];\r\n        if (matches === undefined) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < matches.length; i++) {\r\n            if (this.equalsFn(matches[i][0], key)) {\r\n                if (matches.length === 1) {\r\n                    delete this.inner[id];\r\n                }\r\n                else {\r\n                    matches.splice(i, 1);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    forEach(fn) {\r\n        forEach(this.inner, (_, entries) => {\r\n            for (const [k, v] of entries) {\r\n                fn(k, v);\r\n            }\r\n        });\r\n    }\r\n    isEmpty() {\r\n        return isEmpty(this.inner);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\r\n * It can be used to batch up a set of changes to be written to the cache, but\r\n * additionally supports reading entries back with the `getEntry()` method,\r\n * falling back to the underlying RemoteDocumentCache if no entry is\r\n * buffered.\r\n *\r\n * Entries added to the cache *must* be read first. This is to facilitate\r\n * calculating the size delta of the pending changes.\r\n *\r\n * PORTING NOTE: This class was implemented then removed from other platforms.\r\n * If byte-counting ends up being needed on the other platforms, consider\r\n * porting this class as part of that implementation work.\r\n */\r\nclass RemoteDocumentChangeBuffer {\r\n    constructor() {\r\n        // A mapping of document key to the new cache entry that should be written.\r\n        this.changes = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\r\n        this.changesApplied = false;\r\n    }\r\n    /**\r\n     * Buffers a `RemoteDocumentCache.addEntry()` call.\r\n     *\r\n     * You can only modify documents that have already been retrieved via\r\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\r\n     */\r\n    addEntry(document) {\r\n        this.assertNotApplied();\r\n        this.changes.set(document.key, document);\r\n    }\r\n    /**\r\n     * Buffers a `RemoteDocumentCache.removeEntry()` call.\r\n     *\r\n     * You can only remove documents that have already been retrieved via\r\n     * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\r\n     */\r\n    removeEntry(key, readTime) {\r\n        this.assertNotApplied();\r\n        this.changes.set(key, MutableDocument.newInvalidDocument(key).setReadTime(readTime));\r\n    }\r\n    /**\r\n     * Looks up an entry in the cache. The buffered changes will first be checked,\r\n     * and if no buffered change applies, this will forward to\r\n     * `RemoteDocumentCache.getEntry()`.\r\n     *\r\n     * @param transaction - The transaction in which to perform any persistence\r\n     *     operations.\r\n     * @param documentKey - The key of the entry to look up.\r\n     * @returns The cached document or an invalid document if we have nothing\r\n     * cached.\r\n     */\r\n    getEntry(transaction, documentKey) {\r\n        this.assertNotApplied();\r\n        const bufferedEntry = this.changes.get(documentKey);\r\n        if (bufferedEntry !== undefined) {\r\n            return PersistencePromise.resolve(bufferedEntry);\r\n        }\r\n        else {\r\n            return this.getFromCache(transaction, documentKey);\r\n        }\r\n    }\r\n    /**\r\n     * Looks up several entries in the cache, forwarding to\r\n     * `RemoteDocumentCache.getEntry()`.\r\n     *\r\n     * @param transaction - The transaction in which to perform any persistence\r\n     *     operations.\r\n     * @param documentKeys - The keys of the entries to look up.\r\n     * @returns A map of cached documents, indexed by key. If an entry cannot be\r\n     *     found, the corresponding key will be mapped to an invalid document.\r\n     */\r\n    getEntries(transaction, documentKeys) {\r\n        return this.getAllFromCache(transaction, documentKeys);\r\n    }\r\n    /**\r\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\r\n     * the provided transaction.\r\n     */\r\n    apply(transaction) {\r\n        this.assertNotApplied();\r\n        this.changesApplied = true;\r\n        return this.applyChanges(transaction);\r\n    }\r\n    /** Helper to assert this.changes is not null  */\r\n    assertNotApplied() {\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The RemoteDocumentCache for IndexedDb. To construct, invoke\r\n * `newIndexedDbRemoteDocumentCache()`.\r\n */\r\nclass IndexedDbRemoteDocumentCacheImpl {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n    }\r\n    setIndexManager(indexManager) {\r\n        this.indexManager = indexManager;\r\n    }\r\n    /**\r\n     * Adds the supplied entries to the cache.\r\n     *\r\n     * All calls of `addEntry` are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\r\n     */\r\n    addEntry(transaction, key, doc) {\r\n        const documentStore = remoteDocumentsStore(transaction);\r\n        return documentStore.put(dbKey(key), doc);\r\n    }\r\n    /**\r\n     * Removes a document from the cache.\r\n     *\r\n     * All calls of `removeEntry`  are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()` to ensure proper accounting of metadata.\r\n     */\r\n    removeEntry(transaction, documentKey) {\r\n        const store = remoteDocumentsStore(transaction);\r\n        const key = dbKey(documentKey);\r\n        return store.delete(key);\r\n    }\r\n    /**\r\n     * Updates the current cache size.\r\n     *\r\n     * Callers to `addEntry()` and `removeEntry()` *must* call this afterwards to update the\r\n     * cache's metadata.\r\n     */\r\n    updateMetadata(transaction, sizeDelta) {\r\n        return this.getMetadata(transaction).next(metadata => {\r\n            metadata.byteSize += sizeDelta;\r\n            return this.setMetadata(transaction, metadata);\r\n        });\r\n    }\r\n    getEntry(transaction, documentKey) {\r\n        return remoteDocumentsStore(transaction)\r\n            .get(dbKey(documentKey))\r\n            .next(dbRemoteDoc => {\r\n            return this.maybeDecodeDocument(documentKey, dbRemoteDoc);\r\n        });\r\n    }\r\n    /**\r\n     * Looks up an entry in the cache.\r\n     *\r\n     * @param documentKey - The key of the entry to look up.\r\n     * @returns The cached document entry and its size.\r\n     */\r\n    getSizedEntry(transaction, documentKey) {\r\n        return remoteDocumentsStore(transaction)\r\n            .get(dbKey(documentKey))\r\n            .next(dbRemoteDoc => {\r\n            const doc = this.maybeDecodeDocument(documentKey, dbRemoteDoc);\r\n            return {\r\n                document: doc,\r\n                size: dbDocumentSize(dbRemoteDoc)\r\n            };\r\n        });\r\n    }\r\n    getEntries(transaction, documentKeys) {\r\n        let results = mutableDocumentMap();\r\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\r\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\r\n            results = results.insert(key, doc);\r\n        }).next(() => results);\r\n    }\r\n    /**\r\n     * Looks up several entries in the cache.\r\n     *\r\n     * @param documentKeys - The set of keys entries to look up.\r\n     * @returns A map of documents indexed by key and a map of sizes indexed by\r\n     *     key (zero if the document does not exist).\r\n     */\r\n    getSizedEntries(transaction, documentKeys) {\r\n        let results = mutableDocumentMap();\r\n        let sizeMap = new SortedMap(DocumentKey.comparator);\r\n        return this.forEachDbEntry(transaction, documentKeys, (key, dbRemoteDoc) => {\r\n            const doc = this.maybeDecodeDocument(key, dbRemoteDoc);\r\n            results = results.insert(key, doc);\r\n            sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));\r\n        }).next(() => {\r\n            return { documents: results, sizeMap };\r\n        });\r\n    }\r\n    forEachDbEntry(transaction, documentKeys, callback) {\r\n        if (documentKeys.isEmpty()) {\r\n            return PersistencePromise.resolve();\r\n        }\r\n        const range = IDBKeyRange.bound(documentKeys.first().path.toArray(), documentKeys.last().path.toArray());\r\n        const keyIter = documentKeys.getIterator();\r\n        let nextKey = keyIter.getNext();\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate({ range }, (potentialKeyRaw, dbRemoteDoc, control) => {\r\n            const potentialKey = DocumentKey.fromSegments(potentialKeyRaw);\r\n            // Go through keys not found in cache.\r\n            while (nextKey && DocumentKey.comparator(nextKey, potentialKey) < 0) {\r\n                callback(nextKey, null);\r\n                nextKey = keyIter.getNext();\r\n            }\r\n            if (nextKey && nextKey.isEqual(potentialKey)) {\r\n                // Key found in cache.\r\n                callback(nextKey, dbRemoteDoc);\r\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\r\n            }\r\n            // Skip to the next key (if there is one).\r\n            if (nextKey) {\r\n                control.skip(nextKey.path.toArray());\r\n            }\r\n            else {\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => {\r\n            // The rest of the keys are not in the cache. One case where `iterate`\r\n            // above won't go through them is when the cache is empty.\r\n            while (nextKey) {\r\n                callback(nextKey, null);\r\n                nextKey = keyIter.hasNext() ? keyIter.getNext() : null;\r\n            }\r\n        });\r\n    }\r\n    getAll(transaction, collection, sinceReadTime) {\r\n        let results = mutableDocumentMap();\r\n        const immediateChildrenPathLength = collection.length + 1;\r\n        const iterationOptions = {};\r\n        if (sinceReadTime.isEqual(SnapshotVersion.min())) {\r\n            // Documents are ordered by key, so we can use a prefix scan to narrow\r\n            // down the documents we need to match the query against.\r\n            const startKey = collection.toArray();\r\n            iterationOptions.range = IDBKeyRange.lowerBound(startKey);\r\n        }\r\n        else {\r\n            // Execute an index-free query and filter by read time. This is safe\r\n            // since all document changes to queries that have a\r\n            // lastLimboFreeSnapshotVersion (`sinceReadTime`) have a read time set.\r\n            const collectionKey = collection.toArray();\r\n            const readTimeKey = toDbTimestampKey(sinceReadTime);\r\n            iterationOptions.range = IDBKeyRange.lowerBound([collectionKey, readTimeKey], \r\n            /* open= */ true);\r\n            iterationOptions.index = DbRemoteDocument.collectionReadTimeIndex;\r\n        }\r\n        return remoteDocumentsStore(transaction)\r\n            .iterate(iterationOptions, (key, dbRemoteDoc, control) => {\r\n            // The query is actually returning any path that starts with the query\r\n            // path prefix which may include documents in subcollections. For\r\n            // example, a query on 'rooms' will return rooms/abc/messages/xyx but we\r\n            // shouldn't match it. Fix this by discarding rows with document keys\r\n            // more than one segment longer than the query path.\r\n            if (key.length !== immediateChildrenPathLength) {\r\n                return;\r\n            }\r\n            const document = this.maybeDecodeDocument(DocumentKey.fromSegments(key), dbRemoteDoc);\r\n            if (collection.isPrefixOf(document.key.path)) {\r\n                results = results.insert(document.key, document);\r\n            }\r\n            else {\r\n                control.done();\r\n            }\r\n        })\r\n            .next(() => results);\r\n    }\r\n    newChangeBuffer(options) {\r\n        return new IndexedDbRemoteDocumentChangeBuffer(this, !!options && options.trackRemovals);\r\n    }\r\n    getSize(txn) {\r\n        return this.getMetadata(txn).next(metadata => metadata.byteSize);\r\n    }\r\n    getMetadata(txn) {\r\n        return documentGlobalStore(txn)\r\n            .get(DbRemoteDocumentGlobal.key)\r\n            .next(metadata => {\r\n            hardAssert(!!metadata);\r\n            return metadata;\r\n        });\r\n    }\r\n    setMetadata(txn, metadata) {\r\n        return documentGlobalStore(txn).put(DbRemoteDocumentGlobal.key, metadata);\r\n    }\r\n    /**\r\n     * Decodes `dbRemoteDoc` and returns the document (or an invalid document if\r\n     * the document corresponds to the format used for sentinel deletes).\r\n     */\r\n    maybeDecodeDocument(documentKey, dbRemoteDoc) {\r\n        if (dbRemoteDoc) {\r\n            const doc = fromDbRemoteDocument(this.serializer, dbRemoteDoc);\r\n            // Whether the document is a sentinel removal and should only be used in the\r\n            // `getNewDocumentChanges()`\r\n            const isSentinelRemoval = doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min());\r\n            if (!isSentinelRemoval) {\r\n                return doc;\r\n            }\r\n        }\r\n        return MutableDocument.newInvalidDocument(documentKey);\r\n    }\r\n}\r\n/** Creates a new IndexedDbRemoteDocumentCache. */\r\nfunction newIndexedDbRemoteDocumentCache(serializer) {\r\n    return new IndexedDbRemoteDocumentCacheImpl(serializer);\r\n}\r\n/**\r\n * Returns the set of documents that have changed since the specified read\r\n * time.\r\n */\r\n// PORTING NOTE: This is only used for multi-tab synchronization.\r\nfunction remoteDocumentCacheGetNewDocumentChanges(remoteDocumentCache, transaction, sinceReadTime) {\r\n    const remoteDocumentCacheImpl = debugCast(remoteDocumentCache);\r\n    let changedDocs = mutableDocumentMap();\r\n    let lastReadTime = toDbTimestampKey(sinceReadTime);\r\n    const documentsStore = remoteDocumentsStore(transaction);\r\n    const range = IDBKeyRange.lowerBound(lastReadTime, true);\r\n    return documentsStore\r\n        .iterate({ index: DbRemoteDocument.readTimeIndex, range }, (_, dbRemoteDoc) => {\r\n        // Unlike `getEntry()` and others, `getNewDocumentChanges()` parses\r\n        // the documents directly since we want to keep sentinel deletes.\r\n        const doc = fromDbRemoteDocument(remoteDocumentCacheImpl.serializer, dbRemoteDoc);\r\n        changedDocs = changedDocs.insert(doc.key, doc);\r\n        lastReadTime = dbRemoteDoc.readTime;\r\n    })\r\n        .next(() => {\r\n        return {\r\n            changedDocs,\r\n            readTime: fromDbTimestampKey(lastReadTime)\r\n        };\r\n    });\r\n}\r\n/**\r\n * Returns the read time of the most recently read document in the cache, or\r\n * SnapshotVersion.min() if not available.\r\n */\r\n// PORTING NOTE: This is only used for multi-tab synchronization.\r\nfunction remoteDocumentCacheGetLastReadTime(transaction) {\r\n    const documentsStore = remoteDocumentsStore(transaction);\r\n    // If there are no existing entries, we return SnapshotVersion.min().\r\n    let readTime = SnapshotVersion.min();\r\n    return documentsStore\r\n        .iterate({ index: DbRemoteDocument.readTimeIndex, reverse: true }, (key, dbRemoteDoc, control) => {\r\n        if (dbRemoteDoc.readTime) {\r\n            readTime = fromDbTimestampKey(dbRemoteDoc.readTime);\r\n        }\r\n        control.done();\r\n    })\r\n        .next(() => readTime);\r\n}\r\n/**\r\n * Handles the details of adding and updating documents in the IndexedDbRemoteDocumentCache.\r\n *\r\n * Unlike the MemoryRemoteDocumentChangeBuffer, the IndexedDb implementation computes the size\r\n * delta for all submitted changes. This avoids having to re-read all documents from IndexedDb\r\n * when we apply the changes.\r\n */\r\nclass IndexedDbRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\r\n    /**\r\n     * @param documentCache - The IndexedDbRemoteDocumentCache to apply the changes to.\r\n     * @param trackRemovals - Whether to create sentinel deletes that can be tracked by\r\n     * `getNewDocumentChanges()`.\r\n     */\r\n    constructor(documentCache, trackRemovals) {\r\n        super();\r\n        this.documentCache = documentCache;\r\n        this.trackRemovals = trackRemovals;\r\n        // A map of document sizes prior to applying the changes in this buffer.\r\n        this.documentSizes = new ObjectMap(key => key.toString(), (l, r) => l.isEqual(r));\r\n    }\r\n    applyChanges(transaction) {\r\n        const promises = [];\r\n        let sizeDelta = 0;\r\n        let collectionParents = new SortedSet((l, r) => primitiveComparator(l.canonicalString(), r.canonicalString()));\r\n        this.changes.forEach((key, documentChange) => {\r\n            const previousSize = this.documentSizes.get(key);\r\n            if (documentChange.isValidDocument()) {\r\n                const doc = toDbRemoteDocument(this.documentCache.serializer, documentChange);\r\n                collectionParents = collectionParents.add(key.path.popLast());\r\n                const size = dbDocumentSize(doc);\r\n                sizeDelta += size - previousSize;\r\n                promises.push(this.documentCache.addEntry(transaction, key, doc));\r\n            }\r\n            else {\r\n                sizeDelta -= previousSize;\r\n                if (this.trackRemovals) {\r\n                    // In order to track removals, we store a \"sentinel delete\" in the\r\n                    // RemoteDocumentCache. This entry is represented by a NoDocument\r\n                    // with a version of 0 and ignored by `maybeDecodeDocument()` but\r\n                    // preserved in `getNewDocumentChanges()`.\r\n                    const deletedDoc = toDbRemoteDocument(this.documentCache.serializer, documentChange.convertToNoDocument(SnapshotVersion.min()));\r\n                    promises.push(this.documentCache.addEntry(transaction, key, deletedDoc));\r\n                }\r\n                else {\r\n                    promises.push(this.documentCache.removeEntry(transaction, key));\r\n                }\r\n            }\r\n        });\r\n        collectionParents.forEach(parent => {\r\n            promises.push(this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent));\r\n        });\r\n        promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getFromCache(transaction, documentKey) {\r\n        // Record the size of everything we load from the cache so we can compute a delta later.\r\n        return this.documentCache\r\n            .getSizedEntry(transaction, documentKey)\r\n            .next(getResult => {\r\n            this.documentSizes.set(documentKey, getResult.size);\r\n            return getResult.document;\r\n        });\r\n    }\r\n    getAllFromCache(transaction, documentKeys) {\r\n        // Record the size of everything we load from the cache so we can compute\r\n        // a delta later.\r\n        return this.documentCache\r\n            .getSizedEntries(transaction, documentKeys)\r\n            .next(({ documents, sizeMap }) => {\r\n            // Note: `getAllFromCache` returns two maps instead of a single map from\r\n            // keys to `DocumentSizeEntry`s. This is to allow returning the\r\n            // `MutableDocumentMap` directly, without a conversion.\r\n            sizeMap.forEach((documentKey, size) => {\r\n                this.documentSizes.set(documentKey, size);\r\n            });\r\n            return documents;\r\n        });\r\n    }\r\n}\r\nfunction documentGlobalStore(txn) {\r\n    return getStore(txn, DbRemoteDocumentGlobal.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\r\n */\r\nfunction remoteDocumentsStore(txn) {\r\n    return getStore(txn, DbRemoteDocument.store);\r\n}\r\nfunction dbKey(docKey) {\r\n    return docKey.path.toArray();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Performs database creation and schema upgrades. */\r\nclass SchemaConverter {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n    }\r\n    /**\r\n     * Performs database creation and schema upgrades.\r\n     *\r\n     * Note that in production, this method is only ever used to upgrade the schema\r\n     * to SCHEMA_VERSION. Different values of toVersion are only used for testing\r\n     * and local feature development.\r\n     */\r\n    createOrUpgrade(db, txn, fromVersion, toVersion) {\r\n        const simpleDbTransaction = new SimpleDbTransaction('createOrUpgrade', txn);\r\n        if (fromVersion < 1 && toVersion >= 1) {\r\n            createPrimaryClientStore(db);\r\n            createMutationQueue(db);\r\n            createQueryCache(db);\r\n            createRemoteDocumentCache(db);\r\n        }\r\n        // Migration 2 to populate the targetGlobal object no longer needed since\r\n        // migration 3 unconditionally clears it.\r\n        let p = PersistencePromise.resolve();\r\n        if (fromVersion < 3 && toVersion >= 3) {\r\n            // Brand new clients don't need to drop and recreate--only clients that\r\n            // potentially have corrupt data.\r\n            if (fromVersion !== 0) {\r\n                dropQueryCache(db);\r\n                createQueryCache(db);\r\n            }\r\n            p = p.next(() => writeEmptyTargetGlobalEntry(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 4 && toVersion >= 4) {\r\n            if (fromVersion !== 0) {\r\n                // Schema version 3 uses auto-generated keys to generate globally unique\r\n                // mutation batch IDs (this was previously ensured internally by the\r\n                // client). To migrate to the new schema, we have to read all mutations\r\n                // and write them back out. We preserve the existing batch IDs to guarantee\r\n                // consistency with other object stores. Any further mutation batch IDs will\r\n                // be auto-generated.\r\n                p = p.next(() => upgradeMutationBatchSchemaAndMigrateData(db, simpleDbTransaction));\r\n            }\r\n            p = p.next(() => {\r\n                createClientMetadataStore(db);\r\n            });\r\n        }\r\n        if (fromVersion < 5 && toVersion >= 5) {\r\n            p = p.next(() => this.removeAcknowledgedMutations(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 6 && toVersion >= 6) {\r\n            p = p.next(() => {\r\n                createDocumentGlobalStore(db);\r\n                return this.addDocumentGlobal(simpleDbTransaction);\r\n            });\r\n        }\r\n        if (fromVersion < 7 && toVersion >= 7) {\r\n            p = p.next(() => this.ensureSequenceNumbers(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 8 && toVersion >= 8) {\r\n            p = p.next(() => this.createCollectionParentIndex(db, simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 9 && toVersion >= 9) {\r\n            p = p.next(() => {\r\n                // Multi-Tab used to manage its own changelog, but this has been moved\r\n                // to the DbRemoteDocument object store itself. Since the previous change\r\n                // log only contained transient data, we can drop its object store.\r\n                dropRemoteDocumentChangesStore(db);\r\n                createRemoteDocumentReadTimeIndex(txn);\r\n            });\r\n        }\r\n        if (fromVersion < 10 && toVersion >= 10) {\r\n            p = p.next(() => this.rewriteCanonicalIds(simpleDbTransaction));\r\n        }\r\n        if (fromVersion < 11 && toVersion >= 11) {\r\n            p = p.next(() => {\r\n                createBundlesStore(db);\r\n                createNamedQueriesStore(db);\r\n            });\r\n        }\r\n        if (fromVersion < 12 && toVersion >= 12) {\r\n            p = p.next(() => {\r\n                createDocumentOverlayStore(db);\r\n            });\r\n        }\r\n        if (fromVersion < 13 && toVersion >= 13) {\r\n            p = p.next(() => {\r\n                createFieldIndex(db);\r\n            });\r\n        }\r\n        return p;\r\n    }\r\n    addDocumentGlobal(txn) {\r\n        let byteCount = 0;\r\n        return txn\r\n            .store(DbRemoteDocument.store)\r\n            .iterate((_, doc) => {\r\n            byteCount += dbDocumentSize(doc);\r\n        })\r\n            .next(() => {\r\n            const metadata = new DbRemoteDocumentGlobal(byteCount);\r\n            return txn\r\n                .store(DbRemoteDocumentGlobal.store)\r\n                .put(DbRemoteDocumentGlobal.key, metadata);\r\n        });\r\n    }\r\n    removeAcknowledgedMutations(txn) {\r\n        const queuesStore = txn.store(DbMutationQueue.store);\r\n        const mutationsStore = txn.store(DbMutationBatch.store);\r\n        return queuesStore.loadAll().next(queues => {\r\n            return PersistencePromise.forEach(queues, (queue) => {\r\n                const range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);\r\n                return mutationsStore\r\n                    .loadAll(DbMutationBatch.userMutationsIndex, range)\r\n                    .next(dbBatches => {\r\n                    return PersistencePromise.forEach(dbBatches, (dbBatch) => {\r\n                        hardAssert(dbBatch.userId === queue.userId);\r\n                        const batch = fromDbMutationBatch(this.serializer, dbBatch);\r\n                        return removeMutationBatch(txn, queue.userId, batch).next(() => { });\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Ensures that every document in the remote document cache has a corresponding sentinel row\r\n     * with a sequence number. Missing rows are given the most recently used sequence number.\r\n     */\r\n    ensureSequenceNumbers(txn) {\r\n        const documentTargetStore = txn.store(DbTargetDocument.store);\r\n        const documentsStore = txn.store(DbRemoteDocument.store);\r\n        const globalTargetStore = txn.store(DbTargetGlobal.store);\r\n        return globalTargetStore.get(DbTargetGlobal.key).next(metadata => {\r\n            const writeSentinelKey = (path) => {\r\n                return documentTargetStore.put(new DbTargetDocument(0, encodeResourcePath(path), metadata.highestListenSequenceNumber));\r\n            };\r\n            const promises = [];\r\n            return documentsStore\r\n                .iterate((key, doc) => {\r\n                const path = new ResourcePath(key);\r\n                const docSentinelKey = sentinelKey(path);\r\n                promises.push(documentTargetStore.get(docSentinelKey).next(maybeSentinel => {\r\n                    if (!maybeSentinel) {\r\n                        return writeSentinelKey(path);\r\n                    }\r\n                    else {\r\n                        return PersistencePromise.resolve();\r\n                    }\r\n                }));\r\n            })\r\n                .next(() => PersistencePromise.waitFor(promises));\r\n        });\r\n    }\r\n    createCollectionParentIndex(db, txn) {\r\n        // Create the index.\r\n        db.createObjectStore(DbCollectionParent.store, {\r\n            keyPath: DbCollectionParent.keyPath\r\n        });\r\n        const collectionParentsStore = txn.store(DbCollectionParent.store);\r\n        // Helper to add an index entry iff we haven't already written it.\r\n        const cache = new MemoryCollectionParentIndex();\r\n        const addEntry = (collectionPath) => {\r\n            if (cache.add(collectionPath)) {\r\n                const collectionId = collectionPath.lastSegment();\r\n                const parentPath = collectionPath.popLast();\r\n                return collectionParentsStore.put({\r\n                    collectionId,\r\n                    parent: encodeResourcePath(parentPath)\r\n                });\r\n            }\r\n        };\r\n        // Index existing remote documents.\r\n        return txn\r\n            .store(DbRemoteDocument.store)\r\n            .iterate({ keysOnly: true }, (pathSegments, _) => {\r\n            const path = new ResourcePath(pathSegments);\r\n            return addEntry(path.popLast());\r\n        })\r\n            .next(() => {\r\n            // Index existing mutations.\r\n            return txn\r\n                .store(DbDocumentMutation.store)\r\n                .iterate({ keysOnly: true }, ([userID, encodedPath, batchId], _) => {\r\n                const path = decodeResourcePath(encodedPath);\r\n                return addEntry(path.popLast());\r\n            });\r\n        });\r\n    }\r\n    rewriteCanonicalIds(txn) {\r\n        const targetStore = txn.store(DbTarget.store);\r\n        return targetStore.iterate((key, originalDbTarget) => {\r\n            const originalTargetData = fromDbTarget(originalDbTarget);\r\n            const updatedDbTarget = toDbTarget(this.serializer, originalTargetData);\r\n            return targetStore.put(updatedDbTarget);\r\n        });\r\n    }\r\n}\r\nfunction sentinelKey(path) {\r\n    return [0, encodeResourcePath(path)];\r\n}\r\nfunction createPrimaryClientStore(db) {\r\n    db.createObjectStore(DbPrimaryClient.store);\r\n}\r\nfunction createMutationQueue(db) {\r\n    db.createObjectStore(DbMutationQueue.store, {\r\n        keyPath: DbMutationQueue.keyPath\r\n    });\r\n    const mutationBatchesStore = db.createObjectStore(DbMutationBatch.store, {\r\n        keyPath: DbMutationBatch.keyPath,\r\n        autoIncrement: true\r\n    });\r\n    mutationBatchesStore.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, { unique: true });\r\n    db.createObjectStore(DbDocumentMutation.store);\r\n}\r\n/**\r\n * Upgrade function to migrate the 'mutations' store from V1 to V3. Loads\r\n * and rewrites all data.\r\n */\r\nfunction upgradeMutationBatchSchemaAndMigrateData(db, txn) {\r\n    const v1MutationsStore = txn.store(DbMutationBatch.store);\r\n    return v1MutationsStore.loadAll().next(existingMutations => {\r\n        db.deleteObjectStore(DbMutationBatch.store);\r\n        const mutationsStore = db.createObjectStore(DbMutationBatch.store, {\r\n            keyPath: DbMutationBatch.keyPath,\r\n            autoIncrement: true\r\n        });\r\n        mutationsStore.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, { unique: true });\r\n        const v3MutationsStore = txn.store(DbMutationBatch.store);\r\n        const writeAll = existingMutations.map(mutation => v3MutationsStore.put(mutation));\r\n        return PersistencePromise.waitFor(writeAll);\r\n    });\r\n}\r\nfunction createRemoteDocumentCache(db) {\r\n    db.createObjectStore(DbRemoteDocument.store);\r\n}\r\nfunction createDocumentGlobalStore(db) {\r\n    db.createObjectStore(DbRemoteDocumentGlobal.store);\r\n}\r\nfunction createQueryCache(db) {\r\n    const targetDocumentsStore = db.createObjectStore(DbTargetDocument.store, {\r\n        keyPath: DbTargetDocument.keyPath\r\n    });\r\n    targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });\r\n    const targetStore = db.createObjectStore(DbTarget.store, {\r\n        keyPath: DbTarget.keyPath\r\n    });\r\n    // NOTE: This is unique only because the TargetId is the suffix.\r\n    targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });\r\n    db.createObjectStore(DbTargetGlobal.store);\r\n}\r\nfunction dropQueryCache(db) {\r\n    db.deleteObjectStore(DbTargetDocument.store);\r\n    db.deleteObjectStore(DbTarget.store);\r\n    db.deleteObjectStore(DbTargetGlobal.store);\r\n}\r\nfunction dropRemoteDocumentChangesStore(db) {\r\n    if (db.objectStoreNames.contains('remoteDocumentChanges')) {\r\n        db.deleteObjectStore('remoteDocumentChanges');\r\n    }\r\n}\r\n/**\r\n * Creates the target global singleton row.\r\n *\r\n * @param txn - The version upgrade transaction for indexeddb\r\n */\r\nfunction writeEmptyTargetGlobalEntry(txn) {\r\n    const globalStore = txn.store(DbTargetGlobal.store);\r\n    const metadata = new DbTargetGlobal(\r\n    /*highestTargetId=*/ 0, \r\n    /*lastListenSequenceNumber=*/ 0, SnapshotVersion.min().toTimestamp(), \r\n    /*targetCount=*/ 0);\r\n    return globalStore.put(DbTargetGlobal.key, metadata);\r\n}\r\n/**\r\n * Creates indices on the RemoteDocuments store used for both multi-tab\r\n * and Index-Free queries.\r\n */\r\nfunction createRemoteDocumentReadTimeIndex(txn) {\r\n    const remoteDocumentStore = txn.objectStore(DbRemoteDocument.store);\r\n    remoteDocumentStore.createIndex(DbRemoteDocument.readTimeIndex, DbRemoteDocument.readTimeIndexPath, { unique: false });\r\n    remoteDocumentStore.createIndex(DbRemoteDocument.collectionReadTimeIndex, DbRemoteDocument.collectionReadTimeIndexPath, { unique: false });\r\n}\r\nfunction createClientMetadataStore(db) {\r\n    db.createObjectStore(DbClientMetadata.store, {\r\n        keyPath: DbClientMetadata.keyPath\r\n    });\r\n}\r\nfunction createBundlesStore(db) {\r\n    db.createObjectStore(DbBundle.store, {\r\n        keyPath: DbBundle.keyPath\r\n    });\r\n}\r\nfunction createNamedQueriesStore(db) {\r\n    db.createObjectStore(DbNamedQuery.store, {\r\n        keyPath: DbNamedQuery.keyPath\r\n    });\r\n}\r\nfunction createFieldIndex(db) {\r\n    const indexConfiguratioStore = db.createObjectStore(DbIndexConfiguration.store, {\r\n        keyPath: DbIndexConfiguration.keyPath,\r\n        autoIncrement: true\r\n    });\r\n    indexConfiguratioStore.createIndex(DbIndexConfiguration.collectionGroupIndex, DbIndexConfiguration.collectionGroupIndexPath, { unique: false });\r\n    const indexStateStore = db.createObjectStore(DbIndexState.store, {\r\n        keyPath: DbIndexState.keyPath\r\n    });\r\n    indexStateStore.createIndex(DbIndexState.sequenceNumberIndex, DbIndexState.sequenceNumberIndexPath, { unique: false });\r\n    const indexEntryStore = db.createObjectStore(DbIndexEntry.store, {\r\n        keyPath: DbIndexEntry.keyPath\r\n    });\r\n    indexEntryStore.createIndex(DbIndexEntry.documentKeyIndex, DbIndexEntry.documentKeyIndexPath, { unique: false });\r\n}\r\nfunction createDocumentOverlayStore(db) {\r\n    const documentOverlayStore = db.createObjectStore(DbDocumentOverlay.store, {\r\n        keyPath: DbDocumentOverlay.keyPath\r\n    });\r\n    documentOverlayStore.createIndex(DbDocumentOverlay.collectionPathOverlayIndex, DbDocumentOverlay.collectionPathOverlayIndexPath, { unique: false });\r\n    documentOverlayStore.createIndex(DbDocumentOverlay.collectionGroupOverlayIndex, DbDocumentOverlay.collectionGroupOverlayIndexPath, { unique: false });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$d = 'IndexedDbPersistence';\r\n/**\r\n * Oldest acceptable age in milliseconds for client metadata before the client\r\n * is considered inactive and its associated data is garbage collected.\r\n */\r\nconst MAX_CLIENT_AGE_MS = 30 * 60 * 1000; // 30 minutes\r\n/**\r\n * Oldest acceptable metadata age for clients that may participate in the\r\n * primary lease election. Clients that have not updated their client metadata\r\n * within 5 seconds are not eligible to receive a primary lease.\r\n */\r\nconst MAX_PRIMARY_ELIGIBLE_AGE_MS = 5000;\r\n/**\r\n * The interval at which clients will update their metadata, including\r\n * refreshing their primary lease if held or potentially trying to acquire it if\r\n * not held.\r\n *\r\n * Primary clients may opportunistically refresh their metadata earlier\r\n * if they're already performing an IndexedDB operation.\r\n */\r\nconst CLIENT_METADATA_REFRESH_INTERVAL_MS = 4000;\r\n/** User-facing error when the primary lease is required but not available. */\r\nconst PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = 'Failed to obtain exclusive access to the persistence layer. To allow ' +\r\n    'shared access, multi-tab synchronization has to be enabled in all tabs. ' +\r\n    'If you are using `experimentalForceOwningTab:true`, make sure that only ' +\r\n    'one tab has persistence enabled at any given time.';\r\nconst UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing IndexedDB or is known to have ' +\r\n    'an incomplete implementation. Offline persistence has been disabled.';\r\n// The format of the LocalStorage key that stores zombied client is:\r\n//     firestore_zombie_<persistence_prefix>_<instance_key>\r\nconst ZOMBIED_CLIENTS_KEY_PREFIX = 'firestore_zombie';\r\n/**\r\n * The name of the main (and currently only) IndexedDB database. This name is\r\n * appended to the prefix provided to the IndexedDbPersistence constructor.\r\n */\r\nconst MAIN_DATABASE = 'main';\r\n/**\r\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\r\n * across sessions.\r\n *\r\n * On Web only, the Firestore SDKs support shared access to its persistence\r\n * layer. This allows multiple browser tabs to read and write to IndexedDb and\r\n * to synchronize state even without network connectivity. Shared access is\r\n * currently optional and not enabled unless all clients invoke\r\n * `enablePersistence()` with `{synchronizeTabs:true}`.\r\n *\r\n * In multi-tab mode, if multiple clients are active at the same time, the SDK\r\n * will designate one client as the primary client. An effort is made to pick\r\n * a visible, network-connected and active client, and this client is\r\n * responsible for letting other clients know about its presence. The primary\r\n * client writes a unique client-generated identifier (the client ID) to\r\n * IndexedDbs owner store every 4 seconds. If the primary client fails to\r\n * update this entry, another client can acquire the lease and take over as\r\n * primary.\r\n *\r\n * Some persistence operations in the SDK are designated as primary-client only\r\n * operations. This includes the acknowledgment of mutations and all updates of\r\n * remote documents. The effects of these operations are written to persistence\r\n * and then broadcast to other tabs via LocalStorage (see\r\n * `WebStorageSharedClientState`), which then refresh their state from\r\n * persistence.\r\n *\r\n * Similarly, the primary client listens to notifications sent by secondary\r\n * clients to discover persistence changes written by secondary clients, such as\r\n * the addition of new mutations and query targets.\r\n *\r\n * If multi-tab is not enabled and another tab already obtained the primary\r\n * lease, IndexedDbPersistence enters a failed state and all subsequent\r\n * operations will automatically fail.\r\n *\r\n * Additionally, there is an optimization so that when a tab is closed, the\r\n * primary lease is released immediately (this is especially important to make\r\n * sure that a refreshed tab is able to immediately re-acquire the primary\r\n * lease). Unfortunately, IndexedDB cannot be reliably used in window.unload\r\n * since it is an asynchronous API. So in addition to attempting to give up the\r\n * lease, the leaseholder writes its client ID to a \"zombiedClient\" entry in\r\n * LocalStorage which acts as an indicator that another tab should go ahead and\r\n * take the primary lease immediately regardless of the current lease timestamp.\r\n *\r\n * TODO(b/114226234): Remove `synchronizeTabs` section when multi-tab is no\r\n * longer optional.\r\n */\r\nclass IndexedDbPersistence {\r\n    constructor(\r\n    /**\r\n     * Whether to synchronize the in-memory state of multiple tabs and share\r\n     * access to local persistence.\r\n     */\r\n    allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window, document, serializer, sequenceNumberSyncer, \r\n    /**\r\n     * If set to true, forcefully obtains database access. Existing tabs will\r\n     * no longer be able to access IndexedDB.\r\n     */\r\n    forceOwningTab, schemaVersion = SCHEMA_VERSION) {\r\n        this.allowTabSynchronization = allowTabSynchronization;\r\n        this.persistenceKey = persistenceKey;\r\n        this.clientId = clientId;\r\n        this.queue = queue;\r\n        this.window = window;\r\n        this.document = document;\r\n        this.sequenceNumberSyncer = sequenceNumberSyncer;\r\n        this.forceOwningTab = forceOwningTab;\r\n        this.schemaVersion = schemaVersion;\r\n        this.listenSequence = null;\r\n        this._started = false;\r\n        this.isPrimary = false;\r\n        this.networkEnabled = true;\r\n        /** Our window.unload handler, if registered. */\r\n        this.windowUnloadHandler = null;\r\n        this.inForeground = false;\r\n        /** Our 'visibilitychange' listener if registered. */\r\n        this.documentVisibilityHandler = null;\r\n        /** The client metadata refresh task. */\r\n        this.clientMetadataRefresher = null;\r\n        /** The last time we garbage collected the client metadata object store. */\r\n        this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;\r\n        /** A listener to notify on primary state changes. */\r\n        this.primaryStateListener = _ => Promise.resolve();\r\n        if (!IndexedDbPersistence.isAvailable()) {\r\n            throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\r\n        }\r\n        this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);\r\n        this.dbName = persistenceKey + MAIN_DATABASE;\r\n        this.serializer = new LocalSerializer(serializer);\r\n        this.simpleDb = new SimpleDb(this.dbName, this.schemaVersion, new SchemaConverter(this.serializer));\r\n        this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);\r\n        this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer);\r\n        this.bundleCache = new IndexedDbBundleCache();\r\n        if (this.window && this.window.localStorage) {\r\n            this.webStorage = this.window.localStorage;\r\n        }\r\n        else {\r\n            this.webStorage = null;\r\n            if (forceOwningTab === false) {\r\n                logError(LOG_TAG$d, 'LocalStorage is unavailable. As a result, persistence may not work ' +\r\n                    'reliably. In particular enablePersistence() could fail immediately ' +\r\n                    'after refreshing the page.');\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Attempt to start IndexedDb persistence.\r\n     *\r\n     * @returns Whether persistence was enabled.\r\n     */\r\n    start() {\r\n        // NOTE: This is expected to fail sometimes (in the case of another tab\r\n        // already having the persistence lock), so it's the first thing we should\r\n        // do.\r\n        return this.updateClientMetadataAndTryBecomePrimary()\r\n            .then(() => {\r\n            if (!this.isPrimary && !this.allowTabSynchronization) {\r\n                // Fail `start()` if `synchronizeTabs` is disabled and we cannot\r\n                // obtain the primary lease.\r\n                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\r\n            }\r\n            this.attachVisibilityHandler();\r\n            this.attachWindowUnloadHook();\r\n            this.scheduleClientMetadataAndPrimaryLeaseRefreshes();\r\n            return this.runTransaction('getHighestListenSequenceNumber', 'readonly', txn => this.targetCache.getHighestSequenceNumber(txn));\r\n        })\r\n            .then(highestListenSequenceNumber => {\r\n            this.listenSequence = new ListenSequence(highestListenSequenceNumber, this.sequenceNumberSyncer);\r\n        })\r\n            .then(() => {\r\n            this._started = true;\r\n        })\r\n            .catch(reason => {\r\n            this.simpleDb && this.simpleDb.close();\r\n            return Promise.reject(reason);\r\n        });\r\n    }\r\n    /**\r\n     * Registers a listener that gets called when the primary state of the\r\n     * instance changes. Upon registering, this listener is invoked immediately\r\n     * with the current primary state.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    setPrimaryStateListener(primaryStateListener) {\r\n        this.primaryStateListener = async (primaryState) => {\r\n            if (this.started) {\r\n                return primaryStateListener(primaryState);\r\n            }\r\n        };\r\n        return primaryStateListener(this.isPrimary);\r\n    }\r\n    /**\r\n     * Registers a listener that gets called when the database receives a\r\n     * version change event indicating that it has deleted.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    setDatabaseDeletedListener(databaseDeletedListener) {\r\n        this.simpleDb.setVersionChangeListener(async (event) => {\r\n            // Check if an attempt is made to delete IndexedDB.\r\n            if (event.newVersion === null) {\r\n                await databaseDeletedListener();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Adjusts the current network state in the client's metadata, potentially\r\n     * affecting the primary lease.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    setNetworkEnabled(networkEnabled) {\r\n        if (this.networkEnabled !== networkEnabled) {\r\n            this.networkEnabled = networkEnabled;\r\n            // Schedule a primary lease refresh for immediate execution. The eventual\r\n            // lease update will be propagated via `primaryStateListener`.\r\n            this.queue.enqueueAndForget(async () => {\r\n                if (this.started) {\r\n                    await this.updateClientMetadataAndTryBecomePrimary();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Updates the client metadata in IndexedDb and attempts to either obtain or\r\n     * extend the primary lease for the local client. Asynchronously notifies the\r\n     * primary state listener if the client either newly obtained or released its\r\n     * primary lease.\r\n     */\r\n    updateClientMetadataAndTryBecomePrimary() {\r\n        return this.runTransaction('updateClientMetadataAndTryBecomePrimary', 'readwrite', txn => {\r\n            const metadataStore = clientMetadataStore(txn);\r\n            return metadataStore\r\n                .put(new DbClientMetadata(this.clientId, Date.now(), this.networkEnabled, this.inForeground))\r\n                .next(() => {\r\n                if (this.isPrimary) {\r\n                    return this.verifyPrimaryLease(txn).next(success => {\r\n                        if (!success) {\r\n                            this.isPrimary = false;\r\n                            this.queue.enqueueRetryable(() => this.primaryStateListener(false));\r\n                        }\r\n                    });\r\n                }\r\n            })\r\n                .next(() => this.canActAsPrimary(txn))\r\n                .next(canActAsPrimary => {\r\n                if (this.isPrimary && !canActAsPrimary) {\r\n                    return this.releasePrimaryLeaseIfHeld(txn).next(() => false);\r\n                }\r\n                else if (canActAsPrimary) {\r\n                    return this.acquireOrExtendPrimaryLease(txn).next(() => true);\r\n                }\r\n                else {\r\n                    return /* canActAsPrimary= */ false;\r\n                }\r\n            });\r\n        })\r\n            .catch(e => {\r\n            if (isIndexedDbTransactionError(e)) {\r\n                logDebug(LOG_TAG$d, 'Failed to extend owner lease: ', e);\r\n                // Proceed with the existing state. Any subsequent access to\r\n                // IndexedDB will verify the lease.\r\n                return this.isPrimary;\r\n            }\r\n            if (!this.allowTabSynchronization) {\r\n                throw e;\r\n            }\r\n            logDebug(LOG_TAG$d, 'Releasing owner lease after error during lease refresh', e);\r\n            return /* isPrimary= */ false;\r\n        })\r\n            .then(isPrimary => {\r\n            if (this.isPrimary !== isPrimary) {\r\n                this.queue.enqueueRetryable(() => this.primaryStateListener(isPrimary));\r\n            }\r\n            this.isPrimary = isPrimary;\r\n        });\r\n    }\r\n    verifyPrimaryLease(txn) {\r\n        const store = primaryClientStore(txn);\r\n        return store.get(DbPrimaryClient.key).next(primaryClient => {\r\n            return PersistencePromise.resolve(this.isLocalClient(primaryClient));\r\n        });\r\n    }\r\n    removeClientMetadata(txn) {\r\n        const metadataStore = clientMetadataStore(txn);\r\n        return metadataStore.delete(this.clientId);\r\n    }\r\n    /**\r\n     * If the garbage collection threshold has passed, prunes the\r\n     * RemoteDocumentChanges and the ClientMetadata store based on the last update\r\n     * time of all clients.\r\n     */\r\n    async maybeGarbageCollectMultiClientState() {\r\n        if (this.isPrimary &&\r\n            !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)) {\r\n            this.lastGarbageCollectionTime = Date.now();\r\n            const inactiveClients = await this.runTransaction('maybeGarbageCollectMultiClientState', 'readwrite-primary', txn => {\r\n                const metadataStore = getStore(txn, DbClientMetadata.store);\r\n                return metadataStore.loadAll().next(existingClients => {\r\n                    const active = this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);\r\n                    const inactive = existingClients.filter(client => active.indexOf(client) === -1);\r\n                    // Delete metadata for clients that are no longer considered active.\r\n                    return PersistencePromise.forEach(inactive, (inactiveClient) => metadataStore.delete(inactiveClient.clientId)).next(() => inactive);\r\n                });\r\n            }).catch(() => {\r\n                // Ignore primary lease violations or any other type of error. The next\r\n                // primary will run `maybeGarbageCollectMultiClientState()` again.\r\n                // We don't use `ignoreIfPrimaryLeaseLoss()` since we don't want to depend\r\n                // on LocalStore.\r\n                return [];\r\n            });\r\n            // Delete potential leftover entries that may continue to mark the\r\n            // inactive clients as zombied in LocalStorage.\r\n            // Ideally we'd delete the IndexedDb and LocalStorage zombie entries for\r\n            // the client atomically, but we can't. So we opt to delete the IndexedDb\r\n            // entries first to avoid potentially reviving a zombied client.\r\n            if (this.webStorage) {\r\n                for (const inactiveClient of inactiveClients) {\r\n                    this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Schedules a recurring timer to update the client metadata and to either\r\n     * extend or acquire the primary lease if the client is eligible.\r\n     */\r\n    scheduleClientMetadataAndPrimaryLeaseRefreshes() {\r\n        this.clientMetadataRefresher = this.queue.enqueueAfterDelay(\"client_metadata_refresh\" /* ClientMetadataRefresh */, CLIENT_METADATA_REFRESH_INTERVAL_MS, () => {\r\n            return this.updateClientMetadataAndTryBecomePrimary()\r\n                .then(() => this.maybeGarbageCollectMultiClientState())\r\n                .then(() => this.scheduleClientMetadataAndPrimaryLeaseRefreshes());\r\n        });\r\n    }\r\n    /** Checks whether `client` is the local client. */\r\n    isLocalClient(client) {\r\n        return client ? client.ownerId === this.clientId : false;\r\n    }\r\n    /**\r\n     * Evaluate the state of all active clients and determine whether the local\r\n     * client is or can act as the holder of the primary lease. Returns whether\r\n     * the client is eligible for the lease, but does not actually acquire it.\r\n     * May return 'false' even if there is no active leaseholder and another\r\n     * (foreground) client should become leaseholder instead.\r\n     */\r\n    canActAsPrimary(txn) {\r\n        if (this.forceOwningTab) {\r\n            return PersistencePromise.resolve(true);\r\n        }\r\n        const store = primaryClientStore(txn);\r\n        return store\r\n            .get(DbPrimaryClient.key)\r\n            .next(currentPrimary => {\r\n            const currentLeaseIsValid = currentPrimary !== null &&\r\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\r\n                !this.isClientZombied(currentPrimary.ownerId);\r\n            // A client is eligible for the primary lease if:\r\n            // - its network is enabled and the client's tab is in the foreground.\r\n            // - its network is enabled and no other client's tab is in the\r\n            //   foreground.\r\n            // - every clients network is disabled and the client's tab is in the\r\n            //   foreground.\r\n            // - every clients network is disabled and no other client's tab is in\r\n            //   the foreground.\r\n            // - the `forceOwningTab` setting was passed in.\r\n            if (currentLeaseIsValid) {\r\n                if (this.isLocalClient(currentPrimary) && this.networkEnabled) {\r\n                    return true;\r\n                }\r\n                if (!this.isLocalClient(currentPrimary)) {\r\n                    if (!currentPrimary.allowTabSynchronization) {\r\n                        // Fail the `canActAsPrimary` check if the current leaseholder has\r\n                        // not opted into multi-tab synchronization. If this happens at\r\n                        // client startup, we reject the Promise returned by\r\n                        // `enablePersistence()` and the user can continue to use Firestore\r\n                        // with in-memory persistence.\r\n                        // If this fails during a lease refresh, we will instead block the\r\n                        // AsyncQueue from executing further operations. Note that this is\r\n                        // acceptable since mixing & matching different `synchronizeTabs`\r\n                        // settings is not supported.\r\n                        //\r\n                        // TODO(b/114226234): Remove this check when `synchronizeTabs` can\r\n                        // no longer be turned off.\r\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            if (this.networkEnabled && this.inForeground) {\r\n                return true;\r\n            }\r\n            return clientMetadataStore(txn)\r\n                .loadAll()\r\n                .next(existingClients => {\r\n                // Process all existing clients and determine whether at least one of\r\n                // them is better suited to obtain the primary lease.\r\n                const preferredCandidate = this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(otherClient => {\r\n                    if (this.clientId !== otherClient.clientId) {\r\n                        const otherClientHasBetterNetworkState = !this.networkEnabled && otherClient.networkEnabled;\r\n                        const otherClientHasBetterVisibility = !this.inForeground && otherClient.inForeground;\r\n                        const otherClientHasSameNetworkState = this.networkEnabled === otherClient.networkEnabled;\r\n                        if (otherClientHasBetterNetworkState ||\r\n                            (otherClientHasBetterVisibility &&\r\n                                otherClientHasSameNetworkState)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return false;\r\n                });\r\n                return preferredCandidate === undefined;\r\n            });\r\n        })\r\n            .next(canActAsPrimary => {\r\n            if (this.isPrimary !== canActAsPrimary) {\r\n                logDebug(LOG_TAG$d, `Client ${canActAsPrimary ? 'is' : 'is not'} eligible for a primary lease.`);\r\n            }\r\n            return canActAsPrimary;\r\n        });\r\n    }\r\n    async shutdown() {\r\n        // The shutdown() operations are idempotent and can be called even when\r\n        // start() aborted (e.g. because it couldn't acquire the persistence lease).\r\n        this._started = false;\r\n        this.markClientZombied();\r\n        if (this.clientMetadataRefresher) {\r\n            this.clientMetadataRefresher.cancel();\r\n            this.clientMetadataRefresher = null;\r\n        }\r\n        this.detachVisibilityHandler();\r\n        this.detachWindowUnloadHook();\r\n        // Use `SimpleDb.runTransaction` directly to avoid failing if another tab\r\n        // has obtained the primary lease.\r\n        await this.simpleDb.runTransaction('shutdown', 'readwrite', [DbPrimaryClient.store, DbClientMetadata.store], simpleDbTxn => {\r\n            const persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);\r\n            return this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(() => this.removeClientMetadata(persistenceTransaction));\r\n        });\r\n        this.simpleDb.close();\r\n        // Remove the entry marking the client as zombied from LocalStorage since\r\n        // we successfully deleted its metadata from IndexedDb.\r\n        this.removeClientZombiedEntry();\r\n    }\r\n    /**\r\n     * Returns clients that are not zombied and have an updateTime within the\r\n     * provided threshold.\r\n     */\r\n    filterActiveClients(clients, activityThresholdMs) {\r\n        return clients.filter(client => this.isWithinAge(client.updateTimeMs, activityThresholdMs) &&\r\n            !this.isClientZombied(client.clientId));\r\n    }\r\n    /**\r\n     * Returns the IDs of the clients that are currently active. If multi-tab\r\n     * is not supported, returns an array that only contains the local client's\r\n     * ID.\r\n     *\r\n     * PORTING NOTE: This is only used for Web multi-tab.\r\n     */\r\n    getActiveClients() {\r\n        return this.runTransaction('getActiveClients', 'readonly', txn => {\r\n            return clientMetadataStore(txn)\r\n                .loadAll()\r\n                .next(clients => this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(clientMetadata => clientMetadata.clientId));\r\n        });\r\n    }\r\n    get started() {\r\n        return this._started;\r\n    }\r\n    getMutationQueue(user, indexManager) {\r\n        return IndexedDbMutationQueue.forUser(user, this.serializer, indexManager, this.referenceDelegate);\r\n    }\r\n    getTargetCache() {\r\n        return this.targetCache;\r\n    }\r\n    getRemoteDocumentCache() {\r\n        return this.remoteDocumentCache;\r\n    }\r\n    getIndexManager(user) {\r\n        return new IndexedDbIndexManager(user);\r\n    }\r\n    getDocumentOverlayCache(user) {\r\n        return IndexedDbDocumentOverlayCache.forUser(this.serializer, user);\r\n    }\r\n    getBundleCache() {\r\n        return this.bundleCache;\r\n    }\r\n    runTransaction(action, mode, transactionOperation) {\r\n        logDebug(LOG_TAG$d, 'Starting transaction:', action);\r\n        const simpleDbMode = mode === 'readonly' ? 'readonly' : 'readwrite';\r\n        const objectStores = getObjectStores(this.schemaVersion);\r\n        let persistenceTransaction;\r\n        // Do all transactions as readwrite against all object stores, since we\r\n        // are the only reader/writer.\r\n        return this.simpleDb\r\n            .runTransaction(action, simpleDbMode, objectStores, simpleDbTxn => {\r\n            persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, this.listenSequence\r\n                ? this.listenSequence.next()\r\n                : ListenSequence.INVALID);\r\n            if (mode === 'readwrite-primary') {\r\n                // While we merely verify that we have (or can acquire) the lease\r\n                // immediately, we wait to extend the primary lease until after\r\n                // executing transactionOperation(). This ensures that even if the\r\n                // transactionOperation takes a long time, we'll use a recent\r\n                // leaseTimestampMs in the extended (or newly acquired) lease.\r\n                return this.verifyPrimaryLease(persistenceTransaction)\r\n                    .next(holdsPrimaryLease => {\r\n                    if (holdsPrimaryLease) {\r\n                        return /* holdsPrimaryLease= */ true;\r\n                    }\r\n                    return this.canActAsPrimary(persistenceTransaction);\r\n                })\r\n                    .next(holdsPrimaryLease => {\r\n                    if (!holdsPrimaryLease) {\r\n                        logError(`Failed to obtain primary lease for action '${action}'.`);\r\n                        this.isPrimary = false;\r\n                        this.queue.enqueueRetryable(() => this.primaryStateListener(false));\r\n                        throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);\r\n                    }\r\n                    return transactionOperation(persistenceTransaction);\r\n                })\r\n                    .next(result => {\r\n                    return this.acquireOrExtendPrimaryLease(persistenceTransaction).next(() => result);\r\n                });\r\n            }\r\n            else {\r\n                return this.verifyAllowTabSynchronization(persistenceTransaction).next(() => transactionOperation(persistenceTransaction));\r\n            }\r\n        })\r\n            .then(result => {\r\n            persistenceTransaction.raiseOnCommittedEvent();\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Verifies that the current tab is the primary leaseholder or alternatively\r\n     * that the leaseholder has opted into multi-tab synchronization.\r\n     */\r\n    // TODO(b/114226234): Remove this check when `synchronizeTabs` can no longer\r\n    // be turned off.\r\n    verifyAllowTabSynchronization(txn) {\r\n        const store = primaryClientStore(txn);\r\n        return store.get(DbPrimaryClient.key).next(currentPrimary => {\r\n            const currentLeaseIsValid = currentPrimary !== null &&\r\n                this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) &&\r\n                !this.isClientZombied(currentPrimary.ownerId);\r\n            if (currentLeaseIsValid && !this.isLocalClient(currentPrimary)) {\r\n                if (!this.forceOwningTab &&\r\n                    (!this.allowTabSynchronization ||\r\n                        !currentPrimary.allowTabSynchronization)) {\r\n                    throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Obtains or extends the new primary lease for the local client. This\r\n     * method does not verify that the client is eligible for this lease.\r\n     */\r\n    acquireOrExtendPrimaryLease(txn) {\r\n        const newPrimary = new DbPrimaryClient(this.clientId, this.allowTabSynchronization, Date.now());\r\n        return primaryClientStore(txn).put(DbPrimaryClient.key, newPrimary);\r\n    }\r\n    static isAvailable() {\r\n        return SimpleDb.isAvailable();\r\n    }\r\n    /** Checks the primary lease and removes it if we are the current primary. */\r\n    releasePrimaryLeaseIfHeld(txn) {\r\n        const store = primaryClientStore(txn);\r\n        return store.get(DbPrimaryClient.key).next(primaryClient => {\r\n            if (this.isLocalClient(primaryClient)) {\r\n                logDebug(LOG_TAG$d, 'Releasing primary lease.');\r\n                return store.delete(DbPrimaryClient.key);\r\n            }\r\n            else {\r\n                return PersistencePromise.resolve();\r\n            }\r\n        });\r\n    }\r\n    /** Verifies that `updateTimeMs` is within `maxAgeMs`. */\r\n    isWithinAge(updateTimeMs, maxAgeMs) {\r\n        const now = Date.now();\r\n        const minAcceptable = now - maxAgeMs;\r\n        const maxAcceptable = now;\r\n        if (updateTimeMs < minAcceptable) {\r\n            return false;\r\n        }\r\n        else if (updateTimeMs > maxAcceptable) {\r\n            logError(`Detected an update time that is in the future: ${updateTimeMs} > ${maxAcceptable}`);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    attachVisibilityHandler() {\r\n        if (this.document !== null &&\r\n            typeof this.document.addEventListener === 'function') {\r\n            this.documentVisibilityHandler = () => {\r\n                this.queue.enqueueAndForget(() => {\r\n                    this.inForeground = this.document.visibilityState === 'visible';\r\n                    return this.updateClientMetadataAndTryBecomePrimary();\r\n                });\r\n            };\r\n            this.document.addEventListener('visibilitychange', this.documentVisibilityHandler);\r\n            this.inForeground = this.document.visibilityState === 'visible';\r\n        }\r\n    }\r\n    detachVisibilityHandler() {\r\n        if (this.documentVisibilityHandler) {\r\n            this.document.removeEventListener('visibilitychange', this.documentVisibilityHandler);\r\n            this.documentVisibilityHandler = null;\r\n        }\r\n    }\r\n    /**\r\n     * Attaches a window.unload handler that will synchronously write our\r\n     * clientId to a \"zombie client id\" location in LocalStorage. This can be used\r\n     * by tabs trying to acquire the primary lease to determine that the lease\r\n     * is no longer valid even if the timestamp is recent. This is particularly\r\n     * important for the refresh case (so the tab correctly re-acquires the\r\n     * primary lease). LocalStorage is used for this rather than IndexedDb because\r\n     * it is a synchronous API and so can be used reliably from  an unload\r\n     * handler.\r\n     */\r\n    attachWindowUnloadHook() {\r\n        var _a;\r\n        if (typeof ((_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener) === 'function') {\r\n            this.windowUnloadHandler = () => {\r\n                // Note: In theory, this should be scheduled on the AsyncQueue since it\r\n                // accesses internal state. We execute this code directly during shutdown\r\n                // to make sure it gets a chance to run.\r\n                this.markClientZombied();\r\n                if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.isSafari)() && navigator.appVersion.match(/Version\\/1[45]/)) {\r\n                    // On Safari 14 and 15, we do not run any cleanup actions as it might\r\n                    // trigger a bug that prevents Safari from re-opening IndexedDB during\r\n                    // the next page load.\r\n                    // See https://bugs.webkit.org/show_bug.cgi?id=226547\r\n                    this.queue.enterRestrictedMode(/* purgeExistingTasks= */ true);\r\n                }\r\n                this.queue.enqueueAndForget(() => {\r\n                    // Attempt graceful shutdown (including releasing our primary lease),\r\n                    // but there's no guarantee it will complete.\r\n                    return this.shutdown();\r\n                });\r\n            };\r\n            this.window.addEventListener('pagehide', this.windowUnloadHandler);\r\n        }\r\n    }\r\n    detachWindowUnloadHook() {\r\n        if (this.windowUnloadHandler) {\r\n            this.window.removeEventListener('pagehide', this.windowUnloadHandler);\r\n            this.windowUnloadHandler = null;\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether a client is \"zombied\" based on its LocalStorage entry.\r\n     * Clients become zombied when their tab closes without running all of the\r\n     * cleanup logic in `shutdown()`.\r\n     */\r\n    isClientZombied(clientId) {\r\n        var _a;\r\n        try {\r\n            const isZombied = ((_a = this.webStorage) === null || _a === void 0 ? void 0 : _a.getItem(this.zombiedClientLocalStorageKey(clientId))) !== null;\r\n            logDebug(LOG_TAG$d, `Client '${clientId}' ${isZombied ? 'is' : 'is not'} zombied in LocalStorage`);\r\n            return isZombied;\r\n        }\r\n        catch (e) {\r\n            // Gracefully handle if LocalStorage isn't working.\r\n            logError(LOG_TAG$d, 'Failed to get zombied client id.', e);\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Record client as zombied (a client that had its tab closed). Zombied\r\n     * clients are ignored during primary tab selection.\r\n     */\r\n    markClientZombied() {\r\n        if (!this.webStorage) {\r\n            return;\r\n        }\r\n        try {\r\n            this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\r\n        }\r\n        catch (e) {\r\n            // Gracefully handle if LocalStorage isn't available / working.\r\n            logError('Failed to set zombie client id.', e);\r\n        }\r\n    }\r\n    /** Removes the zombied client entry if it exists. */\r\n    removeClientZombiedEntry() {\r\n        if (!this.webStorage) {\r\n            return;\r\n        }\r\n        try {\r\n            this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\r\n        }\r\n        catch (e) {\r\n            // Ignore\r\n        }\r\n    }\r\n    zombiedClientLocalStorageKey(clientId) {\r\n        return `${ZOMBIED_CLIENTS_KEY_PREFIX}_${this.persistenceKey}_${clientId}`;\r\n    }\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the primary client object store.\r\n */\r\nfunction primaryClientStore(txn) {\r\n    return getStore(txn, DbPrimaryClient.store);\r\n}\r\n/**\r\n * Helper to get a typed SimpleDbStore for the client metadata object store.\r\n */\r\nfunction clientMetadataStore(txn) {\r\n    return getStore(txn, DbClientMetadata.store);\r\n}\r\n/**\r\n * Generates a string used as a prefix when storing data in IndexedDB and\r\n * LocalStorage.\r\n */\r\nfunction indexedDbStoragePrefix(databaseId, persistenceKey) {\r\n    // Use two different prefix formats:\r\n    //\r\n    //   * firestore / persistenceKey / projectID . databaseID / ...\r\n    //   * firestore / persistenceKey / projectID / ...\r\n    //\r\n    // projectIDs are DNS-compatible names and cannot contain dots\r\n    // so there's no danger of collisions.\r\n    let database = databaseId.projectId;\r\n    if (!databaseId.isDefaultDatabase) {\r\n        database += '.' + databaseId.database;\r\n    }\r\n    return 'firestore/' + persistenceKey + '/' + database + '/';\r\n}\r\nasync function indexedDbClearPersistence(persistenceKey) {\r\n    if (!SimpleDb.isAvailable()) {\r\n        return Promise.resolve();\r\n    }\r\n    const dbName = persistenceKey + MAIN_DATABASE;\r\n    await SimpleDb.delete(dbName);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A readonly view of the local state of all documents we're tracking (i.e. we\r\n * have a cached version in remoteDocumentCache or local mutations for the\r\n * document). The view is computed by applying the mutations in the\r\n * MutationQueue to the RemoteDocumentCache.\r\n */\r\nclass LocalDocumentsView {\r\n    constructor(remoteDocumentCache, mutationQueue, indexManager) {\r\n        this.remoteDocumentCache = remoteDocumentCache;\r\n        this.mutationQueue = mutationQueue;\r\n        this.indexManager = indexManager;\r\n    }\r\n    /**\r\n     * Get the local view of the document identified by `key`.\r\n     *\r\n     * @returns Local view of the document or null if we don't have any cached\r\n     * state for it.\r\n     */\r\n    getDocument(transaction, key) {\r\n        return this.mutationQueue\r\n            .getAllMutationBatchesAffectingDocumentKey(transaction, key)\r\n            .next(batches => this.getDocumentInternal(transaction, key, batches));\r\n    }\r\n    /** Internal version of `getDocument` that allows reusing batches. */\r\n    getDocumentInternal(transaction, key, inBatches) {\r\n        return this.remoteDocumentCache.getEntry(transaction, key).next(doc => {\r\n            for (const batch of inBatches) {\r\n                batch.applyToLocalView(doc);\r\n            }\r\n            return doc;\r\n        });\r\n    }\r\n    // Returns the view of the given `docs` as they would appear after applying\r\n    // all mutations in the given `batches`.\r\n    applyLocalMutationsToDocuments(docs, batches) {\r\n        docs.forEach((key, localView) => {\r\n            for (const batch of batches) {\r\n                batch.applyToLocalView(localView);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Gets the local view of the documents identified by `keys`.\r\n     *\r\n     * If we don't have cached state for a document in `keys`, a NoDocument will\r\n     * be stored for that key in the resulting set.\r\n     */\r\n    getDocuments(transaction, keys) {\r\n        return this.remoteDocumentCache\r\n            .getEntries(transaction, keys)\r\n            .next(docs => this.applyLocalViewToDocuments(transaction, docs).next(() => docs));\r\n    }\r\n    /**\r\n     * Applies the local view the given `baseDocs` without retrieving documents\r\n     * from the local store.\r\n     */\r\n    applyLocalViewToDocuments(transaction, baseDocs) {\r\n        return this.mutationQueue\r\n            .getAllMutationBatchesAffectingDocumentKeys(transaction, baseDocs)\r\n            .next(batches => this.applyLocalMutationsToDocuments(baseDocs, batches));\r\n    }\r\n    /**\r\n     * Performs a query against the local view of all documents.\r\n     *\r\n     * @param transaction - The persistence transaction.\r\n     * @param query - The query to match documents against.\r\n     * @param sinceReadTime - If not set to SnapshotVersion.min(), return only\r\n     *     documents that have been read since this snapshot version (exclusive).\r\n     */\r\n    getDocumentsMatchingQuery(transaction, query, sinceReadTime) {\r\n        if (isDocumentQuery$1(query)) {\r\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\r\n        }\r\n        else if (isCollectionGroupQuery(query)) {\r\n            return this.getDocumentsMatchingCollectionGroupQuery(transaction, query, sinceReadTime);\r\n        }\r\n        else {\r\n            return this.getDocumentsMatchingCollectionQuery(transaction, query, sinceReadTime);\r\n        }\r\n    }\r\n    getDocumentsMatchingDocumentQuery(transaction, docPath) {\r\n        // Just do a simple document lookup.\r\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(document => {\r\n            let result = documentMap();\r\n            if (document.isFoundDocument()) {\r\n                result = result.insert(document.key, document);\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    getDocumentsMatchingCollectionGroupQuery(transaction, query, sinceReadTime) {\r\n        const collectionId = query.collectionGroup;\r\n        let results = documentMap();\r\n        return this.indexManager\r\n            .getCollectionParents(transaction, collectionId)\r\n            .next(parents => {\r\n            // Perform a collection query against each parent that contains the\r\n            // collectionId and aggregate the results.\r\n            return PersistencePromise.forEach(parents, (parent) => {\r\n                const collectionQuery = asCollectionQueryAtPath(query, parent.child(collectionId));\r\n                return this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, sinceReadTime).next(r => {\r\n                    r.forEach((key, doc) => {\r\n                        results = results.insert(key, doc);\r\n                    });\r\n                });\r\n            }).next(() => results);\r\n        });\r\n    }\r\n    getDocumentsMatchingCollectionQuery(transaction, query, sinceReadTime) {\r\n        // Query the remote documents and overlay mutations.\r\n        let results;\r\n        return this.remoteDocumentCache\r\n            .getAll(transaction, query.path, sinceReadTime)\r\n            .next(queryResults => {\r\n            results = queryResults;\r\n            return this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);\r\n        })\r\n            .next(mutationBatches => {\r\n            for (const batch of mutationBatches) {\r\n                for (const mutation of batch.mutations) {\r\n                    const key = mutation.key;\r\n                    let document = results.get(key);\r\n                    if (document == null) {\r\n                        // Create invalid document to apply mutations on top of\r\n                        document = MutableDocument.newInvalidDocument(key);\r\n                        results = results.insert(key, document);\r\n                    }\r\n                    mutationApplyToLocalView(mutation, document, batch.localWriteTime);\r\n                    if (!document.isFoundDocument()) {\r\n                        results = results.remove(key);\r\n                    }\r\n                }\r\n            }\r\n        })\r\n            .next(() => {\r\n            // Finally, filter out any documents that don't actually match\r\n            // the query.\r\n            results.forEach((key, doc) => {\r\n                if (!queryMatches(query, doc)) {\r\n                    results = results.remove(key);\r\n                }\r\n            });\r\n            return results;\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$c = 'LocalStore';\r\n/**\r\n * The maximum time to leave a resume token buffered without writing it out.\r\n * This value is arbitrary: it's long enough to avoid several writes\r\n * (possibly indefinitely if updates come more frequently than this) but\r\n * short enough that restarting after crashing will still have a pretty\r\n * recent resume token.\r\n */\r\nconst RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;\r\n/**\r\n * Implements `LocalStore` interface.\r\n *\r\n * Note: some field defined in this class might have public access level, but\r\n * the class is not exported so they are only accessible from this module.\r\n * This is useful to implement optional features (like bundles) in free\r\n * functions, such that they are tree-shakeable.\r\n */\r\nclass LocalStoreImpl {\r\n    constructor(\r\n    /** Manages our in-memory or durable persistence. */\r\n    persistence, queryEngine, initialUser, serializer) {\r\n        this.persistence = persistence;\r\n        this.queryEngine = queryEngine;\r\n        this.serializer = serializer;\r\n        /**\r\n         * Maps a targetID to data about its target.\r\n         *\r\n         * PORTING NOTE: We are using an immutable data structure on Web to make re-runs\r\n         * of `applyRemoteEvent()` idempotent.\r\n         */\r\n        this.targetDataByTarget = new SortedMap(primitiveComparator);\r\n        /** Maps a target to its targetID. */\r\n        // TODO(wuandy): Evaluate if TargetId can be part of Target.\r\n        this.targetIdByTarget = new ObjectMap(t => canonifyTarget(t), targetEquals);\r\n        /**\r\n         * The read time of the last entry processed by `getNewDocumentChanges()`.\r\n         *\r\n         * PORTING NOTE: This is only used for multi-tab synchronization.\r\n         */\r\n        this.lastDocumentChangeReadTime = SnapshotVersion.min();\r\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\r\n        this.targetCache = persistence.getTargetCache();\r\n        this.bundleCache = persistence.getBundleCache();\r\n        this.initializeUserComponents(initialUser);\r\n    }\r\n    initializeUserComponents(user) {\r\n        // TODO(indexing): Add spec tests that test these components change after a\r\n        // user change\r\n        this.indexManager = this.persistence.getIndexManager(user);\r\n        this.mutationQueue = this.persistence.getMutationQueue(user, this.indexManager);\r\n        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.indexManager);\r\n        this.remoteDocuments.setIndexManager(this.indexManager);\r\n        this.queryEngine.setLocalDocumentsView(this.localDocuments);\r\n    }\r\n    collectGarbage(garbageCollector) {\r\n        return this.persistence.runTransaction('Collect garbage', 'readwrite-primary', txn => garbageCollector.collect(txn, this.targetDataByTarget));\r\n    }\r\n}\r\nfunction newLocalStore(\r\n/** Manages our in-memory or durable persistence. */\r\npersistence, queryEngine, initialUser, serializer) {\r\n    return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);\r\n}\r\n/**\r\n * Tells the LocalStore that the currently authenticated user has changed.\r\n *\r\n * In response the local store switches the mutation queue to the new user and\r\n * returns any resulting document changes.\r\n */\r\n// PORTING NOTE: Android and iOS only return the documents affected by the\r\n// change.\r\nasync function localStoreHandleUserChange(localStore, user) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const result = await localStoreImpl.persistence.runTransaction('Handle user change', 'readonly', txn => {\r\n        // Swap out the mutation queue, grabbing the pending mutation batches\r\n        // before and after.\r\n        let oldBatches;\r\n        return localStoreImpl.mutationQueue\r\n            .getAllMutationBatches(txn)\r\n            .next(promisedOldBatches => {\r\n            oldBatches = promisedOldBatches;\r\n            localStoreImpl.initializeUserComponents(user);\r\n            return localStoreImpl.mutationQueue.getAllMutationBatches(txn);\r\n        })\r\n            .next(newBatches => {\r\n            const removedBatchIds = [];\r\n            const addedBatchIds = [];\r\n            // Union the old/new changed keys.\r\n            let changedKeys = documentKeySet();\r\n            for (const batch of oldBatches) {\r\n                removedBatchIds.push(batch.batchId);\r\n                for (const mutation of batch.mutations) {\r\n                    changedKeys = changedKeys.add(mutation.key);\r\n                }\r\n            }\r\n            for (const batch of newBatches) {\r\n                addedBatchIds.push(batch.batchId);\r\n                for (const mutation of batch.mutations) {\r\n                    changedKeys = changedKeys.add(mutation.key);\r\n                }\r\n            }\r\n            // Return the set of all (potentially) changed documents and the list\r\n            // of mutation batch IDs that were affected by change.\r\n            return localStoreImpl.localDocuments\r\n                .getDocuments(txn, changedKeys)\r\n                .next(affectedDocuments => {\r\n                return {\r\n                    affectedDocuments,\r\n                    removedBatchIds,\r\n                    addedBatchIds\r\n                };\r\n            });\r\n        });\r\n    });\r\n    return result;\r\n}\r\n/* Accepts locally generated Mutations and commit them to storage. */\r\nfunction localStoreWriteLocally(localStore, mutations) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const localWriteTime = Timestamp.now();\r\n    const keys = mutations.reduce((keys, m) => keys.add(m.key), documentKeySet());\r\n    let existingDocs;\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Locally write mutations', 'readwrite', txn => {\r\n        // Load and apply all existing mutations. This lets us compute the\r\n        // current base state for all non-idempotent transforms before applying\r\n        // any additional user-provided writes.\r\n        return localStoreImpl.localDocuments\r\n            .getDocuments(txn, keys)\r\n            .next(docs => {\r\n            existingDocs = docs;\r\n            // For non-idempotent mutations (such as `FieldValue.increment()`),\r\n            // we record the base state in a separate patch mutation. This is\r\n            // later used to guarantee consistent values and prevents flicker\r\n            // even if the backend sends us an update that already includes our\r\n            // transform.\r\n            const baseMutations = [];\r\n            for (const mutation of mutations) {\r\n                const baseValue = mutationExtractBaseValue(mutation, existingDocs.get(mutation.key));\r\n                if (baseValue != null) {\r\n                    // NOTE: The base state should only be applied if there's some\r\n                    // existing document to override, so use a Precondition of\r\n                    // exists=true\r\n                    baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.value.mapValue), Precondition.exists(true)));\r\n                }\r\n            }\r\n            return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);\r\n        });\r\n    })\r\n        .then(batch => {\r\n        batch.applyToLocalDocumentSet(existingDocs);\r\n        return { batchId: batch.batchId, changes: existingDocs };\r\n    });\r\n}\r\n/**\r\n * Acknowledges the given batch.\r\n *\r\n * On the happy path when a batch is acknowledged, the local store will\r\n *\r\n *  + remove the batch from the mutation queue;\r\n *  + apply the changes to the remote document cache;\r\n *  + recalculate the latency compensated view implied by those changes (there\r\n *    may be mutations in the queue that affect the documents but haven't been\r\n *    acknowledged yet); and\r\n *  + give the changed documents back the sync engine\r\n *\r\n * @returns The resulting (modified) documents.\r\n */\r\nfunction localStoreAcknowledgeBatch(localStore, batchResult) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Acknowledge batch', 'readwrite-primary', txn => {\r\n        const affected = batchResult.batch.keys();\r\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\r\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\r\n        });\r\n        return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer)\r\n            .next(() => documentBuffer.apply(txn))\r\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\r\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affected));\r\n    });\r\n}\r\n/**\r\n * Removes mutations from the MutationQueue for the specified batch;\r\n * LocalDocuments will be recalculated.\r\n *\r\n * @returns The resulting modified documents.\r\n */\r\nfunction localStoreRejectBatch(localStore, batchId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Reject batch', 'readwrite-primary', txn => {\r\n        let affectedKeys;\r\n        return localStoreImpl.mutationQueue\r\n            .lookupMutationBatch(txn, batchId)\r\n            .next((batch) => {\r\n            hardAssert(batch !== null);\r\n            affectedKeys = batch.keys();\r\n            return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);\r\n        })\r\n            .next(() => localStoreImpl.mutationQueue.performConsistencyCheck(txn))\r\n            .next(() => localStoreImpl.localDocuments.getDocuments(txn, affectedKeys));\r\n    });\r\n}\r\n/**\r\n * Returns the largest (latest) batch id in mutation queue that is pending\r\n * server response.\r\n *\r\n * Returns `BATCHID_UNKNOWN` if the queue is empty.\r\n */\r\nfunction localStoreGetHighestUnacknowledgedBatchId(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get highest unacknowledged batch id', 'readonly', txn => localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn));\r\n}\r\n/**\r\n * Returns the last consistent snapshot processed (used by the RemoteStore to\r\n * determine whether to buffer incoming snapshots from the backend).\r\n */\r\nfunction localStoreGetLastRemoteSnapshotVersion(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get last remote snapshot version', 'readonly', txn => localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn));\r\n}\r\n/**\r\n * Updates the \"ground-state\" (remote) documents. We assume that the remote\r\n * event reflects any write batches that have been acknowledged or rejected\r\n * (i.e. we do not re-apply local mutations to updates from this event).\r\n *\r\n * LocalDocuments are re-calculated if there are remaining mutations in the\r\n * queue.\r\n */\r\nfunction localStoreApplyRemoteEventToLocalCache(localStore, remoteEvent) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const remoteVersion = remoteEvent.snapshotVersion;\r\n    let newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Apply remote event', 'readwrite-primary', txn => {\r\n        const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\r\n            trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\r\n        });\r\n        // Reset newTargetDataByTargetMap in case this transaction gets re-run.\r\n        newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;\r\n        const promises = [];\r\n        remoteEvent.targetChanges.forEach((change, targetId) => {\r\n            const oldTargetData = newTargetDataByTargetMap.get(targetId);\r\n            if (!oldTargetData) {\r\n                return;\r\n            }\r\n            // Only update the remote keys if the target is still active. This\r\n            // ensures that we can persist the updated target data along with\r\n            // the updated assignment.\r\n            promises.push(localStoreImpl.targetCache\r\n                .removeMatchingKeys(txn, change.removedDocuments, targetId)\r\n                .next(() => {\r\n                return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);\r\n            }));\r\n            let newTargetData = oldTargetData.withSequenceNumber(txn.currentSequenceNumber);\r\n            if (remoteEvent.targetMismatches.has(targetId)) {\r\n                newTargetData = newTargetData\r\n                    .withResumeToken(ByteString.EMPTY_BYTE_STRING, SnapshotVersion.min())\r\n                    .withLastLimboFreeSnapshotVersion(SnapshotVersion.min());\r\n            }\r\n            else if (change.resumeToken.approximateByteSize() > 0) {\r\n                newTargetData = newTargetData.withResumeToken(change.resumeToken, remoteVersion);\r\n            }\r\n            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);\r\n            // Update the target data if there are target changes (or if\r\n            // sufficient time has passed since the last update).\r\n            if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {\r\n                promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));\r\n            }\r\n        });\r\n        let changedDocs = mutableDocumentMap();\r\n        remoteEvent.documentUpdates.forEach(key => {\r\n            if (remoteEvent.resolvedLimboDocuments.has(key)) {\r\n                promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));\r\n            }\r\n        });\r\n        // Each loop iteration only affects its \"own\" doc, so it's safe to get all the remote\r\n        // documents in advance in a single call.\r\n        promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates).next(result => {\r\n            changedDocs = result;\r\n        }));\r\n        // HACK: The only reason we allow a null snapshot version is so that we\r\n        // can synthesize remote events when we get permission denied errors while\r\n        // trying to resolve the state of a locally cached document that is in\r\n        // limbo.\r\n        if (!remoteVersion.isEqual(SnapshotVersion.min())) {\r\n            const updateRemoteVersion = localStoreImpl.targetCache\r\n                .getLastRemoteSnapshotVersion(txn)\r\n                .next(lastRemoteSnapshotVersion => {\r\n                return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);\r\n            });\r\n            promises.push(updateRemoteVersion);\r\n        }\r\n        return PersistencePromise.waitFor(promises)\r\n            .next(() => documentBuffer.apply(txn))\r\n            .next(() => localStoreImpl.localDocuments.applyLocalViewToDocuments(txn, changedDocs))\r\n            .next(() => changedDocs);\r\n    })\r\n        .then(changedDocs => {\r\n        localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;\r\n        return changedDocs;\r\n    });\r\n}\r\n/**\r\n * Populates document change buffer with documents from backend or a bundle.\r\n * Returns the document changes resulting from applying those documents.\r\n *\r\n * @param txn - Transaction to use to read existing documents from storage.\r\n * @param documentBuffer - Document buffer to collect the resulted changes to be\r\n *        applied to storage.\r\n * @param documents - Documents to be applied.\r\n * @param globalVersion - A `SnapshotVersion` representing the read time if all\r\n *        documents have the same read time.\r\n * @param documentVersions - A DocumentKey-to-SnapshotVersion map if documents\r\n *        have their own read time.\r\n *\r\n * Note: this function will use `documentVersions` if it is defined;\r\n * when it is not defined, resorts to `globalVersion`.\r\n */\r\nfunction populateDocumentChangeBuffer(txn, documentBuffer, documents) {\r\n    let updatedKeys = documentKeySet();\r\n    documents.forEach(k => (updatedKeys = updatedKeys.add(k)));\r\n    return documentBuffer.getEntries(txn, updatedKeys).next(existingDocs => {\r\n        let changedDocs = mutableDocumentMap();\r\n        documents.forEach((key, doc) => {\r\n            const existingDoc = existingDocs.get(key);\r\n            // Note: The order of the steps below is important, since we want\r\n            // to ensure that rejected limbo resolutions (which fabricate\r\n            // NoDocuments with SnapshotVersion.min()) never add documents to\r\n            // cache.\r\n            if (doc.isNoDocument() && doc.version.isEqual(SnapshotVersion.min())) {\r\n                // NoDocuments with SnapshotVersion.min() are used in manufactured\r\n                // events. We remove these documents from cache since we lost\r\n                // access.\r\n                documentBuffer.removeEntry(key, doc.readTime);\r\n                changedDocs = changedDocs.insert(key, doc);\r\n            }\r\n            else if (!existingDoc.isValidDocument() ||\r\n                doc.version.compareTo(existingDoc.version) > 0 ||\r\n                (doc.version.compareTo(existingDoc.version) === 0 &&\r\n                    existingDoc.hasPendingWrites)) {\r\n                documentBuffer.addEntry(doc);\r\n                changedDocs = changedDocs.insert(key, doc);\r\n            }\r\n            else {\r\n                logDebug(LOG_TAG$c, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\r\n            }\r\n        });\r\n        return changedDocs;\r\n    });\r\n}\r\n/**\r\n * Returns true if the newTargetData should be persisted during an update of\r\n * an active target. TargetData should always be persisted when a target is\r\n * being released and should not call this function.\r\n *\r\n * While the target is active, TargetData updates can be omitted when nothing\r\n * about the target has changed except metadata like the resume token or\r\n * snapshot version. Occasionally it's worth the extra write to prevent these\r\n * values from getting too stale after a crash, but this doesn't have to be\r\n * too frequent.\r\n */\r\nfunction shouldPersistTargetData(oldTargetData, newTargetData, change) {\r\n    // Always persist target data if we don't already have a resume token.\r\n    if (oldTargetData.resumeToken.approximateByteSize() === 0) {\r\n        return true;\r\n    }\r\n    // Don't allow resume token changes to be buffered indefinitely. This\r\n    // allows us to be reasonably up-to-date after a crash and avoids needing\r\n    // to loop over all active queries on shutdown. Especially in the browser\r\n    // we may not get time to do anything interesting while the current tab is\r\n    // closing.\r\n    const timeDelta = newTargetData.snapshotVersion.toMicroseconds() -\r\n        oldTargetData.snapshotVersion.toMicroseconds();\r\n    if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {\r\n        return true;\r\n    }\r\n    // Otherwise if the only thing that has changed about a target is its resume\r\n    // token it's not worth persisting. Note that the RemoteStore keeps an\r\n    // in-memory view of the currently active targets which includes the current\r\n    // resume token, so stream failure or user changes will still use an\r\n    // up-to-date resume token regardless of what we do here.\r\n    const changes = change.addedDocuments.size +\r\n        change.modifiedDocuments.size +\r\n        change.removedDocuments.size;\r\n    return changes > 0;\r\n}\r\n/**\r\n * Notifies local store of the changed views to locally pin documents.\r\n */\r\nasync function localStoreNotifyLocalViewChanges(localStore, viewChanges) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    try {\r\n        await localStoreImpl.persistence.runTransaction('notifyLocalViewChanges', 'readwrite', txn => {\r\n            return PersistencePromise.forEach(viewChanges, (viewChange) => {\r\n                return PersistencePromise.forEach(viewChange.addedKeys, (key) => localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange.targetId, key)).next(() => PersistencePromise.forEach(viewChange.removedKeys, (key) => localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange.targetId, key)));\r\n            });\r\n        });\r\n    }\r\n    catch (e) {\r\n        if (isIndexedDbTransactionError(e)) {\r\n            // If `notifyLocalViewChanges` fails, we did not advance the sequence\r\n            // number for the documents that were included in this transaction.\r\n            // This might trigger them to be deleted earlier than they otherwise\r\n            // would have, but it should not invalidate the integrity of the data.\r\n            logDebug(LOG_TAG$c, 'Failed to update sequence numbers: ' + e);\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    for (const viewChange of viewChanges) {\r\n        const targetId = viewChange.targetId;\r\n        if (!viewChange.fromCache) {\r\n            const targetData = localStoreImpl.targetDataByTarget.get(targetId);\r\n            // Advance the last limbo free snapshot version\r\n            const lastLimboFreeSnapshotVersion = targetData.snapshotVersion;\r\n            const updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);\r\n            localStoreImpl.targetDataByTarget =\r\n                localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Gets the mutation batch after the passed in batchId in the mutation queue\r\n * or null if empty.\r\n * @param afterBatchId - If provided, the batch to search after.\r\n * @returns The next mutation or null if there wasn't one.\r\n */\r\nfunction localStoreGetNextMutationBatch(localStore, afterBatchId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get next mutation batch', 'readonly', txn => {\r\n        if (afterBatchId === undefined) {\r\n            afterBatchId = BATCHID_UNKNOWN;\r\n        }\r\n        return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\r\n    });\r\n}\r\n/**\r\n * Reads the current value of a Document with a given key or null if not\r\n * found - used for testing.\r\n */\r\nfunction localStoreReadDocument(localStore, key) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('read document', 'readonly', txn => localStoreImpl.localDocuments.getDocument(txn, key));\r\n}\r\n/**\r\n * Assigns the given target an internal ID so that its results can be pinned so\r\n * they don't get GC'd. A target must be allocated in the local store before\r\n * the store can be used to manage its view.\r\n *\r\n * Allocating an already allocated `Target` will return the existing `TargetData`\r\n * for that `Target`.\r\n */\r\nfunction localStoreAllocateTarget(localStore, target) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Allocate target', 'readwrite', txn => {\r\n        let targetData;\r\n        return localStoreImpl.targetCache\r\n            .getTargetData(txn, target)\r\n            .next((cached) => {\r\n            if (cached) {\r\n                // This target has been listened to previously, so reuse the\r\n                // previous targetID.\r\n                // TODO(mcg): freshen last accessed date?\r\n                targetData = cached;\r\n                return PersistencePromise.resolve(targetData);\r\n            }\r\n            else {\r\n                return localStoreImpl.targetCache\r\n                    .allocateTargetId(txn)\r\n                    .next(targetId => {\r\n                    targetData = new TargetData(target, targetId, 0 /* Listen */, txn.currentSequenceNumber);\r\n                    return localStoreImpl.targetCache\r\n                        .addTargetData(txn, targetData)\r\n                        .next(() => targetData);\r\n                });\r\n            }\r\n        });\r\n    })\r\n        .then(targetData => {\r\n        // If Multi-Tab is enabled, the existing target data may be newer than\r\n        // the in-memory data\r\n        const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);\r\n        if (cachedTargetData === null ||\r\n            targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) >\r\n                0) {\r\n            localStoreImpl.targetDataByTarget =\r\n                localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);\r\n            localStoreImpl.targetIdByTarget.set(target, targetData.targetId);\r\n        }\r\n        return targetData;\r\n    });\r\n}\r\n/**\r\n * Returns the TargetData as seen by the LocalStore, including updates that may\r\n * have not yet been persisted to the TargetCache.\r\n */\r\n// Visible for testing.\r\nfunction localStoreGetTargetData(localStore, transaction, target) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const targetId = localStoreImpl.targetIdByTarget.get(target);\r\n    if (targetId !== undefined) {\r\n        return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));\r\n    }\r\n    else {\r\n        return localStoreImpl.targetCache.getTargetData(transaction, target);\r\n    }\r\n}\r\n/**\r\n * Unpins all the documents associated with the given target. If\r\n * `keepPersistedTargetData` is set to false and Eager GC enabled, the method\r\n * directly removes the associated target data from the target cache.\r\n *\r\n * Releasing a non-existing `Target` is a no-op.\r\n */\r\n// PORTING NOTE: `keepPersistedTargetData` is multi-tab only.\r\nasync function localStoreReleaseTarget(localStore, targetId, keepPersistedTargetData) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const targetData = localStoreImpl.targetDataByTarget.get(targetId);\r\n    const mode = keepPersistedTargetData ? 'readwrite' : 'readwrite-primary';\r\n    try {\r\n        if (!keepPersistedTargetData) {\r\n            await localStoreImpl.persistence.runTransaction('Release target', mode, txn => {\r\n                return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);\r\n            });\r\n        }\r\n    }\r\n    catch (e) {\r\n        if (isIndexedDbTransactionError(e)) {\r\n            // All `releaseTarget` does is record the final metadata state for the\r\n            // target, but we've been recording this periodically during target\r\n            // activity. If we lose this write this could cause a very slight\r\n            // difference in the order of target deletion during GC, but we\r\n            // don't define exact LRU semantics so this is acceptable.\r\n            logDebug(LOG_TAG$c, `Failed to update sequence numbers for target ${targetId}: ${e}`);\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    localStoreImpl.targetDataByTarget =\r\n        localStoreImpl.targetDataByTarget.remove(targetId);\r\n    localStoreImpl.targetIdByTarget.delete(targetData.target);\r\n}\r\n/**\r\n * Runs the specified query against the local store and returns the results,\r\n * potentially taking advantage of query data from previous executions (such\r\n * as the set of remote keys).\r\n *\r\n * @param usePreviousResults - Whether results from previous executions can\r\n * be used to optimize this query execution.\r\n */\r\nfunction localStoreExecuteQuery(localStore, query, usePreviousResults) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    let lastLimboFreeSnapshotVersion = SnapshotVersion.min();\r\n    let remoteKeys = documentKeySet();\r\n    return localStoreImpl.persistence.runTransaction('Execute query', 'readonly', txn => {\r\n        return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query))\r\n            .next(targetData => {\r\n            if (targetData) {\r\n                lastLimboFreeSnapshotVersion =\r\n                    targetData.lastLimboFreeSnapshotVersion;\r\n                return localStoreImpl.targetCache\r\n                    .getMatchingKeysForTargetId(txn, targetData.targetId)\r\n                    .next(result => {\r\n                    remoteKeys = result;\r\n                });\r\n            }\r\n        })\r\n            .next(() => localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query, usePreviousResults\r\n            ? lastLimboFreeSnapshotVersion\r\n            : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet()))\r\n            .next(documents => {\r\n            return { documents, remoteKeys };\r\n        });\r\n    });\r\n}\r\nfunction applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {\r\n    const batch = batchResult.batch;\r\n    const docKeys = batch.keys();\r\n    let promiseChain = PersistencePromise.resolve();\r\n    docKeys.forEach(docKey => {\r\n        promiseChain = promiseChain\r\n            .next(() => documentBuffer.getEntry(txn, docKey))\r\n            .next(doc => {\r\n            const ackVersion = batchResult.docVersions.get(docKey);\r\n            hardAssert(ackVersion !== null);\r\n            if (doc.version.compareTo(ackVersion) < 0) {\r\n                batch.applyToRemoteDocument(doc, batchResult);\r\n                if (doc.isValidDocument()) {\r\n                    // We use the commitVersion as the readTime rather than the\r\n                    // document's updateTime since the updateTime is not advanced\r\n                    // for updates that do not modify the underlying document.\r\n                    doc.setReadTime(batchResult.commitVersion);\r\n                    documentBuffer.addEntry(doc);\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return promiseChain.next(() => localStoreImpl.mutationQueue.removeMutationBatch(txn, batch));\r\n}\r\n/** Returns the local view of the documents affected by a mutation batch. */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreLookupMutationDocuments(localStore, batchId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);\r\n    return localStoreImpl.persistence.runTransaction('Lookup mutation documents', 'readonly', txn => {\r\n        return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(keys => {\r\n            if (keys) {\r\n                return localStoreImpl.localDocuments.getDocuments(txn, keys);\r\n            }\r\n            else {\r\n                return PersistencePromise.resolve(null);\r\n            }\r\n        });\r\n    });\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreRemoveCachedMutationBatchMetadata(localStore, batchId) {\r\n    const mutationQueueImpl = debugCast(debugCast(localStore, LocalStoreImpl).mutationQueue);\r\n    mutationQueueImpl.removeCachedMutationKeys(batchId);\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreGetActiveClients(localStore) {\r\n    const persistenceImpl = debugCast(debugCast(localStore, LocalStoreImpl).persistence);\r\n    return persistenceImpl.getActiveClients();\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreGetCachedTarget(localStore, targetId) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const targetCacheImpl = debugCast(localStoreImpl.targetCache);\r\n    const cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);\r\n    if (cachedTargetData) {\r\n        return Promise.resolve(cachedTargetData.target);\r\n    }\r\n    else {\r\n        return localStoreImpl.persistence.runTransaction('Get target data', 'readonly', txn => {\r\n            return targetCacheImpl\r\n                .getTargetDataForTarget(txn, targetId)\r\n                .next(targetData => (targetData ? targetData.target : null));\r\n        });\r\n    }\r\n}\r\n/**\r\n * Returns the set of documents that have been updated since the last call.\r\n * If this is the first call, returns the set of changes since client\r\n * initialization. Further invocations will return document that have changed\r\n * since the prior call.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction localStoreGetNewDocumentChanges(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Get new document changes', 'readonly', txn => remoteDocumentCacheGetNewDocumentChanges(localStoreImpl.remoteDocuments, txn, localStoreImpl.lastDocumentChangeReadTime))\r\n        .then(({ changedDocs, readTime }) => {\r\n        localStoreImpl.lastDocumentChangeReadTime = readTime;\r\n        return changedDocs;\r\n    });\r\n}\r\n/**\r\n * Reads the newest document change from persistence and moves the internal\r\n * synchronization marker forward so that calls to `getNewDocumentChanges()`\r\n * only return changes that happened after client initialization.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function localStoreSynchronizeLastDocumentChangeReadTime(localStore) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence\r\n        .runTransaction('Synchronize last document change read time', 'readonly', txn => remoteDocumentCacheGetLastReadTime(txn))\r\n        .then(readTime => {\r\n        localStoreImpl.lastDocumentChangeReadTime = readTime;\r\n    });\r\n}\r\n/**\r\n * Creates a new target using the given bundle name, which will be used to\r\n * hold the keys of all documents from the bundle in query-document mappings.\r\n * This ensures that the loaded documents do not get garbage collected\r\n * right away.\r\n */\r\nfunction umbrellaTarget(bundleName) {\r\n    // It is OK that the path used for the query is not valid, because this will\r\n    // not be read and queried.\r\n    return queryToTarget(newQueryForPath(ResourcePath.fromString(`__bundle__/docs/${bundleName}`)));\r\n}\r\n/**\r\n * Applies the documents from a bundle to the \"ground-state\" (remote)\r\n * documents.\r\n *\r\n * LocalDocuments are re-calculated if there are remaining mutations in the\r\n * queue.\r\n */\r\nasync function localStoreApplyBundledDocuments(localStore, bundleConverter, documents, bundleName) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    let documentKeys = documentKeySet();\r\n    let documentMap = mutableDocumentMap();\r\n    for (const bundleDoc of documents) {\r\n        const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\r\n        if (bundleDoc.document) {\r\n            documentKeys = documentKeys.add(documentKey);\r\n        }\r\n        const doc = bundleConverter.toMutableDocument(bundleDoc);\r\n        doc.setReadTime(bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));\r\n        documentMap = documentMap.insert(documentKey, doc);\r\n    }\r\n    const documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({\r\n        trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\r\n    });\r\n    // Allocates a target to hold all document keys from the bundle, such that\r\n    // they will not get garbage collected right away.\r\n    const umbrellaTargetData = await localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName));\r\n    return localStoreImpl.persistence.runTransaction('Apply bundle documents', 'readwrite', txn => {\r\n        return populateDocumentChangeBuffer(txn, documentBuffer, documentMap)\r\n            .next(changedDocs => {\r\n            documentBuffer.apply(txn);\r\n            return changedDocs;\r\n        })\r\n            .next(changedDocs => {\r\n            return localStoreImpl.targetCache\r\n                .removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId)\r\n                .next(() => localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId))\r\n                .next(() => localStoreImpl.localDocuments.applyLocalViewToDocuments(txn, changedDocs))\r\n                .next(() => changedDocs);\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns a promise of a boolean to indicate if the given bundle has already\r\n * been loaded and the create time is newer than the current loading bundle.\r\n */\r\nfunction localStoreHasNewerBundle(localStore, bundleMetadata) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    const currentReadTime = fromVersion(bundleMetadata.createTime);\r\n    return localStoreImpl.persistence\r\n        .runTransaction('hasNewerBundle', 'readonly', transaction => {\r\n        return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);\r\n    })\r\n        .then(cached => {\r\n        return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;\r\n    });\r\n}\r\n/**\r\n * Saves the given `BundleMetadata` to local persistence.\r\n */\r\nfunction localStoreSaveBundle(localStore, bundleMetadata) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Save bundle', 'readwrite', transaction => {\r\n        return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);\r\n    });\r\n}\r\n/**\r\n * Returns a promise of a `NamedQuery` associated with given query name. Promise\r\n * resolves to undefined if no persisted data can be found.\r\n */\r\nfunction localStoreGetNamedQuery(localStore, queryName) {\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Get named query', 'readonly', transaction => localStoreImpl.bundleCache.getNamedQuery(transaction, queryName));\r\n}\r\n/**\r\n * Saves the given `NamedQuery` to local persistence.\r\n */\r\nasync function localStoreSaveNamedQuery(localStore, query, documents = documentKeySet()) {\r\n    // Allocate a target for the named query such that it can be resumed\r\n    // from associated read time if users use it to listen.\r\n    // NOTE: this also means if no corresponding target exists, the new target\r\n    // will remain active and will not get collected, unless users happen to\r\n    // unlisten the query somehow.\r\n    const allocated = await localStoreAllocateTarget(localStore, queryToTarget(fromBundledQuery(query.bundledQuery)));\r\n    const localStoreImpl = debugCast(localStore);\r\n    return localStoreImpl.persistence.runTransaction('Save named query', 'readwrite', transaction => {\r\n        const readTime = fromVersion(query.readTime);\r\n        // Simply save the query itself if it is older than what the SDK already\r\n        // has.\r\n        if (allocated.snapshotVersion.compareTo(readTime) >= 0) {\r\n            return localStoreImpl.bundleCache.saveNamedQuery(transaction, query);\r\n        }\r\n        // Update existing target data because the query from the bundle is newer.\r\n        const newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);\r\n        localStoreImpl.targetDataByTarget =\r\n            localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);\r\n        return localStoreImpl.targetCache\r\n            .updateTargetData(transaction, newTargetData)\r\n            .next(() => localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId))\r\n            .next(() => localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId))\r\n            .next(() => localStoreImpl.bundleCache.saveNamedQuery(transaction, query));\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryBundleCache {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n        this.bundles = new Map();\r\n        this.namedQueries = new Map();\r\n    }\r\n    getBundleMetadata(transaction, bundleId) {\r\n        return PersistencePromise.resolve(this.bundles.get(bundleId));\r\n    }\r\n    saveBundleMetadata(transaction, bundleMetadata) {\r\n        this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getNamedQuery(transaction, queryName) {\r\n        return PersistencePromise.resolve(this.namedQueries.get(queryName));\r\n    }\r\n    saveNamedQuery(transaction, query) {\r\n        this.namedQueries.set(query.name, fromProtoNamedQuery(query));\r\n        return PersistencePromise.resolve();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory implementation of DocumentOverlayCache.\r\n */\r\nclass MemoryDocumentOverlayCache {\r\n    constructor() {\r\n        // A map sorted by DocumentKey, whose value is a pair of the largest batch id\r\n        // for the overlay and the overlay itself.\r\n        this.overlays = new SortedMap(DocumentKey.comparator);\r\n        this.overlayByBatchId = new Map();\r\n    }\r\n    getOverlay(transaction, key) {\r\n        return PersistencePromise.resolve(this.overlays.get(key));\r\n    }\r\n    saveOverlays(transaction, largestBatchId, overlays) {\r\n        overlays.forEach(mutation => {\r\n            this.saveOverlay(transaction, largestBatchId, mutation);\r\n        });\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeOverlaysForBatchId(transaction, documentKeys, batchId) {\r\n        const keys = this.overlayByBatchId.get(batchId);\r\n        if (keys !== undefined) {\r\n            keys.forEach(key => (this.overlays = this.overlays.remove(key)));\r\n            this.overlayByBatchId.delete(batchId);\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getOverlaysForCollection(transaction, collection, sinceBatchId) {\r\n        const result = new Map();\r\n        const immediateChildrenPathLength = collection.length + 1;\r\n        const prefix = new DocumentKey(collection.child(''));\r\n        const iter = this.overlays.getIteratorFrom(prefix);\r\n        while (iter.hasNext()) {\r\n            const entry = iter.getNext();\r\n            const overlay = entry.value;\r\n            const key = overlay.getKey();\r\n            if (!collection.isPrefixOf(key.path)) {\r\n                break;\r\n            }\r\n            // Documents from sub-collections\r\n            if (key.path.length !== immediateChildrenPathLength) {\r\n                continue;\r\n            }\r\n            if (overlay.largestBatchId > sinceBatchId) {\r\n                result.set(overlay.getKey(), overlay);\r\n            }\r\n        }\r\n        return PersistencePromise.resolve(result);\r\n    }\r\n    getOverlaysForCollectionGroup(transaction, collectionGroup, sinceBatchId, count) {\r\n        let batchIdToOverlays = new SortedMap((key1, key2) => key1 - key2);\r\n        const iter = this.overlays.getIterator();\r\n        while (iter.hasNext()) {\r\n            const entry = iter.getNext();\r\n            const overlay = entry.value;\r\n            const key = overlay.getKey();\r\n            if (key.getCollectionGroup() !== collectionGroup) {\r\n                continue;\r\n            }\r\n            if (overlay.largestBatchId > sinceBatchId) {\r\n                let overlaysForBatchId = batchIdToOverlays.get(overlay.largestBatchId);\r\n                if (overlaysForBatchId === null) {\r\n                    overlaysForBatchId = new Map();\r\n                    batchIdToOverlays = batchIdToOverlays.insert(overlay.largestBatchId, overlaysForBatchId);\r\n                }\r\n                overlaysForBatchId.set(overlay.getKey(), overlay);\r\n            }\r\n        }\r\n        const result = new Map();\r\n        const batchIter = batchIdToOverlays.getIterator();\r\n        while (batchIter.hasNext()) {\r\n            const entry = batchIter.getNext();\r\n            const overlays = entry.value;\r\n            overlays.forEach((overlay, key) => result.set(key, overlay));\r\n            if (result.size >= count) {\r\n                break;\r\n            }\r\n        }\r\n        return PersistencePromise.resolve(result);\r\n    }\r\n    saveOverlay(transaction, largestBatchId, mutation) {\r\n        if (mutation === null) {\r\n            return;\r\n        }\r\n        // Remove the association of the overlay to its batch id.\r\n        const existing = this.overlays.get(mutation.key);\r\n        if (existing !== null) {\r\n            this.overlayByBatchId.get(existing.largestBatchId).delete(mutation.key);\r\n        }\r\n        this.overlays = this.overlays.insert(mutation.key, new Overlay(largestBatchId, mutation));\r\n        // Create the association of this overlay to the given largestBatchId.\r\n        let batch = this.overlayByBatchId.get(largestBatchId);\r\n        if (batch === undefined) {\r\n            batch = new Set();\r\n            this.overlayByBatchId.set(largestBatchId, batch);\r\n        }\r\n        batch.add(mutation.key);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A collection of references to a document from some kind of numbered entity\r\n * (either a target ID or batch ID). As references are added to or removed from\r\n * the set corresponding events are emitted to a registered garbage collector.\r\n *\r\n * Each reference is represented by a DocumentReference object. Each of them\r\n * contains enough information to uniquely identify the reference. They are all\r\n * stored primarily in a set sorted by key. A document is considered garbage if\r\n * there's no references in that set (this can be efficiently checked thanks to\r\n * sorting by key).\r\n *\r\n * ReferenceSet also keeps a secondary set that contains references sorted by\r\n * IDs. This one is used to efficiently implement removal of all references by\r\n * some target ID.\r\n */\r\nclass ReferenceSet {\r\n    constructor() {\r\n        // A set of outstanding references to a document sorted by key.\r\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\r\n        // A set of outstanding references to a document sorted by target id.\r\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\r\n    }\r\n    /** Returns true if the reference set contains no references. */\r\n    isEmpty() {\r\n        return this.refsByKey.isEmpty();\r\n    }\r\n    /** Adds a reference to the given document key for the given ID. */\r\n    addReference(key, id) {\r\n        const ref = new DocReference(key, id);\r\n        this.refsByKey = this.refsByKey.add(ref);\r\n        this.refsByTarget = this.refsByTarget.add(ref);\r\n    }\r\n    /** Add references to the given document keys for the given ID. */\r\n    addReferences(keys, id) {\r\n        keys.forEach(key => this.addReference(key, id));\r\n    }\r\n    /**\r\n     * Removes a reference to the given document key for the given\r\n     * ID.\r\n     */\r\n    removeReference(key, id) {\r\n        this.removeRef(new DocReference(key, id));\r\n    }\r\n    removeReferences(keys, id) {\r\n        keys.forEach(key => this.removeReference(key, id));\r\n    }\r\n    /**\r\n     * Clears all references with a given ID. Calls removeRef() for each key\r\n     * removed.\r\n     */\r\n    removeReferencesForId(id) {\r\n        const emptyKey = new DocumentKey(new ResourcePath([]));\r\n        const startRef = new DocReference(emptyKey, id);\r\n        const endRef = new DocReference(emptyKey, id + 1);\r\n        const keys = [];\r\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\r\n            this.removeRef(ref);\r\n            keys.push(ref.key);\r\n        });\r\n        return keys;\r\n    }\r\n    removeAllReferences() {\r\n        this.refsByKey.forEach(ref => this.removeRef(ref));\r\n    }\r\n    removeRef(ref) {\r\n        this.refsByKey = this.refsByKey.delete(ref);\r\n        this.refsByTarget = this.refsByTarget.delete(ref);\r\n    }\r\n    referencesForId(id) {\r\n        const emptyKey = new DocumentKey(new ResourcePath([]));\r\n        const startRef = new DocReference(emptyKey, id);\r\n        const endRef = new DocReference(emptyKey, id + 1);\r\n        let keys = documentKeySet();\r\n        this.refsByTarget.forEachInRange([startRef, endRef], ref => {\r\n            keys = keys.add(ref.key);\r\n        });\r\n        return keys;\r\n    }\r\n    containsKey(key) {\r\n        const ref = new DocReference(key, 0);\r\n        const firstRef = this.refsByKey.firstAfterOrEqual(ref);\r\n        return firstRef !== null && key.isEqual(firstRef.key);\r\n    }\r\n}\r\nclass DocReference {\r\n    constructor(key, targetOrBatchId) {\r\n        this.key = key;\r\n        this.targetOrBatchId = targetOrBatchId;\r\n    }\r\n    /** Compare by key then by ID */\r\n    static compareByKey(left, right) {\r\n        return (DocumentKey.comparator(left.key, right.key) ||\r\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\r\n    }\r\n    /** Compare by ID then by key */\r\n    static compareByTargetId(left, right) {\r\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\r\n            DocumentKey.comparator(left.key, right.key));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryMutationQueue {\r\n    constructor(indexManager, referenceDelegate) {\r\n        this.indexManager = indexManager;\r\n        this.referenceDelegate = referenceDelegate;\r\n        /**\r\n         * The set of all mutations that have been sent but not yet been applied to\r\n         * the backend.\r\n         */\r\n        this.mutationQueue = [];\r\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\r\n        this.nextBatchId = 1;\r\n        /** An ordered mapping between documents and the mutations batch IDs. */\r\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\r\n    }\r\n    checkEmpty(transaction) {\r\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\r\n    }\r\n    addMutationBatch(transaction, localWriteTime, baseMutations, mutations) {\r\n        const batchId = this.nextBatchId;\r\n        this.nextBatchId++;\r\n        if (this.mutationQueue.length > 0) {\r\n            this.mutationQueue[this.mutationQueue.length - 1];\r\n        }\r\n        const batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);\r\n        this.mutationQueue.push(batch);\r\n        // Track references by document key and index collection parents.\r\n        for (const mutation of mutations) {\r\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\r\n            this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());\r\n        }\r\n        return PersistencePromise.resolve(batch);\r\n    }\r\n    lookupMutationBatch(transaction, batchId) {\r\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\r\n    }\r\n    getNextMutationBatchAfterBatchId(transaction, batchId) {\r\n        const nextBatchId = batchId + 1;\r\n        // The requested batchId may still be out of range so normalize it to the\r\n        // start of the queue.\r\n        const rawIndex = this.indexOfBatchId(nextBatchId);\r\n        const index = rawIndex < 0 ? 0 : rawIndex;\r\n        return PersistencePromise.resolve(this.mutationQueue.length > index ? this.mutationQueue[index] : null);\r\n    }\r\n    getHighestUnacknowledgedBatchId() {\r\n        return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);\r\n    }\r\n    getAllMutationBatches(transaction) {\r\n        return PersistencePromise.resolve(this.mutationQueue.slice());\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKey(transaction, documentKey) {\r\n        const start = new DocReference(documentKey, 0);\r\n        const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\r\n        const result = [];\r\n        this.batchesByDocumentKey.forEachInRange([start, end], ref => {\r\n            const batch = this.findMutationBatch(ref.targetOrBatchId);\r\n            result.push(batch);\r\n        });\r\n        return PersistencePromise.resolve(result);\r\n    }\r\n    getAllMutationBatchesAffectingDocumentKeys(transaction, documentKeys) {\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        documentKeys.forEach(documentKey => {\r\n            const start = new DocReference(documentKey, 0);\r\n            const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\r\n            this.batchesByDocumentKey.forEachInRange([start, end], ref => {\r\n                uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\r\n            });\r\n        });\r\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\r\n    }\r\n    getAllMutationBatchesAffectingQuery(transaction, query) {\r\n        // Use the query path as a prefix for testing if a document matches the\r\n        // query.\r\n        const prefix = query.path;\r\n        const immediateChildrenPathLength = prefix.length + 1;\r\n        // Construct a document reference for actually scanning the index. Unlike\r\n        // the prefix the document key in this reference must have an even number of\r\n        // segments. The empty segment can be used a suffix of the query path\r\n        // because it precedes all other segments in an ordered traversal.\r\n        let startPath = prefix;\r\n        if (!DocumentKey.isDocumentKey(startPath)) {\r\n            startPath = startPath.child('');\r\n        }\r\n        const start = new DocReference(new DocumentKey(startPath), 0);\r\n        // Find unique batchIDs referenced by all documents potentially matching the\r\n        // query.\r\n        let uniqueBatchIDs = new SortedSet(primitiveComparator);\r\n        this.batchesByDocumentKey.forEachWhile(ref => {\r\n            const rowKeyPath = ref.key.path;\r\n            if (!prefix.isPrefixOf(rowKeyPath)) {\r\n                return false;\r\n            }\r\n            else {\r\n                // Rows with document keys more than one segment longer than the query\r\n                // path can't be matches. For example, a query on 'rooms' can't match\r\n                // the document /rooms/abc/messages/xyx.\r\n                // TODO(mcg): we'll need a different scanner when we implement\r\n                // ancestor queries.\r\n                if (rowKeyPath.length === immediateChildrenPathLength) {\r\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\r\n                }\r\n                return true;\r\n            }\r\n        }, start);\r\n        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\r\n    }\r\n    findMutationBatches(batchIDs) {\r\n        // Construct an array of matching batches, sorted by batchID to ensure that\r\n        // multiple mutations affecting the same document key are applied in order.\r\n        const result = [];\r\n        batchIDs.forEach(batchId => {\r\n            const batch = this.findMutationBatch(batchId);\r\n            if (batch !== null) {\r\n                result.push(batch);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    removeMutationBatch(transaction, batch) {\r\n        // Find the position of the first batch for removal.\r\n        const batchIndex = this.indexOfExistingBatchId(batch.batchId, 'removed');\r\n        hardAssert(batchIndex === 0);\r\n        this.mutationQueue.shift();\r\n        let references = this.batchesByDocumentKey;\r\n        return PersistencePromise.forEach(batch.mutations, (mutation) => {\r\n            const ref = new DocReference(mutation.key, batch.batchId);\r\n            references = references.delete(ref);\r\n            return this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);\r\n        }).next(() => {\r\n            this.batchesByDocumentKey = references;\r\n        });\r\n    }\r\n    removeCachedMutationKeys(batchId) {\r\n        // No-op since the memory mutation queue does not maintain a separate cache.\r\n    }\r\n    containsKey(txn, key) {\r\n        const ref = new DocReference(key, 0);\r\n        const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\r\n        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\r\n    }\r\n    performConsistencyCheck(txn) {\r\n        if (this.mutationQueue.length === 0) ;\r\n        return PersistencePromise.resolve();\r\n    }\r\n    /**\r\n     * Finds the index of the given batchId in the mutation queue and asserts that\r\n     * the resulting index is within the bounds of the queue.\r\n     *\r\n     * @param batchId - The batchId to search for\r\n     * @param action - A description of what the caller is doing, phrased in passive\r\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\r\n     */\r\n    indexOfExistingBatchId(batchId, action) {\r\n        const index = this.indexOfBatchId(batchId);\r\n        return index;\r\n    }\r\n    /**\r\n     * Finds the index of the given batchId in the mutation queue. This operation\r\n     * is O(1).\r\n     *\r\n     * @returns The computed index of the batch with the given batchId, based on\r\n     * the state of the queue. Note this index can be negative if the requested\r\n     * batchId has already been remvoed from the queue or past the end of the\r\n     * queue if the batchId is larger than the last added batch.\r\n     */\r\n    indexOfBatchId(batchId) {\r\n        if (this.mutationQueue.length === 0) {\r\n            // As an index this is past the end of the queue\r\n            return 0;\r\n        }\r\n        // Examine the front of the queue to figure out the difference between the\r\n        // batchId and indexes in the array. Note that since the queue is ordered\r\n        // by batchId, if the first batch has a larger batchId then the requested\r\n        // batchId doesn't exist in the queue.\r\n        const firstBatchId = this.mutationQueue[0].batchId;\r\n        return batchId - firstBatchId;\r\n    }\r\n    /**\r\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\r\n     * other functions that uses this code easier to read and more efficent.\r\n     */\r\n    findMutationBatch(batchId) {\r\n        const index = this.indexOfBatchId(batchId);\r\n        if (index < 0 || index >= this.mutationQueue.length) {\r\n            return null;\r\n        }\r\n        const batch = this.mutationQueue[index];\r\n        return batch;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction documentEntryMap() {\r\n    return new SortedMap(DocumentKey.comparator);\r\n}\r\n/**\r\n * The memory-only RemoteDocumentCache for IndexedDb. To construct, invoke\r\n * `newMemoryRemoteDocumentCache()`.\r\n */\r\nclass MemoryRemoteDocumentCacheImpl {\r\n    /**\r\n     * @param sizer - Used to assess the size of a document. For eager GC, this is\r\n     * expected to just return 0 to avoid unnecessarily doing the work of\r\n     * calculating the size.\r\n     */\r\n    constructor(sizer) {\r\n        this.sizer = sizer;\r\n        /** Underlying cache of documents and their read times. */\r\n        this.docs = documentEntryMap();\r\n        /** Size of all cached documents. */\r\n        this.size = 0;\r\n    }\r\n    setIndexManager(indexManager) {\r\n        this.indexManager = indexManager;\r\n    }\r\n    /**\r\n     * Adds the supplied entry to the cache and updates the cache size as appropriate.\r\n     *\r\n     * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()`.\r\n     */\r\n    addEntry(transaction, doc) {\r\n        const key = doc.key;\r\n        const entry = this.docs.get(key);\r\n        const previousSize = entry ? entry.size : 0;\r\n        const currentSize = this.sizer(doc);\r\n        this.docs = this.docs.insert(key, {\r\n            document: doc.mutableCopy(),\r\n            size: currentSize\r\n        });\r\n        this.size += currentSize - previousSize;\r\n        return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());\r\n    }\r\n    /**\r\n     * Removes the specified entry from the cache and updates the cache size as appropriate.\r\n     *\r\n     * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer\r\n     * returned by `newChangeBuffer()`.\r\n     */\r\n    removeEntry(documentKey) {\r\n        const entry = this.docs.get(documentKey);\r\n        if (entry) {\r\n            this.docs = this.docs.remove(documentKey);\r\n            this.size -= entry.size;\r\n        }\r\n    }\r\n    getEntry(transaction, documentKey) {\r\n        const entry = this.docs.get(documentKey);\r\n        return PersistencePromise.resolve(entry\r\n            ? entry.document.mutableCopy()\r\n            : MutableDocument.newInvalidDocument(documentKey));\r\n    }\r\n    getEntries(transaction, documentKeys) {\r\n        let results = mutableDocumentMap();\r\n        documentKeys.forEach(documentKey => {\r\n            const entry = this.docs.get(documentKey);\r\n            results = results.insert(documentKey, entry\r\n                ? entry.document.mutableCopy()\r\n                : MutableDocument.newInvalidDocument(documentKey));\r\n        });\r\n        return PersistencePromise.resolve(results);\r\n    }\r\n    getAll(transaction, collectionPath, sinceReadTime) {\r\n        let results = mutableDocumentMap();\r\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\r\n        // the documents we need to match the query against.\r\n        const prefix = new DocumentKey(collectionPath.child(''));\r\n        const iterator = this.docs.getIteratorFrom(prefix);\r\n        while (iterator.hasNext()) {\r\n            const { key, value: { document } } = iterator.getNext();\r\n            if (!collectionPath.isPrefixOf(key.path)) {\r\n                break;\r\n            }\r\n            if (key.path.length > collectionPath.length + 1) {\r\n                // Exclude entries from subcollections.\r\n                continue;\r\n            }\r\n            if (document.readTime.compareTo(sinceReadTime) <= 0) {\r\n                continue;\r\n            }\r\n            results = results.insert(document.key, document.mutableCopy());\r\n        }\r\n        return PersistencePromise.resolve(results);\r\n    }\r\n    forEachDocumentKey(transaction, f) {\r\n        return PersistencePromise.forEach(this.docs, (key) => f(key));\r\n    }\r\n    newChangeBuffer(options) {\r\n        // `trackRemovals` is ignores since the MemoryRemoteDocumentCache keeps\r\n        // a separate changelog and does not need special handling for removals.\r\n        return new MemoryRemoteDocumentChangeBuffer(this);\r\n    }\r\n    getSize(txn) {\r\n        return PersistencePromise.resolve(this.size);\r\n    }\r\n}\r\n/**\r\n * Creates a new memory-only RemoteDocumentCache.\r\n *\r\n * @param sizer - Used to assess the size of a document. For eager GC, this is\r\n * expected to just return 0 to avoid unnecessarily doing the work of\r\n * calculating the size.\r\n */\r\nfunction newMemoryRemoteDocumentCache(sizer) {\r\n    return new MemoryRemoteDocumentCacheImpl(sizer);\r\n}\r\n/**\r\n * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.\r\n */\r\nclass MemoryRemoteDocumentChangeBuffer extends RemoteDocumentChangeBuffer {\r\n    constructor(documentCache) {\r\n        super();\r\n        this.documentCache = documentCache;\r\n    }\r\n    applyChanges(transaction) {\r\n        const promises = [];\r\n        this.changes.forEach((key, doc) => {\r\n            if (doc.isValidDocument()) {\r\n                promises.push(this.documentCache.addEntry(transaction, doc));\r\n            }\r\n            else {\r\n                this.documentCache.removeEntry(key);\r\n            }\r\n        });\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    getFromCache(transaction, documentKey) {\r\n        return this.documentCache.getEntry(transaction, documentKey);\r\n    }\r\n    getAllFromCache(transaction, documentKeys) {\r\n        return this.documentCache.getEntries(transaction, documentKeys);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass MemoryTargetCache {\r\n    constructor(persistence) {\r\n        this.persistence = persistence;\r\n        /**\r\n         * Maps a target to the data about that target\r\n         */\r\n        this.targets = new ObjectMap(t => canonifyTarget(t), targetEquals);\r\n        /** The last received snapshot version. */\r\n        this.lastRemoteSnapshotVersion = SnapshotVersion.min();\r\n        /** The highest numbered target ID encountered. */\r\n        this.highestTargetId = 0;\r\n        /** The highest sequence number encountered. */\r\n        this.highestSequenceNumber = 0;\r\n        /**\r\n         * A ordered bidirectional mapping between documents and the remote target\r\n         * IDs.\r\n         */\r\n        this.references = new ReferenceSet();\r\n        this.targetCount = 0;\r\n        this.targetIdGenerator = TargetIdGenerator.forTargetCache();\r\n    }\r\n    forEachTarget(txn, f) {\r\n        this.targets.forEach((_, targetData) => f(targetData));\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getLastRemoteSnapshotVersion(transaction) {\r\n        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);\r\n    }\r\n    getHighestSequenceNumber(transaction) {\r\n        return PersistencePromise.resolve(this.highestSequenceNumber);\r\n    }\r\n    allocateTargetId(transaction) {\r\n        this.highestTargetId = this.targetIdGenerator.next();\r\n        return PersistencePromise.resolve(this.highestTargetId);\r\n    }\r\n    setTargetsMetadata(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {\r\n        if (lastRemoteSnapshotVersion) {\r\n            this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\r\n        }\r\n        if (highestListenSequenceNumber > this.highestSequenceNumber) {\r\n            this.highestSequenceNumber = highestListenSequenceNumber;\r\n        }\r\n        return PersistencePromise.resolve();\r\n    }\r\n    saveTargetData(targetData) {\r\n        this.targets.set(targetData.target, targetData);\r\n        const targetId = targetData.targetId;\r\n        if (targetId > this.highestTargetId) {\r\n            this.targetIdGenerator = new TargetIdGenerator(targetId);\r\n            this.highestTargetId = targetId;\r\n        }\r\n        if (targetData.sequenceNumber > this.highestSequenceNumber) {\r\n            this.highestSequenceNumber = targetData.sequenceNumber;\r\n        }\r\n    }\r\n    addTargetData(transaction, targetData) {\r\n        this.saveTargetData(targetData);\r\n        this.targetCount += 1;\r\n        return PersistencePromise.resolve();\r\n    }\r\n    updateTargetData(transaction, targetData) {\r\n        this.saveTargetData(targetData);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTargetData(transaction, targetData) {\r\n        this.targets.delete(targetData.target);\r\n        this.references.removeReferencesForId(targetData.targetId);\r\n        this.targetCount -= 1;\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTargets(transaction, upperBound, activeTargetIds) {\r\n        let count = 0;\r\n        const removals = [];\r\n        this.targets.forEach((key, targetData) => {\r\n            if (targetData.sequenceNumber <= upperBound &&\r\n                activeTargetIds.get(targetData.targetId) === null) {\r\n                this.targets.delete(key);\r\n                removals.push(this.removeMatchingKeysForTargetId(transaction, targetData.targetId));\r\n                count++;\r\n            }\r\n        });\r\n        return PersistencePromise.waitFor(removals).next(() => count);\r\n    }\r\n    getTargetCount(transaction) {\r\n        return PersistencePromise.resolve(this.targetCount);\r\n    }\r\n    getTargetData(transaction, target) {\r\n        const targetData = this.targets.get(target) || null;\r\n        return PersistencePromise.resolve(targetData);\r\n    }\r\n    addMatchingKeys(txn, keys, targetId) {\r\n        this.references.addReferences(keys, targetId);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeMatchingKeys(txn, keys, targetId) {\r\n        this.references.removeReferences(keys, targetId);\r\n        const referenceDelegate = this.persistence.referenceDelegate;\r\n        const promises = [];\r\n        if (referenceDelegate) {\r\n            keys.forEach(key => {\r\n                promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));\r\n            });\r\n        }\r\n        return PersistencePromise.waitFor(promises);\r\n    }\r\n    removeMatchingKeysForTargetId(txn, targetId) {\r\n        this.references.removeReferencesForId(targetId);\r\n        return PersistencePromise.resolve();\r\n    }\r\n    getMatchingKeysForTargetId(txn, targetId) {\r\n        const matchingKeys = this.references.referencesForId(targetId);\r\n        return PersistencePromise.resolve(matchingKeys);\r\n    }\r\n    containsKey(txn, key) {\r\n        return PersistencePromise.resolve(this.references.containsKey(key));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$b = 'MemoryPersistence';\r\n/**\r\n * A memory-backed instance of Persistence. Data is stored only in RAM and\r\n * not persisted across sessions.\r\n */\r\nclass MemoryPersistence {\r\n    /**\r\n     * The constructor accepts a factory for creating a reference delegate. This\r\n     * allows both the delegate and this instance to have strong references to\r\n     * each other without having nullable fields that would then need to be\r\n     * checked or asserted on every access.\r\n     */\r\n    constructor(referenceDelegateFactory, serializer) {\r\n        this.mutationQueues = {};\r\n        this.overlays = {};\r\n        this.listenSequence = new ListenSequence(0);\r\n        this._started = false;\r\n        this._started = true;\r\n        this.referenceDelegate = referenceDelegateFactory(this);\r\n        this.targetCache = new MemoryTargetCache(this);\r\n        const sizer = (doc) => this.referenceDelegate.documentSize(doc);\r\n        this.indexManager = new MemoryIndexManager();\r\n        this.remoteDocumentCache = newMemoryRemoteDocumentCache(sizer);\r\n        this.serializer = new LocalSerializer(serializer);\r\n        this.bundleCache = new MemoryBundleCache(this.serializer);\r\n    }\r\n    start() {\r\n        return Promise.resolve();\r\n    }\r\n    shutdown() {\r\n        // No durable state to ensure is closed on shutdown.\r\n        this._started = false;\r\n        return Promise.resolve();\r\n    }\r\n    get started() {\r\n        return this._started;\r\n    }\r\n    setDatabaseDeletedListener() {\r\n        // No op.\r\n    }\r\n    setNetworkEnabled() {\r\n        // No op.\r\n    }\r\n    getIndexManager(user) {\r\n        // We do not currently support indices for memory persistence, so we can\r\n        // return the same shared instance of the memory index manager.\r\n        return this.indexManager;\r\n    }\r\n    getDocumentOverlayCache(user) {\r\n        let overlay = this.overlays[user.toKey()];\r\n        if (!overlay) {\r\n            overlay = new MemoryDocumentOverlayCache();\r\n            this.overlays[user.toKey()] = overlay;\r\n        }\r\n        return overlay;\r\n    }\r\n    getMutationQueue(user, indexManager) {\r\n        let queue = this.mutationQueues[user.toKey()];\r\n        if (!queue) {\r\n            queue = new MemoryMutationQueue(indexManager, this.referenceDelegate);\r\n            this.mutationQueues[user.toKey()] = queue;\r\n        }\r\n        return queue;\r\n    }\r\n    getTargetCache() {\r\n        return this.targetCache;\r\n    }\r\n    getRemoteDocumentCache() {\r\n        return this.remoteDocumentCache;\r\n    }\r\n    getBundleCache() {\r\n        return this.bundleCache;\r\n    }\r\n    runTransaction(action, mode, transactionOperation) {\r\n        logDebug(LOG_TAG$b, 'Starting transaction:', action);\r\n        const txn = new MemoryTransaction(this.listenSequence.next());\r\n        this.referenceDelegate.onTransactionStarted();\r\n        return transactionOperation(txn)\r\n            .next(result => {\r\n            return this.referenceDelegate\r\n                .onTransactionCommitted(txn)\r\n                .next(() => result);\r\n        })\r\n            .toPromise()\r\n            .then(result => {\r\n            txn.raiseOnCommittedEvent();\r\n            return result;\r\n        });\r\n    }\r\n    mutationQueuesContainKey(transaction, key) {\r\n        return PersistencePromise.or(Object.values(this.mutationQueues).map(queue => () => queue.containsKey(transaction, key)));\r\n    }\r\n}\r\n/**\r\n * Memory persistence is not actually transactional, but future implementations\r\n * may have transaction-scoped state.\r\n */\r\nclass MemoryTransaction extends PersistenceTransaction {\r\n    constructor(currentSequenceNumber) {\r\n        super();\r\n        this.currentSequenceNumber = currentSequenceNumber;\r\n    }\r\n}\r\nclass MemoryEagerDelegate {\r\n    constructor(persistence) {\r\n        this.persistence = persistence;\r\n        /** Tracks all documents that are active in Query views. */\r\n        this.localViewReferences = new ReferenceSet();\r\n        /** The list of documents that are potentially GCed after each transaction. */\r\n        this._orphanedDocuments = null;\r\n    }\r\n    static factory(persistence) {\r\n        return new MemoryEagerDelegate(persistence);\r\n    }\r\n    get orphanedDocuments() {\r\n        if (!this._orphanedDocuments) {\r\n            throw fail();\r\n        }\r\n        else {\r\n            return this._orphanedDocuments;\r\n        }\r\n    }\r\n    addReference(txn, targetId, key) {\r\n        this.localViewReferences.addReference(key, targetId);\r\n        this.orphanedDocuments.delete(key.toString());\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeReference(txn, targetId, key) {\r\n        this.localViewReferences.removeReference(key, targetId);\r\n        this.orphanedDocuments.add(key.toString());\r\n        return PersistencePromise.resolve();\r\n    }\r\n    markPotentiallyOrphaned(txn, key) {\r\n        this.orphanedDocuments.add(key.toString());\r\n        return PersistencePromise.resolve();\r\n    }\r\n    removeTarget(txn, targetData) {\r\n        const orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);\r\n        orphaned.forEach(key => this.orphanedDocuments.add(key.toString()));\r\n        const cache = this.persistence.getTargetCache();\r\n        return cache\r\n            .getMatchingKeysForTargetId(txn, targetData.targetId)\r\n            .next(keys => {\r\n            keys.forEach(key => this.orphanedDocuments.add(key.toString()));\r\n        })\r\n            .next(() => cache.removeTargetData(txn, targetData));\r\n    }\r\n    onTransactionStarted() {\r\n        this._orphanedDocuments = new Set();\r\n    }\r\n    onTransactionCommitted(txn) {\r\n        // Remove newly orphaned documents.\r\n        const cache = this.persistence.getRemoteDocumentCache();\r\n        const changeBuffer = cache.newChangeBuffer();\r\n        return PersistencePromise.forEach(this.orphanedDocuments, (path) => {\r\n            const key = DocumentKey.fromPath(path);\r\n            return this.isReferenced(txn, key).next(isReferenced => {\r\n                if (!isReferenced) {\r\n                    changeBuffer.removeEntry(key, SnapshotVersion.min());\r\n                }\r\n            });\r\n        }).next(() => {\r\n            this._orphanedDocuments = null;\r\n            return changeBuffer.apply(txn);\r\n        });\r\n    }\r\n    updateLimboDocument(txn, key) {\r\n        return this.isReferenced(txn, key).next(isReferenced => {\r\n            if (isReferenced) {\r\n                this.orphanedDocuments.delete(key.toString());\r\n            }\r\n            else {\r\n                this.orphanedDocuments.add(key.toString());\r\n            }\r\n        });\r\n    }\r\n    documentSize(doc) {\r\n        // For eager GC, we don't care about the document size, there are no size thresholds.\r\n        return 0;\r\n    }\r\n    isReferenced(txn, key) {\r\n        return PersistencePromise.or([\r\n            () => PersistencePromise.resolve(this.localViewReferences.containsKey(key)),\r\n            () => this.persistence.getTargetCache().containsKey(txn, key),\r\n            () => this.persistence.mutationQueuesContainKey(txn, key)\r\n        ]);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A query engine that takes advantage of the target document mapping in the\r\n * QueryCache. Query execution is optimized by only reading the documents that\r\n * previously matched a query plus any documents that were edited after the\r\n * query was last listened to.\r\n *\r\n * There are some cases when this optimization is not guaranteed to produce\r\n * the same results as full collection scans. In these cases, query\r\n * processing falls back to full scans. These cases are:\r\n *\r\n * - Limit queries where a document that matched the query previously no longer\r\n *   matches the query.\r\n *\r\n * - Limit queries where a document edit may cause the document to sort below\r\n *   another document that is in the local cache.\r\n *\r\n * - Queries that have never been CURRENT or free of limbo documents.\r\n */\r\nclass QueryEngine {\r\n    /** Sets the document view to query against. */\r\n    setLocalDocumentsView(localDocuments) {\r\n        this.localDocumentsView = localDocuments;\r\n    }\r\n    /** Returns all local documents matching the specified query. */\r\n    getDocumentsMatchingQuery(transaction, query, lastLimboFreeSnapshotVersion, remoteKeys) {\r\n        // Queries that match all documents don't benefit from using\r\n        // key-based lookups. It is more efficient to scan all documents in a\r\n        // collection, rather than to perform individual lookups.\r\n        if (matchesAllDocuments(query)) {\r\n            return this.executeFullCollectionScan(transaction, query);\r\n        }\r\n        // Queries that have never seen a snapshot without limbo free documents\r\n        // should also be run as a full collection scan.\r\n        if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {\r\n            return this.executeFullCollectionScan(transaction, query);\r\n        }\r\n        return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(documents => {\r\n            const previousResults = this.applyQuery(query, documents);\r\n            if ((hasLimitToFirst(query) || hasLimitToLast(query)) &&\r\n                this.needsRefill(query.limitType, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {\r\n                return this.executeFullCollectionScan(transaction, query);\r\n            }\r\n            if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n                logDebug('QueryEngine', 'Re-using previous result from %s to execute query: %s', lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query));\r\n            }\r\n            // Retrieve all results for documents that were updated since the last\r\n            // limbo-document free remote snapshot.\r\n            return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query, lastLimboFreeSnapshotVersion).next(updatedResults => {\r\n                // We merge `previousResults` into `updateResults`, since\r\n                // `updateResults` is already a DocumentMap. If a document is\r\n                // contained in both lists, then its contents are the same.\r\n                previousResults.forEach(doc => {\r\n                    updatedResults = updatedResults.insert(doc.key, doc);\r\n                });\r\n                return updatedResults;\r\n            });\r\n        });\r\n    }\r\n    /** Applies the query filter and sorting to the provided documents.  */\r\n    applyQuery(query, documents) {\r\n        // Sort the documents and re-apply the query filter since previously\r\n        // matching documents do not necessarily still match the query.\r\n        let queryResults = new SortedSet(newQueryComparator(query));\r\n        documents.forEach((_, maybeDoc) => {\r\n            if (queryMatches(query, maybeDoc)) {\r\n                queryResults = queryResults.add(maybeDoc);\r\n            }\r\n        });\r\n        return queryResults;\r\n    }\r\n    /**\r\n     * Determines if a limit query needs to be refilled from cache, making it\r\n     * ineligible for index-free execution.\r\n     *\r\n     * @param sortedPreviousResults - The documents that matched the query when it\r\n     * was last synchronized, sorted by the query's comparator.\r\n     * @param remoteKeys - The document keys that matched the query at the last\r\n     * snapshot.\r\n     * @param limboFreeSnapshotVersion - The version of the snapshot when the\r\n     * query was last synchronized.\r\n     */\r\n    needsRefill(limitType, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {\r\n        // The query needs to be refilled if a previously matching document no\r\n        // longer matches.\r\n        if (remoteKeys.size !== sortedPreviousResults.size) {\r\n            return true;\r\n        }\r\n        // Limit queries are not eligible for index-free query execution if there is\r\n        // a potential that an older document from cache now sorts before a document\r\n        // that was previously part of the limit. This, however, can only happen if\r\n        // the document at the edge of the limit goes out of limit.\r\n        // If a document that is not the limit boundary sorts differently,\r\n        // the boundary of the limit itself did not change and documents from cache\r\n        // will continue to be \"rejected\" by this boundary. Therefore, we can ignore\r\n        // any modifications that don't affect the last document.\r\n        const docAtLimitEdge = limitType === \"F\" /* First */\r\n            ? sortedPreviousResults.last()\r\n            : sortedPreviousResults.first();\r\n        if (!docAtLimitEdge) {\r\n            // We don't need to refill the query if there were already no documents.\r\n            return false;\r\n        }\r\n        return (docAtLimitEdge.hasPendingWrites ||\r\n            docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0);\r\n    }\r\n    executeFullCollectionScan(transaction, query) {\r\n        if (getLogLevel() <= _firebase_logger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.DEBUG) {\r\n            logDebug('QueryEngine', 'Using full collection scan to execute query:', stringifyQuery(query));\r\n        }\r\n        return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query, SnapshotVersion.min());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// The format of the LocalStorage key that stores the client state is:\r\n//     firestore_clients_<persistence_prefix>_<instance_key>\r\nconst CLIENT_STATE_KEY_PREFIX = 'firestore_clients';\r\n/** Assembles the key for a client state in WebStorage */\r\nfunction createWebStorageClientStateKey(persistenceKey, clientId) {\r\n    return `${CLIENT_STATE_KEY_PREFIX}_${persistenceKey}_${clientId}`;\r\n}\r\n// The format of the WebStorage key that stores the mutation state is:\r\n//     firestore_mutations_<persistence_prefix>_<batch_id>\r\n//     (for unauthenticated users)\r\n// or: firestore_mutations_<persistence_prefix>_<batch_id>_<user_uid>\r\n//\r\n// 'user_uid' is last to avoid needing to escape '_' characters that it might\r\n// contain.\r\nconst MUTATION_BATCH_KEY_PREFIX = 'firestore_mutations';\r\n/** Assembles the key for a mutation batch in WebStorage */\r\nfunction createWebStorageMutationBatchKey(persistenceKey, user, batchId) {\r\n    let mutationKey = `${MUTATION_BATCH_KEY_PREFIX}_${persistenceKey}_${batchId}`;\r\n    if (user.isAuthenticated()) {\r\n        mutationKey += `_${user.uid}`;\r\n    }\r\n    return mutationKey;\r\n}\r\n// The format of the WebStorage key that stores a query target's metadata is:\r\n//     firestore_targets_<persistence_prefix>_<target_id>\r\nconst QUERY_TARGET_KEY_PREFIX = 'firestore_targets';\r\n/** Assembles the key for a query state in WebStorage */\r\nfunction createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {\r\n    return `${QUERY_TARGET_KEY_PREFIX}_${persistenceKey}_${targetId}`;\r\n}\r\n// The WebStorage prefix that stores the primary tab's online state. The\r\n// format of the key is:\r\n//     firestore_online_state_<persistence_prefix>\r\nconst ONLINE_STATE_KEY_PREFIX = 'firestore_online_state';\r\n/** Assembles the key for the online state of the primary tab. */\r\nfunction createWebStorageOnlineStateKey(persistenceKey) {\r\n    return `${ONLINE_STATE_KEY_PREFIX}_${persistenceKey}`;\r\n}\r\n// The WebStorage prefix that plays as a event to indicate the remote documents\r\n// might have changed due to some secondary tabs loading a bundle.\r\n// format of the key is:\r\n//     firestore_bundle_loaded_<persistenceKey>\r\nconst BUNDLE_LOADED_KEY_PREFIX = 'firestore_bundle_loaded';\r\nfunction createBundleLoadedKey(persistenceKey) {\r\n    return `${BUNDLE_LOADED_KEY_PREFIX}_${persistenceKey}`;\r\n}\r\n// The WebStorage key prefix for the key that stores the last sequence number allocated. The key\r\n// looks like 'firestore_sequence_number_<persistence_prefix>'.\r\nconst SEQUENCE_NUMBER_KEY_PREFIX = 'firestore_sequence_number';\r\n/** Assembles the key for the current sequence number. */\r\nfunction createWebStorageSequenceNumberKey(persistenceKey) {\r\n    return `${SEQUENCE_NUMBER_KEY_PREFIX}_${persistenceKey}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$a = 'SharedClientState';\r\n/**\r\n * Holds the state of a mutation batch, including its user ID, batch ID and\r\n * whether the batch is 'pending', 'acknowledged' or 'rejected'.\r\n */\r\n// Visible for testing\r\nclass MutationMetadata {\r\n    constructor(user, batchId, state, error) {\r\n        this.user = user;\r\n        this.batchId = batchId;\r\n        this.state = state;\r\n        this.error = error;\r\n    }\r\n    /**\r\n     * Parses a MutationMetadata from its JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(user, batchId, value) {\r\n        const mutationBatch = JSON.parse(value);\r\n        let validData = typeof mutationBatch === 'object' &&\r\n            ['pending', 'acknowledged', 'rejected'].indexOf(mutationBatch.state) !==\r\n                -1 &&\r\n            (mutationBatch.error === undefined ||\r\n                typeof mutationBatch.error === 'object');\r\n        let firestoreError = undefined;\r\n        if (validData && mutationBatch.error) {\r\n            validData =\r\n                typeof mutationBatch.error.message === 'string' &&\r\n                    typeof mutationBatch.error.code === 'string';\r\n            if (validData) {\r\n                firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);\r\n            }\r\n        }\r\n        if (validData) {\r\n            return new MutationMetadata(user, batchId, mutationBatch.state, firestoreError);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse mutation state for ID '${batchId}': ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n    toWebStorageJSON() {\r\n        const batchMetadata = {\r\n            state: this.state,\r\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\r\n        };\r\n        if (this.error) {\r\n            batchMetadata.error = {\r\n                code: this.error.code,\r\n                message: this.error.message\r\n            };\r\n        }\r\n        return JSON.stringify(batchMetadata);\r\n    }\r\n}\r\n/**\r\n * Holds the state of a query target, including its target ID and whether the\r\n * target is 'not-current', 'current' or 'rejected'.\r\n */\r\n// Visible for testing\r\nclass QueryTargetMetadata {\r\n    constructor(targetId, state, error) {\r\n        this.targetId = targetId;\r\n        this.state = state;\r\n        this.error = error;\r\n    }\r\n    /**\r\n     * Parses a QueryTargetMetadata from its JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(targetId, value) {\r\n        const targetState = JSON.parse(value);\r\n        let validData = typeof targetState === 'object' &&\r\n            ['not-current', 'current', 'rejected'].indexOf(targetState.state) !==\r\n                -1 &&\r\n            (targetState.error === undefined ||\r\n                typeof targetState.error === 'object');\r\n        let firestoreError = undefined;\r\n        if (validData && targetState.error) {\r\n            validData =\r\n                typeof targetState.error.message === 'string' &&\r\n                    typeof targetState.error.code === 'string';\r\n            if (validData) {\r\n                firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);\r\n            }\r\n        }\r\n        if (validData) {\r\n            return new QueryTargetMetadata(targetId, targetState.state, firestoreError);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse target state for ID '${targetId}': ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n    toWebStorageJSON() {\r\n        const targetState = {\r\n            state: this.state,\r\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\r\n        };\r\n        if (this.error) {\r\n            targetState.error = {\r\n                code: this.error.code,\r\n                message: this.error.message\r\n            };\r\n        }\r\n        return JSON.stringify(targetState);\r\n    }\r\n}\r\n/**\r\n * This class represents the immutable ClientState for a client read from\r\n * WebStorage, containing the list of active query targets.\r\n */\r\nclass RemoteClientState {\r\n    constructor(clientId, activeTargetIds) {\r\n        this.clientId = clientId;\r\n        this.activeTargetIds = activeTargetIds;\r\n    }\r\n    /**\r\n     * Parses a RemoteClientState from the JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(clientId, value) {\r\n        const clientState = JSON.parse(value);\r\n        let validData = typeof clientState === 'object' &&\r\n            clientState.activeTargetIds instanceof Array;\r\n        let activeTargetIdsSet = targetIdSet();\r\n        for (let i = 0; validData && i < clientState.activeTargetIds.length; ++i) {\r\n            validData = isSafeInteger(clientState.activeTargetIds[i]);\r\n            activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);\r\n        }\r\n        if (validData) {\r\n            return new RemoteClientState(clientId, activeTargetIdsSet);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse client data for instance '${clientId}': ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * This class represents the online state for all clients participating in\r\n * multi-tab. The online state is only written to by the primary client, and\r\n * used in secondary clients to update their query views.\r\n */\r\nclass SharedOnlineState {\r\n    constructor(clientId, onlineState) {\r\n        this.clientId = clientId;\r\n        this.onlineState = onlineState;\r\n    }\r\n    /**\r\n     * Parses a SharedOnlineState from its JSON representation in WebStorage.\r\n     * Logs a warning and returns null if the format of the data is not valid.\r\n     */\r\n    static fromWebStorageEntry(value) {\r\n        const onlineState = JSON.parse(value);\r\n        const validData = typeof onlineState === 'object' &&\r\n            ['Unknown', 'Online', 'Offline'].indexOf(onlineState.onlineState) !==\r\n                -1 &&\r\n            typeof onlineState.clientId === 'string';\r\n        if (validData) {\r\n            return new SharedOnlineState(onlineState.clientId, onlineState.onlineState);\r\n        }\r\n        else {\r\n            logError(LOG_TAG$a, `Failed to parse online state: ${value}`);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Metadata state of the local client. Unlike `RemoteClientState`, this class is\r\n * mutable and keeps track of all pending mutations, which allows us to\r\n * update the range of pending mutation batch IDs as new mutations are added or\r\n * removed.\r\n *\r\n * The data in `LocalClientState` is not read from WebStorage and instead\r\n * updated via its instance methods. The updated state can be serialized via\r\n * `toWebStorageJSON()`.\r\n */\r\n// Visible for testing.\r\nclass LocalClientState {\r\n    constructor() {\r\n        this.activeTargetIds = targetIdSet();\r\n    }\r\n    addQueryTarget(targetId) {\r\n        this.activeTargetIds = this.activeTargetIds.add(targetId);\r\n    }\r\n    removeQueryTarget(targetId) {\r\n        this.activeTargetIds = this.activeTargetIds.delete(targetId);\r\n    }\r\n    /**\r\n     * Converts this entry into a JSON-encoded format we can use for WebStorage.\r\n     * Does not encode `clientId` as it is part of the key in WebStorage.\r\n     */\r\n    toWebStorageJSON() {\r\n        const data = {\r\n            activeTargetIds: this.activeTargetIds.toArray(),\r\n            updateTimeMs: Date.now() // Modify the existing value to trigger update.\r\n        };\r\n        return JSON.stringify(data);\r\n    }\r\n}\r\n/**\r\n * `WebStorageSharedClientState` uses WebStorage (window.localStorage) as the\r\n * backing store for the SharedClientState. It keeps track of all active\r\n * clients and supports modifications of the local client's data.\r\n */\r\nclass WebStorageSharedClientState {\r\n    constructor(window, queue, persistenceKey, localClientId, initialUser) {\r\n        this.window = window;\r\n        this.queue = queue;\r\n        this.persistenceKey = persistenceKey;\r\n        this.localClientId = localClientId;\r\n        this.syncEngine = null;\r\n        this.onlineStateHandler = null;\r\n        this.sequenceNumberHandler = null;\r\n        this.storageListener = this.handleWebStorageEvent.bind(this);\r\n        this.activeClients = new SortedMap(primitiveComparator);\r\n        this.started = false;\r\n        /**\r\n         * Captures WebStorage events that occur before `start()` is called. These\r\n         * events are replayed once `WebStorageSharedClientState` is started.\r\n         */\r\n        this.earlyEvents = [];\r\n        // Escape the special characters mentioned here:\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\r\n        const escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n        this.storage = this.window.localStorage;\r\n        this.currentUser = initialUser;\r\n        this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);\r\n        this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);\r\n        this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());\r\n        this.clientStateKeyRe = new RegExp(`^${CLIENT_STATE_KEY_PREFIX}_${escapedPersistenceKey}_([^_]*)$`);\r\n        this.mutationBatchKeyRe = new RegExp(`^${MUTATION_BATCH_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)(?:_(.*))?$`);\r\n        this.queryTargetKeyRe = new RegExp(`^${QUERY_TARGET_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)$`);\r\n        this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);\r\n        this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);\r\n        // Rather than adding the storage observer during start(), we add the\r\n        // storage observer during initialization. This ensures that we collect\r\n        // events before other components populate their initial state (during their\r\n        // respective start() calls). Otherwise, we might for example miss a\r\n        // mutation that is added after LocalStore's start() processed the existing\r\n        // mutations but before we observe WebStorage events.\r\n        this.window.addEventListener('storage', this.storageListener);\r\n    }\r\n    /** Returns 'true' if WebStorage is available in the current environment. */\r\n    static isAvailable(window) {\r\n        return !!(window && window.localStorage);\r\n    }\r\n    async start() {\r\n        // Retrieve the list of existing clients to backfill the data in\r\n        // SharedClientState.\r\n        const existingClients = await this.syncEngine.getActiveClients();\r\n        for (const clientId of existingClients) {\r\n            if (clientId === this.localClientId) {\r\n                continue;\r\n            }\r\n            const storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));\r\n            if (storageItem) {\r\n                const clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);\r\n                if (clientState) {\r\n                    this.activeClients = this.activeClients.insert(clientState.clientId, clientState);\r\n                }\r\n            }\r\n        }\r\n        this.persistClientState();\r\n        // Check if there is an existing online state and call the callback handler\r\n        // if applicable.\r\n        const onlineStateJSON = this.storage.getItem(this.onlineStateKey);\r\n        if (onlineStateJSON) {\r\n            const onlineState = this.fromWebStorageOnlineState(onlineStateJSON);\r\n            if (onlineState) {\r\n                this.handleOnlineStateEvent(onlineState);\r\n            }\r\n        }\r\n        for (const event of this.earlyEvents) {\r\n            this.handleWebStorageEvent(event);\r\n        }\r\n        this.earlyEvents = [];\r\n        // Register a window unload hook to remove the client metadata entry from\r\n        // WebStorage even if `shutdown()` was not called.\r\n        this.window.addEventListener('pagehide', () => this.shutdown());\r\n        this.started = true;\r\n    }\r\n    writeSequenceNumber(sequenceNumber) {\r\n        this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));\r\n    }\r\n    getAllActiveQueryTargets() {\r\n        return this.extractActiveQueryTargets(this.activeClients);\r\n    }\r\n    isActiveQueryTarget(targetId) {\r\n        let found = false;\r\n        this.activeClients.forEach((key, value) => {\r\n            if (value.activeTargetIds.has(targetId)) {\r\n                found = true;\r\n            }\r\n        });\r\n        return found;\r\n    }\r\n    addPendingMutation(batchId) {\r\n        this.persistMutationState(batchId, 'pending');\r\n    }\r\n    updateMutationState(batchId, state, error) {\r\n        this.persistMutationState(batchId, state, error);\r\n        // Once a final mutation result is observed by other clients, they no longer\r\n        // access the mutation's metadata entry. Since WebStorage replays events\r\n        // in order, it is safe to delete the entry right after updating it.\r\n        this.removeMutationState(batchId);\r\n    }\r\n    addLocalQueryTarget(targetId) {\r\n        let queryState = 'not-current';\r\n        // Lookup an existing query state if the target ID was already registered\r\n        // by another tab\r\n        if (this.isActiveQueryTarget(targetId)) {\r\n            const storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\r\n            if (storageItem) {\r\n                const metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);\r\n                if (metadata) {\r\n                    queryState = metadata.state;\r\n                }\r\n            }\r\n        }\r\n        this.localClientState.addQueryTarget(targetId);\r\n        this.persistClientState();\r\n        return queryState;\r\n    }\r\n    removeLocalQueryTarget(targetId) {\r\n        this.localClientState.removeQueryTarget(targetId);\r\n        this.persistClientState();\r\n    }\r\n    isLocalQueryTarget(targetId) {\r\n        return this.localClientState.activeTargetIds.has(targetId);\r\n    }\r\n    clearQueryState(targetId) {\r\n        this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));\r\n    }\r\n    updateQueryState(targetId, state, error) {\r\n        this.persistQueryTargetState(targetId, state, error);\r\n    }\r\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\r\n        removedBatchIds.forEach(batchId => {\r\n            this.removeMutationState(batchId);\r\n        });\r\n        this.currentUser = user;\r\n        addedBatchIds.forEach(batchId => {\r\n            this.addPendingMutation(batchId);\r\n        });\r\n    }\r\n    setOnlineState(onlineState) {\r\n        this.persistOnlineState(onlineState);\r\n    }\r\n    notifyBundleLoaded() {\r\n        this.persistBundleLoadedState();\r\n    }\r\n    shutdown() {\r\n        if (this.started) {\r\n            this.window.removeEventListener('storage', this.storageListener);\r\n            this.removeItem(this.localClientStorageKey);\r\n            this.started = false;\r\n        }\r\n    }\r\n    getItem(key) {\r\n        const value = this.storage.getItem(key);\r\n        logDebug(LOG_TAG$a, 'READ', key, value);\r\n        return value;\r\n    }\r\n    setItem(key, value) {\r\n        logDebug(LOG_TAG$a, 'SET', key, value);\r\n        this.storage.setItem(key, value);\r\n    }\r\n    removeItem(key) {\r\n        logDebug(LOG_TAG$a, 'REMOVE', key);\r\n        this.storage.removeItem(key);\r\n    }\r\n    handleWebStorageEvent(event) {\r\n        // Note: The function is typed to take Event to be interface-compatible with\r\n        // `Window.addEventListener`.\r\n        const storageEvent = event;\r\n        if (storageEvent.storageArea === this.storage) {\r\n            logDebug(LOG_TAG$a, 'EVENT', storageEvent.key, storageEvent.newValue);\r\n            if (storageEvent.key === this.localClientStorageKey) {\r\n                logError('Received WebStorage notification for local change. Another client might have ' +\r\n                    'garbage-collected our state');\r\n                return;\r\n            }\r\n            this.queue.enqueueRetryable(async () => {\r\n                if (!this.started) {\r\n                    this.earlyEvents.push(storageEvent);\r\n                    return;\r\n                }\r\n                if (storageEvent.key === null) {\r\n                    return;\r\n                }\r\n                if (this.clientStateKeyRe.test(storageEvent.key)) {\r\n                    if (storageEvent.newValue != null) {\r\n                        const clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);\r\n                        if (clientState) {\r\n                            return this.handleClientStateEvent(clientState.clientId, clientState);\r\n                        }\r\n                    }\r\n                    else {\r\n                        const clientId = this.fromWebStorageClientStateKey(storageEvent.key);\r\n                        return this.handleClientStateEvent(clientId, null);\r\n                    }\r\n                }\r\n                else if (this.mutationBatchKeyRe.test(storageEvent.key)) {\r\n                    if (storageEvent.newValue !== null) {\r\n                        const mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);\r\n                        if (mutationMetadata) {\r\n                            return this.handleMutationBatchEvent(mutationMetadata);\r\n                        }\r\n                    }\r\n                }\r\n                else if (this.queryTargetKeyRe.test(storageEvent.key)) {\r\n                    if (storageEvent.newValue !== null) {\r\n                        const queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);\r\n                        if (queryTargetMetadata) {\r\n                            return this.handleQueryTargetEvent(queryTargetMetadata);\r\n                        }\r\n                    }\r\n                }\r\n                else if (storageEvent.key === this.onlineStateKey) {\r\n                    if (storageEvent.newValue !== null) {\r\n                        const onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);\r\n                        if (onlineState) {\r\n                            return this.handleOnlineStateEvent(onlineState);\r\n                        }\r\n                    }\r\n                }\r\n                else if (storageEvent.key === this.sequenceNumberKey) {\r\n                    const sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);\r\n                    if (sequenceNumber !== ListenSequence.INVALID) {\r\n                        this.sequenceNumberHandler(sequenceNumber);\r\n                    }\r\n                }\r\n                else if (storageEvent.key === this.bundleLoadedKey) {\r\n                    return this.syncEngine.synchronizeWithChangedDocuments();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    get localClientState() {\r\n        return this.activeClients.get(this.localClientId);\r\n    }\r\n    persistClientState() {\r\n        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\r\n    }\r\n    persistMutationState(batchId, state, error) {\r\n        const mutationState = new MutationMetadata(this.currentUser, batchId, state, error);\r\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\r\n        this.setItem(mutationKey, mutationState.toWebStorageJSON());\r\n    }\r\n    removeMutationState(batchId) {\r\n        const mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);\r\n        this.removeItem(mutationKey);\r\n    }\r\n    persistOnlineState(onlineState) {\r\n        const entry = {\r\n            clientId: this.localClientId,\r\n            onlineState\r\n        };\r\n        this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));\r\n    }\r\n    persistQueryTargetState(targetId, state, error) {\r\n        const targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);\r\n        const targetMetadata = new QueryTargetMetadata(targetId, state, error);\r\n        this.setItem(targetKey, targetMetadata.toWebStorageJSON());\r\n    }\r\n    persistBundleLoadedState() {\r\n        this.setItem(this.bundleLoadedKey, 'value-not-used');\r\n    }\r\n    /**\r\n     * Parses a client state key in WebStorage. Returns null if the key does not\r\n     * match the expected key format.\r\n     */\r\n    fromWebStorageClientStateKey(key) {\r\n        const match = this.clientStateKeyRe.exec(key);\r\n        return match ? match[1] : null;\r\n    }\r\n    /**\r\n     * Parses a client state in WebStorage. Returns 'null' if the value could not\r\n     * be parsed.\r\n     */\r\n    fromWebStorageClientState(key, value) {\r\n        const clientId = this.fromWebStorageClientStateKey(key);\r\n        return RemoteClientState.fromWebStorageEntry(clientId, value);\r\n    }\r\n    /**\r\n     * Parses a mutation batch state in WebStorage. Returns 'null' if the value\r\n     * could not be parsed.\r\n     */\r\n    fromWebStorageMutationMetadata(key, value) {\r\n        const match = this.mutationBatchKeyRe.exec(key);\r\n        const batchId = Number(match[1]);\r\n        const userId = match[2] !== undefined ? match[2] : null;\r\n        return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);\r\n    }\r\n    /**\r\n     * Parses a query target state from WebStorage. Returns 'null' if the value\r\n     * could not be parsed.\r\n     */\r\n    fromWebStorageQueryTargetMetadata(key, value) {\r\n        const match = this.queryTargetKeyRe.exec(key);\r\n        const targetId = Number(match[1]);\r\n        return QueryTargetMetadata.fromWebStorageEntry(targetId, value);\r\n    }\r\n    /**\r\n     * Parses an online state from WebStorage. Returns 'null' if the value\r\n     * could not be parsed.\r\n     */\r\n    fromWebStorageOnlineState(value) {\r\n        return SharedOnlineState.fromWebStorageEntry(value);\r\n    }\r\n    async handleMutationBatchEvent(mutationBatch) {\r\n        if (mutationBatch.user.uid !== this.currentUser.uid) {\r\n            logDebug(LOG_TAG$a, `Ignoring mutation for non-active user ${mutationBatch.user.uid}`);\r\n            return;\r\n        }\r\n        return this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error);\r\n    }\r\n    handleQueryTargetEvent(targetMetadata) {\r\n        return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);\r\n    }\r\n    handleClientStateEvent(clientId, clientState) {\r\n        const updatedClients = clientState\r\n            ? this.activeClients.insert(clientId, clientState)\r\n            : this.activeClients.remove(clientId);\r\n        const existingTargets = this.extractActiveQueryTargets(this.activeClients);\r\n        const newTargets = this.extractActiveQueryTargets(updatedClients);\r\n        const addedTargets = [];\r\n        const removedTargets = [];\r\n        newTargets.forEach(targetId => {\r\n            if (!existingTargets.has(targetId)) {\r\n                addedTargets.push(targetId);\r\n            }\r\n        });\r\n        existingTargets.forEach(targetId => {\r\n            if (!newTargets.has(targetId)) {\r\n                removedTargets.push(targetId);\r\n            }\r\n        });\r\n        return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(() => {\r\n            this.activeClients = updatedClients;\r\n        });\r\n    }\r\n    handleOnlineStateEvent(onlineState) {\r\n        // We check whether the client that wrote this online state is still active\r\n        // by comparing its client ID to the list of clients kept active in\r\n        // IndexedDb. If a client does not update their IndexedDb client state\r\n        // within 5 seconds, it is considered inactive and we don't emit an online\r\n        // state event.\r\n        if (this.activeClients.get(onlineState.clientId)) {\r\n            this.onlineStateHandler(onlineState.onlineState);\r\n        }\r\n    }\r\n    extractActiveQueryTargets(clients) {\r\n        let activeTargets = targetIdSet();\r\n        clients.forEach((kev, value) => {\r\n            activeTargets = activeTargets.unionWith(value.activeTargetIds);\r\n        });\r\n        return activeTargets;\r\n    }\r\n}\r\nfunction fromWebStorageSequenceNumber(seqString) {\r\n    let sequenceNumber = ListenSequence.INVALID;\r\n    if (seqString != null) {\r\n        try {\r\n            const parsed = JSON.parse(seqString);\r\n            hardAssert(typeof parsed === 'number');\r\n            sequenceNumber = parsed;\r\n        }\r\n        catch (e) {\r\n            logError(LOG_TAG$a, 'Failed to read sequence number from WebStorage', e);\r\n        }\r\n    }\r\n    return sequenceNumber;\r\n}\r\n/**\r\n * `MemorySharedClientState` is a simple implementation of SharedClientState for\r\n * clients using memory persistence. The state in this class remains fully\r\n * isolated and no synchronization is performed.\r\n */\r\nclass MemorySharedClientState {\r\n    constructor() {\r\n        this.localState = new LocalClientState();\r\n        this.queryState = {};\r\n        this.onlineStateHandler = null;\r\n        this.sequenceNumberHandler = null;\r\n    }\r\n    addPendingMutation(batchId) {\r\n        // No op.\r\n    }\r\n    updateMutationState(batchId, state, error) {\r\n        // No op.\r\n    }\r\n    addLocalQueryTarget(targetId) {\r\n        this.localState.addQueryTarget(targetId);\r\n        return this.queryState[targetId] || 'not-current';\r\n    }\r\n    updateQueryState(targetId, state, error) {\r\n        this.queryState[targetId] = state;\r\n    }\r\n    removeLocalQueryTarget(targetId) {\r\n        this.localState.removeQueryTarget(targetId);\r\n    }\r\n    isLocalQueryTarget(targetId) {\r\n        return this.localState.activeTargetIds.has(targetId);\r\n    }\r\n    clearQueryState(targetId) {\r\n        delete this.queryState[targetId];\r\n    }\r\n    getAllActiveQueryTargets() {\r\n        return this.localState.activeTargetIds;\r\n    }\r\n    isActiveQueryTarget(targetId) {\r\n        return this.localState.activeTargetIds.has(targetId);\r\n    }\r\n    start() {\r\n        this.localState = new LocalClientState();\r\n        return Promise.resolve();\r\n    }\r\n    handleUserChange(user, removedBatchIds, addedBatchIds) {\r\n        // No op.\r\n    }\r\n    setOnlineState(onlineState) {\r\n        // No op.\r\n    }\r\n    shutdown() { }\r\n    writeSequenceNumber(sequenceNumber) { }\r\n    notifyBundleLoaded() {\r\n        // No op.\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass NoopConnectivityMonitor {\r\n    addCallback(callback) {\r\n        // No-op.\r\n    }\r\n    shutdown() {\r\n        // No-op.\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides a simple helper class that implements the Stream interface to\r\n * bridge to other implementations that are streams but do not implement the\r\n * interface. The stream callbacks are invoked with the callOn... methods.\r\n */\r\nclass StreamBridge {\r\n    constructor(args) {\r\n        this.sendFn = args.sendFn;\r\n        this.closeFn = args.closeFn;\r\n    }\r\n    onOpen(callback) {\r\n        this.wrappedOnOpen = callback;\r\n    }\r\n    onClose(callback) {\r\n        this.wrappedOnClose = callback;\r\n    }\r\n    onMessage(callback) {\r\n        this.wrappedOnMessage = callback;\r\n    }\r\n    close() {\r\n        this.closeFn();\r\n    }\r\n    send(msg) {\r\n        this.sendFn(msg);\r\n    }\r\n    callOnOpen() {\r\n        this.wrappedOnOpen();\r\n    }\r\n    callOnClose(err) {\r\n        this.wrappedOnClose(err);\r\n    }\r\n    callOnMessage(msg) {\r\n        this.wrappedOnMessage(msg);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*\r\n * Utilities for dealing with node.js-style APIs. See nodePromise for more\r\n * details.\r\n */\r\n/**\r\n * Creates a node-style callback that resolves or rejects a new Promise. The\r\n * callback is passed to the given action which can then use the callback as\r\n * a parameter to a node-style function.\r\n *\r\n * The intent is to directly bridge a node-style function (which takes a\r\n * callback) into a Promise without manually converting between the node-style\r\n * callback and the promise at each call.\r\n *\r\n * In effect it allows you to convert:\r\n *\r\n * @example\r\n * new Promise((resolve: (value?: fs.Stats) => void,\r\n *              reject: (error?: any) => void) => {\r\n *   fs.stat(path, (error?: any, stat?: fs.Stats) => {\r\n *     if (error) {\r\n *       reject(error);\r\n *     } else {\r\n *       resolve(stat);\r\n *     }\r\n *   });\r\n * });\r\n *\r\n * Into\r\n * @example\r\n * nodePromise((callback: NodeCallback<fs.Stats>) => {\r\n *   fs.stat(path, callback);\r\n * });\r\n *\r\n * @param action - a function that takes a node-style callback as an argument\r\n *     and then uses that callback to invoke some node-style API.\r\n * @returns a new Promise which will be rejected if the callback is given the\r\n *     first Error parameter or will resolve to the value given otherwise.\r\n */\r\nfunction nodePromise(action) {\r\n    return new Promise((resolve, reject) => {\r\n        action((error, value) => {\r\n            if (error) {\r\n                reject(error);\r\n            }\r\n            else {\r\n                resolve(value);\r\n            }\r\n        });\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO: Fetch runtime version from grpc-js/package.json instead\r\n// when there's a cleaner way to dynamic require JSON in both Node ESM and CJS\r\nconst grpcVersion = '1.3.7';\r\nconst LOG_TAG$9 = 'Connection';\r\nconst X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION} grpc/${grpcVersion}`;\r\nfunction createMetadata(databasePath, authToken, appCheckToken, appId) {\r\n    hardAssert(authToken === null || authToken.type === 'OAuth');\r\n    const metadata = new _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__.Metadata();\r\n    if (authToken) {\r\n        authToken.headers.forEach((value, key) => metadata.set(key, value));\r\n    }\r\n    if (appCheckToken) {\r\n        appCheckToken.headers.forEach((value, key) => metadata.set(key, value));\r\n    }\r\n    if (appId) {\r\n        metadata.set('X-Firebase-GMPID', appId);\r\n    }\r\n    metadata.set('X-Goog-Api-Client', X_GOOG_API_CLIENT_VALUE);\r\n    // This header is used to improve routing and project isolation by the\r\n    // backend.\r\n    metadata.set('Google-Cloud-Resource-Prefix', databasePath);\r\n    return metadata;\r\n}\r\n/**\r\n * A Connection implemented by GRPC-Node.\r\n */\r\nclass GrpcConnection {\r\n    constructor(protos, databaseInfo) {\r\n        this.databaseInfo = databaseInfo;\r\n        // We cache stubs for the most-recently-used token.\r\n        this.cachedStub = null;\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        this.firestore = protos['google']['firestore']['v1'];\r\n        this.databasePath = `projects/${databaseInfo.databaseId.projectId}/databases/${databaseInfo.databaseId.database}`;\r\n    }\r\n    ensureActiveStub() {\r\n        if (!this.cachedStub) {\r\n            logDebug(LOG_TAG$9, 'Creating Firestore stub.');\r\n            const credentials = this.databaseInfo.ssl\r\n                ? _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__.credentials.createSsl()\r\n                : _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__.credentials.createInsecure();\r\n            this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials);\r\n        }\r\n        return this.cachedStub;\r\n    }\r\n    invokeRPC(rpcName, path, request, authToken, appCheckToken) {\r\n        const stub = this.ensureActiveStub();\r\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\r\n        const jsonRequest = Object.assign({ database: this.databasePath }, request);\r\n        return nodePromise((callback) => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' invoked with request:`, request);\r\n            return stub[rpcName](jsonRequest, metadata, (grpcError, value) => {\r\n                if (grpcError) {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' failed with error:`, grpcError);\r\n                    callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$9, `RPC '${rpcName}' completed with response:`, value);\r\n                    callback(undefined, value);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken) {\r\n        const results = [];\r\n        const responseDeferred = new Deferred();\r\n        logDebug(LOG_TAG$9, `RPC '${rpcName}' invoked (streaming) with request:`, request);\r\n        const stub = this.ensureActiveStub();\r\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\r\n        const jsonRequest = Object.assign(Object.assign({}, request), { database: this.databasePath });\r\n        const stream = stub[rpcName](jsonRequest, metadata);\r\n        stream.on('data', (response) => {\r\n            logDebug(LOG_TAG$9, `RPC ${rpcName} received result:`, response);\r\n            results.push(response);\r\n        });\r\n        stream.on('end', () => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' completed.`);\r\n            responseDeferred.resolve(results);\r\n        });\r\n        stream.on('error', (grpcError) => {\r\n            logDebug(LOG_TAG$9, `RPC '${rpcName}' failed with error:`, grpcError);\r\n            const code = mapCodeFromRpcCode(grpcError.code);\r\n            responseDeferred.reject(new FirestoreError(code, grpcError.message));\r\n        });\r\n        return responseDeferred.promise;\r\n    }\r\n    // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\r\n    openStream(rpcName, authToken, appCheckToken) {\r\n        const stub = this.ensureActiveStub();\r\n        const metadata = createMetadata(this.databasePath, authToken, appCheckToken, this.databaseInfo.appId);\r\n        const grpcStream = stub[rpcName](metadata);\r\n        let closed = false;\r\n        const close = (err) => {\r\n            if (!closed) {\r\n                closed = true;\r\n                stream.callOnClose(err);\r\n                grpcStream.end();\r\n            }\r\n        };\r\n        const stream = new StreamBridge({\r\n            sendFn: (msg) => {\r\n                if (!closed) {\r\n                    logDebug(LOG_TAG$9, 'GRPC stream sending:', msg);\r\n                    try {\r\n                        grpcStream.write(msg);\r\n                    }\r\n                    catch (e) {\r\n                        // This probably means we didn't conform to the proto.  Make sure to\r\n                        // log the message we sent.\r\n                        logError('Failure sending:', msg);\r\n                        logError('Error:', e);\r\n                        throw e;\r\n                    }\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$9, 'Not sending because gRPC stream is closed:', msg);\r\n                }\r\n            },\r\n            closeFn: () => {\r\n                logDebug(LOG_TAG$9, 'GRPC stream closed locally via close().');\r\n                close();\r\n            }\r\n        });\r\n        grpcStream.on('data', (msg) => {\r\n            if (!closed) {\r\n                logDebug(LOG_TAG$9, 'GRPC stream received:', msg);\r\n                stream.callOnMessage(msg);\r\n            }\r\n        });\r\n        grpcStream.on('end', () => {\r\n            logDebug(LOG_TAG$9, 'GRPC stream ended.');\r\n            close();\r\n        });\r\n        grpcStream.on('error', (grpcError) => {\r\n            if (!closed) {\r\n                logWarn(LOG_TAG$9, 'GRPC stream error. Code:', grpcError.code, 'Message:', grpcError.message);\r\n                const code = mapCodeFromRpcCode(grpcError.code);\r\n                close(new FirestoreError(code, grpcError.message));\r\n            }\r\n        });\r\n        logDebug(LOG_TAG$9, 'Opening GRPC stream');\r\n        // TODO(dimond): Since grpc has no explicit open status (or does it?) we\r\n        // simulate an onOpen in the next loop after the stream had it's listeners\r\n        // registered\r\n        setTimeout(() => {\r\n            stream.callOnOpen();\r\n        }, 0);\r\n        return stream;\r\n    }\r\n}\n\nconst nested = {\n\tgoogle: {\n\t\tnested: {\n\t\t\tprotobuf: {\n\t\t\t\toptions: {\n\t\t\t\t\tcsharp_namespace: \"Google.Protobuf.WellKnownTypes\",\n\t\t\t\t\tgo_package: \"github.com/golang/protobuf/ptypes/wrappers\",\n\t\t\t\t\tjava_package: \"com.google.protobuf\",\n\t\t\t\t\tjava_outer_classname: \"WrappersProto\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tobjc_class_prefix: \"GPB\",\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\toptimize_for: \"SPEED\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tTimestamp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tseconds: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnanos: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorSet: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfile: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FileDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"package\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpublicDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 10,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweakDependency: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 11,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tpacked: false\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessageType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tservice: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ServiceDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FileOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsourceCodeInfo: {\n\t\t\t\t\t\t\t\ttype: \"SourceCodeInfo\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tsyntax: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textension: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"FieldDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnestedType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"DescriptorProto\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tenumType: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textensionRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ExtensionRange\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofDecl: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"OneofDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MessageOptions\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedRange: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"ReservedRange\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\treservedName: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tExtensionRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tReservedRange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFieldDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\ttype: \"Label\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttype: {\n\t\t\t\t\t\t\t\ttype: \"Type\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttypeName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\textendee: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdefaultValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toneofIndex: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjsonName: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"FieldOptions\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tTYPE_DOUBLE: 1,\n\t\t\t\t\t\t\t\t\tTYPE_FLOAT: 2,\n\t\t\t\t\t\t\t\t\tTYPE_INT64: 3,\n\t\t\t\t\t\t\t\t\tTYPE_UINT64: 4,\n\t\t\t\t\t\t\t\t\tTYPE_INT32: 5,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED64: 6,\n\t\t\t\t\t\t\t\t\tTYPE_FIXED32: 7,\n\t\t\t\t\t\t\t\t\tTYPE_BOOL: 8,\n\t\t\t\t\t\t\t\t\tTYPE_STRING: 9,\n\t\t\t\t\t\t\t\t\tTYPE_GROUP: 10,\n\t\t\t\t\t\t\t\t\tTYPE_MESSAGE: 11,\n\t\t\t\t\t\t\t\t\tTYPE_BYTES: 12,\n\t\t\t\t\t\t\t\t\tTYPE_UINT32: 13,\n\t\t\t\t\t\t\t\t\tTYPE_ENUM: 14,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED32: 15,\n\t\t\t\t\t\t\t\t\tTYPE_SFIXED64: 16,\n\t\t\t\t\t\t\t\t\tTYPE_SINT32: 17,\n\t\t\t\t\t\t\t\t\tTYPE_SINT64: 18\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tLabel: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tLABEL_OPTIONAL: 1,\n\t\t\t\t\t\t\t\t\tLABEL_REQUIRED: 2,\n\t\t\t\t\t\t\t\t\tLABEL_REPEATED: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"OneofOptions\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"EnumValueDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumber: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"EnumValueOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tServiceDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmethod: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"MethodDescriptorProto\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"ServiceOptions\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMethodDescriptorProto: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tinputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toutputType: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\ttype: \"MethodOptions\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclientStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tserverStreaming: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFileOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tjavaPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaOuterClassname: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaMultipleFiles: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenerateEqualsAndHash: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 20,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\tdeprecated: true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaStringCheckUtf8: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 27\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\toptimizeFor: {\n\t\t\t\t\t\t\t\ttype: \"OptimizeMode\",\n\t\t\t\t\t\t\t\tid: 9,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"SPEED\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgoPackage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 16\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjavaGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpyGenericServices: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 23\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tccEnableArenas: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 31\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tobjcClassPrefix: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 36\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcsharpNamespace: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 37\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t38,\n\t\t\t\t\t\t\t\t38\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tOptimizeMode: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSPEED: 1,\n\t\t\t\t\t\t\t\t\tCODE_SIZE: 2,\n\t\t\t\t\t\t\t\t\tLITE_RUNTIME: 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tMessageOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tmessageSetWireFormat: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnoStandardDescriptorAccessor: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmapEntry: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t8,\n\t\t\t\t\t\t\t\t8\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tFieldOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tctype: {\n\t\t\t\t\t\t\t\ttype: \"CType\",\n\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"STRING\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpacked: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tjstype: {\n\t\t\t\t\t\t\t\ttype: \"JSType\",\n\t\t\t\t\t\t\t\tid: 6,\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"default\": \"JS_NORMAL\"\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlazy: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tweak: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\treserved: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t4,\n\t\t\t\t\t\t\t\t4\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t],\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tCType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tSTRING: 0,\n\t\t\t\t\t\t\t\t\tCORD: 1,\n\t\t\t\t\t\t\t\t\tSTRING_PIECE: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tJSType: {\n\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\tJS_NORMAL: 0,\n\t\t\t\t\t\t\t\t\tJS_STRING: 1,\n\t\t\t\t\t\t\t\t\tJS_NUMBER: 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tOneofOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tallowAlias: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tEnumValueOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tServiceOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tMethodOptions: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tdeprecated: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 33\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuninterpretedOption: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"UninterpretedOption\",\n\t\t\t\t\t\t\t\tid: 999\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\textensions: [\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t1000,\n\t\t\t\t\t\t\t\t536870911\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\tUninterpretedOption: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"NamePart\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tidentifierValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpositiveIntValue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnegativeIntValue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\taggregateValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tNamePart: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnamePart: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tisExtension: {\n\t\t\t\t\t\t\t\t\t\trule: \"required\",\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tSourceCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlocation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Location\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tLocation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tspan: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttrailingComments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tleadingDetachedComments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tGeneratedCodeInfo: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tannotation: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Annotation\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tAnnotation: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tsourceFile: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbegin: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStruct: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tValue: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\"numberValue\",\n\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\"boolValue\",\n\t\t\t\t\t\t\t\t\t\"structValue\",\n\t\t\t\t\t\t\t\t\t\"listValue\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\ttype: \"NullValue\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tnumberValue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tboolValue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tstructValue: {\n\t\t\t\t\t\t\t\ttype: \"Struct\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlistValue: {\n\t\t\t\t\t\t\t\ttype: \"ListValue\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tNullValue: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tNULL_VALUE: 0\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tListValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tEmpty: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tDoubleValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tFloatValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"float\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt64Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint64\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tUInt32Value: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"uint32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBoolValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tStringValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBytesValue: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tAny: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\ttypeUrl: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirestore: {\n\t\t\t\tnested: {\n\t\t\t\t\tv1: {\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tcsharp_namespace: \"Google.Cloud.Firestore.V1\",\n\t\t\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/firestore/v1;firestore\",\n\t\t\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\t\t\tjava_outer_classname: \"WriteProto\",\n\t\t\t\t\t\t\tjava_package: \"com.google.firestore.v1\",\n\t\t\t\t\t\t\tobjc_class_prefix: \"GCFS\",\n\t\t\t\t\t\t\tphp_namespace: \"Google\\\\Cloud\\\\Firestore\\\\V1\",\n\t\t\t\t\t\t\truby_package: \"Google::Cloud::Firestore::V1\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\tDocumentMask: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfieldPaths: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPrecondition: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconditionType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"exists\",\n\t\t\t\t\t\t\t\t\t\t\t\"updateTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\texists: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTransactionOptions: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tmode: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"readOnly\",\n\t\t\t\t\t\t\t\t\t\t\t\"readWrite\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\treadOnly: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadOnly\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadWrite: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ReadWrite\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tReadWrite: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tretryTransaction: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tReadOnly: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocument: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcreateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tValue: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tvalueType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"nullValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"booleanValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"integerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"doubleValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"timestampValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"stringValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"bytesValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"referenceValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"geoPointValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"arrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\"mapValue\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tnullValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.NullValue\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbooleanValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tintegerValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdoubleValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttimestampValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstringValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 17\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbytesValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 18\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treferenceValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tgeoPointValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.type.LatLng\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tarrayValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\tid: 9\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmapValue: {\n\t\t\t\t\t\t\t\t\t\ttype: \"MapValue\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tArrayValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tMapValue: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tFirestore: {\n\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\"(google.api.default_host)\": \"firestore.googleapis.com\",\n\t\t\t\t\t\t\t\t\t\"(google.api.oauth_scopes)\": \"https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/datastore\"\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmethods: {\n\t\t\t\t\t\t\t\t\tGetDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"GetDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).get\": \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tget: \"/v1/{parent=projects/*/databases/*/documents/*/**}/{collection_id}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUpdateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"UpdateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).patch\": \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpatch: \"/v1/{document.name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"document,update_mask\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDeleteDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"DeleteDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"delete\": \"/v1/{name=projects/*/databases/*/documents/*/**}\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"name\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchGetDocuments: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchGetDocumentsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchGetDocumentsResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchGet\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBeginTransaction: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BeginTransactionRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BeginTransactionResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:beginTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCommit: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CommitRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"CommitResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:commit\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,writes\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRollback: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RollbackRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"google.protobuf.Empty\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:rollback\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"database,transaction\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tRunQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"RunQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"RunQueryResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:runQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tPartitionQuery: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"PartitionQueryRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"PartitionQueryResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:partitionQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"WriteRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"WriteResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:write\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListen: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListenRequest\",\n\t\t\t\t\t\t\t\t\t\trequestStream: true,\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListenResponse\",\n\t\t\t\t\t\t\t\t\t\tresponseStream: true,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:listen\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tListCollectionIds: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"ListCollectionIdsRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"ListCollectionIdsResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.post\": \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).additional_bindings.body\": \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tadditional_bindings: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/*/**}:listCollectionIds\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.method_signature)\": \"parent\"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tBatchWrite: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"BatchWriteRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"BatchWriteResponse\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"*\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{database=projects/*/databases/*}/documents:batchWrite\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"*\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCreateDocument: {\n\t\t\t\t\t\t\t\t\t\trequestType: \"CreateDocumentRequest\",\n\t\t\t\t\t\t\t\t\t\tresponseType: \"Document\",\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).post\": \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http).body\": \"document\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tparsedOptions: [\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\"(google.api.http)\": {\n\t\t\t\t\t\t\t\t\t\t\t\t\tpost: \"/v1/{parent=projects/*/databases/*/documents/**}/{collection_id}\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tbody: \"document\"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tGetDocumentRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 10\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tshowMissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 12\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListDocumentsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCreateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 4,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUpdateDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDeleteDocumentRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tname: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchGetDocumentsResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresult: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"found\",\n\t\t\t\t\t\t\t\t\t\t\t\"missing\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tfound: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tmissing: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBeginTransactionResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCommitResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRollbackRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tconsistencySelector: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"transaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"newTransaction\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnewTransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TransactionOptions\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tRunQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttransaction: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tskippedResults: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpartitionCount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int64\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPartitionQueryResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tpartitions: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tstreamId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstreamToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcommitTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenRequest: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"addTarget\",\n\t\t\t\t\t\t\t\t\t\t\t\"removeTarget\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\taddTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Target\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremoveTarget: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListenResponse: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\tresponseType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"targetChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentChange\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentDelete\",\n\t\t\t\t\t\t\t\t\t\t\t\"documentRemove\",\n\t\t\t\t\t\t\t\t\t\t\t\"filter\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChange\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentChange: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentChange\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentDelete: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentDelete\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocumentRemove: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentRemove\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfilter: {\n\t\t\t\t\t\t\t\t\t\ttype: \"ExistenceFilter\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTarget: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\ttargetType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"query\",\n\t\t\t\t\t\t\t\t\t\t\t\"documents\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeType: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"resumeToken\",\n\t\t\t\t\t\t\t\t\t\t\t\"readTime\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tquery: {\n\t\t\t\t\t\t\t\t\t\ttype: \"QueryTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentsTarget\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tonce: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tDocumentsTarget: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tdocuments: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tQueryTarget: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tqueryType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"structuredQuery\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tstructuredQuery: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"StructuredQuery\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTargetChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetChangeType: {\n\t\t\t\t\t\t\t\t\t\ttype: \"TargetChangeType\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcause: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tresumeToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bytes\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tTargetChangeType: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tNO_CHANGE: 0,\n\t\t\t\t\t\t\t\t\t\t\tADD: 1,\n\t\t\t\t\t\t\t\t\t\t\tREMOVE: 2,\n\t\t\t\t\t\t\t\t\t\t\tCURRENT: 3,\n\t\t\t\t\t\t\t\t\t\t\tRESET: 4\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tparent: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageSize: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tpageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tListCollectionIdsResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tcollectionIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnextPageToken: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteRequest: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdatabase: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\t\t\t\t\t\"(google.api.field_behavior)\": \"REQUIRED\"\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twrites: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Write\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\t\t\t\tkeyType: \"string\",\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tBatchWriteResponse: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\twriteResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"WriteResult\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"google.rpc.Status\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tStructuredQuery: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tselect: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Projection\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfrom: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"CollectionSelector\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\twhere: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Order\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tstartAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tendAt: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Cursor\",\n\t\t\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\toffset: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tlimit: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Int32Value\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tCollectionSelector: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcollectionId: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tallDescendants: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\tfilterType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"compositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"fieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"unaryFilter\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tcompositeFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"CompositeFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfieldFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tunaryFilter: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"UnaryFilter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tCompositeFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfilters: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Filter\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tAND: 1\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldFilter: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\tLESS_THAN_OR_EQUAL: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGREATER_THAN_OR_EQUAL: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tEQUAL: 5,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_EQUAL: 6,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS: 7,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIN: 8,\n\t\t\t\t\t\t\t\t\t\t\t\t\tARRAY_CONTAINS_ANY: 9,\n\t\t\t\t\t\t\t\t\t\t\t\t\tNOT_IN: 10\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tUnaryFilter: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\toperandType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"field\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\top: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Operator\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tOperator: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tOPERATOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NAN: 2,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NULL: 3,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NAN: 4,\n\t\t\t\t\t\t\t\t\t\t\t\t\tIS_NOT_NULL: 5\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tOrder: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfield: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tdirection: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Direction\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tFieldReference: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProjection: {\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"FieldReference\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tDirection: {\n\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\tDIRECTION_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\tASCENDING: 1,\n\t\t\t\t\t\t\t\t\t\t\tDESCENDING: 2\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCursor: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tbefore: {\n\t\t\t\t\t\t\t\t\t\ttype: \"bool\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWrite: {\n\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\toperation: {\n\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\"update\",\n\t\t\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\t\t\"verify\",\n\t\t\t\t\t\t\t\t\t\t\t\"transform\"\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdate: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tverify: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransform: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateMask: {\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentMask\",\n\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tupdateTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"DocumentTransform.FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcurrentDocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Precondition\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentTransform: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tfieldTransforms: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"FieldTransform\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\tFieldTransform: {\n\t\t\t\t\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\t\t\t\t\ttransformType: {\n\t\t\t\t\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"setToServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"increment\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"maximum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"minimum\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"appendMissingElements\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"removeAllFromArray\"\n\t\t\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\t\t\tfieldPath: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tsetToServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ServerValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tincrement: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tmaximum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tminimum: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tappendMissingElements: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\tremoveAllFromArray: {\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"ArrayValue\",\n\t\t\t\t\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tnested: {\n\t\t\t\t\t\t\t\t\t\t\tServerValue: {\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\t\t\t\t\t\t\tSERVER_VALUE_UNSPECIFIED: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\tREQUEST_TIME: 1\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tWriteResult: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tupdateTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttransformResults: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"Value\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentChange: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"Document\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\ttargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentDelete: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tDocumentRemove: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\tdocument: {\n\t\t\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tremovedTargetIds: {\n\t\t\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\treadTime: {\n\t\t\t\t\t\t\t\t\t\ttype: \"google.protobuf.Timestamp\",\n\t\t\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tExistenceFilter: {\n\t\t\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\t\t\ttargetId: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcount: {\n\t\t\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tapi: {\n\t\t\t\toptions: {\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/api/annotations;annotations\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"HttpProto\",\n\t\t\t\t\tjava_package: \"com.google.api\",\n\t\t\t\t\tobjc_class_prefix: \"GAPI\",\n\t\t\t\t\tcc_enable_arenas: true\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\thttp: {\n\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\tid: 72295728,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tHttp: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\trules: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tHttpRule: {\n\t\t\t\t\t\toneofs: {\n\t\t\t\t\t\t\tpattern: {\n\t\t\t\t\t\t\t\toneof: [\n\t\t\t\t\t\t\t\t\t\"get\",\n\t\t\t\t\t\t\t\t\t\"put\",\n\t\t\t\t\t\t\t\t\t\"post\",\n\t\t\t\t\t\t\t\t\t\"delete\",\n\t\t\t\t\t\t\t\t\t\"patch\",\n\t\t\t\t\t\t\t\t\t\"custom\"\n\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tget: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tput: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpost: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 4\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"delete\": {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 5\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpatch: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 6\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tcustom: {\n\t\t\t\t\t\t\t\ttype: \"CustomHttpPattern\",\n\t\t\t\t\t\t\t\tid: 8\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tselector: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tbody: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 7\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tadditionalBindings: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"HttpRule\",\n\t\t\t\t\t\t\t\tid: 11\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tCustomHttpPattern: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tkind: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpath: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmethodSignature: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1051,\n\t\t\t\t\t\textend: \"google.protobuf.MethodOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tdefaultHost: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1049,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\toauthScopes: {\n\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\tid: 1050,\n\t\t\t\t\t\textend: \"google.protobuf.ServiceOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tfieldBehavior: {\n\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\ttype: \"google.api.FieldBehavior\",\n\t\t\t\t\t\tid: 1052,\n\t\t\t\t\t\textend: \"google.protobuf.FieldOptions\"\n\t\t\t\t\t},\n\t\t\t\t\tFieldBehavior: {\n\t\t\t\t\t\tvalues: {\n\t\t\t\t\t\t\tFIELD_BEHAVIOR_UNSPECIFIED: 0,\n\t\t\t\t\t\t\tOPTIONAL: 1,\n\t\t\t\t\t\t\tREQUIRED: 2,\n\t\t\t\t\t\t\tOUTPUT_ONLY: 3,\n\t\t\t\t\t\t\tINPUT_ONLY: 4,\n\t\t\t\t\t\t\tIMMUTABLE: 5,\n\t\t\t\t\t\t\tUNORDERED_LIST: 6,\n\t\t\t\t\t\t\tNON_EMPTY_DEFAULT: 7\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\ttype: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/type/latlng;latlng\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"LatLngProto\",\n\t\t\t\t\tjava_package: \"com.google.type\",\n\t\t\t\t\tobjc_class_prefix: \"GTP\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tLatLng: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tlatitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlongitude: {\n\t\t\t\t\t\t\t\ttype: \"double\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\trpc: {\n\t\t\t\toptions: {\n\t\t\t\t\tcc_enable_arenas: true,\n\t\t\t\t\tgo_package: \"google.golang.org/genproto/googleapis/rpc/status;status\",\n\t\t\t\t\tjava_multiple_files: true,\n\t\t\t\t\tjava_outer_classname: \"StatusProto\",\n\t\t\t\t\tjava_package: \"com.google.rpc\",\n\t\t\t\t\tobjc_class_prefix: \"RPC\"\n\t\t\t\t},\n\t\t\t\tnested: {\n\t\t\t\t\tStatus: {\n\t\t\t\t\t\tfields: {\n\t\t\t\t\t\t\tcode: {\n\t\t\t\t\t\t\t\ttype: \"int32\",\n\t\t\t\t\t\t\t\tid: 1\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: {\n\t\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\t\tid: 2\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdetails: {\n\t\t\t\t\t\t\t\trule: \"repeated\",\n\t\t\t\t\t\t\t\ttype: \"google.protobuf.Any\",\n\t\t\t\t\t\t\t\tid: 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nvar protos = {\n\tnested: nested\n};\n\nvar protos$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  nested: nested,\n  'default': protos\n});\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Used by tests so we can match @grpc/proto-loader behavior. */\r\nconst protoLoaderOptions = {\r\n    longs: String,\r\n    enums: String,\r\n    defaults: true,\r\n    oneofs: false\r\n};\r\n/**\r\n * Loads the protocol buffer definitions for Firestore.\r\n *\r\n * @returns The GrpcObject representing our protos.\r\n */\r\nfunction loadProtos() {\r\n    const packageDefinition = _grpc_proto_loader__WEBPACK_IMPORTED_MODULE_7__.fromJSON(protos$1, protoLoaderOptions);\r\n    return _grpc_grpc_js__WEBPACK_IMPORTED_MODULE_6__.loadPackageDefinition(packageDefinition);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Loads the GRPC stack */\r\nfunction newConnection(databaseInfo) {\r\n    const protos = loadProtos();\r\n    return new GrpcConnection(protos, databaseInfo);\r\n}\r\n/** Return the Platform-specific connectivity monitor. */\r\nfunction newConnectivityMonitor() {\r\n    return new NoopConnectivityMonitor();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** The Platform's 'window' implementation or null if not available. */\r\nfunction getWindow() {\r\n    if (process.env.USE_MOCK_PERSISTENCE === 'YES') {\r\n        // eslint-disable-next-line no-restricted-globals\r\n        return window;\r\n    }\r\n    return null;\r\n}\r\n/** The Platform's 'document' implementation or null if not available. */\r\nfunction getDocument() {\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction newSerializer(databaseId) {\r\n    return new JsonProtoSerializer(databaseId, /* useProto3Json= */ false);\r\n}\r\n/**\r\n * An instance of the Platform's 'TextEncoder' implementation.\r\n */\r\nfunction newTextEncoder() {\r\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextEncoder();\r\n}\r\n/**\r\n * An instance of the Platform's 'TextDecoder' implementation.\r\n */\r\nfunction newTextDecoder() {\r\n    return new util__WEBPACK_IMPORTED_MODULE_3__.TextDecoder('utf-8');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$8 = 'ExponentialBackoff';\r\n/**\r\n * Initial backoff time in milliseconds after an error.\r\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\r\n */\r\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\r\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\r\n/** Maximum backoff time in milliseconds */\r\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\r\n/**\r\n * A helper for running delayed tasks following an exponential backoff curve\r\n * between attempts.\r\n *\r\n * Each delay is made up of a \"base\" delay which follows the exponential\r\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\r\n * base delay. This prevents clients from accidentally synchronizing their\r\n * delays causing spikes of load to the backend.\r\n */\r\nclass ExponentialBackoff {\r\n    constructor(\r\n    /**\r\n     * The AsyncQueue to run backoff operations on.\r\n     */\r\n    queue, \r\n    /**\r\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\r\n     */\r\n    timerId, \r\n    /**\r\n     * The initial delay (used as the base delay on the first retry attempt).\r\n     * Note that jitter will still be applied, so the actual delay could be as\r\n     * little as 0.5*initialDelayMs.\r\n     */\r\n    initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, \r\n    /**\r\n     * The multiplier to use to determine the extended base delay after each\r\n     * attempt.\r\n     */\r\n    backoffFactor = DEFAULT_BACKOFF_FACTOR, \r\n    /**\r\n     * The maximum base delay after which no further backoff is performed.\r\n     * Note that jitter will still be applied, so the actual delay could be as\r\n     * much as 1.5*maxDelayMs.\r\n     */\r\n    maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) {\r\n        this.queue = queue;\r\n        this.timerId = timerId;\r\n        this.initialDelayMs = initialDelayMs;\r\n        this.backoffFactor = backoffFactor;\r\n        this.maxDelayMs = maxDelayMs;\r\n        this.currentBaseMs = 0;\r\n        this.timerPromise = null;\r\n        /** The last backoff attempt, as epoch milliseconds. */\r\n        this.lastAttemptTime = Date.now();\r\n        this.reset();\r\n    }\r\n    /**\r\n     * Resets the backoff delay.\r\n     *\r\n     * The very next backoffAndWait() will have no delay. If it is called again\r\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\r\n     * subsequent ones will increase according to the backoffFactor.\r\n     */\r\n    reset() {\r\n        this.currentBaseMs = 0;\r\n    }\r\n    /**\r\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\r\n     * RESOURCE_EXHAUSTED error).\r\n     */\r\n    resetToMax() {\r\n        this.currentBaseMs = this.maxDelayMs;\r\n    }\r\n    /**\r\n     * Returns a promise that resolves after currentDelayMs, and increases the\r\n     * delay for any subsequent attempts. If there was a pending backoff operation\r\n     * already, it will be canceled.\r\n     */\r\n    backoffAndRun(op) {\r\n        // Cancel any pending backoff operation.\r\n        this.cancel();\r\n        // First schedule using the current base (which may be 0 and should be\r\n        // honored as such).\r\n        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());\r\n        // Guard against lastAttemptTime being in the future due to a clock change.\r\n        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);\r\n        // Guard against the backoff delay already being past.\r\n        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);\r\n        if (remainingDelayMs > 0) {\r\n            logDebug(LOG_TAG$8, `Backing off for ${remainingDelayMs} ms ` +\r\n                `(base delay: ${this.currentBaseMs} ms, ` +\r\n                `delay with jitter: ${desiredDelayWithJitterMs} ms, ` +\r\n                `last attempt: ${delaySoFarMs} ms ago)`);\r\n        }\r\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => {\r\n            this.lastAttemptTime = Date.now();\r\n            return op();\r\n        });\r\n        // Apply backoff factor to determine next delay and ensure it is within\r\n        // bounds.\r\n        this.currentBaseMs *= this.backoffFactor;\r\n        if (this.currentBaseMs < this.initialDelayMs) {\r\n            this.currentBaseMs = this.initialDelayMs;\r\n        }\r\n        if (this.currentBaseMs > this.maxDelayMs) {\r\n            this.currentBaseMs = this.maxDelayMs;\r\n        }\r\n    }\r\n    skipBackoff() {\r\n        if (this.timerPromise !== null) {\r\n            this.timerPromise.skipDelay();\r\n            this.timerPromise = null;\r\n        }\r\n    }\r\n    cancel() {\r\n        if (this.timerPromise !== null) {\r\n            this.timerPromise.cancel();\r\n            this.timerPromise = null;\r\n        }\r\n    }\r\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\r\n    jitterDelayMs() {\r\n        return (Math.random() - 0.5) * this.currentBaseMs;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$7 = 'PersistentStream';\r\n/** The time a stream stays open after it is marked idle. */\r\nconst IDLE_TIMEOUT_MS = 60 * 1000;\r\n/** The time a stream stays open until we consider it healthy. */\r\nconst HEALTHY_TIMEOUT_MS = 10 * 1000;\r\n/**\r\n * A PersistentStream is an abstract base class that represents a streaming RPC\r\n * to the Firestore backend. It's built on top of the connections own support\r\n * for streaming RPCs, and adds several critical features for our clients:\r\n *\r\n *   - Exponential backoff on failure\r\n *   - Authentication via CredentialsProvider\r\n *   - Dispatching all callbacks into the shared worker queue\r\n *   - Closing idle streams after 60 seconds of inactivity\r\n *\r\n * Subclasses of PersistentStream implement serialization of models to and\r\n * from the JSON representation of the protocol buffers for a specific\r\n * streaming RPC.\r\n *\r\n * ## Starting and Stopping\r\n *\r\n * Streaming RPCs are stateful and need to be start()ed before messages can\r\n * be sent and received. The PersistentStream will call the onOpen() function\r\n * of the listener once the stream is ready to accept requests.\r\n *\r\n * Should a start() fail, PersistentStream will call the registered onClose()\r\n * listener with a FirestoreError indicating what went wrong.\r\n *\r\n * A PersistentStream can be started and stopped repeatedly.\r\n *\r\n * Generic types:\r\n *  SendType: The type of the outgoing message of the underlying\r\n *    connection stream\r\n *  ReceiveType: The type of the incoming message of the underlying\r\n *    connection stream\r\n *  ListenerType: The type of the listener that will be used for callbacks\r\n */\r\nclass PersistentStream {\r\n    constructor(queue, connectionTimerId, idleTimerId, healthTimerId, connection, authCredentialsProvider, appCheckCredentialsProvider, listener) {\r\n        this.queue = queue;\r\n        this.idleTimerId = idleTimerId;\r\n        this.healthTimerId = healthTimerId;\r\n        this.connection = connection;\r\n        this.authCredentialsProvider = authCredentialsProvider;\r\n        this.appCheckCredentialsProvider = appCheckCredentialsProvider;\r\n        this.listener = listener;\r\n        this.state = 0 /* Initial */;\r\n        /**\r\n         * A close count that's incremented every time the stream is closed; used by\r\n         * getCloseGuardedDispatcher() to invalidate callbacks that happen after\r\n         * close.\r\n         */\r\n        this.closeCount = 0;\r\n        this.idleTimer = null;\r\n        this.healthCheck = null;\r\n        this.stream = null;\r\n        this.backoff = new ExponentialBackoff(queue, connectionTimerId);\r\n    }\r\n    /**\r\n     * Returns true if start() has been called and no error has occurred. True\r\n     * indicates the stream is open or in the process of opening (which\r\n     * encompasses respecting backoff, getting auth tokens, and starting the\r\n     * actual RPC). Use isOpen() to determine if the stream is open and ready for\r\n     * outbound requests.\r\n     */\r\n    isStarted() {\r\n        return (this.state === 1 /* Starting */ ||\r\n            this.state === 5 /* Backoff */ ||\r\n            this.isOpen());\r\n    }\r\n    /**\r\n     * Returns true if the underlying RPC is open (the onOpen() listener has been\r\n     * called) and the stream is ready for outbound requests.\r\n     */\r\n    isOpen() {\r\n        return (this.state === 2 /* Open */ ||\r\n            this.state === 3 /* Healthy */);\r\n    }\r\n    /**\r\n     * Starts the RPC. Only allowed if isStarted() returns false. The stream is\r\n     * not immediately ready for use: onOpen() will be invoked when the RPC is\r\n     * ready for outbound requests, at which point isOpen() will return true.\r\n     *\r\n     * When start returns, isStarted() will return true.\r\n     */\r\n    start() {\r\n        if (this.state === 4 /* Error */) {\r\n            this.performBackoff();\r\n            return;\r\n        }\r\n        this.auth();\r\n    }\r\n    /**\r\n     * Stops the RPC. This call is idempotent and allowed regardless of the\r\n     * current isStarted() state.\r\n     *\r\n     * When stop returns, isStarted() and isOpen() will both return false.\r\n     */\r\n    async stop() {\r\n        if (this.isStarted()) {\r\n            await this.close(0 /* Initial */);\r\n        }\r\n    }\r\n    /**\r\n     * After an error the stream will usually back off on the next attempt to\r\n     * start it. If the error warrants an immediate restart of the stream, the\r\n     * sender can use this to indicate that the receiver should not back off.\r\n     *\r\n     * Each error will call the onClose() listener. That function can decide to\r\n     * inhibit backoff if required.\r\n     */\r\n    inhibitBackoff() {\r\n        this.state = 0 /* Initial */;\r\n        this.backoff.reset();\r\n    }\r\n    /**\r\n     * Marks this stream as idle. If no further actions are performed on the\r\n     * stream for one minute, the stream will automatically close itself and\r\n     * notify the stream's onClose() handler with Status.OK. The stream will then\r\n     * be in a !isStarted() state, requiring the caller to start the stream again\r\n     * before further use.\r\n     *\r\n     * Only streams that are in state 'Open' can be marked idle, as all other\r\n     * states imply pending network operations.\r\n     */\r\n    markIdle() {\r\n        // Starts the idle time if we are in state 'Open' and are not yet already\r\n        // running a timer (in which case the previous idle timeout still applies).\r\n        if (this.isOpen() && this.idleTimer === null) {\r\n            this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, () => this.handleIdleCloseTimer());\r\n        }\r\n    }\r\n    /** Sends a message to the underlying stream. */\r\n    sendRequest(msg) {\r\n        this.cancelIdleCheck();\r\n        this.stream.send(msg);\r\n    }\r\n    /** Called by the idle timer when the stream should close due to inactivity. */\r\n    async handleIdleCloseTimer() {\r\n        if (this.isOpen()) {\r\n            // When timing out an idle stream there's no reason to force the stream into backoff when\r\n            // it restarts so set the stream state to Initial instead of Error.\r\n            return this.close(0 /* Initial */);\r\n        }\r\n    }\r\n    /** Marks the stream as active again. */\r\n    cancelIdleCheck() {\r\n        if (this.idleTimer) {\r\n            this.idleTimer.cancel();\r\n            this.idleTimer = null;\r\n        }\r\n    }\r\n    /** Cancels the health check delayed operation. */\r\n    cancelHealthCheck() {\r\n        if (this.healthCheck) {\r\n            this.healthCheck.cancel();\r\n            this.healthCheck = null;\r\n        }\r\n    }\r\n    /**\r\n     * Closes the stream and cleans up as necessary:\r\n     *\r\n     * * closes the underlying GRPC stream;\r\n     * * calls the onClose handler with the given 'error';\r\n     * * sets internal stream state to 'finalState';\r\n     * * adjusts the backoff timer based on the error\r\n     *\r\n     * A new stream can be opened by calling start().\r\n     *\r\n     * @param finalState - the intended state of the stream after closing.\r\n     * @param error - the error the connection was closed with.\r\n     */\r\n    async close(finalState, error) {\r\n        // Cancel any outstanding timers (they're guaranteed not to execute).\r\n        this.cancelIdleCheck();\r\n        this.cancelHealthCheck();\r\n        this.backoff.cancel();\r\n        // Invalidates any stream-related callbacks (e.g. from auth or the\r\n        // underlying stream), guaranteeing they won't execute.\r\n        this.closeCount++;\r\n        if (finalState !== 4 /* Error */) {\r\n            // If this is an intentional close ensure we don't delay our next connection attempt.\r\n            this.backoff.reset();\r\n        }\r\n        else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\r\n            // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\r\n            logError(error.toString());\r\n            logError('Using maximum backoff delay to prevent overloading the backend.');\r\n            this.backoff.resetToMax();\r\n        }\r\n        else if (error &&\r\n            error.code === Code.UNAUTHENTICATED &&\r\n            this.state !== 3 /* Healthy */) {\r\n            // \"unauthenticated\" error means the token was rejected. This should rarely\r\n            // happen since both Auth and AppCheck ensure a sufficient TTL when we\r\n            // request a token. If a user manually resets their system clock this can\r\n            // fail, however. In this case, we should get a Code.UNAUTHENTICATED error\r\n            // before we received the first message and we need to invalidate the token\r\n            // to ensure that we fetch a new token.\r\n            this.authCredentialsProvider.invalidateToken();\r\n            this.appCheckCredentialsProvider.invalidateToken();\r\n        }\r\n        // Clean up the underlying stream because we are no longer interested in events.\r\n        if (this.stream !== null) {\r\n            this.tearDown();\r\n            this.stream.close();\r\n            this.stream = null;\r\n        }\r\n        // This state must be assigned before calling onClose() to allow the callback to\r\n        // inhibit backoff or otherwise manipulate the state in its non-started state.\r\n        this.state = finalState;\r\n        // Notify the listener that the stream closed.\r\n        await this.listener.onClose(error);\r\n    }\r\n    /**\r\n     * Can be overridden to perform additional cleanup before the stream is closed.\r\n     * Calling super.tearDown() is not required.\r\n     */\r\n    tearDown() { }\r\n    auth() {\r\n        this.state = 1 /* Starting */;\r\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\r\n        // TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.\r\n        const closeCount = this.closeCount;\r\n        Promise.all([\r\n            this.authCredentialsProvider.getToken(),\r\n            this.appCheckCredentialsProvider.getToken()\r\n        ]).then(([authToken, appCheckToken]) => {\r\n            // Stream can be stopped while waiting for authentication.\r\n            // TODO(mikelehen): We really should just use dispatchIfNotClosed\r\n            // and let this dispatch onto the queue, but that opened a spec test can\r\n            // of worms that I don't want to deal with in this PR.\r\n            if (this.closeCount === closeCount) {\r\n                // Normally we'd have to schedule the callback on the AsyncQueue.\r\n                // However, the following calls are safe to be called outside the\r\n                // AsyncQueue since they don't chain asynchronous calls\r\n                this.startStream(authToken, appCheckToken);\r\n            }\r\n        }, (error) => {\r\n            dispatchIfNotClosed(() => {\r\n                const rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\r\n                return this.handleStreamClose(rpcError);\r\n            });\r\n        });\r\n    }\r\n    startStream(authToken, appCheckToken) {\r\n        const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\r\n        this.stream = this.startRpc(authToken, appCheckToken);\r\n        this.stream.onOpen(() => {\r\n            dispatchIfNotClosed(() => {\r\n                this.state = 2 /* Open */;\r\n                this.healthCheck = this.queue.enqueueAfterDelay(this.healthTimerId, HEALTHY_TIMEOUT_MS, () => {\r\n                    if (this.isOpen()) {\r\n                        this.state = 3 /* Healthy */;\r\n                    }\r\n                    return Promise.resolve();\r\n                });\r\n                return this.listener.onOpen();\r\n            });\r\n        });\r\n        this.stream.onClose((error) => {\r\n            dispatchIfNotClosed(() => {\r\n                return this.handleStreamClose(error);\r\n            });\r\n        });\r\n        this.stream.onMessage((msg) => {\r\n            dispatchIfNotClosed(() => {\r\n                return this.onMessage(msg);\r\n            });\r\n        });\r\n    }\r\n    performBackoff() {\r\n        this.state = 5 /* Backoff */;\r\n        this.backoff.backoffAndRun(async () => {\r\n            this.state = 0 /* Initial */;\r\n            this.start();\r\n        });\r\n    }\r\n    // Visible for tests\r\n    handleStreamClose(error) {\r\n        logDebug(LOG_TAG$7, `close with error: ${error}`);\r\n        this.stream = null;\r\n        // In theory the stream could close cleanly, however, in our current model\r\n        // we never expect this to happen because if we stop a stream ourselves,\r\n        // this callback will never be called. To prevent cases where we retry\r\n        // without a backoff accidentally, we set the stream to error in all cases.\r\n        return this.close(4 /* Error */, error);\r\n    }\r\n    /**\r\n     * Returns a \"dispatcher\" function that dispatches operations onto the\r\n     * AsyncQueue but only runs them if closeCount remains unchanged. This allows\r\n     * us to turn auth / stream callbacks into no-ops if the stream is closed /\r\n     * re-opened, etc.\r\n     */\r\n    getCloseGuardedDispatcher(startCloseCount) {\r\n        return (fn) => {\r\n            this.queue.enqueueAndForget(() => {\r\n                if (this.closeCount === startCloseCount) {\r\n                    return fn();\r\n                }\r\n                else {\r\n                    logDebug(LOG_TAG$7, 'stream callback skipped by getCloseGuardedDispatcher.');\r\n                    return Promise.resolve();\r\n                }\r\n            });\r\n        };\r\n    }\r\n}\r\n/**\r\n * A PersistentStream that implements the Listen RPC.\r\n *\r\n * Once the Listen stream has called the onOpen() listener, any number of\r\n * listen() and unlisten() calls can be made to control what changes will be\r\n * sent from the server for ListenResponses.\r\n */\r\nclass PersistentListenStream extends PersistentStream {\r\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\r\n        super(queue, \"listen_stream_connection_backoff\" /* ListenStreamConnectionBackoff */, \"listen_stream_idle\" /* ListenStreamIdle */, \"health_check_timeout\" /* HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\r\n        this.serializer = serializer;\r\n    }\r\n    startRpc(authToken, appCheckToken) {\r\n        return this.connection.openStream('Listen', authToken, appCheckToken);\r\n    }\r\n    onMessage(watchChangeProto) {\r\n        // A successful response means the stream is healthy\r\n        this.backoff.reset();\r\n        const watchChange = fromWatchChange(this.serializer, watchChangeProto);\r\n        const snapshot = versionFromListenResponse(watchChangeProto);\r\n        return this.listener.onWatchChange(watchChange, snapshot);\r\n    }\r\n    /**\r\n     * Registers interest in the results of the given target. If the target\r\n     * includes a resumeToken it will be included in the request. Results that\r\n     * affect the target will be streamed back as WatchChange messages that\r\n     * reference the targetId.\r\n     */\r\n    watch(targetData) {\r\n        const request = {};\r\n        request.database = getEncodedDatabaseId(this.serializer);\r\n        request.addTarget = toTarget(this.serializer, targetData);\r\n        const labels = toListenRequestLabels(this.serializer, targetData);\r\n        if (labels) {\r\n            request.labels = labels;\r\n        }\r\n        this.sendRequest(request);\r\n    }\r\n    /**\r\n     * Unregisters interest in the results of the target associated with the\r\n     * given targetId.\r\n     */\r\n    unwatch(targetId) {\r\n        const request = {};\r\n        request.database = getEncodedDatabaseId(this.serializer);\r\n        request.removeTarget = targetId;\r\n        this.sendRequest(request);\r\n    }\r\n}\r\n/**\r\n * A Stream that implements the Write RPC.\r\n *\r\n * The Write RPC requires the caller to maintain special streamToken\r\n * state in between calls, to help the server understand which responses the\r\n * client has processed by the time the next request is made. Every response\r\n * will contain a streamToken; this value must be passed to the next\r\n * request.\r\n *\r\n * After calling start() on this stream, the next request must be a handshake,\r\n * containing whatever streamToken is on hand. Once a response to this\r\n * request is received, all pending mutations may be submitted. When\r\n * submitting multiple batches of mutations at the same time, it's\r\n * okay to use the same streamToken for the calls to writeMutations.\r\n *\r\n * TODO(b/33271235): Use proto types\r\n */\r\nclass PersistentWriteStream extends PersistentStream {\r\n    constructor(queue, connection, authCredentials, appCheckCredentials, serializer, listener) {\r\n        super(queue, \"write_stream_connection_backoff\" /* WriteStreamConnectionBackoff */, \"write_stream_idle\" /* WriteStreamIdle */, \"health_check_timeout\" /* HealthCheckTimeout */, connection, authCredentials, appCheckCredentials, listener);\r\n        this.serializer = serializer;\r\n        this.handshakeComplete_ = false;\r\n    }\r\n    /**\r\n     * Tracks whether or not a handshake has been successfully exchanged and\r\n     * the stream is ready to accept mutations.\r\n     */\r\n    get handshakeComplete() {\r\n        return this.handshakeComplete_;\r\n    }\r\n    // Override of PersistentStream.start\r\n    start() {\r\n        this.handshakeComplete_ = false;\r\n        this.lastStreamToken = undefined;\r\n        super.start();\r\n    }\r\n    tearDown() {\r\n        if (this.handshakeComplete_) {\r\n            this.writeMutations([]);\r\n        }\r\n    }\r\n    startRpc(authToken, appCheckToken) {\r\n        return this.connection.openStream('Write', authToken, appCheckToken);\r\n    }\r\n    onMessage(responseProto) {\r\n        // Always capture the last stream token.\r\n        hardAssert(!!responseProto.streamToken);\r\n        this.lastStreamToken = responseProto.streamToken;\r\n        if (!this.handshakeComplete_) {\r\n            // The first response is always the handshake response\r\n            hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0);\r\n            this.handshakeComplete_ = true;\r\n            return this.listener.onHandshakeComplete();\r\n        }\r\n        else {\r\n            // A successful first write response means the stream is healthy,\r\n            // Note, that we could consider a successful handshake healthy, however,\r\n            // the write itself might be causing an error we want to back off from.\r\n            this.backoff.reset();\r\n            const results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);\r\n            const commitVersion = fromVersion(responseProto.commitTime);\r\n            return this.listener.onMutationResult(commitVersion, results);\r\n        }\r\n    }\r\n    /**\r\n     * Sends an initial streamToken to the server, performing the handshake\r\n     * required to make the StreamingWrite RPC work. Subsequent\r\n     * calls should wait until onHandshakeComplete was called.\r\n     */\r\n    writeHandshake() {\r\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\r\n        // stream token on the handshake, ignoring any stream token we might have.\r\n        const request = {};\r\n        request.database = getEncodedDatabaseId(this.serializer);\r\n        this.sendRequest(request);\r\n    }\r\n    /** Sends a group of mutations to the Firestore backend to apply. */\r\n    writeMutations(mutations) {\r\n        const request = {\r\n            streamToken: this.lastStreamToken,\r\n            writes: mutations.map(mutation => toMutation(this.serializer, mutation))\r\n        };\r\n        this.sendRequest(request);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Datastore and its related methods are a wrapper around the external Google\r\n * Cloud Datastore grpc API, which provides an interface that is more convenient\r\n * for the rest of the client SDK architecture to consume.\r\n */\r\nclass Datastore {\r\n}\r\n/**\r\n * An implementation of Datastore that exposes additional state for internal\r\n * consumption.\r\n */\r\nclass DatastoreImpl extends Datastore {\r\n    constructor(authCredentials, appCheckCredentials, connection, serializer) {\r\n        super();\r\n        this.authCredentials = authCredentials;\r\n        this.appCheckCredentials = appCheckCredentials;\r\n        this.connection = connection;\r\n        this.serializer = serializer;\r\n        this.terminated = false;\r\n    }\r\n    verifyInitialized() {\r\n        if (this.terminated) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\r\n        }\r\n    }\r\n    /** Invokes the provided RPC with auth and AppCheck tokens. */\r\n    invokeRPC(rpcName, path, request) {\r\n        this.verifyInitialized();\r\n        return Promise.all([\r\n            this.authCredentials.getToken(),\r\n            this.appCheckCredentials.getToken()\r\n        ])\r\n            .then(([authToken, appCheckToken]) => {\r\n            return this.connection.invokeRPC(rpcName, path, request, authToken, appCheckToken);\r\n        })\r\n            .catch((error) => {\r\n            if (error.name === 'FirebaseError') {\r\n                if (error.code === Code.UNAUTHENTICATED) {\r\n                    this.authCredentials.invalidateToken();\r\n                    this.appCheckCredentials.invalidateToken();\r\n                }\r\n                throw error;\r\n            }\r\n            else {\r\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\r\n            }\r\n        });\r\n    }\r\n    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */\r\n    invokeStreamingRPC(rpcName, path, request) {\r\n        this.verifyInitialized();\r\n        return Promise.all([\r\n            this.authCredentials.getToken(),\r\n            this.appCheckCredentials.getToken()\r\n        ])\r\n            .then(([authToken, appCheckToken]) => {\r\n            return this.connection.invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken);\r\n        })\r\n            .catch((error) => {\r\n            if (error.name === 'FirebaseError') {\r\n                if (error.code === Code.UNAUTHENTICATED) {\r\n                    this.authCredentials.invalidateToken();\r\n                    this.appCheckCredentials.invalidateToken();\r\n                }\r\n                throw error;\r\n            }\r\n            else {\r\n                throw new FirestoreError(Code.UNKNOWN, error.toString());\r\n            }\r\n        });\r\n    }\r\n    terminate() {\r\n        this.terminated = true;\r\n    }\r\n}\r\n// TODO(firestorexp): Make sure there is only one Datastore instance per\r\n// firestore-exp client.\r\nfunction newDatastore(authCredentials, appCheckCredentials, connection, serializer) {\r\n    return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);\r\n}\r\nasync function invokeCommitRpc(datastore, mutations) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    const path = getEncodedDatabaseId(datastoreImpl.serializer) + '/documents';\r\n    const request = {\r\n        writes: mutations.map(m => toMutation(datastoreImpl.serializer, m))\r\n    };\r\n    await datastoreImpl.invokeRPC('Commit', path, request);\r\n}\r\nasync function invokeBatchGetDocumentsRpc(datastore, keys) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    const path = getEncodedDatabaseId(datastoreImpl.serializer) + '/documents';\r\n    const request = {\r\n        documents: keys.map(k => toName(datastoreImpl.serializer, k))\r\n    };\r\n    const response = await datastoreImpl.invokeStreamingRPC('BatchGetDocuments', path, request);\r\n    const docs = new Map();\r\n    response.forEach(proto => {\r\n        const doc = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);\r\n        docs.set(doc.key.toString(), doc);\r\n    });\r\n    const result = [];\r\n    keys.forEach(key => {\r\n        const doc = docs.get(key.toString());\r\n        hardAssert(!!doc);\r\n        result.push(doc);\r\n    });\r\n    return result;\r\n}\r\nfunction newPersistentWriteStream(datastore, queue, listener) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    datastoreImpl.verifyInitialized();\r\n    return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\r\n}\r\nfunction newPersistentWatchStream(datastore, queue, listener) {\r\n    const datastoreImpl = debugCast(datastore);\r\n    datastoreImpl.verifyInitialized();\r\n    return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.authCredentials, datastoreImpl.appCheckCredentials, datastoreImpl.serializer, listener);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$6 = 'OnlineStateTracker';\r\n// To deal with transient failures, we allow multiple stream attempts before\r\n// giving up and transitioning from OnlineState.Unknown to Offline.\r\n// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.\r\n// @jdimond thinks that bug is sufficiently fixed so that we can set this back\r\n// to 1. If that works okay, we could potentially remove this logic entirely.\r\nconst MAX_WATCH_STREAM_FAILURES = 1;\r\n// To deal with stream attempts that don't succeed or fail in a timely manner,\r\n// we have a timeout for OnlineState to reach Online or Offline.\r\n// If the timeout is reached, we transition to Offline rather than waiting\r\n// indefinitely.\r\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\r\n/**\r\n * A component used by the RemoteStore to track the OnlineState (that is,\r\n * whether or not the client as a whole should be considered to be online or\r\n * offline), implementing the appropriate heuristics.\r\n *\r\n * In particular, when the client is trying to connect to the backend, we\r\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\r\n * a connection to succeed. If we have too many failures or the timeout elapses,\r\n * then we set the OnlineState to Offline, and the client will behave as if\r\n * it is offline (get()s will return cached data, etc.).\r\n */\r\nclass OnlineStateTracker {\r\n    constructor(asyncQueue, onlineStateHandler) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.onlineStateHandler = onlineStateHandler;\r\n        /** The current OnlineState. */\r\n        this.state = \"Unknown\" /* Unknown */;\r\n        /**\r\n         * A count of consecutive failures to open the stream. If it reaches the\r\n         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\r\n         * Offline.\r\n         */\r\n        this.watchStreamFailures = 0;\r\n        /**\r\n         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\r\n         * transition from OnlineState.Unknown to OnlineState.Offline without waiting\r\n         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\r\n         */\r\n        this.onlineStateTimer = null;\r\n        /**\r\n         * Whether the client should log a warning message if it fails to connect to\r\n         * the backend (initially true, cleared after a successful stream, or if we've\r\n         * logged the message already).\r\n         */\r\n        this.shouldWarnClientIsOffline = true;\r\n    }\r\n    /**\r\n     * Called by RemoteStore when a watch stream is started (including on each\r\n     * backoff attempt).\r\n     *\r\n     * If this is the first attempt, it sets the OnlineState to Unknown and starts\r\n     * the onlineStateTimer.\r\n     */\r\n    handleWatchStreamStart() {\r\n        if (this.watchStreamFailures === 0) {\r\n            this.setAndBroadcast(\"Unknown\" /* Unknown */);\r\n            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\"online_state_timeout\" /* OnlineStateTimeout */, ONLINE_STATE_TIMEOUT_MS, () => {\r\n                this.onlineStateTimer = null;\r\n                this.logClientOfflineWarningIfNecessary(`Backend didn't respond within ${ONLINE_STATE_TIMEOUT_MS / 1000} ` +\r\n                    `seconds.`);\r\n                this.setAndBroadcast(\"Offline\" /* Offline */);\r\n                // NOTE: handleWatchStreamFailure() will continue to increment\r\n                // watchStreamFailures even though we are already marked Offline,\r\n                // but this is non-harmful.\r\n                return Promise.resolve();\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Updates our OnlineState as appropriate after the watch stream reports a\r\n     * failure. The first failure moves us to the 'Unknown' state. We then may\r\n     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\r\n     * actually transition to the 'Offline' state.\r\n     */\r\n    handleWatchStreamFailure(error) {\r\n        if (this.state === \"Online\" /* Online */) {\r\n            this.setAndBroadcast(\"Unknown\" /* Unknown */);\r\n        }\r\n        else {\r\n            this.watchStreamFailures++;\r\n            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\r\n                this.clearOnlineStateTimer();\r\n                this.logClientOfflineWarningIfNecessary(`Connection failed ${MAX_WATCH_STREAM_FAILURES} ` +\r\n                    `times. Most recent error: ${error.toString()}`);\r\n                this.setAndBroadcast(\"Offline\" /* Offline */);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Explicitly sets the OnlineState to the specified state.\r\n     *\r\n     * Note that this resets our timers / failure counters, etc. used by our\r\n     * Offline heuristics, so must not be used in place of\r\n     * handleWatchStreamStart() and handleWatchStreamFailure().\r\n     */\r\n    set(newState) {\r\n        this.clearOnlineStateTimer();\r\n        this.watchStreamFailures = 0;\r\n        if (newState === \"Online\" /* Online */) {\r\n            // We've connected to watch at least once. Don't warn the developer\r\n            // about being offline going forward.\r\n            this.shouldWarnClientIsOffline = false;\r\n        }\r\n        this.setAndBroadcast(newState);\r\n    }\r\n    setAndBroadcast(newState) {\r\n        if (newState !== this.state) {\r\n            this.state = newState;\r\n            this.onlineStateHandler(newState);\r\n        }\r\n    }\r\n    logClientOfflineWarningIfNecessary(details) {\r\n        const message = `Could not reach Cloud Firestore backend. ${details}\\n` +\r\n            `This typically indicates that your device does not have a healthy ` +\r\n            `Internet connection at the moment. The client will operate in offline ` +\r\n            `mode until it is able to successfully connect to the backend.`;\r\n        if (this.shouldWarnClientIsOffline) {\r\n            logError(message);\r\n            this.shouldWarnClientIsOffline = false;\r\n        }\r\n        else {\r\n            logDebug(LOG_TAG$6, message);\r\n        }\r\n    }\r\n    clearOnlineStateTimer() {\r\n        if (this.onlineStateTimer !== null) {\r\n            this.onlineStateTimer.cancel();\r\n            this.onlineStateTimer = null;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$5 = 'RemoteStore';\r\n// TODO(b/35853402): Negotiate this with the stream.\r\nconst MAX_PENDING_WRITES = 10;\r\nclass RemoteStoreImpl {\r\n    constructor(\r\n    /**\r\n     * The local store, used to fill the write pipeline with outbound mutations.\r\n     */\r\n    localStore, \r\n    /** The client-side proxy for interacting with the backend. */\r\n    datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\r\n        this.localStore = localStore;\r\n        this.datastore = datastore;\r\n        this.asyncQueue = asyncQueue;\r\n        this.remoteSyncer = {};\r\n        /**\r\n         * A list of up to MAX_PENDING_WRITES writes that we have fetched from the\r\n         * LocalStore via fillWritePipeline() and have or will send to the write\r\n         * stream.\r\n         *\r\n         * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or\r\n         * restart the write stream. When the stream is established the writes in the\r\n         * pipeline will be sent in order.\r\n         *\r\n         * Writes remain in writePipeline until they are acknowledged by the backend\r\n         * and thus will automatically be re-sent if the stream is interrupted /\r\n         * restarted before they're acknowledged.\r\n         *\r\n         * Write responses from the backend are linked to their originating request\r\n         * purely based on order, and so we can just shift() writes from the front of\r\n         * the writePipeline as we receive responses.\r\n         */\r\n        this.writePipeline = [];\r\n        /**\r\n         * A mapping of watched targets that the client cares about tracking and the\r\n         * user has explicitly called a 'listen' for this target.\r\n         *\r\n         * These targets may or may not have been sent to or acknowledged by the\r\n         * server. On re-establishing the listen stream, these targets should be sent\r\n         * to the server. The targets removed with unlistens are removed eagerly\r\n         * without waiting for confirmation from the listen stream.\r\n         */\r\n        this.listenTargets = new Map();\r\n        /**\r\n         * A set of reasons for why the RemoteStore may be offline. If empty, the\r\n         * RemoteStore may start its network connections.\r\n         */\r\n        this.offlineCauses = new Set();\r\n        /**\r\n         * Event handlers that get called when the network is disabled or enabled.\r\n         *\r\n         * PORTING NOTE: These functions are used on the Web client to create the\r\n         * underlying streams (to support tree-shakeable streams). On Android and iOS,\r\n         * the streams are created during construction of RemoteStore.\r\n         */\r\n        this.onNetworkStatusChange = [];\r\n        this.connectivityMonitor = connectivityMonitor;\r\n        this.connectivityMonitor.addCallback((_) => {\r\n            asyncQueue.enqueueAndForget(async () => {\r\n                // Porting Note: Unlike iOS, `restartNetwork()` is called even when the\r\n                // network becomes unreachable as we don't have any other way to tear\r\n                // down our streams.\r\n                if (canUseNetwork(this)) {\r\n                    logDebug(LOG_TAG$5, 'Restarting streams for network reachability change.');\r\n                    await restartNetwork(this);\r\n                }\r\n            });\r\n        });\r\n        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);\r\n    }\r\n}\r\nfunction newRemoteStore(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {\r\n    return new RemoteStoreImpl(localStore, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);\r\n}\r\n/** Re-enables the network. Idempotent. */\r\nfunction remoteStoreEnableNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.offlineCauses.delete(0 /* UserDisabled */);\r\n    return enableNetworkInternal(remoteStoreImpl);\r\n}\r\nasync function enableNetworkInternal(remoteStoreImpl) {\r\n    if (canUseNetwork(remoteStoreImpl)) {\r\n        for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\r\n            await networkStatusHandler(/* enabled= */ true);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Temporarily disables the network. The network can be re-enabled using\r\n * enableNetwork().\r\n */\r\nasync function remoteStoreDisableNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.offlineCauses.add(0 /* UserDisabled */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    // Set the OnlineState to Offline so get()s return from cache, etc.\r\n    remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* Offline */);\r\n}\r\nasync function disableNetworkInternal(remoteStoreImpl) {\r\n    for (const networkStatusHandler of remoteStoreImpl.onNetworkStatusChange) {\r\n        await networkStatusHandler(/* enabled= */ false);\r\n    }\r\n}\r\nasync function remoteStoreShutdown(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    logDebug(LOG_TAG$5, 'RemoteStore shutting down.');\r\n    remoteStoreImpl.offlineCauses.add(5 /* Shutdown */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    remoteStoreImpl.connectivityMonitor.shutdown();\r\n    // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\r\n    // triggering spurious listener events with cached data, etc.\r\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* Unknown */);\r\n}\r\n/**\r\n * Starts new listen for the given target. Uses resume token if provided. It\r\n * is a no-op if the target of given `TargetData` is already being listened to.\r\n */\r\nfunction remoteStoreListen(remoteStore, targetData) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {\r\n        return;\r\n    }\r\n    // Mark this as something the client is currently listening for.\r\n    remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);\r\n    if (shouldStartWatchStream(remoteStoreImpl)) {\r\n        // The listen will be sent in onWatchStreamOpen\r\n        startWatchStream(remoteStoreImpl);\r\n    }\r\n    else if (ensureWatchStream(remoteStoreImpl).isOpen()) {\r\n        sendWatchRequest(remoteStoreImpl, targetData);\r\n    }\r\n}\r\n/**\r\n * Removes the listen from server. It is a no-op if the given target id is\r\n * not being listened to.\r\n */\r\nfunction remoteStoreUnlisten(remoteStore, targetId) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    const watchStream = ensureWatchStream(remoteStoreImpl);\r\n    remoteStoreImpl.listenTargets.delete(targetId);\r\n    if (watchStream.isOpen()) {\r\n        sendUnwatchRequest(remoteStoreImpl, targetId);\r\n    }\r\n    if (remoteStoreImpl.listenTargets.size === 0) {\r\n        if (watchStream.isOpen()) {\r\n            watchStream.markIdle();\r\n        }\r\n        else if (canUseNetwork(remoteStoreImpl)) {\r\n            // Revert to OnlineState.Unknown if the watch stream is not open and we\r\n            // have no listeners, since without any listens to send we cannot\r\n            // confirm if the stream is healthy and upgrade to OnlineState.Online.\r\n            remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* Unknown */);\r\n        }\r\n    }\r\n}\r\n/**\r\n * We need to increment the the expected number of pending responses we're due\r\n * from watch so we wait for the ack to process any messages from this target.\r\n */\r\nfunction sendWatchRequest(remoteStoreImpl, targetData) {\r\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);\r\n    ensureWatchStream(remoteStoreImpl).watch(targetData);\r\n}\r\n/**\r\n * We need to increment the expected number of pending responses we're due\r\n * from watch so we wait for the removal on the server before we process any\r\n * messages from this target.\r\n */\r\nfunction sendUnwatchRequest(remoteStoreImpl, targetId) {\r\n    remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);\r\n    ensureWatchStream(remoteStoreImpl).unwatch(targetId);\r\n}\r\nfunction startWatchStream(remoteStoreImpl) {\r\n    remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({\r\n        getRemoteKeysForTarget: targetId => remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId),\r\n        getTargetDataForTarget: targetId => remoteStoreImpl.listenTargets.get(targetId) || null\r\n    });\r\n    ensureWatchStream(remoteStoreImpl).start();\r\n    remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();\r\n}\r\n/**\r\n * Returns whether the watch stream should be started because it's necessary\r\n * and has not yet been started.\r\n */\r\nfunction shouldStartWatchStream(remoteStoreImpl) {\r\n    return (canUseNetwork(remoteStoreImpl) &&\r\n        !ensureWatchStream(remoteStoreImpl).isStarted() &&\r\n        remoteStoreImpl.listenTargets.size > 0);\r\n}\r\nfunction canUseNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    return remoteStoreImpl.offlineCauses.size === 0;\r\n}\r\nfunction cleanUpWatchStreamState(remoteStoreImpl) {\r\n    remoteStoreImpl.watchChangeAggregator = undefined;\r\n}\r\nasync function onWatchStreamOpen(remoteStoreImpl) {\r\n    remoteStoreImpl.listenTargets.forEach((targetData, targetId) => {\r\n        sendWatchRequest(remoteStoreImpl, targetData);\r\n    });\r\n}\r\nasync function onWatchStreamClose(remoteStoreImpl, error) {\r\n    cleanUpWatchStreamState(remoteStoreImpl);\r\n    // If we still need the watch stream, retry the connection.\r\n    if (shouldStartWatchStream(remoteStoreImpl)) {\r\n        remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error);\r\n        startWatchStream(remoteStoreImpl);\r\n    }\r\n    else {\r\n        // No need to restart watch stream because there are no active targets.\r\n        // The online state is set to unknown because there is no active attempt\r\n        // at establishing a connection\r\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* Unknown */);\r\n    }\r\n}\r\nasync function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {\r\n    // Mark the client as online since we got a message from the server\r\n    remoteStoreImpl.onlineStateTracker.set(\"Online\" /* Online */);\r\n    if (watchChange instanceof WatchTargetChange &&\r\n        watchChange.state === 2 /* Removed */ &&\r\n        watchChange.cause) {\r\n        // There was an error on a target, don't wait for a consistent snapshot\r\n        // to raise events\r\n        try {\r\n            await handleTargetError(remoteStoreImpl, watchChange);\r\n        }\r\n        catch (e) {\r\n            logDebug(LOG_TAG$5, 'Failed to remove targets %s: %s ', watchChange.targetIds.join(','), e);\r\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\r\n        }\r\n        return;\r\n    }\r\n    if (watchChange instanceof DocumentWatchChange) {\r\n        remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);\r\n    }\r\n    else if (watchChange instanceof ExistenceFilterChange) {\r\n        remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);\r\n    }\r\n    else {\r\n        remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);\r\n    }\r\n    if (!snapshotVersion.isEqual(SnapshotVersion.min())) {\r\n        try {\r\n            const lastRemoteSnapshotVersion = await localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\r\n            if (snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0) {\r\n                // We have received a target change with a global snapshot if the snapshot\r\n                // version is not equal to SnapshotVersion.min().\r\n                await raiseWatchSnapshot(remoteStoreImpl, snapshotVersion);\r\n            }\r\n        }\r\n        catch (e) {\r\n            logDebug(LOG_TAG$5, 'Failed to raise snapshot:', e);\r\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Recovery logic for IndexedDB errors that takes the network offline until\r\n * `op` succeeds. Retries are scheduled with backoff using\r\n * `enqueueRetryable()`. If `op()` is not provided, IndexedDB access is\r\n * validated via a generic operation.\r\n *\r\n * The returned Promise is resolved once the network is disabled and before\r\n * any retry attempt.\r\n */\r\nasync function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {\r\n    if (isIndexedDbTransactionError(e)) {\r\n        remoteStoreImpl.offlineCauses.add(1 /* IndexedDbFailed */);\r\n        // Disable network and raise offline snapshots\r\n        await disableNetworkInternal(remoteStoreImpl);\r\n        remoteStoreImpl.onlineStateTracker.set(\"Offline\" /* Offline */);\r\n        if (!op) {\r\n            // Use a simple read operation to determine if IndexedDB recovered.\r\n            // Ideally, we would expose a health check directly on SimpleDb, but\r\n            // RemoteStore only has access to persistence through LocalStore.\r\n            op = () => localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);\r\n        }\r\n        // Probe IndexedDB periodically and re-enable network\r\n        remoteStoreImpl.asyncQueue.enqueueRetryable(async () => {\r\n            logDebug(LOG_TAG$5, 'Retrying IndexedDB access');\r\n            await op();\r\n            remoteStoreImpl.offlineCauses.delete(1 /* IndexedDbFailed */);\r\n            await enableNetworkInternal(remoteStoreImpl);\r\n        });\r\n    }\r\n    else {\r\n        throw e;\r\n    }\r\n}\r\n/**\r\n * Executes `op`. If `op` fails, takes the network offline until `op`\r\n * succeeds. Returns after the first attempt.\r\n */\r\nfunction executeWithRecovery(remoteStoreImpl, op) {\r\n    return op().catch(e => disableNetworkUntilRecovery(remoteStoreImpl, e, op));\r\n}\r\n/**\r\n * Takes a batch of changes from the Datastore, repackages them as a\r\n * RemoteEvent, and passes that on to the listener, which is typically the\r\n * SyncEngine.\r\n */\r\nfunction raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {\r\n    const remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);\r\n    // Update in-memory resume tokens. LocalStore will update the\r\n    // persistent view of these when applying the completed RemoteEvent.\r\n    remoteEvent.targetChanges.forEach((change, targetId) => {\r\n        if (change.resumeToken.approximateByteSize() > 0) {\r\n            const targetData = remoteStoreImpl.listenTargets.get(targetId);\r\n            // A watched target might have been removed already.\r\n            if (targetData) {\r\n                remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));\r\n            }\r\n        }\r\n    });\r\n    // Re-establish listens for the targets that have been invalidated by\r\n    // existence filter mismatches.\r\n    remoteEvent.targetMismatches.forEach(targetId => {\r\n        const targetData = remoteStoreImpl.listenTargets.get(targetId);\r\n        if (!targetData) {\r\n            // A watched target might have been removed already.\r\n            return;\r\n        }\r\n        // Clear the resume token for the target, since we're in a known mismatch\r\n        // state.\r\n        remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));\r\n        // Cause a hard reset by unwatching and rewatching immediately, but\r\n        // deliberately don't send a resume token so that we get a full update.\r\n        sendUnwatchRequest(remoteStoreImpl, targetId);\r\n        // Mark the target we send as being on behalf of an existence filter\r\n        // mismatch, but don't actually retain that in listenTargets. This ensures\r\n        // that we flag the first re-listen this way without impacting future\r\n        // listens of this target (that might happen e.g. on reconnect).\r\n        const requestTargetData = new TargetData(targetData.target, targetId, 1 /* ExistenceFilterMismatch */, targetData.sequenceNumber);\r\n        sendWatchRequest(remoteStoreImpl, requestTargetData);\r\n    });\r\n    return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);\r\n}\r\n/** Handles an error on a target */\r\nasync function handleTargetError(remoteStoreImpl, watchChange) {\r\n    const error = watchChange.cause;\r\n    for (const targetId of watchChange.targetIds) {\r\n        // A watched target might have been removed already.\r\n        if (remoteStoreImpl.listenTargets.has(targetId)) {\r\n            await remoteStoreImpl.remoteSyncer.rejectListen(targetId, error);\r\n            remoteStoreImpl.listenTargets.delete(targetId);\r\n            remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Attempts to fill our write pipeline with writes from the LocalStore.\r\n *\r\n * Called internally to bootstrap or refill the write pipeline and by\r\n * SyncEngine whenever there are new mutations to process.\r\n *\r\n * Starts the write stream if necessary.\r\n */\r\nasync function fillWritePipeline(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    const writeStream = ensureWriteStream(remoteStoreImpl);\r\n    let lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0\r\n        ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1]\r\n            .batchId\r\n        : BATCHID_UNKNOWN;\r\n    while (canAddToWritePipeline(remoteStoreImpl)) {\r\n        try {\r\n            const batch = await localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved);\r\n            if (batch === null) {\r\n                if (remoteStoreImpl.writePipeline.length === 0) {\r\n                    writeStream.markIdle();\r\n                }\r\n                break;\r\n            }\r\n            else {\r\n                lastBatchIdRetrieved = batch.batchId;\r\n                addToWritePipeline(remoteStoreImpl, batch);\r\n            }\r\n        }\r\n        catch (e) {\r\n            await disableNetworkUntilRecovery(remoteStoreImpl, e);\r\n        }\r\n    }\r\n    if (shouldStartWriteStream(remoteStoreImpl)) {\r\n        startWriteStream(remoteStoreImpl);\r\n    }\r\n}\r\n/**\r\n * Returns true if we can add to the write pipeline (i.e. the network is\r\n * enabled and the write pipeline is not full).\r\n */\r\nfunction canAddToWritePipeline(remoteStoreImpl) {\r\n    return (canUseNetwork(remoteStoreImpl) &&\r\n        remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES);\r\n}\r\n/**\r\n * Queues additional writes to be sent to the write stream, sending them\r\n * immediately if the write stream is established.\r\n */\r\nfunction addToWritePipeline(remoteStoreImpl, batch) {\r\n    remoteStoreImpl.writePipeline.push(batch);\r\n    const writeStream = ensureWriteStream(remoteStoreImpl);\r\n    if (writeStream.isOpen() && writeStream.handshakeComplete) {\r\n        writeStream.writeMutations(batch.mutations);\r\n    }\r\n}\r\nfunction shouldStartWriteStream(remoteStoreImpl) {\r\n    return (canUseNetwork(remoteStoreImpl) &&\r\n        !ensureWriteStream(remoteStoreImpl).isStarted() &&\r\n        remoteStoreImpl.writePipeline.length > 0);\r\n}\r\nfunction startWriteStream(remoteStoreImpl) {\r\n    ensureWriteStream(remoteStoreImpl).start();\r\n}\r\nasync function onWriteStreamOpen(remoteStoreImpl) {\r\n    ensureWriteStream(remoteStoreImpl).writeHandshake();\r\n}\r\nasync function onWriteHandshakeComplete(remoteStoreImpl) {\r\n    const writeStream = ensureWriteStream(remoteStoreImpl);\r\n    // Send the write pipeline now that the stream is established.\r\n    for (const batch of remoteStoreImpl.writePipeline) {\r\n        writeStream.writeMutations(batch.mutations);\r\n    }\r\n}\r\nasync function onMutationResult(remoteStoreImpl, commitVersion, results) {\r\n    const batch = remoteStoreImpl.writePipeline.shift();\r\n    const success = MutationBatchResult.from(batch, commitVersion, results);\r\n    await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success));\r\n    // It's possible that with the completion of this mutation another\r\n    // slot has freed up.\r\n    await fillWritePipeline(remoteStoreImpl);\r\n}\r\nasync function onWriteStreamClose(remoteStoreImpl, error) {\r\n    // If the write stream closed after the write handshake completes, a write\r\n    // operation failed and we fail the pending operation.\r\n    if (error && ensureWriteStream(remoteStoreImpl).handshakeComplete) {\r\n        // This error affects the actual write.\r\n        await handleWriteError(remoteStoreImpl, error);\r\n    }\r\n    // The write stream might have been started by refilling the write\r\n    // pipeline for failed writes\r\n    if (shouldStartWriteStream(remoteStoreImpl)) {\r\n        startWriteStream(remoteStoreImpl);\r\n    }\r\n}\r\nasync function handleWriteError(remoteStoreImpl, error) {\r\n    // Only handle permanent errors here. If it's transient, just let the retry\r\n    // logic kick in.\r\n    if (isPermanentWriteError(error.code)) {\r\n        // This was a permanent error, the request itself was the problem\r\n        // so it's not going to succeed if we resend it.\r\n        const batch = remoteStoreImpl.writePipeline.shift();\r\n        // In this case it's also unlikely that the server itself is melting\r\n        // down -- this was just a bad request so inhibit backoff on the next\r\n        // restart.\r\n        ensureWriteStream(remoteStoreImpl).inhibitBackoff();\r\n        await executeWithRecovery(remoteStoreImpl, () => remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch.batchId, error));\r\n        // It's possible that with the completion of this mutation\r\n        // another slot has freed up.\r\n        await fillWritePipeline(remoteStoreImpl);\r\n    }\r\n}\r\nasync function restartNetwork(remoteStore) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.offlineCauses.add(4 /* ConnectivityChange */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* Unknown */);\r\n    remoteStoreImpl.offlineCauses.delete(4 /* ConnectivityChange */);\r\n    await enableNetworkInternal(remoteStoreImpl);\r\n}\r\nasync function remoteStoreHandleCredentialChange(remoteStore, user) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    remoteStoreImpl.asyncQueue.verifyOperationInProgress();\r\n    logDebug(LOG_TAG$5, 'RemoteStore received new credentials');\r\n    const usesNetwork = canUseNetwork(remoteStoreImpl);\r\n    // Tear down and re-create our network streams. This will ensure we get a\r\n    // fresh auth token for the new user and re-fill the write pipeline with\r\n    // new mutations from the LocalStore (since mutations are per-user).\r\n    remoteStoreImpl.offlineCauses.add(3 /* CredentialChange */);\r\n    await disableNetworkInternal(remoteStoreImpl);\r\n    if (usesNetwork) {\r\n        // Don't set the network status to Unknown if we are offline.\r\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* Unknown */);\r\n    }\r\n    await remoteStoreImpl.remoteSyncer.handleCredentialChange(user);\r\n    remoteStoreImpl.offlineCauses.delete(3 /* CredentialChange */);\r\n    await enableNetworkInternal(remoteStoreImpl);\r\n}\r\n/**\r\n * Toggles the network state when the client gains or loses its primary lease.\r\n */\r\nasync function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {\r\n    const remoteStoreImpl = debugCast(remoteStore);\r\n    if (isPrimary) {\r\n        remoteStoreImpl.offlineCauses.delete(2 /* IsSecondary */);\r\n        await enableNetworkInternal(remoteStoreImpl);\r\n    }\r\n    else if (!isPrimary) {\r\n        remoteStoreImpl.offlineCauses.add(2 /* IsSecondary */);\r\n        await disableNetworkInternal(remoteStoreImpl);\r\n        remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* Unknown */);\r\n    }\r\n}\r\n/**\r\n * If not yet initialized, registers the WatchStream and its network state\r\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\r\n * already available.\r\n *\r\n * PORTING NOTE: On iOS and Android, the WatchStream gets registered on startup.\r\n * This is not done on Web to allow it to be tree-shaken.\r\n */\r\nfunction ensureWatchStream(remoteStoreImpl) {\r\n    if (!remoteStoreImpl.watchStream) {\r\n        // Create stream (but note that it is not started yet).\r\n        remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\r\n            onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),\r\n            onClose: onWatchStreamClose.bind(null, remoteStoreImpl),\r\n            onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)\r\n        });\r\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\r\n            if (enabled) {\r\n                remoteStoreImpl.watchStream.inhibitBackoff();\r\n                if (shouldStartWatchStream(remoteStoreImpl)) {\r\n                    startWatchStream(remoteStoreImpl);\r\n                }\r\n                else {\r\n                    remoteStoreImpl.onlineStateTracker.set(\"Unknown\" /* Unknown */);\r\n                }\r\n            }\r\n            else {\r\n                await remoteStoreImpl.watchStream.stop();\r\n                cleanUpWatchStreamState(remoteStoreImpl);\r\n            }\r\n        });\r\n    }\r\n    return remoteStoreImpl.watchStream;\r\n}\r\n/**\r\n * If not yet initialized, registers the WriteStream and its network state\r\n * callback with `remoteStoreImpl`. Returns the existing stream if one is\r\n * already available.\r\n *\r\n * PORTING NOTE: On iOS and Android, the WriteStream gets registered on startup.\r\n * This is not done on Web to allow it to be tree-shaken.\r\n */\r\nfunction ensureWriteStream(remoteStoreImpl) {\r\n    if (!remoteStoreImpl.writeStream) {\r\n        // Create stream (but note that it is not started yet).\r\n        remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {\r\n            onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),\r\n            onClose: onWriteStreamClose.bind(null, remoteStoreImpl),\r\n            onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),\r\n            onMutationResult: onMutationResult.bind(null, remoteStoreImpl)\r\n        });\r\n        remoteStoreImpl.onNetworkStatusChange.push(async (enabled) => {\r\n            if (enabled) {\r\n                remoteStoreImpl.writeStream.inhibitBackoff();\r\n                // This will start the write stream if necessary.\r\n                await fillWritePipeline(remoteStoreImpl);\r\n            }\r\n            else {\r\n                await remoteStoreImpl.writeStream.stop();\r\n                if (remoteStoreImpl.writePipeline.length > 0) {\r\n                    logDebug(LOG_TAG$5, `Stopping write stream with ${remoteStoreImpl.writePipeline.length} pending writes`);\r\n                    remoteStoreImpl.writePipeline = [];\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return remoteStoreImpl.writeStream;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$4 = 'AsyncQueue';\r\n/**\r\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\r\n *\r\n * It is created via DelayedOperation.createAndSchedule().\r\n *\r\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\r\n *\r\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\r\n * in newer versions of TypeScript defines `finally`, which is not available in\r\n * IE.\r\n */\r\nclass DelayedOperation {\r\n    constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.timerId = timerId;\r\n        this.targetTimeMs = targetTimeMs;\r\n        this.op = op;\r\n        this.removalCallback = removalCallback;\r\n        this.deferred = new Deferred();\r\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\r\n        // It's normal for the deferred promise to be canceled (due to cancellation)\r\n        // and so we attach a dummy catch callback to avoid\r\n        // 'UnhandledPromiseRejectionWarning' log spam.\r\n        this.deferred.promise.catch(err => { });\r\n    }\r\n    /**\r\n     * Creates and returns a DelayedOperation that has been scheduled to be\r\n     * executed on the provided asyncQueue after the provided delayMs.\r\n     *\r\n     * @param asyncQueue - The queue to schedule the operation on.\r\n     * @param id - A Timer ID identifying the type of operation this is.\r\n     * @param delayMs - The delay (ms) before the operation should be scheduled.\r\n     * @param op - The operation to run.\r\n     * @param removalCallback - A callback to be called synchronously once the\r\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\r\n     *   from its delayedOperations list.\r\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\r\n     *   the DelayedOperation class public.\r\n     */\r\n    static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) {\r\n        const targetTime = Date.now() + delayMs;\r\n        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\r\n        delayedOp.start(delayMs);\r\n        return delayedOp;\r\n    }\r\n    /**\r\n     * Starts the timer. This is called immediately after construction by\r\n     * createAndSchedule().\r\n     */\r\n    start(delayMs) {\r\n        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\r\n    }\r\n    /**\r\n     * Queues the operation to run immediately (if it hasn't already been run or\r\n     * canceled).\r\n     */\r\n    skipDelay() {\r\n        return this.handleDelayElapsed();\r\n    }\r\n    /**\r\n     * Cancels the operation if it hasn't already been executed or canceled. The\r\n     * promise will be rejected.\r\n     *\r\n     * As long as the operation has not yet been run, calling cancel() provides a\r\n     * guarantee that the operation will not be run.\r\n     */\r\n    cancel(reason) {\r\n        if (this.timerHandle !== null) {\r\n            this.clearTimeout();\r\n            this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\r\n        }\r\n    }\r\n    handleDelayElapsed() {\r\n        this.asyncQueue.enqueueAndForget(() => {\r\n            if (this.timerHandle !== null) {\r\n                this.clearTimeout();\r\n                return this.op().then(result => {\r\n                    return this.deferred.resolve(result);\r\n                });\r\n            }\r\n            else {\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n    clearTimeout() {\r\n        if (this.timerHandle !== null) {\r\n            this.removalCallback(this);\r\n            clearTimeout(this.timerHandle);\r\n            this.timerHandle = null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a FirestoreError that can be surfaced to the user if the provided\r\n * error is an IndexedDbTransactionError. Re-throws the error otherwise.\r\n */\r\nfunction wrapInUserErrorIfRecoverable(e, msg) {\r\n    logError(LOG_TAG$4, `${msg}: ${e}`);\r\n    if (isIndexedDbTransactionError(e)) {\r\n        return new FirestoreError(Code.UNAVAILABLE, `${msg}: ${e}`);\r\n    }\r\n    else {\r\n        throw e;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\r\n * in order specified by the provided comparator. We always add a document key\r\n * comparator on top of what is provided to guarantee document equality based on\r\n * the key.\r\n */\r\nclass DocumentSet {\r\n    /** The default ordering is by key if the comparator is omitted */\r\n    constructor(comp) {\r\n        // We are adding document key comparator to the end as it's the only\r\n        // guaranteed unique property of a document.\r\n        if (comp) {\r\n            this.comparator = (d1, d2) => comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\r\n        }\r\n        else {\r\n            this.comparator = (d1, d2) => DocumentKey.comparator(d1.key, d2.key);\r\n        }\r\n        this.keyedMap = documentMap();\r\n        this.sortedSet = new SortedMap(this.comparator);\r\n    }\r\n    /**\r\n     * Returns an empty copy of the existing DocumentSet, using the same\r\n     * comparator.\r\n     */\r\n    static emptySet(oldSet) {\r\n        return new DocumentSet(oldSet.comparator);\r\n    }\r\n    has(key) {\r\n        return this.keyedMap.get(key) != null;\r\n    }\r\n    get(key) {\r\n        return this.keyedMap.get(key);\r\n    }\r\n    first() {\r\n        return this.sortedSet.minKey();\r\n    }\r\n    last() {\r\n        return this.sortedSet.maxKey();\r\n    }\r\n    isEmpty() {\r\n        return this.sortedSet.isEmpty();\r\n    }\r\n    /**\r\n     * Returns the index of the provided key in the document set, or -1 if the\r\n     * document key is not present in the set;\r\n     */\r\n    indexOf(key) {\r\n        const doc = this.keyedMap.get(key);\r\n        return doc ? this.sortedSet.indexOf(doc) : -1;\r\n    }\r\n    get size() {\r\n        return this.sortedSet.size;\r\n    }\r\n    /** Iterates documents in order defined by \"comparator\" */\r\n    forEach(cb) {\r\n        this.sortedSet.inorderTraversal((k, v) => {\r\n            cb(k);\r\n            return false;\r\n        });\r\n    }\r\n    /** Inserts or updates a document with the same key */\r\n    add(doc) {\r\n        // First remove the element if we have it.\r\n        const set = this.delete(doc.key);\r\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\r\n    }\r\n    /** Deletes a document with a given key */\r\n    delete(key) {\r\n        const doc = this.get(key);\r\n        if (!doc) {\r\n            return this;\r\n        }\r\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\r\n    }\r\n    isEqual(other) {\r\n        if (!(other instanceof DocumentSet)) {\r\n            return false;\r\n        }\r\n        if (this.size !== other.size) {\r\n            return false;\r\n        }\r\n        const thisIt = this.sortedSet.getIterator();\r\n        const otherIt = other.sortedSet.getIterator();\r\n        while (thisIt.hasNext()) {\r\n            const thisDoc = thisIt.getNext().key;\r\n            const otherDoc = otherIt.getNext().key;\r\n            if (!thisDoc.isEqual(otherDoc)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    toString() {\r\n        const docStrings = [];\r\n        this.forEach(doc => {\r\n            docStrings.push(doc.toString());\r\n        });\r\n        if (docStrings.length === 0) {\r\n            return 'DocumentSet ()';\r\n        }\r\n        else {\r\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\r\n        }\r\n    }\r\n    copy(keyedMap, sortedSet) {\r\n        const newSet = new DocumentSet();\r\n        newSet.comparator = this.comparator;\r\n        newSet.keyedMap = keyedMap;\r\n        newSet.sortedSet = sortedSet;\r\n        return newSet;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\r\n * duplicate events for the same doc.\r\n */\r\nclass DocumentChangeSet {\r\n    constructor() {\r\n        this.changeMap = new SortedMap(DocumentKey.comparator);\r\n    }\r\n    track(change) {\r\n        const key = change.doc.key;\r\n        const oldChange = this.changeMap.get(key);\r\n        if (!oldChange) {\r\n            this.changeMap = this.changeMap.insert(key, change);\r\n            return;\r\n        }\r\n        // Merge the new change with the existing change.\r\n        if (change.type !== 0 /* Added */ &&\r\n            oldChange.type === 3 /* Metadata */) {\r\n            this.changeMap = this.changeMap.insert(key, change);\r\n        }\r\n        else if (change.type === 3 /* Metadata */ &&\r\n            oldChange.type !== 1 /* Removed */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: oldChange.type,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else if (change.type === 2 /* Modified */ &&\r\n            oldChange.type === 2 /* Modified */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 2 /* Modified */,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else if (change.type === 2 /* Modified */ &&\r\n            oldChange.type === 0 /* Added */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 0 /* Added */,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else if (change.type === 1 /* Removed */ &&\r\n            oldChange.type === 0 /* Added */) {\r\n            this.changeMap = this.changeMap.remove(key);\r\n        }\r\n        else if (change.type === 1 /* Removed */ &&\r\n            oldChange.type === 2 /* Modified */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 1 /* Removed */,\r\n                doc: oldChange.doc\r\n            });\r\n        }\r\n        else if (change.type === 0 /* Added */ &&\r\n            oldChange.type === 1 /* Removed */) {\r\n            this.changeMap = this.changeMap.insert(key, {\r\n                type: 2 /* Modified */,\r\n                doc: change.doc\r\n            });\r\n        }\r\n        else {\r\n            // This includes these cases, which don't make sense:\r\n            // Added->Added\r\n            // Removed->Removed\r\n            // Modified->Added\r\n            // Removed->Modified\r\n            // Metadata->Added\r\n            // Removed->Metadata\r\n            fail();\r\n        }\r\n    }\r\n    getChanges() {\r\n        const changes = [];\r\n        this.changeMap.inorderTraversal((key, change) => {\r\n            changes.push(change);\r\n        });\r\n        return changes;\r\n    }\r\n}\r\nclass ViewSnapshot {\r\n    constructor(query, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges) {\r\n        this.query = query;\r\n        this.docs = docs;\r\n        this.oldDocs = oldDocs;\r\n        this.docChanges = docChanges;\r\n        this.mutatedKeys = mutatedKeys;\r\n        this.fromCache = fromCache;\r\n        this.syncStateChanged = syncStateChanged;\r\n        this.excludesMetadataChanges = excludesMetadataChanges;\r\n    }\r\n    /** Returns a view snapshot as if all documents in the snapshot were added. */\r\n    static fromInitialDocuments(query, documents, mutatedKeys, fromCache) {\r\n        const changes = [];\r\n        documents.forEach(doc => {\r\n            changes.push({ type: 0 /* Added */, doc });\r\n        });\r\n        return new ViewSnapshot(query, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, \r\n        /* syncStateChanged= */ true, \r\n        /* excludesMetadataChanges= */ false);\r\n    }\r\n    get hasPendingWrites() {\r\n        return !this.mutatedKeys.isEmpty();\r\n    }\r\n    isEqual(other) {\r\n        if (this.fromCache !== other.fromCache ||\r\n            this.syncStateChanged !== other.syncStateChanged ||\r\n            !this.mutatedKeys.isEqual(other.mutatedKeys) ||\r\n            !queryEquals(this.query, other.query) ||\r\n            !this.docs.isEqual(other.docs) ||\r\n            !this.oldDocs.isEqual(other.oldDocs)) {\r\n            return false;\r\n        }\r\n        const changes = this.docChanges;\r\n        const otherChanges = other.docChanges;\r\n        if (changes.length !== otherChanges.length) {\r\n            return false;\r\n        }\r\n        for (let i = 0; i < changes.length; i++) {\r\n            if (changes[i].type !== otherChanges[i].type ||\r\n                !changes[i].doc.isEqual(otherChanges[i].doc)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Holds the listeners and the last received ViewSnapshot for a query being\r\n * tracked by EventManager.\r\n */\r\nclass QueryListenersInfo {\r\n    constructor() {\r\n        this.viewSnap = undefined;\r\n        this.listeners = [];\r\n    }\r\n}\r\nfunction newEventManager() {\r\n    return new EventManagerImpl();\r\n}\r\nclass EventManagerImpl {\r\n    constructor() {\r\n        this.queries = new ObjectMap(q => canonifyQuery(q), queryEquals);\r\n        this.onlineState = \"Unknown\" /* Unknown */;\r\n        this.snapshotsInSyncListeners = new Set();\r\n    }\r\n}\r\nasync function eventManagerListen(eventManager, listener) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    const query = listener.query;\r\n    let firstListen = false;\r\n    let queryInfo = eventManagerImpl.queries.get(query);\r\n    if (!queryInfo) {\r\n        firstListen = true;\r\n        queryInfo = new QueryListenersInfo();\r\n    }\r\n    if (firstListen) {\r\n        try {\r\n            queryInfo.viewSnap = await eventManagerImpl.onListen(query);\r\n        }\r\n        catch (e) {\r\n            const firestoreError = wrapInUserErrorIfRecoverable(e, `Initialization of query '${stringifyQuery(listener.query)}' failed`);\r\n            listener.onError(firestoreError);\r\n            return;\r\n        }\r\n    }\r\n    eventManagerImpl.queries.set(query, queryInfo);\r\n    queryInfo.listeners.push(listener);\r\n    // Run global snapshot listeners if a consistent snapshot has been emitted.\r\n    listener.applyOnlineStateChange(eventManagerImpl.onlineState);\r\n    if (queryInfo.viewSnap) {\r\n        const raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);\r\n        if (raisedEvent) {\r\n            raiseSnapshotsInSyncEvent(eventManagerImpl);\r\n        }\r\n    }\r\n}\r\nasync function eventManagerUnlisten(eventManager, listener) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    const query = listener.query;\r\n    let lastListen = false;\r\n    const queryInfo = eventManagerImpl.queries.get(query);\r\n    if (queryInfo) {\r\n        const i = queryInfo.listeners.indexOf(listener);\r\n        if (i >= 0) {\r\n            queryInfo.listeners.splice(i, 1);\r\n            lastListen = queryInfo.listeners.length === 0;\r\n        }\r\n    }\r\n    if (lastListen) {\r\n        eventManagerImpl.queries.delete(query);\r\n        return eventManagerImpl.onUnlisten(query);\r\n    }\r\n}\r\nfunction eventManagerOnWatchChange(eventManager, viewSnaps) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    let raisedEvent = false;\r\n    for (const viewSnap of viewSnaps) {\r\n        const query = viewSnap.query;\r\n        const queryInfo = eventManagerImpl.queries.get(query);\r\n        if (queryInfo) {\r\n            for (const listener of queryInfo.listeners) {\r\n                if (listener.onViewSnapshot(viewSnap)) {\r\n                    raisedEvent = true;\r\n                }\r\n            }\r\n            queryInfo.viewSnap = viewSnap;\r\n        }\r\n    }\r\n    if (raisedEvent) {\r\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\r\n    }\r\n}\r\nfunction eventManagerOnWatchError(eventManager, query, error) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    const queryInfo = eventManagerImpl.queries.get(query);\r\n    if (queryInfo) {\r\n        for (const listener of queryInfo.listeners) {\r\n            listener.onError(error);\r\n        }\r\n    }\r\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\r\n    // after an error.\r\n    eventManagerImpl.queries.delete(query);\r\n}\r\nfunction eventManagerOnOnlineStateChange(eventManager, onlineState) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    eventManagerImpl.onlineState = onlineState;\r\n    let raisedEvent = false;\r\n    eventManagerImpl.queries.forEach((_, queryInfo) => {\r\n        for (const listener of queryInfo.listeners) {\r\n            // Run global snapshot listeners if a consistent snapshot has been emitted.\r\n            if (listener.applyOnlineStateChange(onlineState)) {\r\n                raisedEvent = true;\r\n            }\r\n        }\r\n    });\r\n    if (raisedEvent) {\r\n        raiseSnapshotsInSyncEvent(eventManagerImpl);\r\n    }\r\n}\r\nfunction addSnapshotsInSyncListener(eventManager, observer) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    eventManagerImpl.snapshotsInSyncListeners.add(observer);\r\n    // Immediately fire an initial event, indicating all existing listeners\r\n    // are in-sync.\r\n    observer.next();\r\n}\r\nfunction removeSnapshotsInSyncListener(eventManager, observer) {\r\n    const eventManagerImpl = debugCast(eventManager);\r\n    eventManagerImpl.snapshotsInSyncListeners.delete(observer);\r\n}\r\n// Call all global snapshot listeners that have been set.\r\nfunction raiseSnapshotsInSyncEvent(eventManagerImpl) {\r\n    eventManagerImpl.snapshotsInSyncListeners.forEach(observer => {\r\n        observer.next();\r\n    });\r\n}\r\n/**\r\n * QueryListener takes a series of internal view snapshots and determines\r\n * when to raise the event.\r\n *\r\n * It uses an Observer to dispatch events.\r\n */\r\nclass QueryListener {\r\n    constructor(query, queryObserver, options) {\r\n        this.query = query;\r\n        this.queryObserver = queryObserver;\r\n        /**\r\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\r\n         * observer. This flag is set to true once we've actually raised an event.\r\n         */\r\n        this.raisedInitialEvent = false;\r\n        this.snap = null;\r\n        this.onlineState = \"Unknown\" /* Unknown */;\r\n        this.options = options || {};\r\n    }\r\n    /**\r\n     * Applies the new ViewSnapshot to this listener, raising a user-facing event\r\n     * if applicable (depending on what changed, whether the user has opted into\r\n     * metadata-only changes, etc.). Returns true if a user-facing event was\r\n     * indeed raised.\r\n     */\r\n    onViewSnapshot(snap) {\r\n        if (!this.options.includeMetadataChanges) {\r\n            // Remove the metadata only changes.\r\n            const docChanges = [];\r\n            for (const docChange of snap.docChanges) {\r\n                if (docChange.type !== 3 /* Metadata */) {\r\n                    docChanges.push(docChange);\r\n                }\r\n            }\r\n            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, \r\n            /* excludesMetadataChanges= */ true);\r\n        }\r\n        let raisedEvent = false;\r\n        if (!this.raisedInitialEvent) {\r\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\r\n                this.raiseInitialEvent(snap);\r\n                raisedEvent = true;\r\n            }\r\n        }\r\n        else if (this.shouldRaiseEvent(snap)) {\r\n            this.queryObserver.next(snap);\r\n            raisedEvent = true;\r\n        }\r\n        this.snap = snap;\r\n        return raisedEvent;\r\n    }\r\n    onError(error) {\r\n        this.queryObserver.error(error);\r\n    }\r\n    /** Returns whether a snapshot was raised. */\r\n    applyOnlineStateChange(onlineState) {\r\n        this.onlineState = onlineState;\r\n        let raisedEvent = false;\r\n        if (this.snap &&\r\n            !this.raisedInitialEvent &&\r\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\r\n            this.raiseInitialEvent(this.snap);\r\n            raisedEvent = true;\r\n        }\r\n        return raisedEvent;\r\n    }\r\n    shouldRaiseInitialEvent(snap, onlineState) {\r\n        // Always raise the first event when we're synced\r\n        if (!snap.fromCache) {\r\n            return true;\r\n        }\r\n        // NOTE: We consider OnlineState.Unknown as online (it should become Offline\r\n        // or Online if we wait long enough).\r\n        const maybeOnline = onlineState !== \"Offline\" /* Offline */;\r\n        // Don't raise the event if we're online, aren't synced yet (checked\r\n        // above) and are waiting for a sync.\r\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\r\n            return false;\r\n        }\r\n        // Raise data from cache if we have any documents or we are offline\r\n        return !snap.docs.isEmpty() || onlineState === \"Offline\" /* Offline */;\r\n    }\r\n    shouldRaiseEvent(snap) {\r\n        // We don't need to handle includeDocumentMetadataChanges here because\r\n        // the Metadata only changes have already been stripped out if needed.\r\n        // At this point the only changes we will see are the ones we should\r\n        // propagate.\r\n        if (snap.docChanges.length > 0) {\r\n            return true;\r\n        }\r\n        const hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\r\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\r\n            return this.options.includeMetadataChanges === true;\r\n        }\r\n        // Generally we should have hit one of the cases above, but it's possible\r\n        // to get here if there were only metadata docChanges and they got\r\n        // stripped out.\r\n        return false;\r\n    }\r\n    raiseInitialEvent(snap) {\r\n        snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache);\r\n        this.raisedInitialEvent = true;\r\n        this.queryObserver.next(snap);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A set of changes to what documents are currently in view and out of view for\r\n * a given query. These changes are sent to the LocalStore by the View (via\r\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\r\n */\r\nclass LocalViewChanges {\r\n    constructor(targetId, fromCache, addedKeys, removedKeys) {\r\n        this.targetId = targetId;\r\n        this.fromCache = fromCache;\r\n        this.addedKeys = addedKeys;\r\n        this.removedKeys = removedKeys;\r\n    }\r\n    static fromSnapshot(targetId, viewSnapshot) {\r\n        let addedKeys = documentKeySet();\r\n        let removedKeys = documentKeySet();\r\n        for (const docChange of viewSnapshot.docChanges) {\r\n            switch (docChange.type) {\r\n                case 0 /* Added */:\r\n                    addedKeys = addedKeys.add(docChange.doc.key);\r\n                    break;\r\n                case 1 /* Removed */:\r\n                    removedKeys = removedKeys.add(docChange.doc.key);\r\n                    break;\r\n                // do nothing\r\n            }\r\n        }\r\n        return new LocalViewChanges(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass BundleLoadResult {\r\n    constructor(progress, changedDocs) {\r\n        this.progress = progress;\r\n        this.changedDocs = changedDocs;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Helper to convert objects from bundles to model objects in the SDK.\r\n */\r\nclass BundleConverterImpl {\r\n    constructor(serializer) {\r\n        this.serializer = serializer;\r\n    }\r\n    toDocumentKey(name) {\r\n        return fromName(this.serializer, name);\r\n    }\r\n    /**\r\n     * Converts a BundleDocument to a MutableDocument.\r\n     */\r\n    toMutableDocument(bundledDoc) {\r\n        if (bundledDoc.metadata.exists) {\r\n            return fromDocument(this.serializer, bundledDoc.document, false);\r\n        }\r\n        else {\r\n            return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));\r\n        }\r\n    }\r\n    toSnapshotVersion(time) {\r\n        return fromVersion(time);\r\n    }\r\n}\r\n/**\r\n * A class to process the elements from a bundle, load them into local\r\n * storage and provide progress update while loading.\r\n */\r\nclass BundleLoader {\r\n    constructor(bundleMetadata, localStore, serializer) {\r\n        this.bundleMetadata = bundleMetadata;\r\n        this.localStore = localStore;\r\n        this.serializer = serializer;\r\n        /** Batched queries to be saved into storage */\r\n        this.queries = [];\r\n        /** Batched documents to be saved into storage */\r\n        this.documents = [];\r\n        this.progress = bundleInitialProgress(bundleMetadata);\r\n    }\r\n    /**\r\n     * Adds an element from the bundle to the loader.\r\n     *\r\n     * Returns a new progress if adding the element leads to a new progress,\r\n     * otherwise returns null.\r\n     */\r\n    addSizedElement(element) {\r\n        this.progress.bytesLoaded += element.byteLength;\r\n        let documentsLoaded = this.progress.documentsLoaded;\r\n        if (element.payload.namedQuery) {\r\n            this.queries.push(element.payload.namedQuery);\r\n        }\r\n        else if (element.payload.documentMetadata) {\r\n            this.documents.push({ metadata: element.payload.documentMetadata });\r\n            if (!element.payload.documentMetadata.exists) {\r\n                ++documentsLoaded;\r\n            }\r\n        }\r\n        else if (element.payload.document) {\r\n            this.documents[this.documents.length - 1].document =\r\n                element.payload.document;\r\n            ++documentsLoaded;\r\n        }\r\n        if (documentsLoaded !== this.progress.documentsLoaded) {\r\n            this.progress.documentsLoaded = documentsLoaded;\r\n            return Object.assign({}, this.progress);\r\n        }\r\n        return null;\r\n    }\r\n    getQueryDocumentMapping(documents) {\r\n        const queryDocumentMap = new Map();\r\n        const bundleConverter = new BundleConverterImpl(this.serializer);\r\n        for (const bundleDoc of documents) {\r\n            if (bundleDoc.metadata.queries) {\r\n                const documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);\r\n                for (const queryName of bundleDoc.metadata.queries) {\r\n                    const documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);\r\n                    queryDocumentMap.set(queryName, documentKeys);\r\n                }\r\n            }\r\n        }\r\n        return queryDocumentMap;\r\n    }\r\n    /**\r\n     * Update the progress to 'Success' and return the updated progress.\r\n     */\r\n    async complete() {\r\n        const changedDocuments = await localStoreApplyBundledDocuments(this.localStore, new BundleConverterImpl(this.serializer), this.documents, this.bundleMetadata.id);\r\n        const queryDocumentMap = this.getQueryDocumentMapping(this.documents);\r\n        for (const q of this.queries) {\r\n            await localStoreSaveNamedQuery(this.localStore, q, queryDocumentMap.get(q.name));\r\n        }\r\n        this.progress.taskState = 'Success';\r\n        return new BundleLoadResult(Object.assign({}, this.progress), changedDocuments);\r\n    }\r\n}\r\n/**\r\n * Returns a `LoadBundleTaskProgress` representing the initial progress of\r\n * loading a bundle.\r\n */\r\nfunction bundleInitialProgress(metadata) {\r\n    return {\r\n        taskState: 'Running',\r\n        documentsLoaded: 0,\r\n        bytesLoaded: 0,\r\n        totalDocuments: metadata.totalDocuments,\r\n        totalBytes: metadata.totalBytes\r\n    };\r\n}\r\n/**\r\n * Returns a `LoadBundleTaskProgress` representing the progress that the loading\r\n * has succeeded.\r\n */\r\nfunction bundleSuccessProgress(metadata) {\r\n    return {\r\n        taskState: 'Success',\r\n        documentsLoaded: metadata.totalDocuments,\r\n        bytesLoaded: metadata.totalBytes,\r\n        totalDocuments: metadata.totalDocuments,\r\n        totalBytes: metadata.totalBytes\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass AddedLimboDocument {\r\n    constructor(key) {\r\n        this.key = key;\r\n    }\r\n}\r\nclass RemovedLimboDocument {\r\n    constructor(key) {\r\n        this.key = key;\r\n    }\r\n}\r\n/**\r\n * View is responsible for computing the final merged truth of what docs are in\r\n * a query. It gets notified of local and remote changes to docs, and applies\r\n * the query filters and limits to determine the most correct possible results.\r\n */\r\nclass View {\r\n    constructor(query, \r\n    /** Documents included in the remote target */\r\n    _syncedDocuments) {\r\n        this.query = query;\r\n        this._syncedDocuments = _syncedDocuments;\r\n        this.syncState = null;\r\n        /**\r\n         * A flag whether the view is current with the backend. A view is considered\r\n         * current after it has seen the current flag from the backend and did not\r\n         * lose consistency within the watch stream (e.g. because of an existence\r\n         * filter mismatch).\r\n         */\r\n        this.current = false;\r\n        /** Documents in the view but not in the remote target */\r\n        this.limboDocuments = documentKeySet();\r\n        /** Document Keys that have local changes */\r\n        this.mutatedKeys = documentKeySet();\r\n        this.docComparator = newQueryComparator(query);\r\n        this.documentSet = new DocumentSet(this.docComparator);\r\n    }\r\n    /**\r\n     * The set of remote documents that the server has told us belongs to the target associated with\r\n     * this view.\r\n     */\r\n    get syncedDocuments() {\r\n        return this._syncedDocuments;\r\n    }\r\n    /**\r\n     * Iterates over a set of doc changes, applies the query limit, and computes\r\n     * what the new results should be, what the changes were, and whether we may\r\n     * need to go back to the local cache for more results. Does not make any\r\n     * changes to the view.\r\n     * @param docChanges - The doc changes to apply to this view.\r\n     * @param previousChanges - If this is being called with a refill, then start\r\n     *        with this set of docs and changes instead of the current view.\r\n     * @returns a new set of docs, changes, and refill flag.\r\n     */\r\n    computeDocChanges(docChanges, previousChanges) {\r\n        const changeSet = previousChanges\r\n            ? previousChanges.changeSet\r\n            : new DocumentChangeSet();\r\n        const oldDocumentSet = previousChanges\r\n            ? previousChanges.documentSet\r\n            : this.documentSet;\r\n        let newMutatedKeys = previousChanges\r\n            ? previousChanges.mutatedKeys\r\n            : this.mutatedKeys;\r\n        let newDocumentSet = oldDocumentSet;\r\n        let needsRefill = false;\r\n        // Track the last doc in a (full) limit. This is necessary, because some\r\n        // update (a delete, or an update moving a doc past the old limit) might\r\n        // mean there is some other document in the local cache that either should\r\n        // come (1) between the old last limit doc and the new last document, in the\r\n        // case of updates, or (2) after the new last document, in the case of\r\n        // deletes. So we keep this doc at the old limit to compare the updates to.\r\n        //\r\n        // Note that this should never get used in a refill (when previousChanges is\r\n        // set), because there will only be adds -- no deletes or updates.\r\n        const lastDocInLimit = hasLimitToFirst(this.query) && oldDocumentSet.size === this.query.limit\r\n            ? oldDocumentSet.last()\r\n            : null;\r\n        const firstDocInLimit = hasLimitToLast(this.query) && oldDocumentSet.size === this.query.limit\r\n            ? oldDocumentSet.first()\r\n            : null;\r\n        docChanges.inorderTraversal((key, entry) => {\r\n            const oldDoc = oldDocumentSet.get(key);\r\n            const newDoc = queryMatches(this.query, entry) ? entry : null;\r\n            const oldDocHadPendingMutations = oldDoc\r\n                ? this.mutatedKeys.has(oldDoc.key)\r\n                : false;\r\n            const newDocHasPendingMutations = newDoc\r\n                ? newDoc.hasLocalMutations ||\r\n                    // We only consider committed mutations for documents that were\r\n                    // mutated during the lifetime of the view.\r\n                    (this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations)\r\n                : false;\r\n            let changeApplied = false;\r\n            // Calculate change\r\n            if (oldDoc && newDoc) {\r\n                const docsEqual = oldDoc.data.isEqual(newDoc.data);\r\n                if (!docsEqual) {\r\n                    if (!this.shouldWaitForSyncedDocument(oldDoc, newDoc)) {\r\n                        changeSet.track({\r\n                            type: 2 /* Modified */,\r\n                            doc: newDoc\r\n                        });\r\n                        changeApplied = true;\r\n                        if ((lastDocInLimit &&\r\n                            this.docComparator(newDoc, lastDocInLimit) > 0) ||\r\n                            (firstDocInLimit &&\r\n                                this.docComparator(newDoc, firstDocInLimit) < 0)) {\r\n                            // This doc moved from inside the limit to outside the limit.\r\n                            // That means there may be some other doc in the local cache\r\n                            // that should be included instead.\r\n                            needsRefill = true;\r\n                        }\r\n                    }\r\n                }\r\n                else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {\r\n                    changeSet.track({ type: 3 /* Metadata */, doc: newDoc });\r\n                    changeApplied = true;\r\n                }\r\n            }\r\n            else if (!oldDoc && newDoc) {\r\n                changeSet.track({ type: 0 /* Added */, doc: newDoc });\r\n                changeApplied = true;\r\n            }\r\n            else if (oldDoc && !newDoc) {\r\n                changeSet.track({ type: 1 /* Removed */, doc: oldDoc });\r\n                changeApplied = true;\r\n                if (lastDocInLimit || firstDocInLimit) {\r\n                    // A doc was removed from a full limit query. We'll need to\r\n                    // requery from the local cache to see if we know about some other\r\n                    // doc that should be in the results.\r\n                    needsRefill = true;\r\n                }\r\n            }\r\n            if (changeApplied) {\r\n                if (newDoc) {\r\n                    newDocumentSet = newDocumentSet.add(newDoc);\r\n                    if (newDocHasPendingMutations) {\r\n                        newMutatedKeys = newMutatedKeys.add(key);\r\n                    }\r\n                    else {\r\n                        newMutatedKeys = newMutatedKeys.delete(key);\r\n                    }\r\n                }\r\n                else {\r\n                    newDocumentSet = newDocumentSet.delete(key);\r\n                    newMutatedKeys = newMutatedKeys.delete(key);\r\n                }\r\n            }\r\n        });\r\n        // Drop documents out to meet limit/limitToLast requirement.\r\n        if (hasLimitToFirst(this.query) || hasLimitToLast(this.query)) {\r\n            while (newDocumentSet.size > this.query.limit) {\r\n                const oldDoc = hasLimitToFirst(this.query)\r\n                    ? newDocumentSet.last()\r\n                    : newDocumentSet.first();\r\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\r\n                newMutatedKeys = newMutatedKeys.delete(oldDoc.key);\r\n                changeSet.track({ type: 1 /* Removed */, doc: oldDoc });\r\n            }\r\n        }\r\n        return {\r\n            documentSet: newDocumentSet,\r\n            changeSet,\r\n            needsRefill,\r\n            mutatedKeys: newMutatedKeys\r\n        };\r\n    }\r\n    shouldWaitForSyncedDocument(oldDoc, newDoc) {\r\n        // We suppress the initial change event for documents that were modified as\r\n        // part of a write acknowledgment (e.g. when the value of a server transform\r\n        // is applied) as Watch will send us the same document again.\r\n        // By suppressing the event, we only raise two user visible events (one with\r\n        // `hasPendingWrites` and the final state of the document) instead of three\r\n        // (one with `hasPendingWrites`, the modified document with\r\n        // `hasPendingWrites` and the final state of the document).\r\n        return (oldDoc.hasLocalMutations &&\r\n            newDoc.hasCommittedMutations &&\r\n            !newDoc.hasLocalMutations);\r\n    }\r\n    /**\r\n     * Updates the view with the given ViewDocumentChanges and optionally updates\r\n     * limbo docs and sync state from the provided target change.\r\n     * @param docChanges - The set of changes to make to the view's docs.\r\n     * @param updateLimboDocuments - Whether to update limbo documents based on\r\n     *        this change.\r\n     * @param targetChange - A target change to apply for computing limbo docs and\r\n     *        sync state.\r\n     * @returns A new ViewChange with the given docs, changes, and sync state.\r\n     */\r\n    // PORTING NOTE: The iOS/Android clients always compute limbo document changes.\r\n    applyChanges(docChanges, updateLimboDocuments, targetChange) {\r\n        const oldDocs = this.documentSet;\r\n        this.documentSet = docChanges.documentSet;\r\n        this.mutatedKeys = docChanges.mutatedKeys;\r\n        // Sort changes based on type and query comparator\r\n        const changes = docChanges.changeSet.getChanges();\r\n        changes.sort((c1, c2) => {\r\n            return (compareChangeType(c1.type, c2.type) ||\r\n                this.docComparator(c1.doc, c2.doc));\r\n        });\r\n        this.applyTargetChange(targetChange);\r\n        const limboChanges = updateLimboDocuments\r\n            ? this.updateLimboDocuments()\r\n            : [];\r\n        const synced = this.limboDocuments.size === 0 && this.current;\r\n        const newSyncState = synced ? 1 /* Synced */ : 0 /* Local */;\r\n        const syncStateChanged = newSyncState !== this.syncState;\r\n        this.syncState = newSyncState;\r\n        if (changes.length === 0 && !syncStateChanged) {\r\n            // no changes\r\n            return { limboChanges };\r\n        }\r\n        else {\r\n            const snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0 /* Local */, syncStateChanged, \r\n            /* excludesMetadataChanges= */ false);\r\n            return {\r\n                snapshot: snap,\r\n                limboChanges\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Applies an OnlineState change to the view, potentially generating a\r\n     * ViewChange if the view's syncState changes as a result.\r\n     */\r\n    applyOnlineStateChange(onlineState) {\r\n        if (this.current && onlineState === \"Offline\" /* Offline */) {\r\n            // If we're offline, set `current` to false and then call applyChanges()\r\n            // to refresh our syncState and generate a ViewChange as appropriate. We\r\n            // are guaranteed to get a new TargetChange that sets `current` back to\r\n            // true once the client is back online.\r\n            this.current = false;\r\n            return this.applyChanges({\r\n                documentSet: this.documentSet,\r\n                changeSet: new DocumentChangeSet(),\r\n                mutatedKeys: this.mutatedKeys,\r\n                needsRefill: false\r\n            }, \r\n            /* updateLimboDocuments= */ false);\r\n        }\r\n        else {\r\n            // No effect, just return a no-op ViewChange.\r\n            return { limboChanges: [] };\r\n        }\r\n    }\r\n    /**\r\n     * Returns whether the doc for the given key should be in limbo.\r\n     */\r\n    shouldBeInLimbo(key) {\r\n        // If the remote end says it's part of this query, it's not in limbo.\r\n        if (this._syncedDocuments.has(key)) {\r\n            return false;\r\n        }\r\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\r\n        if (!this.documentSet.has(key)) {\r\n            return false;\r\n        }\r\n        // If there are local changes to the doc, they might explain why the server\r\n        // doesn't know that it's part of the query. So don't put it in limbo.\r\n        // TODO(klimt): Ideally, we would only consider changes that might actually\r\n        // affect this specific query.\r\n        if (this.documentSet.get(key).hasLocalMutations) {\r\n            return false;\r\n        }\r\n        // Everything else is in limbo.\r\n        return true;\r\n    }\r\n    /**\r\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\r\n     * Returns the list of changes to which docs are in limbo.\r\n     */\r\n    applyTargetChange(targetChange) {\r\n        if (targetChange) {\r\n            targetChange.addedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.add(key)));\r\n            targetChange.modifiedDocuments.forEach(key => {\r\n            });\r\n            targetChange.removedDocuments.forEach(key => (this._syncedDocuments = this._syncedDocuments.delete(key)));\r\n            this.current = targetChange.current;\r\n        }\r\n    }\r\n    updateLimboDocuments() {\r\n        // We can only determine limbo documents when we're in-sync with the server.\r\n        if (!this.current) {\r\n            return [];\r\n        }\r\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\r\n        // updating many documents.\r\n        const oldLimboDocuments = this.limboDocuments;\r\n        this.limboDocuments = documentKeySet();\r\n        this.documentSet.forEach(doc => {\r\n            if (this.shouldBeInLimbo(doc.key)) {\r\n                this.limboDocuments = this.limboDocuments.add(doc.key);\r\n            }\r\n        });\r\n        // Diff the new limbo docs with the old limbo docs.\r\n        const changes = [];\r\n        oldLimboDocuments.forEach(key => {\r\n            if (!this.limboDocuments.has(key)) {\r\n                changes.push(new RemovedLimboDocument(key));\r\n            }\r\n        });\r\n        this.limboDocuments.forEach(key => {\r\n            if (!oldLimboDocuments.has(key)) {\r\n                changes.push(new AddedLimboDocument(key));\r\n            }\r\n        });\r\n        return changes;\r\n    }\r\n    /**\r\n     * Update the in-memory state of the current view with the state read from\r\n     * persistence.\r\n     *\r\n     * We update the query view whenever a client's primary status changes:\r\n     * - When a client transitions from primary to secondary, it can miss\r\n     *   LocalStorage updates and its query views may temporarily not be\r\n     *   synchronized with the state on disk.\r\n     * - For secondary to primary transitions, the client needs to update the list\r\n     *   of `syncedDocuments` since secondary clients update their query views\r\n     *   based purely on synthesized RemoteEvents.\r\n     *\r\n     * @param queryResult.documents - The documents that match the query according\r\n     * to the LocalStore.\r\n     * @param queryResult.remoteKeys - The keys of the documents that match the\r\n     * query according to the backend.\r\n     *\r\n     * @returns The ViewChange that resulted from this synchronization.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    synchronizeWithPersistedState(queryResult) {\r\n        this._syncedDocuments = queryResult.remoteKeys;\r\n        this.limboDocuments = documentKeySet();\r\n        const docChanges = this.computeDocChanges(queryResult.documents);\r\n        return this.applyChanges(docChanges, /*updateLimboDocuments=*/ true);\r\n    }\r\n    /**\r\n     * Returns a view snapshot as if this query was just listened to. Contains\r\n     * a document add for every existing document and the `fromCache` and\r\n     * `hasPendingWrites` status of the already established view.\r\n     */\r\n    // PORTING NOTE: Multi-tab only.\r\n    computeInitialSnapshot() {\r\n        return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0 /* Local */);\r\n    }\r\n}\r\nfunction compareChangeType(c1, c2) {\r\n    const order = (change) => {\r\n        switch (change) {\r\n            case 0 /* Added */:\r\n                return 1;\r\n            case 2 /* Modified */:\r\n                return 2;\r\n            case 3 /* Metadata */:\r\n                // A metadata change is converted to a modified change at the public\r\n                // api layer.  Since we sort by document key and then change type,\r\n                // metadata and modified changes must be sorted equivalently.\r\n                return 2;\r\n            case 1 /* Removed */:\r\n                return 0;\r\n            default:\r\n                return fail();\r\n        }\r\n    };\r\n    return order(c1) - order(c2);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$3 = 'SyncEngine';\r\n/**\r\n * QueryView contains all of the data that SyncEngine needs to keep track of for\r\n * a particular query.\r\n */\r\nclass QueryView {\r\n    constructor(\r\n    /**\r\n     * The query itself.\r\n     */\r\n    query, \r\n    /**\r\n     * The target number created by the client that is used in the watch\r\n     * stream to identify this query.\r\n     */\r\n    targetId, \r\n    /**\r\n     * The view is responsible for computing the final merged truth of what\r\n     * docs are in the query. It gets notified of local and remote changes,\r\n     * and applies the query filters and limits to determine the most correct\r\n     * possible results.\r\n     */\r\n    view) {\r\n        this.query = query;\r\n        this.targetId = targetId;\r\n        this.view = view;\r\n    }\r\n}\r\n/** Tracks a limbo resolution. */\r\nclass LimboResolution {\r\n    constructor(key) {\r\n        this.key = key;\r\n        /**\r\n         * Set to true once we've received a document. This is used in\r\n         * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to\r\n         * decide whether it needs to manufacture a delete event for the target once\r\n         * the target is CURRENT.\r\n         */\r\n        this.receivedDocument = false;\r\n    }\r\n}\r\n/**\r\n * An implementation of `SyncEngine` coordinating with other parts of SDK.\r\n *\r\n * The parts of SyncEngine that act as a callback to RemoteStore need to be\r\n * registered individually. This is done in `syncEngineWrite()` and\r\n * `syncEngineListen()` (as well as `applyPrimaryState()`) as these methods\r\n * serve as entry points to RemoteStore's functionality.\r\n *\r\n * Note: some field defined in this class might have public access level, but\r\n * the class is not exported so they are only accessible from this module.\r\n * This is useful to implement optional features (like bundles) in free\r\n * functions, such that they are tree-shakeable.\r\n */\r\nclass SyncEngineImpl {\r\n    constructor(localStore, remoteStore, eventManager, \r\n    // PORTING NOTE: Manages state synchronization in multi-tab environments.\r\n    sharedClientState, currentUser, maxConcurrentLimboResolutions) {\r\n        this.localStore = localStore;\r\n        this.remoteStore = remoteStore;\r\n        this.eventManager = eventManager;\r\n        this.sharedClientState = sharedClientState;\r\n        this.currentUser = currentUser;\r\n        this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;\r\n        this.syncEngineListener = {};\r\n        this.queryViewsByQuery = new ObjectMap(q => canonifyQuery(q), queryEquals);\r\n        this.queriesByTarget = new Map();\r\n        /**\r\n         * The keys of documents that are in limbo for which we haven't yet started a\r\n         * limbo resolution query. The strings in this set are the result of calling\r\n         * `key.path.canonicalString()` where `key` is a `DocumentKey` object.\r\n         *\r\n         * The `Set` type was chosen because it provides efficient lookup and removal\r\n         * of arbitrary elements and it also maintains insertion order, providing the\r\n         * desired queue-like FIFO semantics.\r\n         */\r\n        this.enqueuedLimboResolutions = new Set();\r\n        /**\r\n         * Keeps track of the target ID for each document that is in limbo with an\r\n         * active target.\r\n         */\r\n        this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\r\n        /**\r\n         * Keeps track of the information about an active limbo resolution for each\r\n         * active target ID that was started for the purpose of limbo resolution.\r\n         */\r\n        this.activeLimboResolutionsByTarget = new Map();\r\n        this.limboDocumentRefs = new ReferenceSet();\r\n        /** Stores user completion handlers, indexed by User and BatchId. */\r\n        this.mutationUserCallbacks = {};\r\n        /** Stores user callbacks waiting for all pending writes to be acknowledged. */\r\n        this.pendingWritesCallbacks = new Map();\r\n        this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();\r\n        this.onlineState = \"Unknown\" /* Unknown */;\r\n        // The primary state is set to `true` or `false` immediately after Firestore\r\n        // startup. In the interim, a client should only be considered primary if\r\n        // `isPrimary` is true.\r\n        this._isPrimaryClient = undefined;\r\n    }\r\n    get isPrimaryClient() {\r\n        return this._isPrimaryClient === true;\r\n    }\r\n}\r\nfunction newSyncEngine(localStore, remoteStore, eventManager, \r\n// PORTING NOTE: Manages state synchronization in multi-tab environments.\r\nsharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {\r\n    const syncEngine = new SyncEngineImpl(localStore, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);\r\n    if (isPrimary) {\r\n        syncEngine._isPrimaryClient = true;\r\n    }\r\n    return syncEngine;\r\n}\r\n/**\r\n * Initiates the new listen, resolves promise when listen enqueued to the\r\n * server. All the subsequent view snapshots or errors are sent to the\r\n * subscribed handlers. Returns the initial snapshot.\r\n */\r\nasync function syncEngineListen(syncEngine, query) {\r\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\r\n    let targetId;\r\n    let viewSnapshot;\r\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n    if (queryView) {\r\n        // PORTING NOTE: With Multi-Tab Web, it is possible that a query view\r\n        // already exists when EventManager calls us for the first time. This\r\n        // happens when the primary tab is already listening to this query on\r\n        // behalf of another tab and the user of the primary also starts listening\r\n        // to the query. EventManager will not have an assigned target ID in this\r\n        // case and calls `listen` to obtain this ID.\r\n        targetId = queryView.targetId;\r\n        syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId);\r\n        viewSnapshot = queryView.view.computeInitialSnapshot();\r\n    }\r\n    else {\r\n        const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query));\r\n        if (syncEngineImpl.isPrimaryClient) {\r\n            remoteStoreListen(syncEngineImpl.remoteStore, targetData);\r\n        }\r\n        const status = syncEngineImpl.sharedClientState.addLocalQueryTarget(targetData.targetId);\r\n        targetId = targetData.targetId;\r\n        viewSnapshot = await initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, status === 'current');\r\n    }\r\n    return viewSnapshot;\r\n}\r\n/**\r\n * Registers a view for a previously unknown query and computes its initial\r\n * snapshot.\r\n */\r\nasync function initializeViewAndComputeSnapshot(syncEngineImpl, query, targetId, current) {\r\n    // PORTING NOTE: On Web only, we inject the code that registers new Limbo\r\n    // targets based on view changes. This allows us to only depend on Limbo\r\n    // changes when user code includes queries.\r\n    syncEngineImpl.applyDocChanges = (queryView, changes, remoteEvent) => applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);\r\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, query, \r\n    /* usePreviousResults= */ true);\r\n    const view = new View(query, queryResult.remoteKeys);\r\n    const viewDocChanges = view.computeDocChanges(queryResult.documents);\r\n    const synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== \"Offline\" /* Offline */);\r\n    const viewChange = view.applyChanges(viewDocChanges, \r\n    /* updateLimboDocuments= */ syncEngineImpl.isPrimaryClient, synthesizedTargetChange);\r\n    updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);\r\n    const data = new QueryView(query, targetId, view);\r\n    syncEngineImpl.queryViewsByQuery.set(query, data);\r\n    if (syncEngineImpl.queriesByTarget.has(targetId)) {\r\n        syncEngineImpl.queriesByTarget.get(targetId).push(query);\r\n    }\r\n    else {\r\n        syncEngineImpl.queriesByTarget.set(targetId, [query]);\r\n    }\r\n    return viewChange.snapshot;\r\n}\r\n/** Stops listening to the query. */\r\nasync function syncEngineUnlisten(syncEngine, query) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n    // Only clean up the query view and target if this is the only query mapped\r\n    // to the target.\r\n    const queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);\r\n    if (queries.length > 1) {\r\n        syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(q => !queryEquals(q, query)));\r\n        syncEngineImpl.queryViewsByQuery.delete(query);\r\n        return;\r\n    }\r\n    // No other queries are mapped to the target, clean up the query and the target.\r\n    if (syncEngineImpl.isPrimaryClient) {\r\n        // We need to remove the local query target first to allow us to verify\r\n        // whether any other client is still interested in this target.\r\n        syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);\r\n        const targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);\r\n        if (!targetRemainsActive) {\r\n            await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \r\n            /*keepPersistedTargetData=*/ false)\r\n                .then(() => {\r\n                syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);\r\n                remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);\r\n                removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\r\n            })\r\n                .catch(ignoreIfPrimaryLeaseLoss);\r\n        }\r\n    }\r\n    else {\r\n        removeAndCleanupTarget(syncEngineImpl, queryView.targetId);\r\n        await localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, \r\n        /*keepPersistedTargetData=*/ true);\r\n    }\r\n}\r\n/**\r\n * Initiates the write of local mutation batch which involves adding the\r\n * writes to the mutation queue, notifying the remote store about new\r\n * mutations and raising events for any changes this write caused.\r\n *\r\n * The promise returned by this call is resolved when the above steps\r\n * have completed, *not* when the write was acked by the backend. The\r\n * userCallback is resolved once the write was acked/rejected by the\r\n * backend (or failed locally for any other reason).\r\n */\r\nasync function syncEngineWrite(syncEngine, batch, userCallback) {\r\n    const syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);\r\n    try {\r\n        const result = await localStoreWriteLocally(syncEngineImpl.localStore, batch);\r\n        syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);\r\n        addMutationCallback(syncEngineImpl, result.batchId, userCallback);\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes);\r\n        await fillWritePipeline(syncEngineImpl.remoteStore);\r\n    }\r\n    catch (e) {\r\n        // If we can't persist the mutation, we reject the user callback and\r\n        // don't send the mutation. The user can then retry the write.\r\n        const error = wrapInUserErrorIfRecoverable(e, `Failed to persist write`);\r\n        userCallback.reject(error);\r\n    }\r\n}\r\n/**\r\n * Applies one remote event to the sync engine, notifying any views of the\r\n * changes, and releasing any pending mutation batches that would become\r\n * visible because of the snapshot version the remote event contains.\r\n */\r\nasync function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    try {\r\n        const changes = await localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent);\r\n        // Update `receivedDocument` as appropriate for any limbo targets.\r\n        remoteEvent.targetChanges.forEach((targetChange, targetId) => {\r\n            const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\r\n            if (limboResolution) {\r\n                // Since this is a limbo resolution lookup, it's for a single document\r\n                // and it could be added, modified, or removed, but not a combination.\r\n                hardAssert(targetChange.addedDocuments.size +\r\n                    targetChange.modifiedDocuments.size +\r\n                    targetChange.removedDocuments.size <=\r\n                    1);\r\n                if (targetChange.addedDocuments.size > 0) {\r\n                    limboResolution.receivedDocument = true;\r\n                }\r\n                else if (targetChange.modifiedDocuments.size > 0) {\r\n                    hardAssert(limboResolution.receivedDocument);\r\n                }\r\n                else if (targetChange.removedDocuments.size > 0) {\r\n                    hardAssert(limboResolution.receivedDocument);\r\n                    limboResolution.receivedDocument = false;\r\n                }\r\n                else {\r\n                    // This was probably just a CURRENT targetChange or similar.\r\n                }\r\n            }\r\n        });\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent);\r\n    }\r\n    catch (error) {\r\n        await ignoreIfPrimaryLeaseLoss(error);\r\n    }\r\n}\r\n/**\r\n * Applies an OnlineState change to the sync engine and notifies any views of\r\n * the change.\r\n */\r\nfunction syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    // If we are the secondary client, we explicitly ignore the remote store's\r\n    // online state (the local client may go offline, even though the primary\r\n    // tab remains online) and only apply the primary tab's online state from\r\n    // SharedClientState.\r\n    if ((syncEngineImpl.isPrimaryClient &&\r\n        source === 0 /* RemoteStore */) ||\r\n        (!syncEngineImpl.isPrimaryClient &&\r\n            source === 1 /* SharedClientState */)) {\r\n        const newViewSnapshots = [];\r\n        syncEngineImpl.queryViewsByQuery.forEach((query, queryView) => {\r\n            const viewChange = queryView.view.applyOnlineStateChange(onlineState);\r\n            if (viewChange.snapshot) {\r\n                newViewSnapshots.push(viewChange.snapshot);\r\n            }\r\n        });\r\n        eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);\r\n        if (newViewSnapshots.length) {\r\n            syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\r\n        }\r\n        syncEngineImpl.onlineState = onlineState;\r\n        if (syncEngineImpl.isPrimaryClient) {\r\n            syncEngineImpl.sharedClientState.setOnlineState(onlineState);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Rejects the listen for the given targetID. This can be triggered by the\r\n * backend for any active target.\r\n *\r\n * @param syncEngine - The sync engine implementation.\r\n * @param targetId - The targetID corresponds to one previously initiated by the\r\n * user as part of TargetData passed to listen() on RemoteStore.\r\n * @param err - A description of the condition that has forced the rejection.\r\n * Nearly always this will be an indication that the user is no longer\r\n * authorized to see the data matching the target.\r\n */\r\nasync function syncEngineRejectListen(syncEngine, targetId, err) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    // PORTING NOTE: Multi-tab only.\r\n    syncEngineImpl.sharedClientState.updateQueryState(targetId, 'rejected', err);\r\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\r\n    const limboKey = limboResolution && limboResolution.key;\r\n    if (limboKey) {\r\n        // TODO(klimt): We really only should do the following on permission\r\n        // denied errors, but we don't have the cause code here.\r\n        // It's a limbo doc. Create a synthetic event saying it was deleted.\r\n        // This is kind of a hack. Ideally, we would have a method in the local\r\n        // store to purge a document. However, it would be tricky to keep all of\r\n        // the local store's invariants with another method.\r\n        let documentUpdates = new SortedMap(DocumentKey.comparator);\r\n        // TODO(b/217189216): This limbo document should ideally have a read time,\r\n        // so that it is picked up by any read-time based scans. The backend,\r\n        // however, does not send a read time for target removals.\r\n        documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));\r\n        const resolvedLimboDocuments = documentKeySet().add(limboKey);\r\n        const event = new RemoteEvent(SnapshotVersion.min(), \r\n        /* targetChanges= */ new Map(), \r\n        /* targetMismatches= */ new SortedSet(primitiveComparator), documentUpdates, resolvedLimboDocuments);\r\n        await syncEngineApplyRemoteEvent(syncEngineImpl, event);\r\n        // Since this query failed, we won't want to manually unlisten to it.\r\n        // We only remove it from bookkeeping after we successfully applied the\r\n        // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to\r\n        // this query when the RemoteStore restarts the Watch stream, which should\r\n        // re-trigger the target failure.\r\n        syncEngineImpl.activeLimboTargetsByKey =\r\n            syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);\r\n        syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);\r\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\r\n    }\r\n    else {\r\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n        /* keepPersistedTargetData */ false)\r\n            .then(() => removeAndCleanupTarget(syncEngineImpl, targetId, err))\r\n            .catch(ignoreIfPrimaryLeaseLoss);\r\n    }\r\n}\r\nasync function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const batchId = mutationBatchResult.batch.batchId;\r\n    try {\r\n        const changes = await localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult);\r\n        // The local store may or may not be able to apply the write result and\r\n        // raise events immediately (depending on whether the watcher is caught\r\n        // up), so we raise user callbacks first so that they consistently happen\r\n        // before listen events.\r\n        processUserCallback(syncEngineImpl, batchId, /*error=*/ null);\r\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\r\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'acknowledged');\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\r\n    }\r\n    catch (error) {\r\n        await ignoreIfPrimaryLeaseLoss(error);\r\n    }\r\n}\r\nasync function syncEngineRejectFailedWrite(syncEngine, batchId, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    try {\r\n        const changes = await localStoreRejectBatch(syncEngineImpl.localStore, batchId);\r\n        // The local store may or may not be able to apply the write result and\r\n        // raise events immediately (depending on whether the watcher is caught up),\r\n        // so we raise user callbacks first so that they consistently happen before\r\n        // listen events.\r\n        processUserCallback(syncEngineImpl, batchId, error);\r\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\r\n        syncEngineImpl.sharedClientState.updateMutationState(batchId, 'rejected', error);\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);\r\n    }\r\n    catch (error) {\r\n        await ignoreIfPrimaryLeaseLoss(error);\r\n    }\r\n}\r\n/**\r\n * Registers a user callback that resolves when all pending mutations at the moment of calling\r\n * are acknowledged .\r\n */\r\nasync function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    if (!canUseNetwork(syncEngineImpl.remoteStore)) {\r\n        logDebug(LOG_TAG$3, 'The network is disabled. The task returned by ' +\r\n            \"'awaitPendingWrites()' will not complete until the network is enabled.\");\r\n    }\r\n    try {\r\n        const highestBatchId = await localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore);\r\n        if (highestBatchId === BATCHID_UNKNOWN) {\r\n            // Trigger the callback right away if there is no pending writes at the moment.\r\n            callback.resolve();\r\n            return;\r\n        }\r\n        const callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];\r\n        callbacks.push(callback);\r\n        syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, 'Initialization of waitForPendingWrites() operation failed');\r\n        callback.reject(firestoreError);\r\n    }\r\n}\r\n/**\r\n * Triggers the callbacks that are waiting for this batch id to get acknowledged by server,\r\n * if there are any.\r\n */\r\nfunction triggerPendingWritesCallbacks(syncEngineImpl, batchId) {\r\n    (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(callback => {\r\n        callback.resolve();\r\n    });\r\n    syncEngineImpl.pendingWritesCallbacks.delete(batchId);\r\n}\r\n/** Reject all outstanding callbacks waiting for pending writes to complete. */\r\nfunction rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {\r\n    syncEngineImpl.pendingWritesCallbacks.forEach(callbacks => {\r\n        callbacks.forEach(callback => {\r\n            callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));\r\n        });\r\n    });\r\n    syncEngineImpl.pendingWritesCallbacks.clear();\r\n}\r\nfunction addMutationCallback(syncEngineImpl, batchId, callback) {\r\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\r\n    if (!newCallbacks) {\r\n        newCallbacks = new SortedMap(primitiveComparator);\r\n    }\r\n    newCallbacks = newCallbacks.insert(batchId, callback);\r\n    syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\r\n        newCallbacks;\r\n}\r\n/**\r\n * Resolves or rejects the user callback for the given batch and then discards\r\n * it.\r\n */\r\nfunction processUserCallback(syncEngine, batchId, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    let newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];\r\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\r\n    // okay for there to be no callback for this ID.\r\n    if (newCallbacks) {\r\n        const callback = newCallbacks.get(batchId);\r\n        if (callback) {\r\n            if (error) {\r\n                callback.reject(error);\r\n            }\r\n            else {\r\n                callback.resolve();\r\n            }\r\n            newCallbacks = newCallbacks.remove(batchId);\r\n        }\r\n        syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] =\r\n            newCallbacks;\r\n    }\r\n}\r\nfunction removeAndCleanupTarget(syncEngineImpl, targetId, error = null) {\r\n    syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);\r\n    for (const query of syncEngineImpl.queriesByTarget.get(targetId)) {\r\n        syncEngineImpl.queryViewsByQuery.delete(query);\r\n        if (error) {\r\n            syncEngineImpl.syncEngineListener.onWatchError(query, error);\r\n        }\r\n    }\r\n    syncEngineImpl.queriesByTarget.delete(targetId);\r\n    if (syncEngineImpl.isPrimaryClient) {\r\n        const limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);\r\n        limboKeys.forEach(limboKey => {\r\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);\r\n            if (!isReferenced) {\r\n                // We removed the last reference for this key\r\n                removeLimboTarget(syncEngineImpl, limboKey);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction removeLimboTarget(syncEngineImpl, key) {\r\n    syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());\r\n    // It's possible that the target already got removed because the query failed. In that case,\r\n    // the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.\r\n    const limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);\r\n    if (limboTargetId === null) {\r\n        // This target already got removed, because the query failed.\r\n        return;\r\n    }\r\n    remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);\r\n    syncEngineImpl.activeLimboTargetsByKey =\r\n        syncEngineImpl.activeLimboTargetsByKey.remove(key);\r\n    syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);\r\n    pumpEnqueuedLimboResolutions(syncEngineImpl);\r\n}\r\nfunction updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {\r\n    for (const limboChange of limboChanges) {\r\n        if (limboChange instanceof AddedLimboDocument) {\r\n            syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);\r\n            trackLimboChange(syncEngineImpl, limboChange);\r\n        }\r\n        else if (limboChange instanceof RemovedLimboDocument) {\r\n            logDebug(LOG_TAG$3, 'Document no longer in limbo: ' + limboChange.key);\r\n            syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);\r\n            const isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);\r\n            if (!isReferenced) {\r\n                // We removed the last reference for this key\r\n                removeLimboTarget(syncEngineImpl, limboChange.key);\r\n            }\r\n        }\r\n        else {\r\n            fail();\r\n        }\r\n    }\r\n}\r\nfunction trackLimboChange(syncEngineImpl, limboChange) {\r\n    const key = limboChange.key;\r\n    const keyString = key.path.canonicalString();\r\n    if (!syncEngineImpl.activeLimboTargetsByKey.get(key) &&\r\n        !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {\r\n        logDebug(LOG_TAG$3, 'New document in limbo: ' + key);\r\n        syncEngineImpl.enqueuedLimboResolutions.add(keyString);\r\n        pumpEnqueuedLimboResolutions(syncEngineImpl);\r\n    }\r\n}\r\n/**\r\n * Starts listens for documents in limbo that are enqueued for resolution,\r\n * subject to a maximum number of concurrent resolutions.\r\n *\r\n * Without bounding the number of concurrent resolutions, the server can fail\r\n * with \"resource exhausted\" errors which can lead to pathological client\r\n * behavior as seen in https://github.com/firebase/firebase-js-sdk/issues/2683.\r\n */\r\nfunction pumpEnqueuedLimboResolutions(syncEngineImpl) {\r\n    while (syncEngineImpl.enqueuedLimboResolutions.size > 0 &&\r\n        syncEngineImpl.activeLimboTargetsByKey.size <\r\n            syncEngineImpl.maxConcurrentLimboResolutions) {\r\n        const keyString = syncEngineImpl.enqueuedLimboResolutions\r\n            .values()\r\n            .next().value;\r\n        syncEngineImpl.enqueuedLimboResolutions.delete(keyString);\r\n        const key = new DocumentKey(ResourcePath.fromString(keyString));\r\n        const limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();\r\n        syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));\r\n        syncEngineImpl.activeLimboTargetsByKey =\r\n            syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);\r\n        remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, 2 /* LimboResolution */, ListenSequence.INVALID));\r\n    }\r\n}\r\nasync function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const newSnaps = [];\r\n    const docChangesInAllViews = [];\r\n    const queriesProcessed = [];\r\n    if (syncEngineImpl.queryViewsByQuery.isEmpty()) {\r\n        // Return early since `onWatchChange()` might not have been assigned yet.\r\n        return;\r\n    }\r\n    syncEngineImpl.queryViewsByQuery.forEach((_, queryView) => {\r\n        queriesProcessed.push(syncEngineImpl\r\n            .applyDocChanges(queryView, changes, remoteEvent)\r\n            .then(viewSnapshot => {\r\n            if (viewSnapshot) {\r\n                if (syncEngineImpl.isPrimaryClient) {\r\n                    syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, viewSnapshot.fromCache ? 'not-current' : 'current');\r\n                }\r\n                newSnaps.push(viewSnapshot);\r\n                const docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);\r\n                docChangesInAllViews.push(docChanges);\r\n            }\r\n        }));\r\n    });\r\n    await Promise.all(queriesProcessed);\r\n    syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);\r\n    await localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews);\r\n}\r\nasync function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {\r\n    let viewDocChanges = queryView.view.computeDocChanges(changes);\r\n    if (viewDocChanges.needsRefill) {\r\n        // The query has a limit and some docs were removed, so we need\r\n        // to re-run the query against the local store to make sure we\r\n        // didn't lose any good docs that had been past the limit.\r\n        viewDocChanges = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \r\n        /* usePreviousResults= */ false).then(({ documents }) => {\r\n            return queryView.view.computeDocChanges(documents, viewDocChanges);\r\n        });\r\n    }\r\n    const targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);\r\n    const viewChange = queryView.view.applyChanges(viewDocChanges, \r\n    /* updateLimboDocuments= */ syncEngineImpl.isPrimaryClient, targetChange);\r\n    updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);\r\n    return viewChange.snapshot;\r\n}\r\nasync function syncEngineHandleCredentialChange(syncEngine, user) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const userChanged = !syncEngineImpl.currentUser.isEqual(user);\r\n    if (userChanged) {\r\n        logDebug(LOG_TAG$3, 'User change. New user:', user.toKey());\r\n        const result = await localStoreHandleUserChange(syncEngineImpl.localStore, user);\r\n        syncEngineImpl.currentUser = user;\r\n        // Fails tasks waiting for pending writes requested by previous user.\r\n        rejectOutstandingPendingWritesCallbacks(syncEngineImpl, \"'waitForPendingWrites' promise is rejected due to a user change.\");\r\n        // TODO(b/114226417): Consider calling this only in the primary tab.\r\n        syncEngineImpl.sharedClientState.handleUserChange(user, result.removedBatchIds, result.addedBatchIds);\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments);\r\n    }\r\n}\r\nfunction syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);\r\n    if (limboResolution && limboResolution.receivedDocument) {\r\n        return documentKeySet().add(limboResolution.key);\r\n    }\r\n    else {\r\n        let keySet = documentKeySet();\r\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\r\n        if (!queries) {\r\n            return keySet;\r\n        }\r\n        for (const query of queries) {\r\n            const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n            keySet = keySet.unionWith(queryView.view.syncedDocuments);\r\n        }\r\n        return keySet;\r\n    }\r\n}\r\n/**\r\n * Reconcile the list of synced documents in an existing view with those\r\n * from persistence.\r\n */\r\nasync function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const queryResult = await localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, \r\n    /* usePreviousResults= */ true);\r\n    const viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);\r\n    if (syncEngineImpl.isPrimaryClient) {\r\n        updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);\r\n    }\r\n    return viewSnapshot;\r\n}\r\n/**\r\n * Retrieves newly changed documents from remote document cache and raises\r\n * snapshots if needed.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineSynchronizeWithChangedDocuments(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    return localStoreGetNewDocumentChanges(syncEngineImpl.localStore).then(changes => syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes));\r\n}\r\n/** Applies a mutation state to an existing batch.  */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineApplyBatchState(syncEngine, batchId, batchState, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const documents = await localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId);\r\n    if (documents === null) {\r\n        // A throttled tab may not have seen the mutation before it was completed\r\n        // and removed from the mutation queue, in which case we won't have cached\r\n        // the affected documents. In this case we can safely ignore the update\r\n        // since that means we didn't apply the mutation locally at all (if we\r\n        // had, we would have cached the affected documents), and so we will just\r\n        // see any resulting document changes via normal remote document updates\r\n        // as applicable.\r\n        logDebug(LOG_TAG$3, 'Cannot apply mutation batch with id: ' + batchId);\r\n        return;\r\n    }\r\n    if (batchState === 'pending') {\r\n        // If we are the primary client, we need to send this write to the\r\n        // backend. Secondary clients will ignore these writes since their remote\r\n        // connection is disabled.\r\n        await fillWritePipeline(syncEngineImpl.remoteStore);\r\n    }\r\n    else if (batchState === 'acknowledged' || batchState === 'rejected') {\r\n        // NOTE: Both these methods are no-ops for batches that originated from\r\n        // other clients.\r\n        processUserCallback(syncEngineImpl, batchId, error ? error : null);\r\n        triggerPendingWritesCallbacks(syncEngineImpl, batchId);\r\n        localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);\r\n    }\r\n    else {\r\n        fail();\r\n    }\r\n    await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents);\r\n}\r\n/** Applies a query target change from a different tab. */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineApplyPrimaryState(syncEngine, isPrimary) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    ensureWatchCallbacks(syncEngineImpl);\r\n    syncEngineEnsureWriteCallbacks(syncEngineImpl);\r\n    if (isPrimary === true && syncEngineImpl._isPrimaryClient !== true) {\r\n        // Secondary tabs only maintain Views for their local listeners and the\r\n        // Views internal state may not be 100% populated (in particular\r\n        // secondary tabs don't track syncedDocuments, the set of documents the\r\n        // server considers to be in the target). So when a secondary becomes\r\n        // primary, we need to need to make sure that all views for all targets\r\n        // match the state on disk.\r\n        const activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();\r\n        const activeQueries = await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray());\r\n        syncEngineImpl._isPrimaryClient = true;\r\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true);\r\n        for (const targetData of activeQueries) {\r\n            remoteStoreListen(syncEngineImpl.remoteStore, targetData);\r\n        }\r\n    }\r\n    else if (isPrimary === false && syncEngineImpl._isPrimaryClient !== false) {\r\n        const activeTargets = [];\r\n        let p = Promise.resolve();\r\n        syncEngineImpl.queriesByTarget.forEach((_, targetId) => {\r\n            if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {\r\n                activeTargets.push(targetId);\r\n            }\r\n            else {\r\n                p = p.then(() => {\r\n                    removeAndCleanupTarget(syncEngineImpl, targetId);\r\n                    return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n                    /*keepPersistedTargetData=*/ true);\r\n                });\r\n            }\r\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\r\n        });\r\n        await p;\r\n        await synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets);\r\n        resetLimboDocuments(syncEngineImpl);\r\n        syncEngineImpl._isPrimaryClient = false;\r\n        await remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false);\r\n    }\r\n}\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction resetLimboDocuments(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    syncEngineImpl.activeLimboResolutionsByTarget.forEach((_, targetId) => {\r\n        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\r\n    });\r\n    syncEngineImpl.limboDocumentRefs.removeAllReferences();\r\n    syncEngineImpl.activeLimboResolutionsByTarget = new Map();\r\n    syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);\r\n}\r\n/**\r\n * Reconcile the query views of the provided query targets with the state from\r\n * persistence. Raises snapshots for any changes that affect the local\r\n * client and returns the updated state of all target's query data.\r\n *\r\n * @param syncEngine - The sync engine implementation\r\n * @param targets - the list of targets with views that need to be recomputed\r\n * @param transitionToPrimary - `true` iff the tab transitions from a secondary\r\n * tab to a primary tab\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    const activeQueries = [];\r\n    const newViewSnapshots = [];\r\n    for (const targetId of targets) {\r\n        let targetData;\r\n        const queries = syncEngineImpl.queriesByTarget.get(targetId);\r\n        if (queries && queries.length !== 0) {\r\n            // For queries that have a local View, we fetch their current state\r\n            // from LocalStore (as the resume token and the snapshot version\r\n            // might have changed) and reconcile their views with the persisted\r\n            // state (the list of syncedDocuments may have gotten out of sync).\r\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]));\r\n            for (const query of queries) {\r\n                const queryView = syncEngineImpl.queryViewsByQuery.get(query);\r\n                const viewChange = await synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView);\r\n                if (viewChange.snapshot) {\r\n                    newViewSnapshots.push(viewChange.snapshot);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // For queries that never executed on this client, we need to\r\n            // allocate the target in LocalStore and initialize a new View.\r\n            const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\r\n            targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\r\n            await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, \r\n            /*current=*/ false);\r\n        }\r\n        activeQueries.push(targetData);\r\n    }\r\n    syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);\r\n    return activeQueries;\r\n}\r\n/**\r\n * Creates a `Query` object from the specified `Target`. There is no way to\r\n * obtain the original `Query`, so we synthesize a `Query` from the `Target`\r\n * object.\r\n *\r\n * The synthesized result might be different from the original `Query`, but\r\n * since the synthesized `Query` should return the same results as the\r\n * original one (only the presentation of results might differ), the potential\r\n * difference will not cause issues.\r\n */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction synthesizeTargetToQuery(target) {\r\n    return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, \"F\" /* First */, target.startAt, target.endAt);\r\n}\r\n/** Returns the IDs of the clients that are currently active. */\r\n// PORTING NOTE: Multi-Tab only.\r\nfunction syncEngineGetActiveClients(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    return localStoreGetActiveClients(syncEngineImpl.localStore);\r\n}\r\n/** Applies a query target change from a different tab. */\r\n// PORTING NOTE: Multi-Tab only.\r\nasync function syncEngineApplyTargetState(syncEngine, targetId, state, error) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    if (syncEngineImpl._isPrimaryClient) {\r\n        // If we receive a target state notification via WebStorage, we are\r\n        // either already secondary or another tab has taken the primary lease.\r\n        logDebug(LOG_TAG$3, 'Ignoring unexpected query state notification.');\r\n        return;\r\n    }\r\n    if (syncEngineImpl.queriesByTarget.has(targetId)) {\r\n        switch (state) {\r\n            case 'current':\r\n            case 'not-current': {\r\n                const changes = await localStoreGetNewDocumentChanges(syncEngineImpl.localStore);\r\n                const synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === 'current');\r\n                await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent);\r\n                break;\r\n            }\r\n            case 'rejected': {\r\n                await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n                /* keepPersistedTargetData */ true);\r\n                removeAndCleanupTarget(syncEngineImpl, targetId, error);\r\n                break;\r\n            }\r\n            default:\r\n                fail();\r\n        }\r\n    }\r\n}\r\n/** Adds or removes Watch targets for queries from different tabs. */\r\nasync function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {\r\n    const syncEngineImpl = ensureWatchCallbacks(syncEngine);\r\n    if (!syncEngineImpl._isPrimaryClient) {\r\n        return;\r\n    }\r\n    for (const targetId of added) {\r\n        if (syncEngineImpl.queriesByTarget.has(targetId)) {\r\n            // A target might have been added in a previous attempt\r\n            logDebug(LOG_TAG$3, 'Adding an already active target ' + targetId);\r\n            continue;\r\n        }\r\n        const target = await localStoreGetCachedTarget(syncEngineImpl.localStore, targetId);\r\n        const targetData = await localStoreAllocateTarget(syncEngineImpl.localStore, target);\r\n        await initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, \r\n        /*current=*/ false);\r\n        remoteStoreListen(syncEngineImpl.remoteStore, targetData);\r\n    }\r\n    for (const targetId of removed) {\r\n        // Check that the target is still active since the target might have been\r\n        // removed if it has been rejected by the backend.\r\n        if (!syncEngineImpl.queriesByTarget.has(targetId)) {\r\n            continue;\r\n        }\r\n        // Release queries that are still active.\r\n        await localStoreReleaseTarget(syncEngineImpl.localStore, targetId, \r\n        /* keepPersistedTargetData */ false)\r\n            .then(() => {\r\n            remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);\r\n            removeAndCleanupTarget(syncEngineImpl, targetId);\r\n        })\r\n            .catch(ignoreIfPrimaryLeaseLoss);\r\n    }\r\n}\r\nfunction ensureWatchCallbacks(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent =\r\n        syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);\r\n    syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget =\r\n        syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);\r\n    syncEngineImpl.remoteStore.remoteSyncer.rejectListen =\r\n        syncEngineRejectListen.bind(null, syncEngineImpl);\r\n    syncEngineImpl.syncEngineListener.onWatchChange =\r\n        eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);\r\n    syncEngineImpl.syncEngineListener.onWatchError =\r\n        eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);\r\n    return syncEngineImpl;\r\n}\r\nfunction syncEngineEnsureWriteCallbacks(syncEngine) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite =\r\n        syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);\r\n    syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite =\r\n        syncEngineRejectFailedWrite.bind(null, syncEngineImpl);\r\n    return syncEngineImpl;\r\n}\r\n/**\r\n * Loads a Firestore bundle into the SDK. The returned promise resolves when\r\n * the bundle finished loading.\r\n *\r\n * @param syncEngine - SyncEngine to use.\r\n * @param bundleReader - Bundle to load into the SDK.\r\n * @param task - LoadBundleTask used to update the loading progress to public API.\r\n */\r\nfunction syncEngineLoadBundle(syncEngine, bundleReader, task) {\r\n    const syncEngineImpl = debugCast(syncEngine);\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n    loadBundleImpl(syncEngineImpl, bundleReader, task).then(() => {\r\n        syncEngineImpl.sharedClientState.notifyBundleLoaded();\r\n    });\r\n}\r\nasync function loadBundleImpl(syncEngine, reader, task) {\r\n    try {\r\n        const metadata = await reader.getMetadata();\r\n        const skip = await localStoreHasNewerBundle(syncEngine.localStore, metadata);\r\n        if (skip) {\r\n            await reader.close();\r\n            task._completeWith(bundleSuccessProgress(metadata));\r\n            return;\r\n        }\r\n        task._updateProgress(bundleInitialProgress(metadata));\r\n        const loader = new BundleLoader(metadata, syncEngine.localStore, reader.serializer);\r\n        let element = await reader.nextElement();\r\n        while (element) {\r\n            ;\r\n            const progress = await loader.addSizedElement(element);\r\n            if (progress) {\r\n                task._updateProgress(progress);\r\n            }\r\n            element = await reader.nextElement();\r\n        }\r\n        const result = await loader.complete();\r\n        // TODO(b/160876443): This currently raises snapshots with\r\n        // `fromCache=false` if users already listen to some queries and bundles\r\n        // has newer version.\r\n        await syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, \r\n        /* remoteEvent */ undefined);\r\n        // Save metadata, so loading the same bundle will skip.\r\n        await localStoreSaveBundle(syncEngine.localStore, metadata);\r\n        task._completeWith(result.progress);\r\n    }\r\n    catch (e) {\r\n        logWarn(LOG_TAG$3, `Loading bundle failed with ${e}`);\r\n        task._failWith(e);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provides all components needed for Firestore with in-memory persistence.\r\n * Uses EagerGC garbage collection.\r\n */\r\nclass MemoryOfflineComponentProvider {\r\n    constructor() {\r\n        this.synchronizeTabs = false;\r\n    }\r\n    async initialize(cfg) {\r\n        this.serializer = newSerializer(cfg.databaseInfo.databaseId);\r\n        this.sharedClientState = this.createSharedClientState(cfg);\r\n        this.persistence = this.createPersistence(cfg);\r\n        await this.persistence.start();\r\n        this.gcScheduler = this.createGarbageCollectionScheduler(cfg);\r\n        this.localStore = this.createLocalStore(cfg);\r\n    }\r\n    createGarbageCollectionScheduler(cfg) {\r\n        return null;\r\n    }\r\n    createLocalStore(cfg) {\r\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\r\n    }\r\n    createPersistence(cfg) {\r\n        return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);\r\n    }\r\n    createSharedClientState(cfg) {\r\n        return new MemorySharedClientState();\r\n    }\r\n    async terminate() {\r\n        if (this.gcScheduler) {\r\n            this.gcScheduler.stop();\r\n        }\r\n        await this.sharedClientState.shutdown();\r\n        await this.persistence.shutdown();\r\n    }\r\n}\r\n/**\r\n * Provides all components needed for Firestore with IndexedDB persistence.\r\n */\r\nclass IndexedDbOfflineComponentProvider extends MemoryOfflineComponentProvider {\r\n    constructor(onlineComponentProvider, cacheSizeBytes, forceOwnership) {\r\n        super();\r\n        this.onlineComponentProvider = onlineComponentProvider;\r\n        this.cacheSizeBytes = cacheSizeBytes;\r\n        this.forceOwnership = forceOwnership;\r\n        this.synchronizeTabs = false;\r\n    }\r\n    async initialize(cfg) {\r\n        await super.initialize(cfg);\r\n        await localStoreSynchronizeLastDocumentChangeReadTime(this.localStore);\r\n        await this.onlineComponentProvider.initialize(this, cfg);\r\n        // Enqueue writes from a previous session\r\n        await syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine);\r\n        await fillWritePipeline(this.onlineComponentProvider.remoteStore);\r\n        // NOTE: This will immediately call the listener, so we make sure to\r\n        // set it after localStore / remoteStore are started.\r\n        await this.persistence.setPrimaryStateListener(() => {\r\n            if (this.gcScheduler && !this.gcScheduler.started) {\r\n                this.gcScheduler.start(this.localStore);\r\n            }\r\n            return Promise.resolve();\r\n        });\r\n    }\r\n    createLocalStore(cfg) {\r\n        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);\r\n    }\r\n    createGarbageCollectionScheduler(cfg) {\r\n        const garbageCollector = this.persistence.referenceDelegate.garbageCollector;\r\n        return new LruScheduler(garbageCollector, cfg.asyncQueue);\r\n    }\r\n    createPersistence(cfg) {\r\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\r\n        const lruParams = this.cacheSizeBytes !== undefined\r\n            ? LruParams.withCacheSize(this.cacheSizeBytes)\r\n            : LruParams.DEFAULT;\r\n        return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);\r\n    }\r\n    createSharedClientState(cfg) {\r\n        return new MemorySharedClientState();\r\n    }\r\n}\r\n/**\r\n * Provides all components needed for Firestore with multi-tab IndexedDB\r\n * persistence.\r\n *\r\n * In the legacy client, this provider is used to provide both multi-tab and\r\n * non-multi-tab persistence since we cannot tell at build time whether\r\n * `synchronizeTabs` will be enabled.\r\n */\r\nclass MultiTabOfflineComponentProvider extends IndexedDbOfflineComponentProvider {\r\n    constructor(onlineComponentProvider, cacheSizeBytes) {\r\n        super(onlineComponentProvider, cacheSizeBytes, /* forceOwnership= */ false);\r\n        this.onlineComponentProvider = onlineComponentProvider;\r\n        this.cacheSizeBytes = cacheSizeBytes;\r\n        this.synchronizeTabs = true;\r\n    }\r\n    async initialize(cfg) {\r\n        await super.initialize(cfg);\r\n        const syncEngine = this.onlineComponentProvider.syncEngine;\r\n        if (this.sharedClientState instanceof WebStorageSharedClientState) {\r\n            this.sharedClientState.syncEngine = {\r\n                applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),\r\n                applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),\r\n                applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),\r\n                getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),\r\n                synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)\r\n            };\r\n            await this.sharedClientState.start();\r\n        }\r\n        // NOTE: This will immediately call the listener, so we make sure to\r\n        // set it after localStore / remoteStore are started.\r\n        await this.persistence.setPrimaryStateListener(async (isPrimary) => {\r\n            await syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary);\r\n            if (this.gcScheduler) {\r\n                if (isPrimary && !this.gcScheduler.started) {\r\n                    this.gcScheduler.start(this.localStore);\r\n                }\r\n                else if (!isPrimary) {\r\n                    this.gcScheduler.stop();\r\n                }\r\n            }\r\n        });\r\n    }\r\n    createSharedClientState(cfg) {\r\n        const window = getWindow();\r\n        if (!WebStorageSharedClientState.isAvailable(window)) {\r\n            throw new FirestoreError(Code.UNIMPLEMENTED, 'IndexedDB persistence is only available on platforms that support LocalStorage.');\r\n        }\r\n        const persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);\r\n        return new WebStorageSharedClientState(window, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);\r\n    }\r\n}\r\n/**\r\n * Initializes and wires the components that are needed to interface with the\r\n * network.\r\n */\r\nclass OnlineComponentProvider {\r\n    async initialize(offlineComponentProvider, cfg) {\r\n        if (this.localStore) {\r\n            // OnlineComponentProvider may get initialized multiple times if\r\n            // multi-tab persistence is used.\r\n            return;\r\n        }\r\n        this.localStore = offlineComponentProvider.localStore;\r\n        this.sharedClientState = offlineComponentProvider.sharedClientState;\r\n        this.datastore = this.createDatastore(cfg);\r\n        this.remoteStore = this.createRemoteStore(cfg);\r\n        this.eventManager = this.createEventManager(cfg);\r\n        this.syncEngine = this.createSyncEngine(cfg, \r\n        /* startAsPrimary=*/ !offlineComponentProvider.synchronizeTabs);\r\n        this.sharedClientState.onlineStateHandler = onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 1 /* SharedClientState */);\r\n        this.remoteStore.remoteSyncer.handleCredentialChange =\r\n            syncEngineHandleCredentialChange.bind(null, this.syncEngine);\r\n        await remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient);\r\n    }\r\n    createEventManager(cfg) {\r\n        return newEventManager();\r\n    }\r\n    createDatastore(cfg) {\r\n        const serializer = newSerializer(cfg.databaseInfo.databaseId);\r\n        const connection = newConnection(cfg.databaseInfo);\r\n        return newDatastore(cfg.authCredentials, cfg.appCheckCredentials, connection, serializer);\r\n    }\r\n    createRemoteStore(cfg) {\r\n        return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, onlineState => syncEngineApplyOnlineStateChange(this.syncEngine, onlineState, 0 /* RemoteStore */), newConnectivityMonitor());\r\n    }\r\n    createSyncEngine(cfg, startAsPrimary) {\r\n        return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);\r\n    }\r\n    terminate() {\r\n        return remoteStoreShutdown(this.remoteStore);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * How many bytes to read each time when `ReadableStreamReader.read()` is\r\n * called. Only applicable for byte streams that we control (e.g. those backed\r\n * by an UInt8Array).\r\n */\r\nconst DEFAULT_BYTES_PER_READ = 10240;\r\n/**\r\n * Builds a `ByteStreamReader` from a UInt8Array.\r\n * @param source - The data source to use.\r\n * @param bytesPerRead - How many bytes each `read()` from the returned reader\r\n *        will read.\r\n */\r\nfunction toByteStreamReaderHelper(source, bytesPerRead = DEFAULT_BYTES_PER_READ) {\r\n    let readFrom = 0;\r\n    // The TypeScript definition for ReadableStreamReader changed. We use\r\n    // `any` here to allow this code to compile with different versions.\r\n    // See https://github.com/microsoft/TypeScript/issues/42970\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const reader = {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        async read() {\r\n            if (readFrom < source.byteLength) {\r\n                const result = {\r\n                    value: source.slice(readFrom, readFrom + bytesPerRead),\r\n                    done: false\r\n                };\r\n                readFrom += bytesPerRead;\r\n                return result;\r\n            }\r\n            return { done: true };\r\n        },\r\n        async cancel() { },\r\n        releaseLock() { },\r\n        closed: Promise.reject('unimplemented')\r\n    };\r\n    return reader;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction validateNonEmptyArgument(functionName, argumentName, argument) {\r\n    if (!argument) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() cannot be called with an empty ${argumentName}.`);\r\n    }\r\n}\r\n/**\r\n * Validates that two boolean options are not set at the same time.\r\n * @internal\r\n */\r\nfunction validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {\r\n    if (argument1 === true && argument2 === true) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `${optionName1} and ${optionName2} cannot be used together.`);\r\n    }\r\n}\r\n/**\r\n * Validates that `path` refers to a document (indicated by the fact it contains\r\n * an even numbers of segments).\r\n */\r\nfunction validateDocumentPath(path) {\r\n    if (!DocumentKey.isDocumentKey(path)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${path} has ${path.length}.`);\r\n    }\r\n}\r\n/**\r\n * Validates that `path` refers to a collection (indicated by the fact it\r\n * contains an odd numbers of segments).\r\n */\r\nfunction validateCollectionPath(path) {\r\n    if (DocumentKey.isDocumentKey(path)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${path} has ${path.length}.`);\r\n    }\r\n}\r\n/**\r\n * Returns true if it's a non-null object without a custom prototype\r\n * (i.e. excludes Array, Date, etc.).\r\n */\r\nfunction isPlainObject(input) {\r\n    return (typeof input === 'object' &&\r\n        input !== null &&\r\n        (Object.getPrototypeOf(input) === Object.prototype ||\r\n            Object.getPrototypeOf(input) === null));\r\n}\r\n/** Returns a string describing the type / value of the provided input. */\r\nfunction valueDescription(input) {\r\n    if (input === undefined) {\r\n        return 'undefined';\r\n    }\r\n    else if (input === null) {\r\n        return 'null';\r\n    }\r\n    else if (typeof input === 'string') {\r\n        if (input.length > 20) {\r\n            input = `${input.substring(0, 20)}...`;\r\n        }\r\n        return JSON.stringify(input);\r\n    }\r\n    else if (typeof input === 'number' || typeof input === 'boolean') {\r\n        return '' + input;\r\n    }\r\n    else if (typeof input === 'object') {\r\n        if (input instanceof Array) {\r\n            return 'an array';\r\n        }\r\n        else {\r\n            const customObjectName = tryGetCustomObjectType(input);\r\n            if (customObjectName) {\r\n                return `a custom ${customObjectName} object`;\r\n            }\r\n            else {\r\n                return 'an object';\r\n            }\r\n        }\r\n    }\r\n    else if (typeof input === 'function') {\r\n        return 'a function';\r\n    }\r\n    else {\r\n        return fail();\r\n    }\r\n}\r\n/** try to get the constructor name for an object. */\r\nfunction tryGetCustomObjectType(input) {\r\n    if (input.constructor) {\r\n        return input.constructor.name;\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Casts `obj` to `T`, optionally unwrapping Compat types to expose the\r\n * underlying instance. Throws if  `obj` is not an instance of `T`.\r\n *\r\n * This cast is used in the Lite and Full SDK to verify instance types for\r\n * arguments passed to the public API.\r\n * @internal\r\n */\r\nfunction cast(obj, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconstructor) {\r\n    if ('_delegate' in obj) {\r\n        // Unwrap Compat types\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        obj = obj._delegate;\r\n    }\r\n    if (!(obj instanceof constructor)) {\r\n        if (constructor.name === obj.constructor.name) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Type does not match the expected instance. Did you pass a ' +\r\n                `reference from a different Firestore SDK?`);\r\n        }\r\n        else {\r\n            const description = valueDescription(obj);\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '${constructor.name}', but it was: ${description}`);\r\n        }\r\n    }\r\n    return obj;\r\n}\r\nfunction validatePositiveNumber(functionName, n) {\r\n    if (n <= 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${functionName}() requires a positive number, but it was: ${n}.`);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * On Node, only supported data source is a `Uint8Array` for now.\r\n */\r\nfunction toByteStreamReader(source, bytesPerRead) {\r\n    if (!(source instanceof Uint8Array)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `NodePlatform.toByteStreamReader expects source to be Uint8Array, got ${valueDescription(source)}`);\r\n    }\r\n    return toByteStreamReaderHelper(source, bytesPerRead);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*\r\n * A wrapper implementation of Observer<T> that will dispatch events\r\n * asynchronously. To allow immediate silencing, a mute call is added which\r\n * causes events scheduled to no longer be raised.\r\n */\r\nclass AsyncObserver {\r\n    constructor(observer) {\r\n        this.observer = observer;\r\n        /**\r\n         * When set to true, will not raise future events. Necessary to deal with\r\n         * async detachment of listener.\r\n         */\r\n        this.muted = false;\r\n    }\r\n    next(value) {\r\n        if (this.observer.next) {\r\n            this.scheduleEvent(this.observer.next, value);\r\n        }\r\n    }\r\n    error(error) {\r\n        if (this.observer.error) {\r\n            this.scheduleEvent(this.observer.error, error);\r\n        }\r\n        else {\r\n            console.error('Uncaught Error in snapshot listener:', error);\r\n        }\r\n    }\r\n    mute() {\r\n        this.muted = true;\r\n    }\r\n    scheduleEvent(eventHandler, event) {\r\n        if (!this.muted) {\r\n            setTimeout(() => {\r\n                if (!this.muted) {\r\n                    eventHandler(event);\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A complete element in the bundle stream, together with the byte length it\r\n * occupies in the stream.\r\n */\r\nclass SizedBundleElement {\r\n    constructor(payload, \r\n    // How many bytes this element takes to store in the bundle.\r\n    byteLength) {\r\n        this.payload = payload;\r\n        this.byteLength = byteLength;\r\n    }\r\n    isBundleMetadata() {\r\n        return 'metadata' in this.payload;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A class representing a bundle.\r\n *\r\n * Takes a bundle stream or buffer, and presents abstractions to read bundled\r\n * elements out of the underlying content.\r\n */\r\nclass BundleReaderImpl {\r\n    constructor(\r\n    /** The reader to read from underlying binary bundle data source. */\r\n    reader, serializer) {\r\n        this.reader = reader;\r\n        this.serializer = serializer;\r\n        /** Cached bundle metadata. */\r\n        this.metadata = new Deferred();\r\n        /**\r\n         * Internal buffer to hold bundle content, accumulating incomplete element\r\n         * content.\r\n         */\r\n        this.buffer = new Uint8Array();\r\n        this.textDecoder = newTextDecoder();\r\n        // Read the metadata (which is the first element).\r\n        this.nextElementImpl().then(element => {\r\n            if (element && element.isBundleMetadata()) {\r\n                this.metadata.resolve(element.payload.metadata);\r\n            }\r\n            else {\r\n                this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(element === null || element === void 0 ? void 0 : element.payload)}`));\r\n            }\r\n        }, error => this.metadata.reject(error));\r\n    }\r\n    close() {\r\n        return this.reader.cancel();\r\n    }\r\n    async getMetadata() {\r\n        return this.metadata.promise;\r\n    }\r\n    async nextElement() {\r\n        // Makes sure metadata is read before proceeding.\r\n        await this.getMetadata();\r\n        return this.nextElementImpl();\r\n    }\r\n    /**\r\n     * Reads from the head of internal buffer, and pulling more data from\r\n     * underlying stream if a complete element cannot be found, until an\r\n     * element(including the prefixed length and the JSON string) is found.\r\n     *\r\n     * Once a complete element is read, it is dropped from internal buffer.\r\n     *\r\n     * Returns either the bundled element, or null if we have reached the end of\r\n     * the stream.\r\n     */\r\n    async nextElementImpl() {\r\n        const lengthBuffer = await this.readLength();\r\n        if (lengthBuffer === null) {\r\n            return null;\r\n        }\r\n        const lengthString = this.textDecoder.decode(lengthBuffer);\r\n        const length = Number(lengthString);\r\n        if (isNaN(length)) {\r\n            this.raiseError(`length string (${lengthString}) is not valid number`);\r\n        }\r\n        const jsonString = await this.readJsonString(length);\r\n        return new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length);\r\n    }\r\n    /** First index of '{' from the underlying buffer. */\r\n    indexOfOpenBracket() {\r\n        return this.buffer.findIndex(v => v === '{'.charCodeAt(0));\r\n    }\r\n    /**\r\n     * Reads from the beginning of the internal buffer, until the first '{', and\r\n     * return the content.\r\n     *\r\n     * If reached end of the stream, returns a null.\r\n     */\r\n    async readLength() {\r\n        while (this.indexOfOpenBracket() < 0) {\r\n            const done = await this.pullMoreDataToBuffer();\r\n            if (done) {\r\n                break;\r\n            }\r\n        }\r\n        // Broke out of the loop because underlying stream is closed, and there\r\n        // happens to be no more data to process.\r\n        if (this.buffer.length === 0) {\r\n            return null;\r\n        }\r\n        const position = this.indexOfOpenBracket();\r\n        // Broke out of the loop because underlying stream is closed, but still\r\n        // cannot find an open bracket.\r\n        if (position < 0) {\r\n            this.raiseError('Reached the end of bundle when a length string is expected.');\r\n        }\r\n        const result = this.buffer.slice(0, position);\r\n        // Update the internal buffer to drop the read length.\r\n        this.buffer = this.buffer.slice(position);\r\n        return result;\r\n    }\r\n    /**\r\n     * Reads from a specified position from the internal buffer, for a specified\r\n     * number of bytes, pulling more data from the underlying stream if needed.\r\n     *\r\n     * Returns a string decoded from the read bytes.\r\n     */\r\n    async readJsonString(length) {\r\n        while (this.buffer.length < length) {\r\n            const done = await this.pullMoreDataToBuffer();\r\n            if (done) {\r\n                this.raiseError('Reached the end of bundle when more is expected.');\r\n            }\r\n        }\r\n        const result = this.textDecoder.decode(this.buffer.slice(0, length));\r\n        // Update the internal buffer to drop the read json string.\r\n        this.buffer = this.buffer.slice(length);\r\n        return result;\r\n    }\r\n    raiseError(message) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.reader.cancel();\r\n        throw new Error(`Invalid bundle format: ${message}`);\r\n    }\r\n    /**\r\n     * Pulls more data from underlying stream to internal buffer.\r\n     * Returns a boolean indicating whether the stream is finished.\r\n     */\r\n    async pullMoreDataToBuffer() {\r\n        const result = await this.reader.read();\r\n        if (!result.done) {\r\n            const newBuffer = new Uint8Array(this.buffer.length + result.value.length);\r\n            newBuffer.set(this.buffer);\r\n            newBuffer.set(result.value, this.buffer.length);\r\n            this.buffer = newBuffer;\r\n        }\r\n        return result.done;\r\n    }\r\n}\r\nfunction newBundleReader(reader, serializer) {\r\n    return new BundleReaderImpl(reader, serializer);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Internal transaction object responsible for accumulating the mutations to\r\n * perform and the base versions for any documents read.\r\n */\r\nclass Transaction$2 {\r\n    constructor(datastore) {\r\n        this.datastore = datastore;\r\n        // The version of each document that was read during this transaction.\r\n        this.readVersions = new Map();\r\n        this.mutations = [];\r\n        this.committed = false;\r\n        /**\r\n         * A deferred usage error that occurred previously in this transaction that\r\n         * will cause the transaction to fail once it actually commits.\r\n         */\r\n        this.lastWriteError = null;\r\n        /**\r\n         * Set of documents that have been written in the transaction.\r\n         *\r\n         * When there's more than one write to the same key in a transaction, any\r\n         * writes after the first are handled differently.\r\n         */\r\n        this.writtenDocs = new Set();\r\n    }\r\n    async lookup(keys) {\r\n        this.ensureCommitNotCalled();\r\n        if (this.mutations.length > 0) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Firestore transactions require all reads to be executed before all writes.');\r\n        }\r\n        const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);\r\n        docs.forEach(doc => this.recordVersion(doc));\r\n        return docs;\r\n    }\r\n    set(key, data) {\r\n        this.write(data.toMutation(key, this.precondition(key)));\r\n        this.writtenDocs.add(key.toString());\r\n    }\r\n    update(key, data) {\r\n        try {\r\n            this.write(data.toMutation(key, this.preconditionForUpdate(key)));\r\n        }\r\n        catch (e) {\r\n            this.lastWriteError = e;\r\n        }\r\n        this.writtenDocs.add(key.toString());\r\n    }\r\n    delete(key) {\r\n        this.write(new DeleteMutation(key, this.precondition(key)));\r\n        this.writtenDocs.add(key.toString());\r\n    }\r\n    async commit() {\r\n        this.ensureCommitNotCalled();\r\n        if (this.lastWriteError) {\r\n            throw this.lastWriteError;\r\n        }\r\n        const unwritten = this.readVersions;\r\n        // For each mutation, note that the doc was written.\r\n        this.mutations.forEach(mutation => {\r\n            unwritten.delete(mutation.key.toString());\r\n        });\r\n        // For each document that was read but not written to, we want to perform\r\n        // a `verify` operation.\r\n        unwritten.forEach((_, path) => {\r\n            const key = DocumentKey.fromPath(path);\r\n            this.mutations.push(new VerifyMutation(key, this.precondition(key)));\r\n        });\r\n        await invokeCommitRpc(this.datastore, this.mutations);\r\n        this.committed = true;\r\n    }\r\n    recordVersion(doc) {\r\n        let docVersion;\r\n        if (doc.isFoundDocument()) {\r\n            docVersion = doc.version;\r\n        }\r\n        else if (doc.isNoDocument()) {\r\n            // For deleted docs, we must use baseVersion 0 when we overwrite them.\r\n            docVersion = SnapshotVersion.min();\r\n        }\r\n        else {\r\n            throw fail();\r\n        }\r\n        const existingVersion = this.readVersions.get(doc.key.toString());\r\n        if (existingVersion) {\r\n            if (!docVersion.isEqual(existingVersion)) {\r\n                // This transaction will fail no matter what.\r\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\r\n            }\r\n        }\r\n        else {\r\n            this.readVersions.set(doc.key.toString(), docVersion);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the version of this document when it was read in this transaction,\r\n     * as a precondition, or no precondition if it was not read.\r\n     */\r\n    precondition(key) {\r\n        const version = this.readVersions.get(key.toString());\r\n        if (!this.writtenDocs.has(key.toString()) && version) {\r\n            return Precondition.updateTime(version);\r\n        }\r\n        else {\r\n            return Precondition.none();\r\n        }\r\n    }\r\n    /**\r\n     * Returns the precondition for a document if the operation is an update.\r\n     */\r\n    preconditionForUpdate(key) {\r\n        const version = this.readVersions.get(key.toString());\r\n        // The first time a document is written, we want to take into account the\r\n        // read time and existence\r\n        if (!this.writtenDocs.has(key.toString()) && version) {\r\n            if (version.isEqual(SnapshotVersion.min())) {\r\n                // The document doesn't exist, so fail the transaction.\r\n                // This has to be validated locally because you can't send a\r\n                // precondition that a document does not exist without changing the\r\n                // semantics of the backend write to be an insert. This is the reverse\r\n                // of what we want, since we want to assert that the document doesn't\r\n                // exist but then send the update and have it fail. Since we can't\r\n                // express that to the backend, we have to validate locally.\r\n                // Note: this can change once we can send separate verify writes in the\r\n                // transaction.\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't update a document that doesn't exist.\");\r\n            }\r\n            // Document exists, base precondition on document update time.\r\n            return Precondition.updateTime(version);\r\n        }\r\n        else {\r\n            // Document was not read, so we just use the preconditions for a blind\r\n            // update.\r\n            return Precondition.exists(true);\r\n        }\r\n    }\r\n    write(mutation) {\r\n        this.ensureCommitNotCalled();\r\n        this.mutations.push(mutation);\r\n    }\r\n    ensureCommitNotCalled() {\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_MAX_ATTEMPTS_COUNT = 5;\r\n/**\r\n * TransactionRunner encapsulates the logic needed to run and retry transactions\r\n * with backoff.\r\n */\r\nclass TransactionRunner {\r\n    constructor(asyncQueue, datastore, updateFunction, deferred) {\r\n        this.asyncQueue = asyncQueue;\r\n        this.datastore = datastore;\r\n        this.updateFunction = updateFunction;\r\n        this.deferred = deferred;\r\n        this.attemptsRemaining = DEFAULT_MAX_ATTEMPTS_COUNT;\r\n        this.backoff = new ExponentialBackoff(this.asyncQueue, \"transaction_retry\" /* TransactionRetry */);\r\n    }\r\n    /** Runs the transaction and sets the result on deferred. */\r\n    run() {\r\n        this.attemptsRemaining -= 1;\r\n        this.runWithBackOff();\r\n    }\r\n    runWithBackOff() {\r\n        this.backoff.backoffAndRun(async () => {\r\n            const transaction = new Transaction$2(this.datastore);\r\n            const userPromise = this.tryRunUpdateFunction(transaction);\r\n            if (userPromise) {\r\n                userPromise\r\n                    .then(result => {\r\n                    this.asyncQueue.enqueueAndForget(() => {\r\n                        return transaction\r\n                            .commit()\r\n                            .then(() => {\r\n                            this.deferred.resolve(result);\r\n                        })\r\n                            .catch(commitError => {\r\n                            this.handleTransactionError(commitError);\r\n                        });\r\n                    });\r\n                })\r\n                    .catch(userPromiseError => {\r\n                    this.handleTransactionError(userPromiseError);\r\n                });\r\n            }\r\n        });\r\n    }\r\n    tryRunUpdateFunction(transaction) {\r\n        try {\r\n            const userPromise = this.updateFunction(transaction);\r\n            if (isNullOrUndefined(userPromise) ||\r\n                !userPromise.catch ||\r\n                !userPromise.then) {\r\n                this.deferred.reject(Error('Transaction callback must return a Promise'));\r\n                return null;\r\n            }\r\n            return userPromise;\r\n        }\r\n        catch (error) {\r\n            // Do not retry errors thrown by user provided updateFunction.\r\n            this.deferred.reject(error);\r\n            return null;\r\n        }\r\n    }\r\n    handleTransactionError(error) {\r\n        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) {\r\n            this.attemptsRemaining -= 1;\r\n            this.asyncQueue.enqueueAndForget(() => {\r\n                this.runWithBackOff();\r\n                return Promise.resolve();\r\n            });\r\n        }\r\n        else {\r\n            this.deferred.reject(error);\r\n        }\r\n    }\r\n    isRetryableTransactionError(error) {\r\n        if (error.name === 'FirebaseError') {\r\n            // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\r\n            // non-matching document versions with ABORTED. These errors should be retried.\r\n            const code = error.code;\r\n            return (code === 'aborted' ||\r\n                code === 'failed-precondition' ||\r\n                !isPermanentError(code));\r\n        }\r\n        return false;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$2 = 'FirestoreClient';\r\nconst MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;\r\n/**\r\n * FirestoreClient is a top-level class that constructs and owns all of the\r\n * pieces of the client SDK architecture. It is responsible for creating the\r\n * async queue that is shared by all of the other components in the system.\r\n */\r\nclass FirestoreClient {\r\n    constructor(authCredentials, appCheckCredentials, \r\n    /**\r\n     * Asynchronous queue responsible for all of our internal processing. When\r\n     * we get incoming work from the user (via public API) or the network\r\n     * (incoming GRPC messages), we should always schedule onto this queue.\r\n     * This ensures all of our work is properly serialized (e.g. we don't\r\n     * start processing a new operation while the previous one is waiting for\r\n     * an async I/O to complete).\r\n     */\r\n    asyncQueue, databaseInfo) {\r\n        this.authCredentials = authCredentials;\r\n        this.appCheckCredentials = appCheckCredentials;\r\n        this.asyncQueue = asyncQueue;\r\n        this.databaseInfo = databaseInfo;\r\n        this.user = User.UNAUTHENTICATED;\r\n        this.clientId = AutoId.newId();\r\n        this.authCredentialListener = () => Promise.resolve();\r\n        this.appCheckCredentialListener = () => Promise.resolve();\r\n        this.authCredentials.start(asyncQueue, async (user) => {\r\n            logDebug(LOG_TAG$2, 'Received user=', user.uid);\r\n            await this.authCredentialListener(user);\r\n            this.user = user;\r\n        });\r\n        this.appCheckCredentials.start(asyncQueue, newAppCheckToken => {\r\n            logDebug(LOG_TAG$2, 'Received new app check token=', newAppCheckToken);\r\n            return this.appCheckCredentialListener(newAppCheckToken, this.user);\r\n        });\r\n    }\r\n    async getConfiguration() {\r\n        return {\r\n            asyncQueue: this.asyncQueue,\r\n            databaseInfo: this.databaseInfo,\r\n            clientId: this.clientId,\r\n            authCredentials: this.authCredentials,\r\n            appCheckCredentials: this.appCheckCredentials,\r\n            initialUser: this.user,\r\n            maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS\r\n        };\r\n    }\r\n    setCredentialChangeListener(listener) {\r\n        this.authCredentialListener = listener;\r\n    }\r\n    setAppCheckTokenChangeListener(listener) {\r\n        this.appCheckCredentialListener = listener;\r\n    }\r\n    /**\r\n     * Checks that the client has not been terminated. Ensures that other methods on\r\n     * this class cannot be called after the client is terminated.\r\n     */\r\n    verifyNotTerminated() {\r\n        if (this.asyncQueue.isShuttingDown) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');\r\n        }\r\n    }\r\n    terminate() {\r\n        this.asyncQueue.enterRestrictedMode();\r\n        const deferred = new Deferred();\r\n        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {\r\n            try {\r\n                if (this.onlineComponents) {\r\n                    await this.onlineComponents.terminate();\r\n                }\r\n                if (this.offlineComponents) {\r\n                    await this.offlineComponents.terminate();\r\n                }\r\n                // The credentials provider must be terminated after shutting down the\r\n                // RemoteStore as it will prevent the RemoteStore from retrieving auth\r\n                // tokens.\r\n                this.authCredentials.shutdown();\r\n                this.appCheckCredentials.shutdown();\r\n                deferred.resolve();\r\n            }\r\n            catch (e) {\r\n                const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to shutdown persistence`);\r\n                deferred.reject(firestoreError);\r\n            }\r\n        });\r\n        return deferred.promise;\r\n    }\r\n}\r\nasync function setOfflineComponentProvider(client, offlineComponentProvider) {\r\n    client.asyncQueue.verifyOperationInProgress();\r\n    logDebug(LOG_TAG$2, 'Initializing OfflineComponentProvider');\r\n    const configuration = await client.getConfiguration();\r\n    await offlineComponentProvider.initialize(configuration);\r\n    let currentUser = configuration.initialUser;\r\n    client.setCredentialChangeListener(async (user) => {\r\n        if (!currentUser.isEqual(user)) {\r\n            await localStoreHandleUserChange(offlineComponentProvider.localStore, user);\r\n            currentUser = user;\r\n        }\r\n    });\r\n    // When a user calls clearPersistence() in one client, all other clients\r\n    // need to be terminated to allow the delete to succeed.\r\n    offlineComponentProvider.persistence.setDatabaseDeletedListener(() => client.terminate());\r\n    client.offlineComponents = offlineComponentProvider;\r\n}\r\nasync function setOnlineComponentProvider(client, onlineComponentProvider) {\r\n    client.asyncQueue.verifyOperationInProgress();\r\n    const offlineComponentProvider = await ensureOfflineComponents(client);\r\n    logDebug(LOG_TAG$2, 'Initializing OnlineComponentProvider');\r\n    const configuration = await client.getConfiguration();\r\n    await onlineComponentProvider.initialize(offlineComponentProvider, configuration);\r\n    // The CredentialChangeListener of the online component provider takes\r\n    // precedence over the offline component provider.\r\n    client.setCredentialChangeListener(user => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\r\n    client.setAppCheckTokenChangeListener((_, user) => remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user));\r\n    client.onlineComponents = onlineComponentProvider;\r\n}\r\nasync function ensureOfflineComponents(client) {\r\n    if (!client.offlineComponents) {\r\n        logDebug(LOG_TAG$2, 'Using default OfflineComponentProvider');\r\n        await setOfflineComponentProvider(client, new MemoryOfflineComponentProvider());\r\n    }\r\n    return client.offlineComponents;\r\n}\r\nasync function ensureOnlineComponents(client) {\r\n    if (!client.onlineComponents) {\r\n        logDebug(LOG_TAG$2, 'Using default OnlineComponentProvider');\r\n        await setOnlineComponentProvider(client, new OnlineComponentProvider());\r\n    }\r\n    return client.onlineComponents;\r\n}\r\nfunction getPersistence(client) {\r\n    return ensureOfflineComponents(client).then(c => c.persistence);\r\n}\r\nfunction getLocalStore(client) {\r\n    return ensureOfflineComponents(client).then(c => c.localStore);\r\n}\r\nfunction getRemoteStore(client) {\r\n    return ensureOnlineComponents(client).then(c => c.remoteStore);\r\n}\r\nfunction getSyncEngine(client) {\r\n    return ensureOnlineComponents(client).then(c => c.syncEngine);\r\n}\r\nfunction getDatastore(client) {\r\n    return ensureOnlineComponents(client).then(c => c.datastore);\r\n}\r\nasync function getEventManager(client) {\r\n    const onlineComponentProvider = await ensureOnlineComponents(client);\r\n    const eventManager = onlineComponentProvider.eventManager;\r\n    eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);\r\n    eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);\r\n    return eventManager;\r\n}\r\n/** Enables the network connection and re-enqueues all pending operations. */\r\nfunction firestoreClientEnableNetwork(client) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        const persistence = await getPersistence(client);\r\n        const remoteStore = await getRemoteStore(client);\r\n        persistence.setNetworkEnabled(true);\r\n        return remoteStoreEnableNetwork(remoteStore);\r\n    });\r\n}\r\n/** Disables the network connection. Pending operations will not complete. */\r\nfunction firestoreClientDisableNetwork(client) {\r\n    return client.asyncQueue.enqueue(async () => {\r\n        const persistence = await getPersistence(client);\r\n        const remoteStore = await getRemoteStore(client);\r\n        persistence.setNetworkEnabled(false);\r\n        return remoteStoreDisableNetwork(remoteStore);\r\n    });\r\n}\r\n/**\r\n * Returns a Promise that resolves when all writes that were pending at the time\r\n * this method was called received server acknowledgement. An acknowledgement\r\n * can be either acceptance or rejection.\r\n */\r\nfunction firestoreClientWaitForPendingWrites(client) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const syncEngine = await getSyncEngine(client);\r\n        return syncEngineRegisterPendingWritesCallback(syncEngine, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientListen(client, query, options, observer) {\r\n    const wrappedObserver = new AsyncObserver(observer);\r\n    const listener = new QueryListener(query, wrappedObserver, options);\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return eventManagerListen(eventManager, listener);\r\n    });\r\n    return () => {\r\n        wrappedObserver.mute();\r\n        client.asyncQueue.enqueueAndForget(async () => {\r\n            const eventManager = await getEventManager(client);\r\n            return eventManagerUnlisten(eventManager, listener);\r\n        });\r\n    };\r\n}\r\nfunction firestoreClientGetDocumentFromLocalCache(client, docKey) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const localStore = await getLocalStore(client);\r\n        return readDocumentFromCache(localStore, docKey, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientGetDocumentViaSnapshotListener(client, key, options = {}) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientGetDocumentsFromLocalCache(client, query) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const localStore = await getLocalStore(client);\r\n        return executeQueryFromCache(localStore, query, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientGetDocumentsViaSnapshotListener(client, query, options = {}) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query, options, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientWrite(client, mutations) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const syncEngine = await getSyncEngine(client);\r\n        return syncEngineWrite(syncEngine, mutations, deferred);\r\n    });\r\n    return deferred.promise;\r\n}\r\nfunction firestoreClientAddSnapshotsInSyncListener(client, observer) {\r\n    const wrappedObserver = new AsyncObserver(observer);\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const eventManager = await getEventManager(client);\r\n        return addSnapshotsInSyncListener(eventManager, wrappedObserver);\r\n    });\r\n    return () => {\r\n        wrappedObserver.mute();\r\n        client.asyncQueue.enqueueAndForget(async () => {\r\n            const eventManager = await getEventManager(client);\r\n            return removeSnapshotsInSyncListener(eventManager, wrappedObserver);\r\n        });\r\n    };\r\n}\r\n/**\r\n * Takes an updateFunction in which a set of reads and writes can be performed\r\n * atomically. In the updateFunction, the client can read and write values\r\n * using the supplied transaction object. After the updateFunction, all\r\n * changes will be committed. If a retryable error occurs (ex: some other\r\n * client has changed any of the data referenced), then the updateFunction\r\n * will be called again after a backoff. If the updateFunction still fails\r\n * after all retries, then the transaction will be rejected.\r\n *\r\n * The transaction object passed to the updateFunction contains methods for\r\n * accessing documents and collections. Unlike other datastore access, data\r\n * accessed with the transaction will not reflect local changes that have not\r\n * been committed. For this reason, it is required that all reads are\r\n * performed before any writes. Transactions must be performed while online.\r\n */\r\nfunction firestoreClientTransaction(client, updateFunction) {\r\n    const deferred = new Deferred();\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        const datastore = await getDatastore(client);\r\n        new TransactionRunner(client.asyncQueue, datastore, updateFunction, deferred).run();\r\n    });\r\n    return deferred.promise;\r\n}\r\nasync function readDocumentFromCache(localStore, docKey, result) {\r\n    try {\r\n        const document = await localStoreReadDocument(localStore, docKey);\r\n        if (document.isFoundDocument()) {\r\n            result.resolve(document);\r\n        }\r\n        else if (document.isNoDocument()) {\r\n            result.resolve(null);\r\n        }\r\n        else {\r\n            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from cache. (However, this document may ' +\r\n                \"exist on the server. Run again without setting 'source' in \" +\r\n                'the GetOptions to attempt to retrieve the document from the ' +\r\n                'server.)'));\r\n        }\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to get document '${docKey} from cache`);\r\n        result.reject(firestoreError);\r\n    }\r\n}\r\n/**\r\n * Retrieves a latency-compensated document from the backend via a\r\n * SnapshotListener.\r\n */\r\nfunction readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options, result) {\r\n    const wrappedObserver = new AsyncObserver({\r\n        next: (snap) => {\r\n            // Remove query first before passing event to user to avoid\r\n            // user actions affecting the now stale query.\r\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\r\n            const exists = snap.docs.has(key);\r\n            if (!exists && snap.fromCache) {\r\n                // TODO(dimond): If we're online and the document doesn't\r\n                // exist then we resolve with a doc.exists set to false. If\r\n                // we're offline however, we reject the Promise in this\r\n                // case. Two options: 1) Cache the negative response from\r\n                // the server so we can deliver that even when you're\r\n                // offline 2) Actually reject the Promise in the online case\r\n                // if the document doesn't exist.\r\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document because the client is offline.'));\r\n            }\r\n            else if (exists &&\r\n                snap.fromCache &&\r\n                options &&\r\n                options.source === 'server') {\r\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this ' +\r\n                    'document does exist in the local cache. Run again ' +\r\n                    'without setting source to \"server\" to ' +\r\n                    'retrieve the cached document.)'));\r\n            }\r\n            else {\r\n                result.resolve(snap);\r\n            }\r\n        },\r\n        error: e => result.reject(e)\r\n    });\r\n    const listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {\r\n        includeMetadataChanges: true,\r\n        waitForSyncWhenOnline: true\r\n    });\r\n    return eventManagerListen(eventManager, listener);\r\n}\r\nasync function executeQueryFromCache(localStore, query, result) {\r\n    try {\r\n        const queryResult = await localStoreExecuteQuery(localStore, query, \r\n        /* usePreviousResults= */ true);\r\n        const view = new View(query, queryResult.remoteKeys);\r\n        const viewDocChanges = view.computeDocChanges(queryResult.documents);\r\n        const viewChange = view.applyChanges(viewDocChanges, \r\n        /* updateLimboDocuments= */ false);\r\n        result.resolve(viewChange.snapshot);\r\n    }\r\n    catch (e) {\r\n        const firestoreError = wrapInUserErrorIfRecoverable(e, `Failed to execute query '${query} against cache`);\r\n        result.reject(firestoreError);\r\n    }\r\n}\r\n/**\r\n * Retrieves a latency-compensated query snapshot from the backend via a\r\n * SnapshotListener.\r\n */\r\nfunction executeQueryViaSnapshotListener(eventManager, asyncQueue, query, options, result) {\r\n    const wrappedObserver = new AsyncObserver({\r\n        next: snapshot => {\r\n            // Remove query first before passing event to user to avoid\r\n            // user actions affecting the now stale query.\r\n            asyncQueue.enqueueAndForget(() => eventManagerUnlisten(eventManager, listener));\r\n            if (snapshot.fromCache && options.source === 'server') {\r\n                result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these ' +\r\n                    'documents may exist in the local cache. Run again ' +\r\n                    'without setting source to \"server\" to ' +\r\n                    'retrieve the cached documents.)'));\r\n            }\r\n            else {\r\n                result.resolve(snapshot);\r\n            }\r\n        },\r\n        error: e => result.reject(e)\r\n    });\r\n    const listener = new QueryListener(query, wrappedObserver, {\r\n        includeMetadataChanges: true,\r\n        waitForSyncWhenOnline: true\r\n    });\r\n    return eventManagerListen(eventManager, listener);\r\n}\r\nfunction firestoreClientLoadBundle(client, databaseId, data, resultTask) {\r\n    const reader = createBundleReader(data, newSerializer(databaseId));\r\n    client.asyncQueue.enqueueAndForget(async () => {\r\n        syncEngineLoadBundle(await getSyncEngine(client), reader, resultTask);\r\n    });\r\n}\r\nfunction firestoreClientGetNamedQuery(client, queryName) {\r\n    return client.asyncQueue.enqueue(async () => localStoreGetNamedQuery(await getLocalStore(client), queryName));\r\n}\r\nfunction createBundleReader(data, serializer) {\r\n    let content;\r\n    if (typeof data === 'string') {\r\n        content = newTextEncoder().encode(data);\r\n    }\r\n    else {\r\n        content = data;\r\n    }\r\n    return newBundleReader(toByteStreamReader(content), serializer);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG$1 = 'ComponentProvider';\r\n/**\r\n * An instance map that ensures only one Datastore exists per Firestore\r\n * instance.\r\n */\r\nconst datastoreInstances = new Map();\r\n/**\r\n * Removes all components associated with the provided instance. Must be called\r\n * when the `Firestore` instance is terminated.\r\n */\r\nfunction removeComponents(firestore) {\r\n    const datastore = datastoreInstances.get(firestore);\r\n    if (datastore) {\r\n        logDebug(LOG_TAG$1, 'Removing Datastore');\r\n        datastoreInstances.delete(firestore);\r\n        datastore.terminate();\r\n    }\r\n}\r\nfunction makeDatabaseInfo(databaseId, appId, persistenceKey, settings) {\r\n    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, settings.useFetchStreams);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// settings() defaults:\r\nconst DEFAULT_HOST = 'firestore.googleapis.com';\r\nconst DEFAULT_SSL = true;\r\n/**\r\n * A concrete type describing all the values that can be applied via a\r\n * user-supplied `FirestoreSettings` object. This is a separate type so that\r\n * defaults can be supplied and the value can be checked for equality.\r\n */\r\nclass FirestoreSettingsImpl {\r\n    constructor(settings) {\r\n        var _a;\r\n        if (settings.host === undefined) {\r\n            if (settings.ssl !== undefined) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\r\n            }\r\n            this.host = DEFAULT_HOST;\r\n            this.ssl = DEFAULT_SSL;\r\n        }\r\n        else {\r\n            this.host = settings.host;\r\n            this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;\r\n        }\r\n        this.credentials = settings.credentials;\r\n        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;\r\n        if (settings.cacheSizeBytes === undefined) {\r\n            this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;\r\n        }\r\n        else {\r\n            if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED &&\r\n                settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\r\n            }\r\n            else {\r\n                this.cacheSizeBytes = settings.cacheSizeBytes;\r\n            }\r\n        }\r\n        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;\r\n        this.experimentalAutoDetectLongPolling =\r\n            !!settings.experimentalAutoDetectLongPolling;\r\n        this.useFetchStreams = !!settings.useFetchStreams;\r\n        validateIsNotUsedTogether('experimentalForceLongPolling', settings.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', settings.experimentalAutoDetectLongPolling);\r\n    }\r\n    isEqual(other) {\r\n        return (this.host === other.host &&\r\n            this.ssl === other.ssl &&\r\n            this.credentials === other.credentials &&\r\n            this.cacheSizeBytes === other.cacheSizeBytes &&\r\n            this.experimentalForceLongPolling ===\r\n                other.experimentalForceLongPolling &&\r\n            this.experimentalAutoDetectLongPolling ===\r\n                other.experimentalAutoDetectLongPolling &&\r\n            this.ignoreUndefinedProperties === other.ignoreUndefinedProperties &&\r\n            this.useFetchStreams === other.useFetchStreams);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The Cloud Firestore service interface.\r\n *\r\n * Do not call this constructor directly. Instead, use {@link getFirestore}.\r\n */\r\nclass Firestore$1 {\r\n    /** @hideconstructor */\r\n    constructor(databaseIdOrApp, _authCredentials, _appCheckCredentials) {\r\n        this._authCredentials = _authCredentials;\r\n        this._appCheckCredentials = _appCheckCredentials;\r\n        /**\r\n         * Whether it's a Firestore or Firestore Lite instance.\r\n         */\r\n        this.type = 'firestore-lite';\r\n        this._persistenceKey = '(lite)';\r\n        this._settings = new FirestoreSettingsImpl({});\r\n        this._settingsFrozen = false;\r\n        if (databaseIdOrApp instanceof DatabaseId) {\r\n            this._databaseId = databaseIdOrApp;\r\n        }\r\n        else {\r\n            this._app = databaseIdOrApp;\r\n            this._databaseId = databaseIdFromApp(databaseIdOrApp);\r\n        }\r\n    }\r\n    /**\r\n     * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service\r\n     * instance.\r\n     */\r\n    get app() {\r\n        if (!this._app) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\r\n                'not available');\r\n        }\r\n        return this._app;\r\n    }\r\n    get _initialized() {\r\n        return this._settingsFrozen;\r\n    }\r\n    get _terminated() {\r\n        return this._terminateTask !== undefined;\r\n    }\r\n    _setSettings(settings) {\r\n        if (this._settingsFrozen) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\r\n                'be changed. You can only modify settings before calling any other ' +\r\n                'methods on a Firestore object.');\r\n        }\r\n        this._settings = new FirestoreSettingsImpl(settings);\r\n        if (settings.credentials !== undefined) {\r\n            this._authCredentials = makeAuthCredentialsProvider(settings.credentials);\r\n        }\r\n    }\r\n    _getSettings() {\r\n        return this._settings;\r\n    }\r\n    _freezeSettings() {\r\n        this._settingsFrozen = true;\r\n        return this._settings;\r\n    }\r\n    _delete() {\r\n        if (!this._terminateTask) {\r\n            this._terminateTask = this._terminate();\r\n        }\r\n        return this._terminateTask;\r\n    }\r\n    /** Returns a JSON-serializable representation of this `Firestore` instance. */\r\n    toJSON() {\r\n        return {\r\n            app: this._app,\r\n            databaseId: this._databaseId,\r\n            settings: this._settings\r\n        };\r\n    }\r\n    /**\r\n     * Terminates all components used by this client. Subclasses can override\r\n     * this method to clean up their own dependencies, but must also call this\r\n     * method.\r\n     *\r\n     * Only ever called once.\r\n     */\r\n    _terminate() {\r\n        removeComponents(this);\r\n        return Promise.resolve();\r\n    }\r\n}\r\nfunction databaseIdFromApp(app) {\r\n    if (!Object.prototype.hasOwnProperty.apply(app.options, ['projectId'])) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\r\n    }\r\n    return new DatabaseId(app.options.projectId);\r\n}\r\n/**\r\n * Modify this instance to communicate with the Cloud Firestore emulator.\r\n *\r\n * Note: This must be called before this instance has been used to do any\r\n * operations.\r\n *\r\n * @param firestore - The `Firestore` instance to configure to connect to the\r\n * emulator.\r\n * @param host - the emulator host (ex: localhost).\r\n * @param port - the emulator port (ex: 9000).\r\n * @param options.mockUserToken - the mock auth token to use for unit testing\r\n * Security Rules.\r\n */\r\nfunction connectFirestoreEmulator(firestore, host, port, options = {}) {\r\n    var _a;\r\n    firestore = cast(firestore, Firestore$1);\r\n    const settings = firestore._getSettings();\r\n    if (settings.host !== DEFAULT_HOST && settings.host !== host) {\r\n        logWarn('Host has been set in both settings() and useEmulator(), emulator host ' +\r\n            'will be used');\r\n    }\r\n    firestore._setSettings(Object.assign(Object.assign({}, settings), { host: `${host}:${port}`, ssl: false }));\r\n    if (options.mockUserToken) {\r\n        let token;\r\n        let user;\r\n        if (typeof options.mockUserToken === 'string') {\r\n            token = options.mockUserToken;\r\n            user = User.MOCK_USER;\r\n        }\r\n        else {\r\n            // Let createMockUserToken validate first (catches common mistakes like\r\n            // invalid field \"uid\" and missing field \"sub\" / \"user_id\".)\r\n            token = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.createMockUserToken)(options.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);\r\n            const uid = options.mockUserToken.sub || options.mockUserToken.user_id;\r\n            if (!uid) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"mockUserToken must contain 'sub' or 'user_id' field!\");\r\n            }\r\n            user = new User(uid);\r\n        }\r\n        firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `DocumentReference` refers to a document location in a Firestore database\r\n * and can be used to write, read, or listen to the location. The document at\r\n * the referenced location may or may not exist.\r\n */\r\nclass DocumentReference {\r\n    /** @hideconstructor */\r\n    constructor(firestore, \r\n    /**\r\n     * If provided, the `FirestoreDataConverter` associated with this instance.\r\n     */\r\n    converter, _key) {\r\n        this.converter = converter;\r\n        this._key = _key;\r\n        /** The type of this Firestore reference. */\r\n        this.type = 'document';\r\n        this.firestore = firestore;\r\n    }\r\n    get _path() {\r\n        return this._key.path;\r\n    }\r\n    /**\r\n     * The document's identifier within its collection.\r\n     */\r\n    get id() {\r\n        return this._key.path.lastSegment();\r\n    }\r\n    /**\r\n     * A string representing the path of the referenced document (relative\r\n     * to the root of the database).\r\n     */\r\n    get path() {\r\n        return this._key.path.canonicalString();\r\n    }\r\n    /**\r\n     * The collection this `DocumentReference` belongs to.\r\n     */\r\n    get parent() {\r\n        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());\r\n    }\r\n    withConverter(converter) {\r\n        return new DocumentReference(this.firestore, converter, this._key);\r\n    }\r\n}\r\n/**\r\n * A `Query` refers to a query which you can read or listen to. You can also\r\n * construct refined `Query` objects by adding filters and ordering.\r\n */\r\nclass Query {\r\n    // This is the lite version of the Query class in the main SDK.\r\n    /** @hideconstructor protected */\r\n    constructor(firestore, \r\n    /**\r\n     * If provided, the `FirestoreDataConverter` associated with this instance.\r\n     */\r\n    converter, _query) {\r\n        this.converter = converter;\r\n        this._query = _query;\r\n        /** The type of this Firestore reference. */\r\n        this.type = 'query';\r\n        this.firestore = firestore;\r\n    }\r\n    withConverter(converter) {\r\n        return new Query(this.firestore, converter, this._query);\r\n    }\r\n}\r\n/**\r\n * A `CollectionReference` object can be used for adding documents, getting\r\n * document references, and querying for documents (using {@link query}).\r\n */\r\nclass CollectionReference extends Query {\r\n    /** @hideconstructor */\r\n    constructor(firestore, converter, _path) {\r\n        super(firestore, converter, newQueryForPath(_path));\r\n        this._path = _path;\r\n        /** The type of this Firestore reference. */\r\n        this.type = 'collection';\r\n    }\r\n    /** The collection's identifier. */\r\n    get id() {\r\n        return this._query.path.lastSegment();\r\n    }\r\n    /**\r\n     * A string representing the path of the referenced collection (relative\r\n     * to the root of the database).\r\n     */\r\n    get path() {\r\n        return this._query.path.canonicalString();\r\n    }\r\n    /**\r\n     * A reference to the containing `DocumentReference` if this is a\r\n     * subcollection. If this isn't a subcollection, the reference is null.\r\n     */\r\n    get parent() {\r\n        const parentPath = this._path.popLast();\r\n        if (parentPath.isEmpty()) {\r\n            return null;\r\n        }\r\n        else {\r\n            return new DocumentReference(this.firestore, \r\n            /* converter= */ null, new DocumentKey(parentPath));\r\n        }\r\n    }\r\n    withConverter(converter) {\r\n        return new CollectionReference(this.firestore, converter, this._path);\r\n    }\r\n}\r\nfunction collection(parent, path, ...pathSegments) {\r\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\r\n    validateNonEmptyArgument('collection', 'path', path);\r\n    if (parent instanceof Firestore$1) {\r\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\r\n        validateCollectionPath(absolutePath);\r\n        return new CollectionReference(parent, /* converter= */ null, absolutePath);\r\n    }\r\n    else {\r\n        if (!(parent instanceof DocumentReference) &&\r\n            !(parent instanceof CollectionReference)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\r\n                'a DocumentReference or FirebaseFirestore');\r\n        }\r\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\r\n        validateCollectionPath(absolutePath);\r\n        return new CollectionReference(parent.firestore, \r\n        /* converter= */ null, absolutePath);\r\n    }\r\n}\r\n// TODO(firestorelite): Consider using ErrorFactory -\r\n// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106\r\n/**\r\n * Creates and returns a new `Query` instance that includes all documents in the\r\n * database that are contained in a collection or subcollection with the\r\n * given `collectionId`.\r\n *\r\n * @param firestore - A reference to the root `Firestore` instance.\r\n * @param collectionId - Identifies the collections to query over. Every\r\n * collection or subcollection with this ID as the last segment of its path\r\n * will be included. Cannot contain a slash.\r\n * @returns The created `Query`.\r\n */\r\nfunction collectionGroup(firestore, collectionId) {\r\n    firestore = cast(firestore, Firestore$1);\r\n    validateNonEmptyArgument('collectionGroup', 'collection id', collectionId);\r\n    if (collectionId.indexOf('/') >= 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '${collectionId}' passed to function ` +\r\n            `collectionGroup(). Collection IDs must not contain '/'.`);\r\n    }\r\n    return new Query(firestore, \r\n    /* converter= */ null, newQueryForCollectionGroup(collectionId));\r\n}\r\nfunction doc(parent, path, ...pathSegments) {\r\n    parent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(parent);\r\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\r\n    // 'undefined' and 'null'.\r\n    if (arguments.length === 1) {\r\n        path = AutoId.newId();\r\n    }\r\n    validateNonEmptyArgument('doc', 'path', path);\r\n    if (parent instanceof Firestore$1) {\r\n        const absolutePath = ResourcePath.fromString(path, ...pathSegments);\r\n        validateDocumentPath(absolutePath);\r\n        return new DocumentReference(parent, \r\n        /* converter= */ null, new DocumentKey(absolutePath));\r\n    }\r\n    else {\r\n        if (!(parent instanceof DocumentReference) &&\r\n            !(parent instanceof CollectionReference)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +\r\n                'a DocumentReference or FirebaseFirestore');\r\n        }\r\n        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));\r\n        validateDocumentPath(absolutePath);\r\n        return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));\r\n    }\r\n}\r\n/**\r\n * Returns true if the provided references are equal.\r\n *\r\n * @param left - A reference to compare.\r\n * @param right - A reference to compare.\r\n * @returns true if the references point to the same location in the same\r\n * Firestore database.\r\n */\r\nfunction refEqual(left, right) {\r\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\r\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\r\n    if ((left instanceof DocumentReference ||\r\n        left instanceof CollectionReference) &&\r\n        (right instanceof DocumentReference || right instanceof CollectionReference)) {\r\n        return (left.firestore === right.firestore &&\r\n            left.path === right.path &&\r\n            left.converter === right.converter);\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns true if the provided queries point to the same collection and apply\r\n * the same constraints.\r\n *\r\n * @param left - A `Query` to compare.\r\n * @param right - A `Query` to compare.\r\n * @returns true if the references point to the same location in the same\r\n * Firestore database.\r\n */\r\nfunction queryEqual(left, right) {\r\n    left = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(left);\r\n    right = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(right);\r\n    if (left instanceof Query && right instanceof Query) {\r\n        return (left.firestore === right.firestore &&\r\n            queryEquals(left._query, right._query) &&\r\n            left.converter === right.converter);\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_TAG = 'AsyncQueue';\r\nclass AsyncQueueImpl {\r\n    constructor() {\r\n        // The last promise in the queue.\r\n        this.tail = Promise.resolve();\r\n        // A list of retryable operations. Retryable operations are run in order and\r\n        // retried with backoff.\r\n        this.retryableOps = [];\r\n        // Is this AsyncQueue being shut down? Once it is set to true, it will not\r\n        // be changed again.\r\n        this._isShuttingDown = false;\r\n        // Operations scheduled to be queued in the future. Operations are\r\n        // automatically removed after they are run or canceled.\r\n        this.delayedOperations = [];\r\n        // visible for testing\r\n        this.failure = null;\r\n        // Flag set while there's an outstanding AsyncQueue operation, used for\r\n        // assertion sanity-checks.\r\n        this.operationInProgress = false;\r\n        // Enabled during shutdown on Safari to prevent future access to IndexedDB.\r\n        this.skipNonRestrictedTasks = false;\r\n        // List of TimerIds to fast-forward delays for.\r\n        this.timerIdsToSkip = [];\r\n        // Backoff timer used to schedule retries for retryable operations\r\n        this.backoff = new ExponentialBackoff(this, \"async_queue_retry\" /* AsyncQueueRetry */);\r\n        // Visibility handler that triggers an immediate retry of all retryable\r\n        // operations. Meant to speed up recovery when we regain file system access\r\n        // after page comes into foreground.\r\n        this.visibilityHandler = () => {\r\n            this.backoff.skipBackoff();\r\n        };\r\n    }\r\n    get isShuttingDown() {\r\n        return this._isShuttingDown;\r\n    }\r\n    /**\r\n     * Adds a new operation to the queue without waiting for it to complete (i.e.\r\n     * we ignore the Promise result).\r\n     */\r\n    enqueueAndForget(op) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.enqueue(op);\r\n    }\r\n    enqueueAndForgetEvenWhileRestricted(op) {\r\n        this.verifyNotFailed();\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.enqueueInternal(op);\r\n    }\r\n    enterRestrictedMode(purgeExistingTasks) {\r\n        if (!this._isShuttingDown) {\r\n            this._isShuttingDown = true;\r\n            this.skipNonRestrictedTasks = purgeExistingTasks || false;\r\n        }\r\n    }\r\n    enqueue(op) {\r\n        this.verifyNotFailed();\r\n        if (this._isShuttingDown) {\r\n            // Return a Promise which never resolves.\r\n            return new Promise(() => { });\r\n        }\r\n        // Create a deferred Promise that we can return to the callee. This\r\n        // allows us to return a \"hanging Promise\" only to the callee and still\r\n        // advance the queue even when the operation is not run.\r\n        const task = new Deferred();\r\n        return this.enqueueInternal(() => {\r\n            if (this._isShuttingDown && this.skipNonRestrictedTasks) {\r\n                // We do not resolve 'task'\r\n                return Promise.resolve();\r\n            }\r\n            op().then(task.resolve, task.reject);\r\n            return task.promise;\r\n        }).then(() => task.promise);\r\n    }\r\n    enqueueRetryable(op) {\r\n        this.enqueueAndForget(() => {\r\n            this.retryableOps.push(op);\r\n            return this.retryNextOp();\r\n        });\r\n    }\r\n    /**\r\n     * Runs the next operation from the retryable queue. If the operation fails,\r\n     * reschedules with backoff.\r\n     */\r\n    async retryNextOp() {\r\n        if (this.retryableOps.length === 0) {\r\n            return;\r\n        }\r\n        try {\r\n            await this.retryableOps[0]();\r\n            this.retryableOps.shift();\r\n            this.backoff.reset();\r\n        }\r\n        catch (e) {\r\n            if (isIndexedDbTransactionError(e)) {\r\n                logDebug(LOG_TAG, 'Operation failed with retryable error: ' + e);\r\n            }\r\n            else {\r\n                throw e; // Failure will be handled by AsyncQueue\r\n            }\r\n        }\r\n        if (this.retryableOps.length > 0) {\r\n            // If there are additional operations, we re-schedule `retryNextOp()`.\r\n            // This is necessary to run retryable operations that failed during\r\n            // their initial attempt since we don't know whether they are already\r\n            // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`\r\n            // needs to  be re-run, we will run `op1`, `op1`, `op2` using the\r\n            // already enqueued calls to `retryNextOp()`. `op3()` will then run in the\r\n            // call scheduled here.\r\n            // Since `backoffAndRun()` cancels an existing backoff and schedules a\r\n            // new backoff on every call, there is only ever a single additional\r\n            // operation in the queue.\r\n            this.backoff.backoffAndRun(() => this.retryNextOp());\r\n        }\r\n    }\r\n    enqueueInternal(op) {\r\n        const newTail = this.tail.then(() => {\r\n            this.operationInProgress = true;\r\n            return op()\r\n                .catch((error) => {\r\n                this.failure = error;\r\n                this.operationInProgress = false;\r\n                const message = getMessageOrStack(error);\r\n                logError('INTERNAL UNHANDLED ERROR: ', message);\r\n                // Re-throw the error so that this.tail becomes a rejected Promise and\r\n                // all further attempts to chain (via .then) will just short-circuit\r\n                // and return the rejected Promise.\r\n                throw error;\r\n            })\r\n                .then(result => {\r\n                this.operationInProgress = false;\r\n                return result;\r\n            });\r\n        });\r\n        this.tail = newTail;\r\n        return newTail;\r\n    }\r\n    enqueueAfterDelay(timerId, delayMs, op) {\r\n        this.verifyNotFailed();\r\n        // Fast-forward delays for timerIds that have been overriden.\r\n        if (this.timerIdsToSkip.indexOf(timerId) > -1) {\r\n            delayMs = 0;\r\n        }\r\n        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, removedOp => this.removeDelayedOperation(removedOp));\r\n        this.delayedOperations.push(delayedOp);\r\n        return delayedOp;\r\n    }\r\n    verifyNotFailed() {\r\n        if (this.failure) {\r\n            fail();\r\n        }\r\n    }\r\n    verifyOperationInProgress() {\r\n    }\r\n    /**\r\n     * Waits until all currently queued tasks are finished executing. Delayed\r\n     * operations are not run.\r\n     */\r\n    async drain() {\r\n        // Operations in the queue prior to draining may have enqueued additional\r\n        // operations. Keep draining the queue until the tail is no longer advanced,\r\n        // which indicates that no more new operations were enqueued and that all\r\n        // operations were executed.\r\n        let currentTail;\r\n        do {\r\n            currentTail = this.tail;\r\n            await currentTail;\r\n        } while (currentTail !== this.tail);\r\n    }\r\n    /**\r\n     * For Tests: Determine if a delayed operation with a particular TimerId\r\n     * exists.\r\n     */\r\n    containsDelayedOperation(timerId) {\r\n        for (const op of this.delayedOperations) {\r\n            if (op.timerId === timerId) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * For Tests: Runs some or all delayed operations early.\r\n     *\r\n     * @param lastTimerId - Delayed operations up to and including this TimerId\r\n     * will be drained. Pass TimerId.All to run all delayed operations.\r\n     * @returns a Promise that resolves once all operations have been run.\r\n     */\r\n    runAllDelayedOperationsUntil(lastTimerId) {\r\n        // Note that draining may generate more delayed ops, so we do that first.\r\n        return this.drain().then(() => {\r\n            // Run ops in the same order they'd run if they ran naturally.\r\n            this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\r\n            for (const op of this.delayedOperations) {\r\n                op.skipDelay();\r\n                if (lastTimerId !== \"all\" /* All */ && op.timerId === lastTimerId) {\r\n                    break;\r\n                }\r\n            }\r\n            return this.drain();\r\n        });\r\n    }\r\n    /**\r\n     * For Tests: Skip all subsequent delays for a timer id.\r\n     */\r\n    skipDelaysForTimerId(timerId) {\r\n        this.timerIdsToSkip.push(timerId);\r\n    }\r\n    /** Called once a DelayedOperation is run or canceled. */\r\n    removeDelayedOperation(op) {\r\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\r\n        const index = this.delayedOperations.indexOf(op);\r\n        this.delayedOperations.splice(index, 1);\r\n    }\r\n}\r\nfunction newAsyncQueue() {\r\n    return new AsyncQueueImpl();\r\n}\r\n/**\r\n * Chrome includes Error.message in Error.stack. Other browsers do not.\r\n * This returns expected output of message + stack when available.\r\n * @param error - Error or FirestoreError\r\n */\r\nfunction getMessageOrStack(error) {\r\n    let message = error.message || '';\r\n    if (error.stack) {\r\n        if (error.stack.includes(error.message)) {\r\n            message = error.stack;\r\n        }\r\n        else {\r\n            message = error.message + '\\n' + error.stack;\r\n        }\r\n    }\r\n    return message;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Represents the task of loading a Firestore bundle. It provides progress of bundle\r\n * loading, as well as task completion and error events.\r\n *\r\n * The API is compatible with `Promise<LoadBundleTaskProgress>`.\r\n */\r\nclass LoadBundleTask {\r\n    constructor() {\r\n        this._progressObserver = {};\r\n        this._taskCompletionResolver = new Deferred();\r\n        this._lastProgress = {\r\n            taskState: 'Running',\r\n            totalBytes: 0,\r\n            totalDocuments: 0,\r\n            bytesLoaded: 0,\r\n            documentsLoaded: 0\r\n        };\r\n    }\r\n    /**\r\n     * Registers functions to listen to bundle loading progress events.\r\n     * @param next - Called when there is a progress update from bundle loading. Typically `next` calls occur\r\n     *   each time a Firestore document is loaded from the bundle.\r\n     * @param error - Called when an error occurs during bundle loading. The task aborts after reporting the\r\n     *   error, and there should be no more updates after this.\r\n     * @param complete - Called when the loading task is complete.\r\n     */\r\n    onProgress(next, error, complete) {\r\n        this._progressObserver = {\r\n            next,\r\n            error,\r\n            complete\r\n        };\r\n    }\r\n    /**\r\n     * Implements the `Promise<LoadBundleTaskProgress>.catch` interface.\r\n     *\r\n     * @param onRejected - Called when an error occurs during bundle loading.\r\n     */\r\n    catch(onRejected) {\r\n        return this._taskCompletionResolver.promise.catch(onRejected);\r\n    }\r\n    /**\r\n     * Implements the `Promise<LoadBundleTaskProgress>.then` interface.\r\n     *\r\n     * @param onFulfilled - Called on the completion of the loading task with a final `LoadBundleTaskProgress` update.\r\n     *   The update will always have its `taskState` set to `\"Success\"`.\r\n     * @param onRejected - Called when an error occurs during bundle loading.\r\n     */\r\n    then(onFulfilled, onRejected) {\r\n        return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);\r\n    }\r\n    /**\r\n     * Notifies all observers that bundle loading has completed, with a provided\r\n     * `LoadBundleTaskProgress` object.\r\n     *\r\n     * @private\r\n     */\r\n    _completeWith(progress) {\r\n        this._updateProgress(progress);\r\n        if (this._progressObserver.complete) {\r\n            this._progressObserver.complete();\r\n        }\r\n        this._taskCompletionResolver.resolve(progress);\r\n    }\r\n    /**\r\n     * Notifies all observers that bundle loading has failed, with a provided\r\n     * `Error` as the reason.\r\n     *\r\n     * @private\r\n     */\r\n    _failWith(error) {\r\n        this._lastProgress.taskState = 'Error';\r\n        if (this._progressObserver.next) {\r\n            this._progressObserver.next(this._lastProgress);\r\n        }\r\n        if (this._progressObserver.error) {\r\n            this._progressObserver.error(error);\r\n        }\r\n        this._taskCompletionResolver.reject(error);\r\n    }\r\n    /**\r\n     * Notifies a progress update of loading a bundle.\r\n     * @param progress - The new progress.\r\n     *\r\n     * @private\r\n     */\r\n    _updateProgress(progress) {\r\n        this._lastProgress = progress;\r\n        if (this._progressObserver.next) {\r\n            this._progressObserver.next(progress);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** DOMException error code constants. */\r\nconst DOM_EXCEPTION_INVALID_STATE = 11;\r\nconst DOM_EXCEPTION_ABORTED = 20;\r\nconst DOM_EXCEPTION_QUOTA_EXCEEDED = 22;\r\n/**\r\n * Constant used to indicate the LRU garbage collection should be disabled.\r\n * Set this value as the `cacheSizeBytes` on the settings passed to the\r\n * {@link Firestore} instance.\r\n */\r\nconst CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;\r\n/**\r\n * The Cloud Firestore service interface.\r\n *\r\n * Do not call this constructor directly. Instead, use {@link getFirestore}.\r\n */\r\nclass Firestore extends Firestore$1 {\r\n    /** @hideconstructor */\r\n    constructor(databaseIdOrApp, authCredentialsProvider, appCheckCredentialsProvider) {\r\n        super(databaseIdOrApp, authCredentialsProvider, appCheckCredentialsProvider);\r\n        /**\r\n         * Whether it's a {@link Firestore} or Firestore Lite instance.\r\n         */\r\n        this.type = 'firestore';\r\n        this._queue = newAsyncQueue();\r\n        this._persistenceKey =\r\n            'name' in databaseIdOrApp ? databaseIdOrApp.name : '[DEFAULT]';\r\n    }\r\n    _terminate() {\r\n        if (!this._firestoreClient) {\r\n            // The client must be initialized to ensure that all subsequent API\r\n            // usage throws an exception.\r\n            configureFirestore(this);\r\n        }\r\n        return this._firestoreClient.terminate();\r\n    }\r\n}\r\n/**\r\n * Initializes a new instance of {@link Firestore} with the provided settings.\r\n * Can only be called before any other function, including\r\n * {@link getFirestore}. If the custom settings are empty, this function is\r\n * equivalent to calling {@link getFirestore}.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} with which the {@link Firestore} instance will\r\n * be associated.\r\n * @param settings - A settings object to configure the {@link Firestore} instance.\r\n * @returns A newly initialized {@link Firestore} instance.\r\n */\r\nfunction initializeFirestore(app, settings) {\r\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore');\r\n    if (provider.isInitialized()) {\r\n        const existingInstance = provider.getImmediate();\r\n        const initialSettings = provider.getOptions();\r\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(initialSettings, settings)) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'initializeFirestore() has already been called with ' +\r\n                'different options. To avoid this error, call initializeFirestore() with the ' +\r\n                'same options as when it was originally called, or call getFirestore() to return the' +\r\n                ' already initialized instance.');\r\n        }\r\n    }\r\n    if (settings.cacheSizeBytes !== undefined &&\r\n        settings.cacheSizeBytes !== CACHE_SIZE_UNLIMITED &&\r\n        settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least ${LRU_MINIMUM_CACHE_SIZE_BYTES}`);\r\n    }\r\n    return provider.initialize({ options: settings });\r\n}\r\n/**\r\n * Returns the existing {@link Firestore} instance that is associated with the\r\n * provided {@link @firebase/app#FirebaseApp}. If no instance exists, initializes a new\r\n * instance with default settings.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned {@link Firestore}\r\n * instance is associated with.\r\n * @returns The {@link Firestore} instance of the provided app.\r\n */\r\nfunction getFirestore(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\r\n    return (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'firestore').getImmediate();\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction ensureFirestoreConfigured(firestore) {\r\n    if (!firestore._firestoreClient) {\r\n        configureFirestore(firestore);\r\n    }\r\n    firestore._firestoreClient.verifyNotTerminated();\r\n    return firestore._firestoreClient;\r\n}\r\nfunction configureFirestore(firestore) {\r\n    var _a;\r\n    const settings = firestore._freezeSettings();\r\n    const databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || '', firestore._persistenceKey, settings);\r\n    firestore._firestoreClient = new FirestoreClient(firestore._authCredentials, firestore._appCheckCredentials, firestore._queue, databaseInfo);\r\n}\r\n/**\r\n * Attempts to enable persistent storage, if possible.\r\n *\r\n * Must be called before any other functions (other than\r\n * {@link initializeFirestore}, {@link getFirestore} or\r\n * {@link clearIndexedDbPersistence}.\r\n *\r\n * If this fails, `enableIndexedDbPersistence()` will reject the promise it\r\n * returns. Note that even after this failure, the {@link Firestore} instance will\r\n * remain usable, however offline persistence will be disabled.\r\n *\r\n * There are several reasons why this can fail, which can be identified by\r\n * the `code` on the error.\r\n *\r\n *   * failed-precondition: The app is already open in another browser tab.\r\n *   * unimplemented: The browser is incompatible with the offline\r\n *     persistence implementation.\r\n *\r\n * @param firestore - The {@link Firestore} instance to enable persistence for.\r\n * @param persistenceSettings - Optional settings object to configure\r\n * persistence.\r\n * @returns A `Promise` that represents successfully enabling persistent storage.\r\n */\r\nfunction enableIndexedDbPersistence(firestore, persistenceSettings) {\r\n    firestore = cast(firestore, Firestore);\r\n    verifyNotInitialized(firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const settings = firestore._freezeSettings();\r\n    const onlineComponentProvider = new OnlineComponentProvider();\r\n    const offlineComponentProvider = new IndexedDbOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes, persistenceSettings === null || persistenceSettings === void 0 ? void 0 : persistenceSettings.forceOwnership);\r\n    return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);\r\n}\r\n/**\r\n * Attempts to enable multi-tab persistent storage, if possible. If enabled\r\n * across all tabs, all operations share access to local persistence, including\r\n * shared execution of queries and latency-compensated local document updates\r\n * across all connected instances.\r\n *\r\n * If this fails, `enableMultiTabIndexedDbPersistence()` will reject the promise\r\n * it returns. Note that even after this failure, the {@link Firestore} instance will\r\n * remain usable, however offline persistence will be disabled.\r\n *\r\n * There are several reasons why this can fail, which can be identified by\r\n * the `code` on the error.\r\n *\r\n *   * failed-precondition: The app is already open in another browser tab and\r\n *     multi-tab is not enabled.\r\n *   * unimplemented: The browser is incompatible with the offline\r\n *     persistence implementation.\r\n *\r\n * @param firestore - The {@link Firestore} instance to enable persistence for.\r\n * @returns A `Promise` that represents successfully enabling persistent\r\n * storage.\r\n */\r\nfunction enableMultiTabIndexedDbPersistence(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    verifyNotInitialized(firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const settings = firestore._freezeSettings();\r\n    const onlineComponentProvider = new OnlineComponentProvider();\r\n    const offlineComponentProvider = new MultiTabOfflineComponentProvider(onlineComponentProvider, settings.cacheSizeBytes);\r\n    return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);\r\n}\r\n/**\r\n * Registers both the `OfflineComponentProvider` and `OnlineComponentProvider`.\r\n * If the operation fails with a recoverable error (see\r\n * `canRecoverFromIndexedDbError()` below), the returned Promise is rejected\r\n * but the client remains usable.\r\n */\r\nfunction setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider) {\r\n    const persistenceResult = new Deferred();\r\n    return client.asyncQueue\r\n        .enqueue(async () => {\r\n        try {\r\n            await setOfflineComponentProvider(client, offlineComponentProvider);\r\n            await setOnlineComponentProvider(client, onlineComponentProvider);\r\n            persistenceResult.resolve();\r\n        }\r\n        catch (e) {\r\n            if (!canFallbackFromIndexedDbError(e)) {\r\n                throw e;\r\n            }\r\n            console.warn('Error enabling offline persistence. Falling back to ' +\r\n                'persistence disabled: ' +\r\n                e);\r\n            persistenceResult.reject(e);\r\n        }\r\n    })\r\n        .then(() => persistenceResult.promise);\r\n}\r\n/**\r\n * Decides whether the provided error allows us to gracefully disable\r\n * persistence (as opposed to crashing the client).\r\n */\r\nfunction canFallbackFromIndexedDbError(error) {\r\n    if (error.name === 'FirebaseError') {\r\n        return (error.code === Code.FAILED_PRECONDITION ||\r\n            error.code === Code.UNIMPLEMENTED);\r\n    }\r\n    else if (typeof DOMException !== 'undefined' &&\r\n        error instanceof DOMException) {\r\n        // There are a few known circumstances where we can open IndexedDb but\r\n        // trying to read/write will fail (e.g. quota exceeded). For\r\n        // well-understood cases, we attempt to detect these and then gracefully\r\n        // fall back to memory persistence.\r\n        // NOTE: Rather than continue to add to this list, we could decide to\r\n        // always fall back, with the risk that we might accidentally hide errors\r\n        // representing actual SDK bugs.\r\n        return (\r\n        // When the browser is out of quota we could get either quota exceeded\r\n        // or an aborted error depending on whether the error happened during\r\n        // schema migration.\r\n        error.code === DOM_EXCEPTION_QUOTA_EXCEEDED ||\r\n            error.code === DOM_EXCEPTION_ABORTED ||\r\n            // Firefox Private Browsing mode disables IndexedDb and returns\r\n            // INVALID_STATE for any usage.\r\n            error.code === DOM_EXCEPTION_INVALID_STATE);\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Clears the persistent storage. This includes pending writes and cached\r\n * documents.\r\n *\r\n * Must be called while the {@link Firestore} instance is not started (after the app is\r\n * terminated or when the app is first initialized). On startup, this function\r\n * must be called before other functions (other than {@link\r\n * initializeFirestore} or {@link getFirestore})). If the {@link Firestore}\r\n * instance is still running, the promise will be rejected with the error code\r\n * of `failed-precondition`.\r\n *\r\n * Note: `clearIndexedDbPersistence()` is primarily intended to help write\r\n * reliable tests that use Cloud Firestore. It uses an efficient mechanism for\r\n * dropping existing data but does not attempt to securely overwrite or\r\n * otherwise make cached data unrecoverable. For applications that are sensitive\r\n * to the disclosure of cached data in between user sessions, we strongly\r\n * recommend not enabling persistence at all.\r\n *\r\n * @param firestore - The {@link Firestore} instance to clear persistence for.\r\n * @returns A `Promise` that is resolved when the persistent storage is\r\n * cleared. Otherwise, the promise is rejected with an error.\r\n */\r\nfunction clearIndexedDbPersistence(firestore) {\r\n    if (firestore._initialized && !firestore._terminated) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Persistence can only be cleared before a Firestore instance is ' +\r\n            'initialized or after it is terminated.');\r\n    }\r\n    const deferred = new Deferred();\r\n    firestore._queue.enqueueAndForgetEvenWhileRestricted(async () => {\r\n        try {\r\n            await indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey));\r\n            deferred.resolve();\r\n        }\r\n        catch (e) {\r\n            deferred.reject(e);\r\n        }\r\n    });\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Waits until all currently pending writes for the active user have been\r\n * acknowledged by the backend.\r\n *\r\n * The returned promise resolves immediately if there are no outstanding writes.\r\n * Otherwise, the promise waits for all previously issued writes (including\r\n * those written in a previous app session), but it does not wait for writes\r\n * that were added after the function is called. If you want to wait for\r\n * additional writes, call `waitForPendingWrites()` again.\r\n *\r\n * Any outstanding `waitForPendingWrites()` promises are rejected during user\r\n * changes.\r\n *\r\n * @returns A `Promise` which resolves when all currently pending writes have been\r\n * acknowledged by the backend.\r\n */\r\nfunction waitForPendingWrites(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientWaitForPendingWrites(client);\r\n}\r\n/**\r\n * Re-enables use of the network for this {@link Firestore} instance after a prior\r\n * call to {@link disableNetwork}.\r\n *\r\n * @returns A `Promise` that is resolved once the network has been enabled.\r\n */\r\nfunction enableNetwork(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientEnableNetwork(client);\r\n}\r\n/**\r\n * Disables network usage for this instance. It can be re-enabled via {@link\r\n * enableNetwork}. While the network is disabled, any snapshot listeners,\r\n * `getDoc()` or `getDocs()` calls will return results from cache, and any write\r\n * operations will be queued until the network is restored.\r\n *\r\n * @returns A `Promise` that is resolved once the network has been disabled.\r\n */\r\nfunction disableNetwork(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientDisableNetwork(client);\r\n}\r\n/**\r\n * Terminates the provided {@link Firestore} instance.\r\n *\r\n * After calling `terminate()` only the `clearIndexedDbPersistence()` function\r\n * may be used. Any other function will throw a `FirestoreError`.\r\n *\r\n * To restart after termination, create a new instance of FirebaseFirestore with\r\n * {@link getFirestore}.\r\n *\r\n * Termination does not cancel any pending writes, and any promises that are\r\n * awaiting a response from the server will not be resolved. If you have\r\n * persistence enabled, the next time you start this instance, it will resume\r\n * sending these writes to the server.\r\n *\r\n * Note: Under normal circumstances, calling `terminate()` is not required. This\r\n * function is useful only when you want to force this instance to release all\r\n * of its resources or in combination with `clearIndexedDbPersistence()` to\r\n * ensure that all local state is destroyed between test runs.\r\n *\r\n * @returns A `Promise` that is resolved when the instance has been successfully\r\n * terminated.\r\n */\r\nfunction terminate(firestore) {\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._removeServiceInstance)(firestore.app, 'firestore');\r\n    return firestore._delete();\r\n}\r\n/**\r\n * Loads a Firestore bundle into the local cache.\r\n *\r\n * @param firestore - The {@link Firestore} instance to load bundles for.\r\n * @param bundleData - An object representing the bundle to be loaded. Valid\r\n * objects are `ArrayBuffer`, `ReadableStream<Uint8Array>` or `string`.\r\n *\r\n * @returns A `LoadBundleTask` object, which notifies callers with progress\r\n * updates, and completion or error events. It can be used as a\r\n * `Promise<LoadBundleTaskProgress>`.\r\n */\r\nfunction loadBundle(firestore, bundleData) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const resultTask = new LoadBundleTask();\r\n    firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);\r\n    return resultTask;\r\n}\r\n/**\r\n * Reads a Firestore {@link Query} from local cache, identified by the given\r\n * name.\r\n *\r\n * The named queries are packaged  into bundles on the server side (along\r\n * with resulting documents), and loaded to local cache using `loadBundle`. Once\r\n * in local cache, use this method to extract a {@link Query} by name.\r\n *\r\n * @param firestore - The {@link Firestore} instance to read the query from.\r\n * @param name - The name of the query.\r\n * @returns A `Promise` that is resolved with the Query or `null`.\r\n */\r\nfunction namedQuery(firestore, name) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientGetNamedQuery(client, name).then(namedQuery => {\r\n        if (!namedQuery) {\r\n            return null;\r\n        }\r\n        return new Query(firestore, null, namedQuery.query);\r\n    });\r\n}\r\nfunction verifyNotInitialized(firestore) {\r\n    if (firestore._initialized || firestore._terminated) {\r\n        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer be ' +\r\n            'enabled. You can only enable persistence before calling any other ' +\r\n            'methods on a Firestore object.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerFirestore(variant, useFetchStreams = true) {\r\n    setSDKVersion(_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION);\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component('firestore', (container, { options: settings }) => {\r\n        const app = container.getProvider('app').getImmediate();\r\n        const firestoreInstance = new Firestore(app, new FirebaseAuthCredentialsProvider(container.getProvider('auth-internal')), new FirebaseAppCheckTokenProvider(container.getProvider('app-check-internal')));\r\n        settings = Object.assign({ useFetchStreams }, settings);\r\n        firestoreInstance._setSettings(settings);\r\n        return firestoreInstance;\r\n    }, 'PUBLIC'));\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version$1, 'esm2017');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `FieldPath` refers to a field in a document. The path may consist of a\r\n * single field name (referring to a top-level field in the document), or a\r\n * list of field names (referring to a nested field in the document).\r\n *\r\n * Create a `FieldPath` by providing field names. If more than one field\r\n * name is provided, the path will point to a nested field in a document.\r\n */\r\nclass FieldPath {\r\n    /**\r\n     * Creates a `FieldPath` from the provided field names. If more than one field\r\n     * name is provided, the path will point to a nested field in a document.\r\n     *\r\n     * @param fieldNames - A list of field names.\r\n     */\r\n    constructor(...fieldNames) {\r\n        for (let i = 0; i < fieldNames.length; ++i) {\r\n            if (fieldNames[i].length === 0) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). ` +\r\n                    'Field names must not be empty.');\r\n            }\r\n        }\r\n        this._internalPath = new FieldPath$1(fieldNames);\r\n    }\r\n    /**\r\n     * Returns true if this `FieldPath` is equal to the provided one.\r\n     *\r\n     * @param other - The `FieldPath` to compare against.\r\n     * @returns true if this `FieldPath` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return this._internalPath.isEqual(other._internalPath);\r\n    }\r\n}\r\n/**\r\n * Returns a special sentinel `FieldPath` to refer to the ID of a document.\r\n * It can be used in queries to sort or filter by the document ID.\r\n */\r\nfunction documentId() {\r\n    return new FieldPath(DOCUMENT_KEY_NAME);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable object representing an array of bytes.\r\n */\r\nclass Bytes {\r\n    /** @hideconstructor */\r\n    constructor(byteString) {\r\n        this._byteString = byteString;\r\n    }\r\n    /**\r\n     * Creates a new `Bytes` object from the given Base64 string, converting it to\r\n     * bytes.\r\n     *\r\n     * @param base64 - The Base64 string used to create the `Bytes` object.\r\n     */\r\n    static fromBase64String(base64) {\r\n        try {\r\n            return new Bytes(ByteString.fromBase64String(base64));\r\n        }\r\n        catch (e) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + e);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a new `Bytes` object from the given Uint8Array.\r\n     *\r\n     * @param array - The Uint8Array used to create the `Bytes` object.\r\n     */\r\n    static fromUint8Array(array) {\r\n        return new Bytes(ByteString.fromUint8Array(array));\r\n    }\r\n    /**\r\n     * Returns the underlying bytes as a Base64-encoded string.\r\n     *\r\n     * @returns The Base64-encoded string created from the `Bytes` object.\r\n     */\r\n    toBase64() {\r\n        return this._byteString.toBase64();\r\n    }\r\n    /**\r\n     * Returns the underlying bytes in a new `Uint8Array`.\r\n     *\r\n     * @returns The Uint8Array created from the `Bytes` object.\r\n     */\r\n    toUint8Array() {\r\n        return this._byteString.toUint8Array();\r\n    }\r\n    /**\r\n     * Returns a string representation of the `Bytes` object.\r\n     *\r\n     * @returns A string representation of the `Bytes` object.\r\n     */\r\n    toString() {\r\n        return 'Bytes(base64: ' + this.toBase64() + ')';\r\n    }\r\n    /**\r\n     * Returns true if this `Bytes` object is equal to the provided one.\r\n     *\r\n     * @param other - The `Bytes` object to compare against.\r\n     * @returns true if this `Bytes` object is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return this._byteString.isEqual(other._byteString);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sentinel values that can be used when writing document fields with `set()`\r\n * or `update()`.\r\n */\r\nclass FieldValue {\r\n    /**\r\n     * @param _methodName - The public API endpoint that returns this class.\r\n     * @hideconstructor\r\n     */\r\n    constructor(_methodName) {\r\n        this._methodName = _methodName;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable object representing a geographic location in Firestore. The\r\n * location is represented as latitude/longitude pair.\r\n *\r\n * Latitude values are in the range of [-90, 90].\r\n * Longitude values are in the range of [-180, 180].\r\n */\r\nclass GeoPoint {\r\n    /**\r\n     * Creates a new immutable `GeoPoint` object with the provided latitude and\r\n     * longitude values.\r\n     * @param latitude - The latitude as number between -90 and 90.\r\n     * @param longitude - The longitude as number between -180 and 180.\r\n     */\r\n    constructor(latitude, longitude) {\r\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\r\n        }\r\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\r\n        }\r\n        this._lat = latitude;\r\n        this._long = longitude;\r\n    }\r\n    /**\r\n     * The latitude of this `GeoPoint` instance.\r\n     */\r\n    get latitude() {\r\n        return this._lat;\r\n    }\r\n    /**\r\n     * The longitude of this `GeoPoint` instance.\r\n     */\r\n    get longitude() {\r\n        return this._long;\r\n    }\r\n    /**\r\n     * Returns true if this `GeoPoint` is equal to the provided one.\r\n     *\r\n     * @param other - The `GeoPoint` to compare against.\r\n     * @returns true if this `GeoPoint` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return this._lat === other._lat && this._long === other._long;\r\n    }\r\n    /** Returns a JSON-serializable representation of this GeoPoint. */\r\n    toJSON() {\r\n        return { latitude: this._lat, longitude: this._long };\r\n    }\r\n    /**\r\n     * Actually private to JS consumers of our API, so this function is prefixed\r\n     * with an underscore.\r\n     */\r\n    _compareTo(other) {\r\n        return (primitiveComparator(this._lat, other._lat) ||\r\n            primitiveComparator(this._long, other._long));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\r\n/** The result of parsing document data (e.g. for a setData call). */\r\nclass ParsedSetData {\r\n    constructor(data, fieldMask, fieldTransforms) {\r\n        this.data = data;\r\n        this.fieldMask = fieldMask;\r\n        this.fieldTransforms = fieldTransforms;\r\n    }\r\n    toMutation(key, precondition) {\r\n        if (this.fieldMask !== null) {\r\n            return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\r\n        }\r\n        else {\r\n            return new SetMutation(key, this.data, precondition, this.fieldTransforms);\r\n        }\r\n    }\r\n}\r\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\r\nclass ParsedUpdateData {\r\n    constructor(data, \r\n    // The fieldMask does not include document transforms.\r\n    fieldMask, fieldTransforms) {\r\n        this.data = data;\r\n        this.fieldMask = fieldMask;\r\n        this.fieldTransforms = fieldTransforms;\r\n    }\r\n    toMutation(key, precondition) {\r\n        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);\r\n    }\r\n}\r\nfunction isWrite(dataSource) {\r\n    switch (dataSource) {\r\n        case 0 /* Set */: // fall through\r\n        case 2 /* MergeSet */: // fall through\r\n        case 1 /* Update */:\r\n            return true;\r\n        case 3 /* Argument */:\r\n        case 4 /* ArrayArgument */:\r\n            return false;\r\n        default:\r\n            throw fail();\r\n    }\r\n}\r\n/** A \"context\" object passed around while parsing user data. */\r\nclass ParseContextImpl {\r\n    /**\r\n     * Initializes a ParseContext with the given source and path.\r\n     *\r\n     * @param settings - The settings for the parser.\r\n     * @param databaseId - The database ID of the Firestore instance.\r\n     * @param serializer - The serializer to use to generate the Value proto.\r\n     * @param ignoreUndefinedProperties - Whether to ignore undefined properties\r\n     * rather than throw.\r\n     * @param fieldTransforms - A mutable list of field transforms encountered\r\n     * while parsing the data.\r\n     * @param fieldMask - A mutable list of field paths encountered while parsing\r\n     * the data.\r\n     *\r\n     * TODO(b/34871131): We don't support array paths right now, so path can be\r\n     * null to indicate the context represents any location within an array (in\r\n     * which case certain features will not work and errors will be somewhat\r\n     * compromised).\r\n     */\r\n    constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {\r\n        this.settings = settings;\r\n        this.databaseId = databaseId;\r\n        this.serializer = serializer;\r\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\r\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\r\n        // external call and we need to validate the entire path.\r\n        if (fieldTransforms === undefined) {\r\n            this.validatePath();\r\n        }\r\n        this.fieldTransforms = fieldTransforms || [];\r\n        this.fieldMask = fieldMask || [];\r\n    }\r\n    get path() {\r\n        return this.settings.path;\r\n    }\r\n    get dataSource() {\r\n        return this.settings.dataSource;\r\n    }\r\n    /** Returns a new context with the specified settings overwritten. */\r\n    contextWith(configuration) {\r\n        return new ParseContextImpl(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);\r\n    }\r\n    childContextForField(field) {\r\n        var _a;\r\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\r\n        const context = this.contextWith({ path: childPath, arrayElement: false });\r\n        context.validatePathSegment(field);\r\n        return context;\r\n    }\r\n    childContextForFieldPath(field) {\r\n        var _a;\r\n        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);\r\n        const context = this.contextWith({ path: childPath, arrayElement: false });\r\n        context.validatePath();\r\n        return context;\r\n    }\r\n    childContextForArray(index) {\r\n        // TODO(b/34871131): We don't support array paths right now; so make path\r\n        // undefined.\r\n        return this.contextWith({ path: undefined, arrayElement: true });\r\n    }\r\n    createError(reason) {\r\n        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);\r\n    }\r\n    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */\r\n    contains(fieldPath) {\r\n        return (this.fieldMask.find(field => fieldPath.isPrefixOf(field)) !== undefined ||\r\n            this.fieldTransforms.find(transform => fieldPath.isPrefixOf(transform.field)) !== undefined);\r\n    }\r\n    validatePath() {\r\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\r\n        // within arrays.\r\n        if (!this.path) {\r\n            return;\r\n        }\r\n        for (let i = 0; i < this.path.length; i++) {\r\n            this.validatePathSegment(this.path.get(i));\r\n        }\r\n    }\r\n    validatePathSegment(segment) {\r\n        if (segment.length === 0) {\r\n            throw this.createError('Document fields must not be empty');\r\n        }\r\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\r\n            throw this.createError('Document fields cannot begin and end with \"__\"');\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper for parsing raw user input (provided via the API) into internal model\r\n * classes.\r\n */\r\nclass UserDataReader {\r\n    constructor(databaseId, ignoreUndefinedProperties, serializer) {\r\n        this.databaseId = databaseId;\r\n        this.ignoreUndefinedProperties = ignoreUndefinedProperties;\r\n        this.serializer = serializer || newSerializer(databaseId);\r\n    }\r\n    /** Creates a new top-level parse context. */\r\n    createContext(dataSource, methodName, targetDoc, hasConverter = false) {\r\n        return new ParseContextImpl({\r\n            dataSource,\r\n            methodName,\r\n            targetDoc,\r\n            path: FieldPath$1.emptyPath(),\r\n            arrayElement: false,\r\n            hasConverter\r\n        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);\r\n    }\r\n}\r\nfunction newUserDataReader(firestore) {\r\n    const settings = firestore._freezeSettings();\r\n    const serializer = newSerializer(firestore._databaseId);\r\n    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);\r\n}\r\n/** Parse document data from a set() call. */\r\nfunction parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = {}) {\r\n    const context = userDataReader.createContext(options.merge || options.mergeFields\r\n        ? 2 /* MergeSet */\r\n        : 0 /* Set */, methodName, targetDoc, hasConverter);\r\n    validatePlainObject('Data must be an object, but it was:', context, input);\r\n    const updateData = parseObject(input, context);\r\n    let fieldMask;\r\n    let fieldTransforms;\r\n    if (options.merge) {\r\n        fieldMask = new FieldMask(context.fieldMask);\r\n        fieldTransforms = context.fieldTransforms;\r\n    }\r\n    else if (options.mergeFields) {\r\n        const validatedFieldPaths = [];\r\n        for (const stringOrFieldPath of options.mergeFields) {\r\n            const fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);\r\n            if (!context.contains(fieldPath)) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '${fieldPath}' is specified in your field mask but missing from your input data.`);\r\n            }\r\n            if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {\r\n                validatedFieldPaths.push(fieldPath);\r\n            }\r\n        }\r\n        fieldMask = new FieldMask(validatedFieldPaths);\r\n        fieldTransforms = context.fieldTransforms.filter(transform => fieldMask.covers(transform.field));\r\n    }\r\n    else {\r\n        fieldMask = null;\r\n        fieldTransforms = context.fieldTransforms;\r\n    }\r\n    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);\r\n}\r\nclass DeleteFieldValueImpl extends FieldValue {\r\n    _toFieldTransform(context) {\r\n        if (context.dataSource === 2 /* MergeSet */) {\r\n            // No transform to add for a delete, but we need to add it to our\r\n            // fieldMask so it gets deleted.\r\n            context.fieldMask.push(context.path);\r\n        }\r\n        else if (context.dataSource === 1 /* Update */) {\r\n            throw context.createError(`${this._methodName}() can only appear at the top level ` +\r\n                'of your update data');\r\n        }\r\n        else {\r\n            // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\r\n            throw context.createError(`${this._methodName}() cannot be used with set() unless you pass ` +\r\n                '{merge:true}');\r\n        }\r\n        return null;\r\n    }\r\n    isEqual(other) {\r\n        return other instanceof DeleteFieldValueImpl;\r\n    }\r\n}\r\n/**\r\n * Creates a child context for parsing SerializableFieldValues.\r\n *\r\n * This is different than calling `ParseContext.contextWith` because it keeps\r\n * the fieldTransforms and fieldMask separate.\r\n *\r\n * The created context has its `dataSource` set to `UserDataSource.Argument`.\r\n * Although these values are used with writes, any elements in these FieldValues\r\n * are not considered writes since they cannot contain any FieldValue sentinels,\r\n * etc.\r\n *\r\n * @param fieldValue - The sentinel FieldValue for which to create a child\r\n *     context.\r\n * @param context - The parent context.\r\n * @param arrayElement - Whether or not the FieldValue has an array.\r\n */\r\nfunction createSentinelChildContext(fieldValue, context, arrayElement) {\r\n    return new ParseContextImpl({\r\n        dataSource: 3 /* Argument */,\r\n        targetDoc: context.settings.targetDoc,\r\n        methodName: fieldValue._methodName,\r\n        arrayElement\r\n    }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);\r\n}\r\nclass ServerTimestampFieldValueImpl extends FieldValue {\r\n    _toFieldTransform(context) {\r\n        return new FieldTransform(context.path, new ServerTimestampTransform());\r\n    }\r\n    isEqual(other) {\r\n        return other instanceof ServerTimestampFieldValueImpl;\r\n    }\r\n}\r\nclass ArrayUnionFieldValueImpl extends FieldValue {\r\n    constructor(methodName, _elements) {\r\n        super(methodName);\r\n        this._elements = _elements;\r\n    }\r\n    _toFieldTransform(context) {\r\n        const parseContext = createSentinelChildContext(this, context, \r\n        /*array=*/ true);\r\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\r\n        const arrayUnion = new ArrayUnionTransformOperation(parsedElements);\r\n        return new FieldTransform(context.path, arrayUnion);\r\n    }\r\n    isEqual(other) {\r\n        // TODO(mrschmidt): Implement isEquals\r\n        return this === other;\r\n    }\r\n}\r\nclass ArrayRemoveFieldValueImpl extends FieldValue {\r\n    constructor(methodName, _elements) {\r\n        super(methodName);\r\n        this._elements = _elements;\r\n    }\r\n    _toFieldTransform(context) {\r\n        const parseContext = createSentinelChildContext(this, context, \r\n        /*array=*/ true);\r\n        const parsedElements = this._elements.map(element => parseData(element, parseContext));\r\n        const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);\r\n        return new FieldTransform(context.path, arrayUnion);\r\n    }\r\n    isEqual(other) {\r\n        // TODO(mrschmidt): Implement isEquals\r\n        return this === other;\r\n    }\r\n}\r\nclass NumericIncrementFieldValueImpl extends FieldValue {\r\n    constructor(methodName, _operand) {\r\n        super(methodName);\r\n        this._operand = _operand;\r\n    }\r\n    _toFieldTransform(context) {\r\n        const numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));\r\n        return new FieldTransform(context.path, numericIncrement);\r\n    }\r\n    isEqual(other) {\r\n        // TODO(mrschmidt): Implement isEquals\r\n        return this === other;\r\n    }\r\n}\r\n/** Parse update data from an update() call. */\r\nfunction parseUpdateData(userDataReader, methodName, targetDoc, input) {\r\n    const context = userDataReader.createContext(1 /* Update */, methodName, targetDoc);\r\n    validatePlainObject('Data must be an object, but it was:', context, input);\r\n    const fieldMaskPaths = [];\r\n    const updateData = ObjectValue.empty();\r\n    forEach(input, (key, value) => {\r\n        const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);\r\n        // For Compat types, we have to \"extract\" the underlying types before\r\n        // performing validation.\r\n        value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\r\n        const childContext = context.childContextForFieldPath(path);\r\n        if (value instanceof DeleteFieldValueImpl) {\r\n            // Add it to the field mask, but don't add anything to updateData.\r\n            fieldMaskPaths.push(path);\r\n        }\r\n        else {\r\n            const parsedValue = parseData(value, childContext);\r\n            if (parsedValue != null) {\r\n                fieldMaskPaths.push(path);\r\n                updateData.set(path, parsedValue);\r\n            }\r\n        }\r\n    });\r\n    const mask = new FieldMask(fieldMaskPaths);\r\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\r\n}\r\n/** Parse update data from a list of field/value arguments. */\r\nfunction parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {\r\n    const context = userDataReader.createContext(1 /* Update */, methodName, targetDoc);\r\n    const keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];\r\n    const values = [value];\r\n    if (moreFieldsAndValues.length % 2 !== 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function ${methodName}() needs to be called with an even number ` +\r\n            'of arguments that alternate between field names and values.');\r\n    }\r\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\r\n        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));\r\n        values.push(moreFieldsAndValues[i + 1]);\r\n    }\r\n    const fieldMaskPaths = [];\r\n    const updateData = ObjectValue.empty();\r\n    // We iterate in reverse order to pick the last value for a field if the\r\n    // user specified the field multiple times.\r\n    for (let i = keys.length - 1; i >= 0; --i) {\r\n        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {\r\n            const path = keys[i];\r\n            let value = values[i];\r\n            // For Compat types, we have to \"extract\" the underlying types before\r\n            // performing validation.\r\n            value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\r\n            const childContext = context.childContextForFieldPath(path);\r\n            if (value instanceof DeleteFieldValueImpl) {\r\n                // Add it to the field mask, but don't add anything to updateData.\r\n                fieldMaskPaths.push(path);\r\n            }\r\n            else {\r\n                const parsedValue = parseData(value, childContext);\r\n                if (parsedValue != null) {\r\n                    fieldMaskPaths.push(path);\r\n                    updateData.set(path, parsedValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const mask = new FieldMask(fieldMaskPaths);\r\n    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\r\n}\r\n/**\r\n * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\r\n * bound).\r\n *\r\n * @param allowArrays - Whether the query value is an array that may directly\r\n * contain additional arrays (e.g. the operand of an `in` query).\r\n */\r\nfunction parseQueryValue(userDataReader, methodName, input, allowArrays = false) {\r\n    const context = userDataReader.createContext(allowArrays ? 4 /* ArrayArgument */ : 3 /* Argument */, methodName);\r\n    const parsed = parseData(input, context);\r\n    return parsed;\r\n}\r\n/**\r\n * Parses user data to Protobuf Values.\r\n *\r\n * @param input - Data to be parsed.\r\n * @param context - A context object representing the current path being parsed,\r\n * the source of the data being parsed, etc.\r\n * @returns The parsed value, or null if the value was a FieldValue sentinel\r\n * that should not be included in the resulting parsed data.\r\n */\r\nfunction parseData(input, context) {\r\n    // Unwrap the API type from the Compat SDK. This will return the API type\r\n    // from firestore-exp.\r\n    input = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(input);\r\n    if (looksLikeJsonObject(input)) {\r\n        validatePlainObject('Unsupported field value:', context, input);\r\n        return parseObject(input, context);\r\n    }\r\n    else if (input instanceof FieldValue) {\r\n        // FieldValues usually parse into transforms (except deleteField())\r\n        // in which case we do not want to include this field in our parsed data\r\n        // (as doing so will overwrite the field directly prior to the transform\r\n        // trying to transform it). So we don't add this location to\r\n        // context.fieldMask and we return null as our parsing result.\r\n        parseSentinelFieldValue(input, context);\r\n        return null;\r\n    }\r\n    else if (input === undefined && context.ignoreUndefinedProperties) {\r\n        // If the input is undefined it can never participate in the fieldMask, so\r\n        // don't handle this below. If `ignoreUndefinedProperties` is false,\r\n        // `parseScalarValue` will reject an undefined value.\r\n        return null;\r\n    }\r\n    else {\r\n        // If context.path is null we are inside an array and we don't support\r\n        // field mask paths more granular than the top-level array.\r\n        if (context.path) {\r\n            context.fieldMask.push(context.path);\r\n        }\r\n        if (input instanceof Array) {\r\n            // TODO(b/34871131): Include the path containing the array in the error\r\n            // message.\r\n            // In the case of IN queries, the parsed data is an array (representing\r\n            // the set of values to be included for the IN query) that may directly\r\n            // contain additional arrays (each representing an individual field\r\n            // value), so we disable this validation.\r\n            if (context.settings.arrayElement &&\r\n                context.dataSource !== 4 /* ArrayArgument */) {\r\n                throw context.createError('Nested arrays are not supported');\r\n            }\r\n            return parseArray(input, context);\r\n        }\r\n        else {\r\n            return parseScalarValue(input, context);\r\n        }\r\n    }\r\n}\r\nfunction parseObject(obj, context) {\r\n    const fields = {};\r\n    if (isEmpty(obj)) {\r\n        // If we encounter an empty object, we explicitly add it to the update\r\n        // mask to ensure that the server creates a map entry.\r\n        if (context.path && context.path.length > 0) {\r\n            context.fieldMask.push(context.path);\r\n        }\r\n    }\r\n    else {\r\n        forEach(obj, (key, val) => {\r\n            const parsedValue = parseData(val, context.childContextForField(key));\r\n            if (parsedValue != null) {\r\n                fields[key] = parsedValue;\r\n            }\r\n        });\r\n    }\r\n    return { mapValue: { fields } };\r\n}\r\nfunction parseArray(array, context) {\r\n    const values = [];\r\n    let entryIndex = 0;\r\n    for (const entry of array) {\r\n        let parsedEntry = parseData(entry, context.childContextForArray(entryIndex));\r\n        if (parsedEntry == null) {\r\n            // Just include nulls in the array for fields being replaced with a\r\n            // sentinel.\r\n            parsedEntry = { nullValue: 'NULL_VALUE' };\r\n        }\r\n        values.push(parsedEntry);\r\n        entryIndex++;\r\n    }\r\n    return { arrayValue: { values } };\r\n}\r\n/**\r\n * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\r\n * context.fieldTransforms.\r\n */\r\nfunction parseSentinelFieldValue(value, context) {\r\n    // Sentinels are only supported with writes, and not within arrays.\r\n    if (!isWrite(context.dataSource)) {\r\n        throw context.createError(`${value._methodName}() can only be used with update() and set()`);\r\n    }\r\n    if (!context.path) {\r\n        throw context.createError(`${value._methodName}() is not currently supported inside arrays`);\r\n    }\r\n    const fieldTransform = value._toFieldTransform(context);\r\n    if (fieldTransform) {\r\n        context.fieldTransforms.push(fieldTransform);\r\n    }\r\n}\r\n/**\r\n * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\r\n *\r\n * @returns The parsed value\r\n */\r\nfunction parseScalarValue(value, context) {\r\n    value = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(value);\r\n    if (value === null) {\r\n        return { nullValue: 'NULL_VALUE' };\r\n    }\r\n    else if (typeof value === 'number') {\r\n        return toNumber(context.serializer, value);\r\n    }\r\n    else if (typeof value === 'boolean') {\r\n        return { booleanValue: value };\r\n    }\r\n    else if (typeof value === 'string') {\r\n        return { stringValue: value };\r\n    }\r\n    else if (value instanceof Date) {\r\n        const timestamp = Timestamp.fromDate(value);\r\n        return {\r\n            timestampValue: toTimestamp(context.serializer, timestamp)\r\n        };\r\n    }\r\n    else if (value instanceof Timestamp) {\r\n        // Firestore backend truncates precision down to microseconds. To ensure\r\n        // offline mode works the same with regards to truncation, perform the\r\n        // truncation immediately without waiting for the backend to do that.\r\n        const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000);\r\n        return {\r\n            timestampValue: toTimestamp(context.serializer, timestamp)\r\n        };\r\n    }\r\n    else if (value instanceof GeoPoint) {\r\n        return {\r\n            geoPointValue: {\r\n                latitude: value.latitude,\r\n                longitude: value.longitude\r\n            }\r\n        };\r\n    }\r\n    else if (value instanceof Bytes) {\r\n        return { bytesValue: toBytes(context.serializer, value._byteString) };\r\n    }\r\n    else if (value instanceof DocumentReference) {\r\n        const thisDb = context.databaseId;\r\n        const otherDb = value.firestore._databaseId;\r\n        if (!otherDb.isEqual(thisDb)) {\r\n            throw context.createError('Document reference is for database ' +\r\n                `${otherDb.projectId}/${otherDb.database} but should be ` +\r\n                `for database ${thisDb.projectId}/${thisDb.database}`);\r\n        }\r\n        return {\r\n            referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)\r\n        };\r\n    }\r\n    else {\r\n        throw context.createError(`Unsupported field value: ${valueDescription(value)}`);\r\n    }\r\n}\r\n/**\r\n * Checks whether an object looks like a JSON object that should be converted\r\n * into a struct. Normal class/prototype instances are considered to look like\r\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\r\n * GeoPoints, etc. are not considered to look like JSON objects since they map\r\n * to specific FieldValue types other than ObjectValue.\r\n */\r\nfunction looksLikeJsonObject(input) {\r\n    return (typeof input === 'object' &&\r\n        input !== null &&\r\n        !(input instanceof Array) &&\r\n        !(input instanceof Date) &&\r\n        !(input instanceof Timestamp) &&\r\n        !(input instanceof GeoPoint) &&\r\n        !(input instanceof Bytes) &&\r\n        !(input instanceof DocumentReference) &&\r\n        !(input instanceof FieldValue));\r\n}\r\nfunction validatePlainObject(message, context, input) {\r\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\r\n        const description = valueDescription(input);\r\n        if (description === 'an object') {\r\n            // Massage the error if it was an object.\r\n            throw context.createError(message + ' a custom object');\r\n        }\r\n        else {\r\n            throw context.createError(message + ' ' + description);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\r\n */\r\nfunction fieldPathFromArgument$1(methodName, path, targetDoc) {\r\n    // If required, replace the FieldPath Compat class with with the firestore-exp\r\n    // FieldPath.\r\n    path = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(path);\r\n    if (path instanceof FieldPath) {\r\n        return path._internalPath;\r\n    }\r\n    else if (typeof path === 'string') {\r\n        return fieldPathFromDotSeparatedString(methodName, path);\r\n    }\r\n    else {\r\n        const message = 'Field path arguments must be of type string or ';\r\n        throw createError(message, methodName, \r\n        /* hasConverter= */ false, \r\n        /* path= */ undefined, targetDoc);\r\n    }\r\n}\r\n/**\r\n * Matches any characters in a field path string that are reserved.\r\n */\r\nconst FIELD_PATH_RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\r\n/**\r\n * Wraps fromDotSeparatedString with an error message about the method that\r\n * was thrown.\r\n * @param methodName - The publicly visible method name\r\n * @param path - The dot-separated string form of a field path which will be\r\n * split on dots.\r\n * @param targetDoc - The document against which the field path will be\r\n * evaluated.\r\n */\r\nfunction fieldPathFromDotSeparatedString(methodName, path, targetDoc) {\r\n    const found = path.search(FIELD_PATH_RESERVED);\r\n    if (found >= 0) {\r\n        throw createError(`Invalid field path (${path}). Paths must not contain ` +\r\n            `'~', '*', '/', '[', or ']'`, methodName, \r\n        /* hasConverter= */ false, \r\n        /* path= */ undefined, targetDoc);\r\n    }\r\n    try {\r\n        return new FieldPath(...path.split('.'))._internalPath;\r\n    }\r\n    catch (e) {\r\n        throw createError(`Invalid field path (${path}). Paths must not be empty, ` +\r\n            `begin with '.', end with '.', or contain '..'`, methodName, \r\n        /* hasConverter= */ false, \r\n        /* path= */ undefined, targetDoc);\r\n    }\r\n}\r\nfunction createError(reason, methodName, hasConverter, path, targetDoc) {\r\n    const hasPath = path && !path.isEmpty();\r\n    const hasDocument = targetDoc !== undefined;\r\n    let message = `Function ${methodName}() called with invalid data`;\r\n    if (hasConverter) {\r\n        message += ' (via `toFirestore()`)';\r\n    }\r\n    message += '. ';\r\n    let description = '';\r\n    if (hasPath || hasDocument) {\r\n        description += ' (found';\r\n        if (hasPath) {\r\n            description += ` in field ${path}`;\r\n        }\r\n        if (hasDocument) {\r\n            description += ` in document ${targetDoc}`;\r\n        }\r\n        description += ')';\r\n    }\r\n    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);\r\n}\r\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */\r\nfunction fieldMaskContains(haystack, needle) {\r\n    return haystack.some(v => v.isEqual(needle));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A `DocumentSnapshot` contains data read from a document in your Firestore\r\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\r\n * get a specific field.\r\n *\r\n * For a `DocumentSnapshot` that points to a non-existing document, any data\r\n * access will return 'undefined'. You can use the `exists()` method to\r\n * explicitly verify a document's existence.\r\n */\r\nclass DocumentSnapshot$1 {\r\n    // Note: This class is stripped down version of the DocumentSnapshot in\r\n    // the legacy SDK. The changes are:\r\n    // - No support for SnapshotMetadata.\r\n    // - No support for SnapshotOptions.\r\n    /** @hideconstructor protected */\r\n    constructor(_firestore, _userDataWriter, _key, _document, _converter) {\r\n        this._firestore = _firestore;\r\n        this._userDataWriter = _userDataWriter;\r\n        this._key = _key;\r\n        this._document = _document;\r\n        this._converter = _converter;\r\n    }\r\n    /** Property of the `DocumentSnapshot` that provides the document's ID. */\r\n    get id() {\r\n        return this._key.path.lastSegment();\r\n    }\r\n    /**\r\n     * The `DocumentReference` for the document included in the `DocumentSnapshot`.\r\n     */\r\n    get ref() {\r\n        return new DocumentReference(this._firestore, this._converter, this._key);\r\n    }\r\n    /**\r\n     * Signals whether or not the document at the snapshot's location exists.\r\n     *\r\n     * @returns true if the document exists.\r\n     */\r\n    exists() {\r\n        return this._document !== null;\r\n    }\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\r\n     * the document doesn't exist.\r\n     *\r\n     * @returns An `Object` containing all fields in the document or `undefined`\r\n     * if the document doesn't exist.\r\n     */\r\n    data() {\r\n        if (!this._document) {\r\n            return undefined;\r\n        }\r\n        else if (this._converter) {\r\n            // We only want to use the converter and create a new DocumentSnapshot\r\n            // if a converter has been provided.\r\n            const snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, \r\n            /* converter= */ null);\r\n            return this._converter.fromFirestore(snapshot);\r\n        }\r\n        else {\r\n            return this._userDataWriter.convertValue(this._document.data.value);\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\r\n     * document or field doesn't exist.\r\n     *\r\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\r\n     * field.\r\n     * @returns The data at the specified field location or undefined if no such\r\n     * field exists in the document.\r\n     */\r\n    // We are using `any` here to avoid an explicit cast by our users.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    get(fieldPath) {\r\n        if (this._document) {\r\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\r\n            if (value !== null) {\r\n                return this._userDataWriter.convertValue(value);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * A `QueryDocumentSnapshot` contains data read from a document in your\r\n * Firestore database as part of a query. The document is guaranteed to exist\r\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\r\n * specific field.\r\n *\r\n * A `QueryDocumentSnapshot` offers the same API surface as a\r\n * `DocumentSnapshot`. Since query results contain only existing documents, the\r\n * `exists` property will always be true and `data()` will never return\r\n * 'undefined'.\r\n */\r\nclass QueryDocumentSnapshot$1 extends DocumentSnapshot$1 {\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`.\r\n     *\r\n     * @override\r\n     * @returns An `Object` containing all fields in the document.\r\n     */\r\n    data() {\r\n        return super.data();\r\n    }\r\n}\r\n/**\r\n * Helper that calls `fromDotSeparatedString()` but wraps any error thrown.\r\n */\r\nfunction fieldPathFromArgument(methodName, arg) {\r\n    if (typeof arg === 'string') {\r\n        return fieldPathFromDotSeparatedString(methodName, arg);\r\n    }\r\n    else if (arg instanceof FieldPath) {\r\n        return arg._internalPath;\r\n    }\r\n    else {\r\n        return arg._delegate._internalPath;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Metadata about a snapshot, describing the state of the snapshot.\r\n */\r\nclass SnapshotMetadata {\r\n    /** @hideconstructor */\r\n    constructor(hasPendingWrites, fromCache) {\r\n        this.hasPendingWrites = hasPendingWrites;\r\n        this.fromCache = fromCache;\r\n    }\r\n    /**\r\n     * Returns true if this `SnapshotMetadata` is equal to the provided one.\r\n     *\r\n     * @param other - The `SnapshotMetadata` to compare against.\r\n     * @returns true if this `SnapshotMetadata` is equal to the provided one.\r\n     */\r\n    isEqual(other) {\r\n        return (this.hasPendingWrites === other.hasPendingWrites &&\r\n            this.fromCache === other.fromCache);\r\n    }\r\n}\r\n/**\r\n * A `DocumentSnapshot` contains data read from a document in your Firestore\r\n * database. The data can be extracted with `.data()` or `.get(<field>)` to\r\n * get a specific field.\r\n *\r\n * For a `DocumentSnapshot` that points to a non-existing document, any data\r\n * access will return 'undefined'. You can use the `exists()` method to\r\n * explicitly verify a document's existence.\r\n */\r\nclass DocumentSnapshot extends DocumentSnapshot$1 {\r\n    /** @hideconstructor protected */\r\n    constructor(_firestore, userDataWriter, key, document, metadata, converter) {\r\n        super(_firestore, userDataWriter, key, document, converter);\r\n        this._firestore = _firestore;\r\n        this._firestoreImpl = _firestore;\r\n        this.metadata = metadata;\r\n    }\r\n    /**\r\n     * Returns whether or not the data exists. True if the document exists.\r\n     */\r\n    exists() {\r\n        return super.exists();\r\n    }\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`. Returns `undefined` if\r\n     * the document doesn't exist.\r\n     *\r\n     * By default, `serverTimestamp()` values that have not yet been\r\n     * set to their final value will be returned as `null`. You can override\r\n     * this by passing an options object.\r\n     *\r\n     * @param options - An options object to configure how data is retrieved from\r\n     * the snapshot (for example the desired behavior for server timestamps that\r\n     * have not yet been set to their final value).\r\n     * @returns An `Object` containing all fields in the document or `undefined` if\r\n     * the document doesn't exist.\r\n     */\r\n    data(options = {}) {\r\n        if (!this._document) {\r\n            return undefined;\r\n        }\r\n        else if (this._converter) {\r\n            // We only want to use the converter and create a new DocumentSnapshot\r\n            // if a converter has been provided.\r\n            const snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, \r\n            /* converter= */ null);\r\n            return this._converter.fromFirestore(snapshot, options);\r\n        }\r\n        else {\r\n            return this._userDataWriter.convertValue(this._document.data.value, options.serverTimestamps);\r\n        }\r\n    }\r\n    /**\r\n     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the\r\n     * document or field doesn't exist.\r\n     *\r\n     * By default, a `serverTimestamp()` that has not yet been set to\r\n     * its final value will be returned as `null`. You can override this by\r\n     * passing an options object.\r\n     *\r\n     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific\r\n     * field.\r\n     * @param options - An options object to configure how the field is retrieved\r\n     * from the snapshot (for example the desired behavior for server timestamps\r\n     * that have not yet been set to their final value).\r\n     * @returns The data at the specified field location or undefined if no such\r\n     * field exists in the document.\r\n     */\r\n    // We are using `any` here to avoid an explicit cast by our users.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    get(fieldPath, options = {}) {\r\n        if (this._document) {\r\n            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\r\n            if (value !== null) {\r\n                return this._userDataWriter.convertValue(value, options.serverTimestamps);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n/**\r\n * A `QueryDocumentSnapshot` contains data read from a document in your\r\n * Firestore database as part of a query. The document is guaranteed to exist\r\n * and its data can be extracted with `.data()` or `.get(<field>)` to get a\r\n * specific field.\r\n *\r\n * A `QueryDocumentSnapshot` offers the same API surface as a\r\n * `DocumentSnapshot`. Since query results contain only existing documents, the\r\n * `exists` property will always be true and `data()` will never return\r\n * 'undefined'.\r\n */\r\nclass QueryDocumentSnapshot extends DocumentSnapshot {\r\n    /**\r\n     * Retrieves all fields in the document as an `Object`.\r\n     *\r\n     * By default, `serverTimestamp()` values that have not yet been\r\n     * set to their final value will be returned as `null`. You can override\r\n     * this by passing an options object.\r\n     *\r\n     * @override\r\n     * @param options - An options object to configure how data is retrieved from\r\n     * the snapshot (for example the desired behavior for server timestamps that\r\n     * have not yet been set to their final value).\r\n     * @returns An `Object` containing all fields in the document.\r\n     */\r\n    data(options = {}) {\r\n        return super.data(options);\r\n    }\r\n}\r\n/**\r\n * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects\r\n * representing the results of a query. The documents can be accessed as an\r\n * array via the `docs` property or enumerated using the `forEach` method. The\r\n * number of documents can be determined via the `empty` and `size`\r\n * properties.\r\n */\r\nclass QuerySnapshot {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _userDataWriter, query, _snapshot) {\r\n        this._firestore = _firestore;\r\n        this._userDataWriter = _userDataWriter;\r\n        this._snapshot = _snapshot;\r\n        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);\r\n        this.query = query;\r\n    }\r\n    /** An array of all the documents in the `QuerySnapshot`. */\r\n    get docs() {\r\n        const result = [];\r\n        this.forEach(doc => result.push(doc));\r\n        return result;\r\n    }\r\n    /** The number of documents in the `QuerySnapshot`. */\r\n    get size() {\r\n        return this._snapshot.docs.size;\r\n    }\r\n    /** True if there are no documents in the `QuerySnapshot`. */\r\n    get empty() {\r\n        return this.size === 0;\r\n    }\r\n    /**\r\n     * Enumerates all of the documents in the `QuerySnapshot`.\r\n     *\r\n     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for\r\n     * each document in the snapshot.\r\n     * @param thisArg - The `this` binding for the callback.\r\n     */\r\n    forEach(callback, thisArg) {\r\n        this._snapshot.docs.forEach(doc => {\r\n            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, this._userDataWriter, doc.key, doc, new SnapshotMetadata(this._snapshot.mutatedKeys.has(doc.key), this._snapshot.fromCache), this.query.converter));\r\n        });\r\n    }\r\n    /**\r\n     * Returns an array of the documents changes since the last snapshot. If this\r\n     * is the first snapshot, all documents will be in the list as 'added'\r\n     * changes.\r\n     *\r\n     * @param options - `SnapshotListenOptions` that control whether metadata-only\r\n     * changes (i.e. only `DocumentSnapshot.metadata` changed) should trigger\r\n     * snapshot events.\r\n     */\r\n    docChanges(options = {}) {\r\n        const includeMetadataChanges = !!options.includeMetadataChanges;\r\n        if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'To include metadata changes with your document changes, you must ' +\r\n                'also pass { includeMetadataChanges:true } to onSnapshot().');\r\n        }\r\n        if (!this._cachedChanges ||\r\n            this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {\r\n            this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);\r\n            this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\r\n        }\r\n        return this._cachedChanges;\r\n    }\r\n}\r\n/** Calculates the array of `DocumentChange`s for a given `ViewSnapshot`. */\r\nfunction changesFromSnapshot(querySnapshot, includeMetadataChanges) {\r\n    if (querySnapshot._snapshot.oldDocs.isEmpty()) {\r\n        let index = 0;\r\n        return querySnapshot._snapshot.docChanges.map(change => {\r\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\r\n            return {\r\n                type: 'added',\r\n                doc,\r\n                oldIndex: -1,\r\n                newIndex: index++\r\n            };\r\n        });\r\n    }\r\n    else {\r\n        // A `DocumentSet` that is updated incrementally as changes are applied to use\r\n        // to lookup the index of a document.\r\n        let indexTracker = querySnapshot._snapshot.oldDocs;\r\n        return querySnapshot._snapshot.docChanges\r\n            .filter(change => includeMetadataChanges || change.type !== 3 /* Metadata */)\r\n            .map(change => {\r\n            const doc = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);\r\n            let oldIndex = -1;\r\n            let newIndex = -1;\r\n            if (change.type !== 0 /* Added */) {\r\n                oldIndex = indexTracker.indexOf(change.doc.key);\r\n                indexTracker = indexTracker.delete(change.doc.key);\r\n            }\r\n            if (change.type !== 1 /* Removed */) {\r\n                indexTracker = indexTracker.add(change.doc);\r\n                newIndex = indexTracker.indexOf(change.doc.key);\r\n            }\r\n            return {\r\n                type: resultChangeType(change.type),\r\n                doc,\r\n                oldIndex,\r\n                newIndex\r\n            };\r\n        });\r\n    }\r\n}\r\nfunction resultChangeType(type) {\r\n    switch (type) {\r\n        case 0 /* Added */:\r\n            return 'added';\r\n        case 2 /* Modified */:\r\n        case 3 /* Metadata */:\r\n            return 'modified';\r\n        case 1 /* Removed */:\r\n            return 'removed';\r\n        default:\r\n            return fail();\r\n    }\r\n}\r\n// TODO(firestoreexp): Add tests for snapshotEqual with different snapshot\r\n// metadata\r\n/**\r\n * Returns true if the provided snapshots are equal.\r\n *\r\n * @param left - A snapshot to compare.\r\n * @param right - A snapshot to compare.\r\n * @returns true if the snapshots are equal.\r\n */\r\nfunction snapshotEqual(left, right) {\r\n    if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {\r\n        return (left._firestore === right._firestore &&\r\n            left._key.isEqual(right._key) &&\r\n            (left._document === null\r\n                ? right._document === null\r\n                : left._document.isEqual(right._document)) &&\r\n            left._converter === right._converter);\r\n    }\r\n    else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {\r\n        return (left._firestore === right._firestore &&\r\n            queryEqual(left.query, right.query) &&\r\n            left.metadata.isEqual(right.metadata) &&\r\n            left._snapshot.isEqual(right._snapshot));\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction validateHasExplicitOrderByForLimitToLast(query) {\r\n    if (hasLimitToLast(query) && query.explicitOrderBy.length === 0) {\r\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');\r\n    }\r\n}\r\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Firestore query. `QueryConstraint`s are created by invoking {@link where},\r\n * {@link orderBy}, {@link (startAt:1)}, {@link (startAfter:1)}, {@link\r\n * endBefore:1}, {@link (endAt:1)}, {@link limit} or {@link limitToLast} and\r\n * can then be passed to {@link query} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */\r\nclass QueryConstraint {\r\n}\r\n/**\r\n * Creates a new immutable instance of {@link Query} that is extended to also include\r\n * additional query constraints.\r\n *\r\n * @param query - The {@link Query} instance to use as a base for the new constraints.\r\n * @param queryConstraints - The list of {@link QueryConstraint}s to apply.\r\n * @throws if any of the provided query constraints cannot be combined with the\r\n * existing or new constraints.\r\n */\r\nfunction query(query, ...queryConstraints) {\r\n    for (const constraint of queryConstraints) {\r\n        query = constraint._apply(query);\r\n    }\r\n    return query;\r\n}\r\nclass QueryFilterConstraint extends QueryConstraint {\r\n    constructor(_field, _op, _value) {\r\n        super();\r\n        this._field = _field;\r\n        this._op = _op;\r\n        this._value = _value;\r\n        this.type = 'where';\r\n    }\r\n    _apply(query) {\r\n        const reader = newUserDataReader(query.firestore);\r\n        const filter = newQueryFilter(query._query, 'where', reader, query.firestore._databaseId, this._field, this._op, this._value);\r\n        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, filter));\r\n    }\r\n}\r\n/**\r\n * Creates a {@link QueryConstraint} that enforces that documents must contain the\r\n * specified field and that the value should satisfy the relation constraint\r\n * provided.\r\n *\r\n * @param fieldPath - The path to compare\r\n * @param opStr - The operation string (e.g \"&lt;\", \"&lt;=\", \"==\", \"&lt;\",\r\n *   \"&lt;=\", \"!=\").\r\n * @param value - The value for comparison\r\n * @returns The created {@link Query}.\r\n */\r\nfunction where(fieldPath, opStr, value) {\r\n    const op = opStr;\r\n    const field = fieldPathFromArgument('where', fieldPath);\r\n    return new QueryFilterConstraint(field, op, value);\r\n}\r\nclass QueryOrderByConstraint extends QueryConstraint {\r\n    constructor(_field, _direction) {\r\n        super();\r\n        this._field = _field;\r\n        this._direction = _direction;\r\n        this.type = 'orderBy';\r\n    }\r\n    _apply(query) {\r\n        const orderBy = newQueryOrderBy(query._query, this._field, this._direction);\r\n        return new Query(query.firestore, query.converter, queryWithAddedOrderBy(query._query, orderBy));\r\n    }\r\n}\r\n/**\r\n * Creates a {@link QueryConstraint} that sorts the query result by the\r\n * specified field, optionally in descending order instead of ascending.\r\n *\r\n * @param fieldPath - The field to sort by.\r\n * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If\r\n * not specified, order will be ascending.\r\n * @returns The created {@link Query}.\r\n */\r\nfunction orderBy(fieldPath, directionStr = 'asc') {\r\n    const direction = directionStr;\r\n    const path = fieldPathFromArgument('orderBy', fieldPath);\r\n    return new QueryOrderByConstraint(path, direction);\r\n}\r\nclass QueryLimitConstraint extends QueryConstraint {\r\n    constructor(type, _limit, _limitType) {\r\n        super();\r\n        this.type = type;\r\n        this._limit = _limit;\r\n        this._limitType = _limitType;\r\n    }\r\n    _apply(query) {\r\n        return new Query(query.firestore, query.converter, queryWithLimit(query._query, this._limit, this._limitType));\r\n    }\r\n}\r\n/**\r\n * Creates a {@link QueryConstraint} that only returns the first matching documents.\r\n *\r\n * @param limit - The maximum number of items to return.\r\n * @returns The created {@link Query}.\r\n */\r\nfunction limit(limit) {\r\n    validatePositiveNumber('limit', limit);\r\n    return new QueryLimitConstraint('limit', limit, \"F\" /* First */);\r\n}\r\n/**\r\n * Creates a {@link QueryConstraint} that only returns the last matching documents.\r\n *\r\n * You must specify at least one `orderBy` clause for `limitToLast` queries,\r\n * otherwise an exception will be thrown during execution.\r\n *\r\n * @param limit - The maximum number of items to return.\r\n * @returns The created {@link Query}.\r\n */\r\nfunction limitToLast(limit) {\r\n    validatePositiveNumber('limitToLast', limit);\r\n    return new QueryLimitConstraint('limitToLast', limit, \"L\" /* Last */);\r\n}\r\nclass QueryStartAtConstraint extends QueryConstraint {\r\n    constructor(type, _docOrFields, _inclusive) {\r\n        super();\r\n        this.type = type;\r\n        this._docOrFields = _docOrFields;\r\n        this._inclusive = _inclusive;\r\n    }\r\n    _apply(query) {\r\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\r\n        return new Query(query.firestore, query.converter, queryWithStartAt(query._query, bound));\r\n    }\r\n}\r\nfunction startAt(...docOrFields) {\r\n    return new QueryStartAtConstraint('startAt', docOrFields, \r\n    /*inclusive=*/ true);\r\n}\r\nfunction startAfter(...docOrFields) {\r\n    return new QueryStartAtConstraint('startAfter', docOrFields, \r\n    /*inclusive=*/ false);\r\n}\r\nclass QueryEndAtConstraint extends QueryConstraint {\r\n    constructor(type, _docOrFields, _inclusive) {\r\n        super();\r\n        this.type = type;\r\n        this._docOrFields = _docOrFields;\r\n        this._inclusive = _inclusive;\r\n    }\r\n    _apply(query) {\r\n        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);\r\n        return new Query(query.firestore, query.converter, queryWithEndAt(query._query, bound));\r\n    }\r\n}\r\nfunction endBefore(...docOrFields) {\r\n    return new QueryEndAtConstraint('endBefore', docOrFields, \r\n    /*inclusive=*/ false);\r\n}\r\nfunction endAt(...docOrFields) {\r\n    return new QueryEndAtConstraint('endAt', docOrFields, /*inclusive=*/ true);\r\n}\r\n/** Helper function to create a bound from a document or fields */\r\nfunction newQueryBoundFromDocOrFields(query, methodName, docOrFields, inclusive) {\r\n    docOrFields[0] = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(docOrFields[0]);\r\n    if (docOrFields[0] instanceof DocumentSnapshot$1) {\r\n        return newQueryBoundFromDocument(query._query, query.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);\r\n    }\r\n    else {\r\n        const reader = newUserDataReader(query.firestore);\r\n        return newQueryBoundFromFields(query._query, query.firestore._databaseId, reader, methodName, docOrFields, inclusive);\r\n    }\r\n}\r\nfunction newQueryFilter(query, methodName, dataReader, databaseId, fieldPath, op, value) {\r\n    let fieldValue;\r\n    if (fieldPath.isKeyField()) {\r\n        if (op === \"array-contains\" /* ARRAY_CONTAINS */ || op === \"array-contains-any\" /* ARRAY_CONTAINS_ANY */) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. You can't perform '${op}' queries on documentId().`);\r\n        }\r\n        else if (op === \"in\" /* IN */ || op === \"not-in\" /* NOT_IN */) {\r\n            validateDisjunctiveFilterElements(value, op);\r\n            const referenceList = [];\r\n            for (const arrayValue of value) {\r\n                referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));\r\n            }\r\n            fieldValue = { arrayValue: { values: referenceList } };\r\n        }\r\n        else {\r\n            fieldValue = parseDocumentIdValue(databaseId, query, value);\r\n        }\r\n    }\r\n    else {\r\n        if (op === \"in\" /* IN */ ||\r\n            op === \"not-in\" /* NOT_IN */ ||\r\n            op === \"array-contains-any\" /* ARRAY_CONTAINS_ANY */) {\r\n            validateDisjunctiveFilterElements(value, op);\r\n        }\r\n        fieldValue = parseQueryValue(dataReader, methodName, value, \r\n        /* allowArrays= */ op === \"in\" /* IN */ || op === \"not-in\" /* NOT_IN */);\r\n    }\r\n    const filter = FieldFilter.create(fieldPath, op, fieldValue);\r\n    validateNewFilter(query, filter);\r\n    return filter;\r\n}\r\nfunction newQueryOrderBy(query, fieldPath, direction) {\r\n    if (query.startAt !== null) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before ' +\r\n            'calling orderBy().');\r\n    }\r\n    if (query.endAt !== null) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before ' +\r\n            'calling orderBy().');\r\n    }\r\n    const orderBy = new OrderBy(fieldPath, direction);\r\n    validateNewOrderBy(query, orderBy);\r\n    return orderBy;\r\n}\r\n/**\r\n * Create a `Bound` from a query and a document.\r\n *\r\n * Note that the `Bound` will always include the key of the document\r\n * and so only the provided document will compare equal to the returned\r\n * position.\r\n *\r\n * Will throw if the document does not contain all fields of the order by\r\n * of the query or if any of the fields in the order by are an uncommitted\r\n * server timestamp.\r\n */\r\nfunction newQueryBoundFromDocument(query, databaseId, methodName, doc, inclusive) {\r\n    if (!doc) {\r\n        throw new FirestoreError(Code.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ` +\r\n            `${methodName}().`);\r\n    }\r\n    const components = [];\r\n    // Because people expect to continue/end a query at the exact document\r\n    // provided, we need to use the implicit sort order rather than the explicit\r\n    // sort order, because it's guaranteed to contain the document key. That way\r\n    // the position becomes unambiguous and the query continues/ends exactly at\r\n    // the provided document. Without the key (by using the explicit sort\r\n    // orders), multiple documents could match the position, yielding duplicate\r\n    // results.\r\n    for (const orderBy of queryOrderBy(query)) {\r\n        if (orderBy.field.isKeyField()) {\r\n            components.push(refValue(databaseId, doc.key));\r\n        }\r\n        else {\r\n            const value = doc.data.field(orderBy.field);\r\n            if (isServerTimestamp(value)) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a ' +\r\n                    'document for which the field \"' +\r\n                    orderBy.field +\r\n                    '\" is an uncommitted server timestamp. (Since the value of ' +\r\n                    'this field is unknown, you cannot start/end a query with it.)');\r\n            }\r\n            else if (value !== null) {\r\n                components.push(value);\r\n            }\r\n            else {\r\n                const field = orderBy.field.canonicalString();\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a ` +\r\n                    `document for which the field '${field}' (used as the ` +\r\n                    `orderBy) does not exist.`);\r\n            }\r\n        }\r\n    }\r\n    return new Bound(components, inclusive);\r\n}\r\n/**\r\n * Converts a list of field values to a `Bound` for the given query.\r\n */\r\nfunction newQueryBoundFromFields(query, databaseId, dataReader, methodName, values, inclusive) {\r\n    // Use explicit order by's because it has to match the query the user made\r\n    const orderBy = query.explicitOrderBy;\r\n    if (values.length > orderBy.length) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Too many arguments provided to ${methodName}(). ` +\r\n            `The number of arguments must be less than or equal to the ` +\r\n            `number of orderBy() clauses`);\r\n    }\r\n    const components = [];\r\n    for (let i = 0; i < values.length; i++) {\r\n        const rawValue = values[i];\r\n        const orderByComponent = orderBy[i];\r\n        if (orderByComponent.field.isKeyField()) {\r\n            if (typeof rawValue !== 'string') {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ` +\r\n                    `${methodName}(), but got a ${typeof rawValue}`);\r\n            }\r\n            if (!isCollectionGroupQuery(query) && rawValue.indexOf('/') !== -1) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), ` +\r\n                    `the value passed to ${methodName}() must be a plain document ID, but ` +\r\n                    `'${rawValue}' contains a slash.`);\r\n            }\r\n            const path = query.path.child(ResourcePath.fromString(rawValue));\r\n            if (!DocumentKey.isDocumentKey(path)) {\r\n                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by ` +\r\n                    `documentId(), the value passed to ${methodName}() must result in a ` +\r\n                    `valid document path, but '${path}' is not because it contains an odd number ` +\r\n                    `of segments.`);\r\n            }\r\n            const key = new DocumentKey(path);\r\n            components.push(refValue(databaseId, key));\r\n        }\r\n        else {\r\n            const wrapped = parseQueryValue(dataReader, methodName, rawValue);\r\n            components.push(wrapped);\r\n        }\r\n    }\r\n    return new Bound(components, inclusive);\r\n}\r\n/**\r\n * Parses the given `documentIdValue` into a `ReferenceValue`, throwing\r\n * appropriate errors if the value is anything other than a `DocumentReference`\r\n * or `string`, or if the string is malformed.\r\n */\r\nfunction parseDocumentIdValue(databaseId, query, documentIdValue) {\r\n    documentIdValue = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentIdValue);\r\n    if (typeof documentIdValue === 'string') {\r\n        if (documentIdValue === '') {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. When querying with documentId(), you ' +\r\n                'must provide a valid document ID, but it was an empty string.');\r\n        }\r\n        if (!isCollectionGroupQuery(query) && documentIdValue.indexOf('/') !== -1) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection by ` +\r\n                `documentId(), you must provide a plain document ID, but ` +\r\n                `'${documentIdValue}' contains a '/' character.`);\r\n        }\r\n        const path = query.path.child(ResourcePath.fromString(documentIdValue));\r\n        if (!DocumentKey.isDocumentKey(path)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group by ` +\r\n                `documentId(), the value provided must result in a valid document path, ` +\r\n                `but '${path}' is not because it has an odd number of segments (${path.length}).`);\r\n        }\r\n        return refValue(databaseId, new DocumentKey(path));\r\n    }\r\n    else if (documentIdValue instanceof DocumentReference) {\r\n        return refValue(databaseId, documentIdValue._key);\r\n    }\r\n    else {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid ` +\r\n            `string or a DocumentReference, but it was: ` +\r\n            `${valueDescription(documentIdValue)}.`);\r\n    }\r\n}\r\n/**\r\n * Validates that the value passed into a disjunctive filter satisfies all\r\n * array requirements.\r\n */\r\nfunction validateDisjunctiveFilterElements(value, operator) {\r\n    if (!Array.isArray(value) || value.length === 0) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid Query. A non-empty array is required for ' +\r\n            `'${operator.toString()}' filters.`);\r\n    }\r\n    if (value.length > 10) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. '${operator.toString()}' filters support a ` +\r\n            'maximum of 10 elements in the value array.');\r\n    }\r\n}\r\n/**\r\n * Given an operator, returns the set of operators that cannot be used with it.\r\n *\r\n * Operators in a query must adhere to the following set of rules:\r\n * 1. Only one array operator is allowed.\r\n * 2. Only one disjunctive operator is allowed.\r\n * 3. `NOT_EQUAL` cannot be used with another `NOT_EQUAL` operator.\r\n * 4. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.\r\n *\r\n * Array operators: `ARRAY_CONTAINS`, `ARRAY_CONTAINS_ANY`\r\n * Disjunctive operators: `IN`, `ARRAY_CONTAINS_ANY`, `NOT_IN`\r\n */\r\nfunction conflictingOps(op) {\r\n    switch (op) {\r\n        case \"!=\" /* NOT_EQUAL */:\r\n            return [\"!=\" /* NOT_EQUAL */, \"not-in\" /* NOT_IN */];\r\n        case \"array-contains\" /* ARRAY_CONTAINS */:\r\n            return [\r\n                \"array-contains\" /* ARRAY_CONTAINS */,\r\n                \"array-contains-any\" /* ARRAY_CONTAINS_ANY */,\r\n                \"not-in\" /* NOT_IN */\r\n            ];\r\n        case \"in\" /* IN */:\r\n            return [\"array-contains-any\" /* ARRAY_CONTAINS_ANY */, \"in\" /* IN */, \"not-in\" /* NOT_IN */];\r\n        case \"array-contains-any\" /* ARRAY_CONTAINS_ANY */:\r\n            return [\r\n                \"array-contains\" /* ARRAY_CONTAINS */,\r\n                \"array-contains-any\" /* ARRAY_CONTAINS_ANY */,\r\n                \"in\" /* IN */,\r\n                \"not-in\" /* NOT_IN */\r\n            ];\r\n        case \"not-in\" /* NOT_IN */:\r\n            return [\r\n                \"array-contains\" /* ARRAY_CONTAINS */,\r\n                \"array-contains-any\" /* ARRAY_CONTAINS_ANY */,\r\n                \"in\" /* IN */,\r\n                \"not-in\" /* NOT_IN */,\r\n                \"!=\" /* NOT_EQUAL */\r\n            ];\r\n        default:\r\n            return [];\r\n    }\r\n}\r\nfunction validateNewFilter(query, filter) {\r\n    if (filter.isInequality()) {\r\n        const existingField = getInequalityFilterField(query);\r\n        if (existingField !== null && !existingField.isEqual(filter.field)) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' +\r\n                ' (<, <=, !=, not-in, >, or >=) must be on the same field. But you have' +\r\n                ` inequality filters on '${existingField.toString()}'` +\r\n                ` and '${filter.field.toString()}'`);\r\n        }\r\n        const firstOrderByField = getFirstOrderByField(query);\r\n        if (firstOrderByField !== null) {\r\n            validateOrderByAndInequalityMatch(query, filter.field, firstOrderByField);\r\n        }\r\n    }\r\n    const conflictingOp = findFilterOperator(query, conflictingOps(filter.op));\r\n    if (conflictingOp !== null) {\r\n        // Special case when it's a duplicate op to give a slightly clearer error message.\r\n        if (conflictingOp === filter.op) {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You cannot use more than one ' +\r\n                `'${filter.op.toString()}' filter.`);\r\n        }\r\n        else {\r\n            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use '${filter.op.toString()}' filters ` +\r\n                `with '${conflictingOp.toString()}' filters.`);\r\n        }\r\n    }\r\n}\r\nfunction validateNewOrderBy(query, orderBy) {\r\n    if (getFirstOrderByField(query) === null) {\r\n        // This is the first order by. It must match any inequality.\r\n        const inequalityField = getInequalityFilterField(query);\r\n        if (inequalityField !== null) {\r\n            validateOrderByAndInequalityMatch(query, inequalityField, orderBy.field);\r\n        }\r\n    }\r\n}\r\nfunction validateOrderByAndInequalityMatch(baseQuery, inequality, orderBy) {\r\n    if (!orderBy.isEqual(inequality)) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality ` +\r\n            `(<, <=, !=, not-in, >, or >=) on field '${inequality.toString()}' ` +\r\n            `and so you must also use '${inequality.toString()}' ` +\r\n            `as your first argument to orderBy(), but your first orderBy() ` +\r\n            `is on field '${orderBy.toString()}' instead.`);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Converts Firestore's internal types to the JavaScript types that we expose\r\n * to the user.\r\n *\r\n * @internal\r\n */\r\nclass AbstractUserDataWriter {\r\n    convertValue(value, serverTimestampBehavior = 'none') {\r\n        switch (typeOrder(value)) {\r\n            case 0 /* NullValue */:\r\n                return null;\r\n            case 1 /* BooleanValue */:\r\n                return value.booleanValue;\r\n            case 2 /* NumberValue */:\r\n                return normalizeNumber(value.integerValue || value.doubleValue);\r\n            case 3 /* TimestampValue */:\r\n                return this.convertTimestamp(value.timestampValue);\r\n            case 4 /* ServerTimestampValue */:\r\n                return this.convertServerTimestamp(value, serverTimestampBehavior);\r\n            case 5 /* StringValue */:\r\n                return value.stringValue;\r\n            case 6 /* BlobValue */:\r\n                return this.convertBytes(normalizeByteString(value.bytesValue));\r\n            case 7 /* RefValue */:\r\n                return this.convertReference(value.referenceValue);\r\n            case 8 /* GeoPointValue */:\r\n                return this.convertGeoPoint(value.geoPointValue);\r\n            case 9 /* ArrayValue */:\r\n                return this.convertArray(value.arrayValue, serverTimestampBehavior);\r\n            case 10 /* ObjectValue */:\r\n                return this.convertObject(value.mapValue, serverTimestampBehavior);\r\n            default:\r\n                throw fail();\r\n        }\r\n    }\r\n    convertObject(mapValue, serverTimestampBehavior) {\r\n        const result = {};\r\n        forEach(mapValue.fields, (key, value) => {\r\n            result[key] = this.convertValue(value, serverTimestampBehavior);\r\n        });\r\n        return result;\r\n    }\r\n    convertGeoPoint(value) {\r\n        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));\r\n    }\r\n    convertArray(arrayValue, serverTimestampBehavior) {\r\n        return (arrayValue.values || []).map(value => this.convertValue(value, serverTimestampBehavior));\r\n    }\r\n    convertServerTimestamp(value, serverTimestampBehavior) {\r\n        switch (serverTimestampBehavior) {\r\n            case 'previous':\r\n                const previousValue = getPreviousValue(value);\r\n                if (previousValue == null) {\r\n                    return null;\r\n                }\r\n                return this.convertValue(previousValue, serverTimestampBehavior);\r\n            case 'estimate':\r\n                return this.convertTimestamp(getLocalWriteTime(value));\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    convertTimestamp(value) {\r\n        const normalizedValue = normalizeTimestamp(value);\r\n        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);\r\n    }\r\n    convertDocumentKey(name, expectedDatabaseId) {\r\n        const resourcePath = ResourcePath.fromString(name);\r\n        hardAssert(isValidResourceName(resourcePath));\r\n        const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));\r\n        const key = new DocumentKey(resourcePath.popFirst(5));\r\n        if (!databaseId.isEqual(expectedDatabaseId)) {\r\n            // TODO(b/64130202): Somehow support foreign references.\r\n            logError(`Document ${key} contains a document ` +\r\n                `reference within a different database (` +\r\n                `${databaseId.projectId}/${databaseId.database}) which is not ` +\r\n                `supported. It will be treated as a reference in the current ` +\r\n                `database (${expectedDatabaseId.projectId}/${expectedDatabaseId.database}) ` +\r\n                `instead.`);\r\n        }\r\n        return key;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Converts custom model object of type T into `DocumentData` by applying the\r\n * converter if it exists.\r\n *\r\n * This function is used when converting user objects to `DocumentData`\r\n * because we want to provide the user with a more specific error message if\r\n * their `set()` or fails due to invalid data originating from a `toFirestore()`\r\n * call.\r\n */\r\nfunction applyFirestoreDataConverter(converter, value, options) {\r\n    let convertedValue;\r\n    if (converter) {\r\n        if (options && (options.merge || options.mergeFields)) {\r\n            // Cast to `any` in order to satisfy the union type constraint on\r\n            // toFirestore().\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            convertedValue = converter.toFirestore(value, options);\r\n        }\r\n        else {\r\n            convertedValue = converter.toFirestore(value);\r\n        }\r\n    }\r\n    else {\r\n        convertedValue = value;\r\n    }\r\n    return convertedValue;\r\n}\r\nclass LiteUserDataWriter extends AbstractUserDataWriter {\r\n    constructor(firestore) {\r\n        super();\r\n        this.firestore = firestore;\r\n    }\r\n    convertBytes(bytes) {\r\n        return new Bytes(bytes);\r\n    }\r\n    convertReference(name) {\r\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\r\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A write batch, used to perform multiple writes as a single atomic unit.\r\n *\r\n * A `WriteBatch` object can be acquired by calling {@link writeBatch}. It\r\n * provides methods for adding writes to the write batch. None of the writes\r\n * will be committed (or visible locally) until {@link WriteBatch.commit} is\r\n * called.\r\n */\r\nclass WriteBatch {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _commitHandler) {\r\n        this._firestore = _firestore;\r\n        this._commitHandler = _commitHandler;\r\n        this._mutations = [];\r\n        this._committed = false;\r\n        this._dataReader = newUserDataReader(_firestore);\r\n    }\r\n    set(documentRef, data, options) {\r\n        this._verifyNotCommitted();\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);\r\n        const parsed = parseSetData(this._dataReader, 'WriteBatch.set', ref._key, convertedValue, ref.converter !== null, options);\r\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));\r\n        return this;\r\n    }\r\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n        this._verifyNotCommitted();\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        // For Compat types, we have to \"extract\" the underlying types before\r\n        // performing validation.\r\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\r\n        let parsed;\r\n        if (typeof fieldOrUpdateData === 'string' ||\r\n            fieldOrUpdateData instanceof FieldPath) {\r\n            parsed = parseUpdateVarargs(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\r\n        }\r\n        else {\r\n            parsed = parseUpdateData(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData);\r\n        }\r\n        this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));\r\n        return this;\r\n    }\r\n    /**\r\n     * Deletes the document referred to by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be deleted.\r\n     * @returns This `WriteBatch` instance. Used for chaining method calls.\r\n     */\r\n    delete(documentRef) {\r\n        this._verifyNotCommitted();\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));\r\n        return this;\r\n    }\r\n    /**\r\n     * Commits all of the writes in this write batch as a single atomic unit.\r\n     *\r\n     * The result of these writes will only be reflected in document reads that\r\n     * occur after the returned promise resolves. If the client is offline, the\r\n     * write fails. If you would like to see local modifications or buffer writes\r\n     * until the client is online, use the full Firestore SDK.\r\n     *\r\n     * @returns A `Promise` resolved once all of the writes in the batch have been\r\n     * successfully written to the backend as an atomic unit (note that it won't\r\n     * resolve while you're offline).\r\n     */\r\n    commit() {\r\n        this._verifyNotCommitted();\r\n        this._committed = true;\r\n        if (this._mutations.length > 0) {\r\n            return this._commitHandler(this._mutations);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _verifyNotCommitted() {\r\n        if (this._committed) {\r\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\r\n                'has been called.');\r\n        }\r\n    }\r\n}\r\nfunction validateReference(documentRef, firestore) {\r\n    documentRef = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(documentRef);\r\n    if (documentRef.firestore !== firestore) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\r\n    }\r\n    else {\r\n        return documentRef;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the\r\n// legacy SDK.\r\n/**\r\n * A reference to a transaction.\r\n *\r\n * The `Transaction` object passed to a transaction's `updateFunction` provides\r\n * the methods to read and write data within the transaction context. See\r\n * {@link runTransaction}.\r\n */\r\nclass Transaction$1 {\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _transaction) {\r\n        this._firestore = _firestore;\r\n        this._transaction = _transaction;\r\n        this._dataReader = newUserDataReader(_firestore);\r\n    }\r\n    /**\r\n     * Reads the document referenced by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be read.\r\n     * @returns A `DocumentSnapshot` with the read data.\r\n     */\r\n    get(documentRef) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const userDataWriter = new LiteUserDataWriter(this._firestore);\r\n        return this._transaction.lookup([ref._key]).then(docs => {\r\n            if (!docs || docs.length !== 1) {\r\n                return fail();\r\n            }\r\n            const doc = docs[0];\r\n            if (doc.isFoundDocument()) {\r\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, doc.key, doc, ref.converter);\r\n            }\r\n            else if (doc.isNoDocument()) {\r\n                return new DocumentSnapshot$1(this._firestore, userDataWriter, ref._key, null, ref.converter);\r\n            }\r\n            else {\r\n                throw fail();\r\n            }\r\n        });\r\n    }\r\n    set(documentRef, value, options) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);\r\n        const parsed = parseSetData(this._dataReader, 'Transaction.set', ref._key, convertedValue, ref.converter !== null, options);\r\n        this._transaction.set(ref._key, parsed);\r\n        return this;\r\n    }\r\n    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        // For Compat types, we have to \"extract\" the underlying types before\r\n        // performing validation.\r\n        fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\r\n        let parsed;\r\n        if (typeof fieldOrUpdateData === 'string' ||\r\n            fieldOrUpdateData instanceof FieldPath) {\r\n            parsed = parseUpdateVarargs(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);\r\n        }\r\n        else {\r\n            parsed = parseUpdateData(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData);\r\n        }\r\n        this._transaction.update(ref._key, parsed);\r\n        return this;\r\n    }\r\n    /**\r\n     * Deletes the document referred to by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be deleted.\r\n     * @returns This `Transaction` instance. Used for chaining method calls.\r\n     */\r\n    delete(documentRef) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        this._transaction.delete(ref._key);\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction isPartialObserver(obj) {\r\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\r\n}\r\n/**\r\n * Returns true if obj is an object and contains at least one of the specified\r\n * methods.\r\n */\r\nfunction implementsAnyMethods(obj, methods) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return false;\r\n    }\r\n    const object = obj;\r\n    for (const method of methods) {\r\n        if (method in object && typeof object[method] === 'function') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Reads the document referred to by this `DocumentReference`.\r\n *\r\n * Note: `getDoc()` attempts to provide up-to-date data when possible by waiting\r\n * for data from the server, but it may return cached data or fail if you are\r\n * offline and the server cannot be reached. To specify this behavior, invoke\r\n * {@link getDocFromCache} or {@link getDocFromServer}.\r\n *\r\n * @param reference - The reference of the document to fetch.\r\n * @returns A Promise resolved with a `DocumentSnapshot` containing the\r\n * current document contents.\r\n */\r\nfunction getDoc(reference) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\r\n}\r\nclass ExpUserDataWriter extends AbstractUserDataWriter {\r\n    constructor(firestore) {\r\n        super();\r\n        this.firestore = firestore;\r\n    }\r\n    convertBytes(bytes) {\r\n        return new Bytes(bytes);\r\n    }\r\n    convertReference(name) {\r\n        const key = this.convertDocumentKey(name, this.firestore._databaseId);\r\n        return new DocumentReference(this.firestore, /* converter= */ null, key);\r\n    }\r\n}\r\n/**\r\n * Reads the document referred to by this `DocumentReference` from cache.\r\n * Returns an error if the document is not currently cached.\r\n *\r\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\r\n * current document contents.\r\n */\r\nfunction getDocFromCache(reference) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(doc => new DocumentSnapshot(firestore, userDataWriter, reference._key, doc, new SnapshotMetadata(doc !== null && doc.hasLocalMutations, \r\n    /* fromCache= */ true), reference.converter));\r\n}\r\n/**\r\n * Reads the document referred to by this `DocumentReference` from the server.\r\n * Returns an error if the network is not available.\r\n *\r\n * @returns A `Promise` resolved with a `DocumentSnapshot` containing the\r\n * current document contents.\r\n */\r\nfunction getDocFromServer(reference) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {\r\n        source: 'server'\r\n    }).then(snapshot => convertToDocSnapshot(firestore, reference, snapshot));\r\n}\r\n/**\r\n * Executes the query and returns the results as a `QuerySnapshot`.\r\n *\r\n * Note: `getDocs()` attempts to provide up-to-date data when possible by\r\n * waiting for data from the server, but it may return cached data or fail if\r\n * you are offline and the server cannot be reached. To specify this behavior,\r\n * invoke {@link getDocsFromCache} or {@link getDocsFromServer}.\r\n *\r\n * @returns A `Promise` that will be resolved with the results of the query.\r\n */\r\nfunction getDocs(query) {\r\n    query = cast(query, Query);\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    validateHasExplicitOrderByForLimitToLast(query._query);\r\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n}\r\n/**\r\n * Executes the query and returns the results as a `QuerySnapshot` from cache.\r\n * Returns an error if the document is not currently cached.\r\n *\r\n * @returns A `Promise` that will be resolved with the results of the query.\r\n */\r\nfunction getDocsFromCache(query) {\r\n    query = cast(query, Query);\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return firestoreClientGetDocumentsFromLocalCache(client, query._query).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n}\r\n/**\r\n * Executes the query and returns the results as a `QuerySnapshot` from the\r\n * server. Returns an error if the network is not available.\r\n *\r\n * @returns A `Promise` that will be resolved with the results of the query.\r\n */\r\nfunction getDocsFromServer(query) {\r\n    query = cast(query, Query);\r\n    const firestore = cast(query.firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return firestoreClientGetDocumentsViaSnapshotListener(client, query._query, {\r\n        source: 'server'\r\n    }).then(snapshot => new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n}\r\nfunction setDoc(reference, data, options) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);\r\n    const dataReader = newUserDataReader(firestore);\r\n    const parsed = parseSetData(dataReader, 'setDoc', reference._key, convertedValue, reference.converter !== null, options);\r\n    const mutation = parsed.toMutation(reference._key, Precondition.none());\r\n    return executeWrite(firestore, [mutation]);\r\n}\r\nfunction updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) {\r\n    reference = cast(reference, DocumentReference);\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const dataReader = newUserDataReader(firestore);\r\n    // For Compat types, we have to \"extract\" the underlying types before\r\n    // performing validation.\r\n    fieldOrUpdateData = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(fieldOrUpdateData);\r\n    let parsed;\r\n    if (typeof fieldOrUpdateData === 'string' ||\r\n        fieldOrUpdateData instanceof FieldPath) {\r\n        parsed = parseUpdateVarargs(dataReader, 'updateDoc', reference._key, fieldOrUpdateData, value, moreFieldsAndValues);\r\n    }\r\n    else {\r\n        parsed = parseUpdateData(dataReader, 'updateDoc', reference._key, fieldOrUpdateData);\r\n    }\r\n    const mutation = parsed.toMutation(reference._key, Precondition.exists(true));\r\n    return executeWrite(firestore, [mutation]);\r\n}\r\n/**\r\n * Deletes the document referred to by the specified `DocumentReference`.\r\n *\r\n * @param reference - A reference to the document to delete.\r\n * @returns A Promise resolved once the document has been successfully\r\n * deleted from the backend (note that it won't resolve while you're offline).\r\n */\r\nfunction deleteDoc(reference) {\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const mutations = [new DeleteMutation(reference._key, Precondition.none())];\r\n    return executeWrite(firestore, mutations);\r\n}\r\n/**\r\n * Add a new document to specified `CollectionReference` with the given data,\r\n * assigning it a document ID automatically.\r\n *\r\n * @param reference - A reference to the collection to add this document to.\r\n * @param data - An Object containing the data for the new document.\r\n * @returns A `Promise` resolved with a `DocumentReference` pointing to the\r\n * newly created document after it has been written to the backend (Note that it\r\n * won't resolve while you're offline).\r\n */\r\nfunction addDoc(reference, data) {\r\n    const firestore = cast(reference.firestore, Firestore);\r\n    const docRef = doc(reference);\r\n    const convertedValue = applyFirestoreDataConverter(reference.converter, data);\r\n    const dataReader = newUserDataReader(reference.firestore);\r\n    const parsed = parseSetData(dataReader, 'addDoc', docRef._key, convertedValue, reference.converter !== null, {});\r\n    const mutation = parsed.toMutation(docRef._key, Precondition.exists(false));\r\n    return executeWrite(firestore, [mutation]).then(() => docRef);\r\n}\r\nfunction onSnapshot(reference, ...args) {\r\n    var _a, _b, _c;\r\n    reference = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_4__.getModularInstance)(reference);\r\n    let options = {\r\n        includeMetadataChanges: false\r\n    };\r\n    let currArg = 0;\r\n    if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {\r\n        options = args[currArg];\r\n        currArg++;\r\n    }\r\n    const internalOptions = {\r\n        includeMetadataChanges: options.includeMetadataChanges\r\n    };\r\n    if (isPartialObserver(args[currArg])) {\r\n        const userObserver = args[currArg];\r\n        args[currArg] = (_a = userObserver.next) === null || _a === void 0 ? void 0 : _a.bind(userObserver);\r\n        args[currArg + 1] = (_b = userObserver.error) === null || _b === void 0 ? void 0 : _b.bind(userObserver);\r\n        args[currArg + 2] = (_c = userObserver.complete) === null || _c === void 0 ? void 0 : _c.bind(userObserver);\r\n    }\r\n    let observer;\r\n    let firestore;\r\n    let internalQuery;\r\n    if (reference instanceof DocumentReference) {\r\n        firestore = cast(reference.firestore, Firestore);\r\n        internalQuery = newQueryForPath(reference._key.path);\r\n        observer = {\r\n            next: snapshot => {\r\n                if (args[currArg]) {\r\n                    args[currArg](convertToDocSnapshot(firestore, reference, snapshot));\r\n                }\r\n            },\r\n            error: args[currArg + 1],\r\n            complete: args[currArg + 2]\r\n        };\r\n    }\r\n    else {\r\n        const query = cast(reference, Query);\r\n        firestore = cast(query.firestore, Firestore);\r\n        internalQuery = query._query;\r\n        const userDataWriter = new ExpUserDataWriter(firestore);\r\n        observer = {\r\n            next: snapshot => {\r\n                if (args[currArg]) {\r\n                    args[currArg](new QuerySnapshot(firestore, userDataWriter, query, snapshot));\r\n                }\r\n            },\r\n            error: args[currArg + 1],\r\n            complete: args[currArg + 2]\r\n        };\r\n        validateHasExplicitOrderByForLimitToLast(reference._query);\r\n    }\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientListen(client, internalQuery, internalOptions, observer);\r\n}\r\nfunction onSnapshotsInSync(firestore, arg) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    const observer = isPartialObserver(arg)\r\n        ? arg\r\n        : {\r\n            next: arg\r\n        };\r\n    return firestoreClientAddSnapshotsInSyncListener(client, observer);\r\n}\r\n/**\r\n * Locally writes `mutations` on the async queue.\r\n * @internal\r\n */\r\nfunction executeWrite(firestore, mutations) {\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientWrite(client, mutations);\r\n}\r\n/**\r\n * Converts a {@link ViewSnapshot} that contains the single document specified by `ref`\r\n * to a {@link DocumentSnapshot}.\r\n */\r\nfunction convertToDocSnapshot(firestore, ref, snapshot) {\r\n    const doc = snapshot.docs.get(ref._key);\r\n    const userDataWriter = new ExpUserDataWriter(firestore);\r\n    return new DocumentSnapshot(firestore, userDataWriter, ref._key, doc, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref.converter);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A reference to a transaction.\r\n *\r\n * The `Transaction` object passed to a transaction's `updateFunction` provides\r\n * the methods to read and write data within the transaction context. See\r\n * {@link runTransaction}.\r\n */\r\nclass Transaction extends Transaction$1 {\r\n    // This class implements the same logic as the Transaction API in the Lite SDK\r\n    // but is subclassed in order to return its own DocumentSnapshot types.\r\n    /** @hideconstructor */\r\n    constructor(_firestore, _transaction) {\r\n        super(_firestore, _transaction);\r\n        this._firestore = _firestore;\r\n    }\r\n    /**\r\n     * Reads the document referenced by the provided {@link DocumentReference}.\r\n     *\r\n     * @param documentRef - A reference to the document to be read.\r\n     * @returns A `DocumentSnapshot` with the read data.\r\n     */\r\n    get(documentRef) {\r\n        const ref = validateReference(documentRef, this._firestore);\r\n        const userDataWriter = new ExpUserDataWriter(this._firestore);\r\n        return super\r\n            .get(documentRef)\r\n            .then(liteDocumentSnapshot => new DocumentSnapshot(this._firestore, userDataWriter, ref._key, liteDocumentSnapshot._document, new SnapshotMetadata(\r\n        /* hasPendingWrites= */ false, \r\n        /* fromCache= */ false), ref.converter));\r\n    }\r\n}\r\n/**\r\n * Executes the given `updateFunction` and then attempts to commit the changes\r\n * applied within the transaction. If any document read within the transaction\r\n * has changed, Cloud Firestore retries the `updateFunction`. If it fails to\r\n * commit after 5 attempts, the transaction fails.\r\n *\r\n * The maximum number of writes allowed in a single transaction is 500.\r\n *\r\n * @param firestore - A reference to the Firestore database to run this\r\n * transaction against.\r\n * @param updateFunction - The function to execute within the transaction\r\n * context.\r\n * @returns If the transaction completed successfully or was explicitly aborted\r\n * (the `updateFunction` returned a failed promise), the promise returned by the\r\n * `updateFunction `is returned here. Otherwise, if the transaction failed, a\r\n * rejected promise with the corresponding failure error is returned.\r\n */\r\nfunction runTransaction(firestore, updateFunction) {\r\n    firestore = cast(firestore, Firestore);\r\n    const client = ensureFirestoreConfigured(firestore);\r\n    return firestoreClientTransaction(client, internalTransaction => updateFunction(new Transaction(firestore, internalTransaction)));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a sentinel for use with {@link @firebase/firestore/lite#(updateDoc:1)} or\r\n * {@link @firebase/firestore/lite#(setDoc:1)} with `{merge: true}` to mark a field for deletion.\r\n */\r\nfunction deleteField() {\r\n    return new DeleteFieldValueImpl('deleteField');\r\n}\r\n/**\r\n * Returns a sentinel used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link @firebase/firestore/lite#(updateDoc:1)} to\r\n * include a server-generated timestamp in the written data.\r\n */\r\nfunction serverTimestamp() {\r\n    return new ServerTimestampFieldValueImpl('serverTimestamp');\r\n}\r\n/**\r\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\r\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array\r\n * value that already exists on the server. Each specified element that doesn't\r\n * already exist in the array will be added to the end. If the field being\r\n * modified is not already an array it will be overwritten with an array\r\n * containing exactly the specified elements.\r\n *\r\n * @param elements - The elements to union into the array.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`.\r\n */\r\nfunction arrayUnion(...elements) {\r\n    // NOTE: We don't actually parse the data until it's used in set() or\r\n    // update() since we'd need the Firestore instance to do this.\r\n    return new ArrayUnionFieldValueImpl('arrayUnion', elements);\r\n}\r\n/**\r\n * Returns a special value that can be used with {@link (setDoc:1)} or {@link\r\n * updateDoc:1} that tells the server to remove the given elements from any\r\n * array value that already exists on the server. All instances of each element\r\n * specified will be removed from the array. If the field being modified is not\r\n * already an array it will be overwritten with an empty array.\r\n *\r\n * @param elements - The elements to remove from the array.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`\r\n */\r\nfunction arrayRemove(...elements) {\r\n    // NOTE: We don't actually parse the data until it's used in set() or\r\n    // update() since we'd need the Firestore instance to do this.\r\n    return new ArrayRemoveFieldValueImpl('arrayRemove', elements);\r\n}\r\n/**\r\n * Returns a special value that can be used with {@link @firebase/firestore/lite#(setDoc:1)} or {@link\r\n * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by\r\n * the given value.\r\n *\r\n * If either the operand or the current field value uses floating point\r\n * precision, all arithmetic follows IEEE 754 semantics. If both values are\r\n * integers, values outside of JavaScript's safe number range\r\n * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to\r\n * precision loss. Furthermore, once processed by the Firestore backend, all\r\n * integer operations are capped between -2^63 and 2^63-1.\r\n *\r\n * If the current field value is not of type `number`, or if the field does not\r\n * yet exist, the transformation sets the field to the given value.\r\n *\r\n * @param n - The value to increment by.\r\n * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or\r\n * `updateDoc()`\r\n */\r\nfunction increment(n) {\r\n    return new NumericIncrementFieldValueImpl('increment', n);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Creates a write batch, used for performing multiple writes as a single\r\n * atomic operation. The maximum number of writes allowed in a single {@link WriteBatch}\r\n * is 500.\r\n *\r\n * Unlike transactions, write batches are persisted offline and therefore are\r\n * preferable when you don't need to condition your writes on read data.\r\n *\r\n * @returns A {@link WriteBatch} that can be used to atomically execute multiple\r\n * writes.\r\n */\r\nfunction writeBatch(firestore) {\r\n    firestore = cast(firestore, Firestore);\r\n    ensureFirestoreConfigured(firestore);\r\n    return new WriteBatch(firestore, mutations => executeWrite(firestore, mutations));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction setIndexConfiguration(firestore, jsonOrConfiguration) {\r\n    firestore = cast(firestore, Firestore);\r\n    ensureFirestoreConfigured(firestore);\r\n    const indexConfiguration = typeof jsonOrConfiguration === 'string'\r\n        ? tryParseJson(jsonOrConfiguration)\r\n        : jsonOrConfiguration;\r\n    const parsedIndexes = [];\r\n    // PORTING NOTE: We don't return an error if the user has not enabled\r\n    // persistence since `enableIndexeddbPersistence()` can fail on the Web.\r\n    if (Array.isArray(indexConfiguration.indexes)) {\r\n        for (const index of indexConfiguration.indexes) {\r\n            const collectionGroup = tryGetString(index, 'collectionGroup');\r\n            const segments = [];\r\n            if (Array.isArray(index.fields)) {\r\n                for (const field of index.fields) {\r\n                    const fieldPathString = tryGetString(field, 'fieldPath');\r\n                    const fieldPath = fieldPathFromDotSeparatedString('setIndexConfiguration', fieldPathString);\r\n                    if (field.arrayConfig === 'CONTAINS') {\r\n                        segments.push(new IndexSegment(fieldPath, 2 /* CONTAINS */));\r\n                    }\r\n                    else if (field.order === 'ASCENDING') {\r\n                        segments.push(new IndexSegment(fieldPath, 0 /* ASCENDING */));\r\n                    }\r\n                    else if (field.order === 'DESCENDING') {\r\n                        segments.push(new IndexSegment(fieldPath, 1 /* DESCENDING */));\r\n                    }\r\n                }\r\n            }\r\n            parsedIndexes.push(new FieldIndex(FieldIndex.UNKNOWN_ID, collectionGroup, segments, IndexState.empty()));\r\n        }\r\n    }\r\n    // TODO(indexing): Configure indexes\r\n    return Promise.resolve();\r\n}\r\nfunction tryParseJson(json) {\r\n    try {\r\n        return JSON.parse(json);\r\n    }\r\n    catch (e) {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to parse JSON:' + e.message);\r\n    }\r\n}\r\nfunction tryGetString(data, property) {\r\n    if (typeof data[property] !== 'string') {\r\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Missing string value for: ' + property);\r\n    }\r\n    return data[property];\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nregisterFirestore('node');\n\n\n//# sourceMappingURL=index.node.mjs.map\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2luZGV4Lm5vZGUubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdKO0FBQ2hHO0FBQ0k7QUFDSztBQUNpRjtBQUNwRjtBQUNoQjtBQUNZOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkNBQU8sVUFBVSxZQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0REFBYztBQUM1QztBQUNBLHNDQUFzQyxZQUFZLEtBQUssSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNERBQWM7QUFDNUM7QUFDQSxzQ0FBc0MsWUFBWSxLQUFLLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJEQUFhO0FBQzNDO0FBQ0EscUNBQXFDLFlBQVksS0FBSyxJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseURBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVSxVQUFVLFVBQVUsS0FBSyxhQUFhO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDBDQUEwQywwQkFBMEI7QUFDOUo7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG1DQUFtQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdCQUFnQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixLQUFLO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixLQUFLO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscURBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvRUFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFLO0FBQ3hCO0FBQ0EsMENBQTBDLFdBQVcsZ0JBQWdCO0FBQ3JFO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXLFlBQVksTUFBTTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxREFBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RyxVQUFVO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQWE7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0hBQWdIO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBcUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0NBQStDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLEdBQUcsMEJBQTBCO0FBQzVFO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCLEdBQUcsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUksR0FBRyxvQ0FBb0M7QUFDaEU7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQixhQUFhLG9CQUFvQixhQUFhLDJCQUEyQjtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkMsd0JBQXdCLDZDQUE2QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRCxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTLElBQUksYUFBYSxJQUFJLGdDQUFnQztBQUMxRixjQUFjLGdCQUFnQixtQkFBbUI7QUFDakQsY0FBYyxpQkFBaUIsb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQ0FBZ0MsRUFBRSxXQUFXLEVBQUUsMEJBQTBCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseUJBQXlCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQyxHQUFHLFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFDLE1BQU0sZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQSwyQkFBMkIsd0NBQXdDLFlBQVksZ0JBQWdCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxFQUFFLEdBQUcsRUFBRTtBQUN4QztBQUNBLFNBQVM7QUFDVCxpQkFBaUIsRUFBRSx5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsa0JBQWtCO0FBQ2xCLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQixHQUFHLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLDJCQUEyQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWSw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQ0FBa0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFDQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQWtEO0FBQ3pFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFrRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpRUFBaUU7QUFDeEY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQThDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE1BQU07QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsYUFBYSxXQUFXO0FBQ3JHLCtDQUErQyx5Q0FBeUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkNBQTZDO0FBQ3RGLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDLDREQUFjO0FBQy9DO0FBQ0EsNENBQTRDLDJCQUEyQjtBQUN2RSx3REFBd0QsMEJBQTBCO0FBQ2xGLHVCQUF1QixxQ0FBcUM7QUFDNUQsaUNBQWlDLGdCQUFnQjtBQUNqRCx1QkFBdUIscUNBQXFDO0FBQzVELGlDQUFpQyxrQkFBa0I7QUFDbkQsdUJBQXVCLHNDQUFzQztBQUM3RCx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QixzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBOEM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQXNEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpSEFBaUgsY0FBYztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwrR0FBK0csY0FBYztBQUM3SDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUhBQXVILGNBQWM7QUFDckk7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRGQUE0RixjQUFjO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLGVBQWU7QUFDekgsOEhBQThILGVBQWU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtSUFBbUksZUFBZTtBQUNsSjtBQUNBO0FBQ0EsS0FBSztBQUNMLDBHQUEwRyxlQUFlO0FBQ3pIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0dBQW9HLGVBQWU7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUlBQXVJLGVBQWU7QUFDdEoseUlBQXlJLGVBQWU7QUFDeEo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOENBQThDLG1DQUFtQztBQUNqRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtFQUErRSxPQUFPO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGNBQWMsSUFBSSxjQUFjO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTLElBQUksNkJBQTZCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQixHQUFHLG9CQUFvQixHQUFHLFNBQVM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLFNBQVMsSUFBSSxFQUFFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixXQUFXO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWMsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNERBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNERBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QixHQUFHLGVBQWUsR0FBRyxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCLEdBQUcsZUFBZSxHQUFHLFFBQVE7QUFDaEY7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLEdBQUcsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCLEdBQUcsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJCQUEyQixHQUFHLGVBQWU7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxRQUFRLEtBQUssTUFBTTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxTQUFTLEtBQUssTUFBTTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFxRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxTQUFTLEtBQUssTUFBTTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCLEdBQUcsc0JBQXNCO0FBQ2hHLGlEQUFpRCwwQkFBMEIsR0FBRyxzQkFBc0I7QUFDcEcsK0NBQStDLHdCQUF3QixHQUFHLHNCQUFzQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLHVCQUF1QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QixPQUFPLGFBQWEsT0FBTyxZQUFZO0FBQ3pHO0FBQ0E7QUFDQSx5QkFBeUIsbURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDLGFBQWEsaUNBQWlDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQTBCO0FBQzVDLGtCQUFrQixxRUFBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNkJBQTZCO0FBQ3pFO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBLDBEQUEwRCxjQUFjLDZCQUE2QjtBQUNyRztBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBMkM7QUFDckYsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQ0FBMkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZDQUE2QyxFQUFFLGNBQWM7QUFDdkcsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBNkMsRUFBRSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxvREFBb0Q7QUFDaEc7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQW9EO0FBQzlFO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDO0FBQ3hGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQ0FBMkM7QUFDeEU7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRjtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdDQUF3QztBQUNuRjtBQUNBLCtEQUErRCw2Q0FBNkM7QUFDNUc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUE2QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQ0FBZ0M7QUFDM0U7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0NBQXdDO0FBQ25GO0FBQ0EsK0RBQStELDZDQUE2QztBQUM1RztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJDQUEyQyxFQUFFLGNBQWM7QUFDdEc7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJDQUEyQyxFQUFFLGNBQWM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdEQUFvQjtBQUNsRCxXQUFXLGdFQUEwQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBVztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFLGdDQUFnQyxvQkFBb0I7QUFDcEQsc0NBQXNDLDBCQUEwQjtBQUNoRSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsZ0NBQWdDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwyQkFBMkI7QUFDeEcsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxRQUFRO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usc0NBQXNDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSSxJQUFJLEVBQUU7QUFDckM7QUFDQSx1REFBdUQsSUFBSSxJQUFJLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLCtCQUErQjtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNENBQTRDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0NBQWtDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9DQUFvQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELEVBQUU7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhLG9DQUFvQyxhQUFhO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYSxNQUFNLGFBQWE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFKQUFxSixNQUFNLE1BQU0sWUFBWTtBQUM3SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0pBQXdKLE1BQU0sTUFBTSxZQUFZO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsaUJBQWlCLGlCQUFpQixZQUFZO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhLDZDQUE2QyxFQUFFO0FBQ2hJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLHlCQUF5QjtBQUN6SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrRkFBa0Y7QUFDakc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixRQUFRO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsT0FBTztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsNkJBQTZCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlLFNBQVMsS0FBSyxHQUFHLEtBQUssZUFBZTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0IsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QixZQUFZLGtFQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QiwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0EscUJBQXFCLGlDQUFpQyxnQkFBZ0IsaUJBQWlCO0FBQ3ZGO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQSxxQkFBcUIsMkRBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsNkJBQTZCO0FBQ3hIO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQyxhQUFhLGdDQUFnQztBQUM3QztBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQyw0QkFBNEI7QUFDbEY7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0EsNEJBQTRCLHFEQUFNO0FBQ2xDLFdBQVcsMkRBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwQkFBMEIsR0FBRyxvQkFBb0I7QUFDckQsSUFBSSxnQ0FBZ0M7QUFDcEM7QUFDQTtBQUNBLG9EQUFvRCxpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQSxzREFBc0Q7QUFDdEQsd0JBQXdCLElBQUksbUJBQW1CLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RCxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBYTtBQUMvQixJQUFJLGlFQUFrQixLQUFLLDBEQUFTLDRCQUE0QixtQkFBbUI7QUFDbkY7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLDhEQUFlO0FBQ25CO0FBQ0EsSUFBSSw4REFBZTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBc0M7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNDQUFzQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLGtDQUFrQyxxQ0FBcUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRCxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtFQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0VBQWtCO0FBQzlCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQzFELGdDQUFnQyxpQkFBaUIsR0FBRyxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHdCQUF3QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVk7QUFDNUUsSUFBSSxjQUFjLEdBQUcsa0JBQWtCLEdBQUcscUJBQXFCLEdBQUc7QUFDbEUsZUFBZSxHQUFHLGdCQUFnQixHQUFHLGFBQWEsSUFBSSxtQkFBbUI7QUFDekUsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQywwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVEsZUFBZTtBQUN4RSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtFQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsR0FBRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFdBQVc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVyxnQkFBZ0IsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3RELHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEUsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUsscURBQXFELFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0EsMkVBQTJFLG9CQUFvQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5QkFBeUI7QUFDcEUseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0EsOEZBQThGLHFCQUFxQjtBQUNuSCx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxzQkFBc0I7QUFDN0UseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBLG1CQUFtQixxQkFBcUIsR0FBRyxvQkFBb0I7QUFDL0Q7QUFDQSw2QkFBNkIsNkJBQTZCLEdBQUcsNEJBQTRCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQSxpREFBaUQseUJBQXlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrRUFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdCQUF3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHVCQUF1QixJQUFJLHVCQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCLElBQUksd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0VBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsU0FBUyx1QkFBdUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdCQUF3QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEYsSUFBSSwyQ0FBMkMsT0FBTyxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkNBQTJDLElBQUksOENBQThDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwyQ0FBMkMsSUFBSTtBQUNqRywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQixJQUFJO0FBQ3hFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDJDQUEyQyxJQUFJO0FBQ2pHLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWk2QztBQUNqNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2luZGV4Lm5vZGUubWpzPzEyYzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX2dldFByb3ZpZGVyLCBnZXRBcHAsIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UsIF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uLCBTREtfVkVSU0lPTiBhcyBTREtfVkVSU0lPTiQxIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IGluc3BlY3QsIFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgY3JlYXRlTW9ja1VzZXJUb2tlbiwgZ2V0TW9kdWxhckluc3RhbmNlLCBkZWVwRXF1YWwsIGdldFVBLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgaXNTYWZhcmkgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyBhcyByYW5kb21CeXRlcyQxIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIGdycGMgZnJvbSAnQGdycGMvZ3JwYy1qcyc7XG5pbXBvcnQgKiBhcyBwcm90b0xvYWRlciBmcm9tICdAZ3JwYy9wcm90by1sb2FkZXInO1xuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjMuNC41XCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTaW1wbGUgd3JhcHBlciBhcm91bmQgYSBudWxsYWJsZSBVSUQuIE1vc3RseSBleGlzdHMgdG8gbWFrZSBjb2RlIG1vcmVcclxuICogcmVhZGFibGUuXHJcbiAqL1xyXG5jbGFzcyBVc2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHVpZCkge1xyXG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xyXG4gICAgfVxyXG4gICAgaXNBdXRoZW50aWNhdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVpZCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEga2V5IHJlcHJlc2VudGluZyB0aGlzIHVzZXIsIHN1aXRhYmxlIGZvciBpbmNsdXNpb24gaW4gYVxyXG4gICAgICogZGljdGlvbmFyeS5cclxuICAgICAqL1xyXG4gICAgdG9LZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRoZW50aWNhdGVkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd1aWQ6JyArIHRoaXMudWlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMtdXNlcic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlclVzZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXJVc2VyLnVpZCA9PT0gdGhpcy51aWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqIEEgdXNlciB3aXRoIGEgbnVsbCBVSUQuICovXHJcblVzZXIuVU5BVVRIRU5USUNBVEVEID0gbmV3IFVzZXIobnVsbCk7XHJcbi8vIFRPRE8obWlrZWxlaGVuKTogTG9vayBpbnRvIGdldHRpbmcgYSBwcm9wZXIgdWlkLWVxdWl2YWxlbnQgZm9yXHJcbi8vIG5vbi1GaXJlYmFzZUF1dGggcHJvdmlkZXJzLlxyXG5Vc2VyLkdPT0dMRV9DUkVERU5USUFMUyA9IG5ldyBVc2VyKCdnb29nbGUtY3JlZGVudGlhbHMtdWlkJyk7XHJcblVzZXIuRklSU1RfUEFSVFkgPSBuZXcgVXNlcignZmlyc3QtcGFydHktdWlkJyk7XHJcblVzZXIuTU9DS19VU0VSID0gbmV3IFVzZXIoJ21vY2stdXNlcicpO1xuXG5jb25zdCB2ZXJzaW9uID0gXCI5LjYuN1wiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG5mdW5jdGlvbiBzZXRTREtWZXJzaW9uKHZlcnNpb24pIHtcclxuICAgIFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogRm9ybWF0cyBhbiBvYmplY3QgYXMgYSBKU09OIHN0cmluZywgc3VpdGFibGUgZm9yIGxvZ2dpbmcuICovXHJcbmZ1bmN0aW9uIGZvcm1hdEpTT04odmFsdWUpIHtcclxuICAgIC8vIHV0aWwuaW5zcGVjdCgpIHJlc3VsdHMgaW4gbXVjaCBtb3JlIHJlYWRhYmxlIG91dHB1dCB0aGFuIEpTT04uc3RyaW5naWZ5KClcclxuICAgIHJldHVybiBpbnNwZWN0KHZhbHVlLCB7IGRlcHRoOiAxMDAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgbG9nQ2xpZW50ID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2ZpcmVzdG9yZScpO1xyXG4vLyBIZWxwZXIgbWV0aG9kcyBhcmUgbmVlZGVkIGJlY2F1c2UgdmFyaWFibGVzIGNhbid0IGJlIGV4cG9ydGVkIGFzIHJlYWQvd3JpdGVcclxuZnVuY3Rpb24gZ2V0TG9nTGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gbG9nQ2xpZW50LmxvZ0xldmVsO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSB2ZXJib3NpdHkgb2YgQ2xvdWQgRmlyZXN0b3JlIGxvZ3MgKGRlYnVnLCBlcnJvciwgb3Igc2lsZW50KS5cclxuICpcclxuICogQHBhcmFtIGxvZ0xldmVsIC0gVGhlIHZlcmJvc2l0eSB5b3Ugc2V0IGZvciBhY3Rpdml0eSBhbmQgZXJyb3IgbG9nZ2luZy4gQ2FuXHJcbiAqICAgYmUgYW55IG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxyXG4gKlxyXG4gKiAgIDx1bD5cclxuICogICAgIDxsaT5gZGVidWdgIGZvciB0aGUgbW9zdCB2ZXJib3NlIGxvZ2dpbmcgbGV2ZWwsIHByaW1hcmlseSBmb3JcclxuICogICAgIGRlYnVnZ2luZy48L2xpPlxyXG4gKiAgICAgPGxpPmBlcnJvcmAgdG8gbG9nIGVycm9ycyBvbmx5LjwvbGk+XHJcbiAqICAgICA8bGk+PGNvZGU+YHNpbGVudGAgdG8gdHVybiBvZmYgbG9nZ2luZy48L2xpPlxyXG4gKiAgIDwvdWw+XHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xyXG4gICAgbG9nQ2xpZW50LnNldExvZ0xldmVsKGxvZ0xldmVsKTtcclxufVxyXG5mdW5jdGlvbiBsb2dEZWJ1Zyhtc2csIC4uLm9iaikge1xyXG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5ERUJVRykge1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBvYmoubWFwKGFyZ1RvU3RyaW5nKTtcclxuICAgICAgICBsb2dDbGllbnQuZGVidWcoYEZpcmVzdG9yZSAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBsb2dFcnJvcihtc2csIC4uLm9iaikge1xyXG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5FUlJPUikge1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBvYmoubWFwKGFyZ1RvU3RyaW5nKTtcclxuICAgICAgICBsb2dDbGllbnQuZXJyb3IoYEZpcmVzdG9yZSAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2dXYXJuKG1zZywgLi4ub2JqKSB7XHJcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IExvZ0xldmVsLldBUk4pIHtcclxuICAgICAgICBjb25zdCBhcmdzID0gb2JqLm1hcChhcmdUb1N0cmluZyk7XHJcbiAgICAgICAgbG9nQ2xpZW50Lndhcm4oYEZpcmVzdG9yZSAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29udmVydHMgYW4gYWRkaXRpb25hbCBsb2cgcGFyYW1ldGVyIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJnVG9TdHJpbmcob2JqKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEpTT04ob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydGluZyB0byBKU09OIGZhaWxlZCwganVzdCBsb2cgdGhlIG9iamVjdCBkaXJlY3RseVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVW5jb25kaXRpb25hbGx5IGZhaWxzLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxyXG4gKiBNZXNzYWdlcyBhcmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMuXHJcbiAqXHJcbiAqIFJldHVybnMgYG5ldmVyYCBhbmQgY2FuIGJlIHVzZWQgaW4gZXhwcmVzc2lvbnM6XHJcbiAqIEBleGFtcGxlXHJcbiAqIGxldCBmdXR1cmVWYXIgPSBmYWlsKCdub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XHJcbiAqL1xyXG5mdW5jdGlvbiBmYWlsKGZhaWx1cmUgPSAnVW5leHBlY3RlZCBzdGF0ZScpIHtcclxuICAgIC8vIExvZyB0aGUgZmFpbHVyZSBpbiBhZGRpdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24sIGp1c3QgaW4gY2FzZSB0aGVcclxuICAgIC8vIGV4Y2VwdGlvbiBpcyBzd2FsbG93ZWQuXHJcbiAgICBjb25zdCBtZXNzYWdlID0gYEZJUkVTVE9SRSAoJHtTREtfVkVSU0lPTn0pIElOVEVSTkFMIEFTU0VSVElPTiBGQUlMRUQ6IGAgKyBmYWlsdXJlO1xyXG4gICAgbG9nRXJyb3IobWVzc2FnZSk7XHJcbiAgICAvLyBOT1RFOiBXZSBkb24ndCB1c2UgRmlyZXN0b3JlRXJyb3IgaGVyZSBiZWNhdXNlIHRoZXNlIGFyZSBpbnRlcm5hbCBmYWlsdXJlc1xyXG4gICAgLy8gdGhhdCBjYW5ub3QgYmUgaGFuZGxlZCBieSB0aGUgdXNlci4gKEFsc28gaXQgd291bGQgY3JlYXRlIGEgY2lyY3VsYXJcclxuICAgIC8vIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgZXJyb3IgYW5kIGFzc2VydCBtb2R1bGVzIHdoaWNoIGRvZXNuJ3Qgd29yay4pXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbn1cclxuLyoqXHJcbiAqIEZhaWxzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gY29uZGl0aW9uIGlzIGZhbHNlLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZVxyXG4gKiBnaXZlbiBtZXNzYWdlIGlmIGl0IGRpZC5cclxuICpcclxuICogTWVzc2FnZXMgYXJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFyZEFzc2VydChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcclxuICAgIGlmICghYXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBGYWlscyBpZiB0aGUgZ2l2ZW4gYXNzZXJ0aW9uIGNvbmRpdGlvbiBpcyBmYWxzZSwgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGVcclxuICogZ2l2ZW4gbWVzc2FnZSBpZiBpdCBkaWQuXHJcbiAqXHJcbiAqIFRoZSBjb2RlIG9mIGNhbGxzaXRlcyBpbnZva2luZyB0aGlzIGZ1bmN0aW9uIGFyZSBzdHJpcHBlZCBvdXQgaW4gcHJvZHVjdGlvblxyXG4gKiBidWlsZHMuIEFueSBzaWRlLWVmZmVjdHMgb2YgY29kZSB3aXRoaW4gdGhlIGRlYnVnQXNzZXJ0KCkgaW52b2NhdGlvbiB3aWxsIG5vdFxyXG4gKiBoYXBwZW4gaW4gdGhpcyBjYXNlLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGRlYnVnQXNzZXJ0KGFzc2VydGlvbiwgbWVzc2FnZSkge1xyXG4gICAgaWYgKCFhc3NlcnRpb24pIHtcclxuICAgICAgICBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENhc3RzIGBvYmpgIHRvIGBUYC4gSW4gbm9uLXByb2R1Y3Rpb24gYnVpbGRzLCB2ZXJpZmllcyB0aGF0IGBvYmpgIGlzIGFuXHJcbiAqIGluc3RhbmNlIG9mIGBUYCBiZWZvcmUgY2FzdGluZy5cclxuICovXHJcbmZ1bmN0aW9uIGRlYnVnQ2FzdChvYmosIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdHJ1Y3Rvcikge1xyXG4gICAgcmV0dXJuIG9iajtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBDb2RlID0ge1xyXG4gICAgLy8gQ2F1c2VzIGFyZSBjb3BpZWQgZnJvbTpcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9iY2VlYzk0ZWE0ZmM1ZjAwODVkODEyMzVkOGUxYzA2Nzk4ZGMzNDFhL2luY2x1ZGUvZ3JwYyUyQiUyQi9pbXBsL2NvZGVnZW4vc3RhdHVzX2NvZGVfZW51bS5oXHJcbiAgICAvKiogTm90IGFuIGVycm9yOyByZXR1cm5lZCBvbiBzdWNjZXNzLiAqL1xyXG4gICAgT0s6ICdvaycsXHJcbiAgICAvKiogVGhlIG9wZXJhdGlvbiB3YXMgY2FuY2VsbGVkICh0eXBpY2FsbHkgYnkgdGhlIGNhbGxlcikuICovXHJcbiAgICBDQU5DRUxMRUQ6ICdjYW5jZWxsZWQnLFxyXG4gICAgLyoqIFVua25vd24gZXJyb3Igb3IgYW4gZXJyb3IgZnJvbSBhIGRpZmZlcmVudCBlcnJvciBkb21haW4uICovXHJcbiAgICBVTktOT1dOOiAndW5rbm93bicsXHJcbiAgICAvKipcclxuICAgICAqIENsaWVudCBzcGVjaWZpZWQgYW4gaW52YWxpZCBhcmd1bWVudC4gTm90ZSB0aGF0IHRoaXMgZGlmZmVycyBmcm9tXHJcbiAgICAgKiBGQUlMRURfUFJFQ09ORElUSU9OLiBJTlZBTElEX0FSR1VNRU5UIGluZGljYXRlcyBhcmd1bWVudHMgdGhhdCBhcmVcclxuICAgICAqIHByb2JsZW1hdGljIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlIG9mIHRoZSBzeXN0ZW0gKGUuZy4sIGEgbWFsZm9ybWVkIGZpbGVcclxuICAgICAqIG5hbWUpLlxyXG4gICAgICovXHJcbiAgICBJTlZBTElEX0FSR1VNRU5UOiAnaW52YWxpZC1hcmd1bWVudCcsXHJcbiAgICAvKipcclxuICAgICAqIERlYWRsaW5lIGV4cGlyZWQgYmVmb3JlIG9wZXJhdGlvbiBjb3VsZCBjb21wbGV0ZS4gRm9yIG9wZXJhdGlvbnMgdGhhdFxyXG4gICAgICogY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgc3lzdGVtLCB0aGlzIGVycm9yIG1heSBiZSByZXR1cm5lZCBldmVuIGlmIHRoZVxyXG4gICAgICogb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBGb3IgZXhhbXBsZSwgYSBzdWNjZXNzZnVsIHJlc3BvbnNlXHJcbiAgICAgKiBmcm9tIGEgc2VydmVyIGNvdWxkIGhhdmUgYmVlbiBkZWxheWVkIGxvbmcgZW5vdWdoIGZvciB0aGUgZGVhZGxpbmUgdG9cclxuICAgICAqIGV4cGlyZS5cclxuICAgICAqL1xyXG4gICAgREVBRExJTkVfRVhDRUVERUQ6ICdkZWFkbGluZS1leGNlZWRlZCcsXHJcbiAgICAvKiogU29tZSByZXF1ZXN0ZWQgZW50aXR5IChlLmcuLCBmaWxlIG9yIGRpcmVjdG9yeSkgd2FzIG5vdCBmb3VuZC4gKi9cclxuICAgIE5PVF9GT1VORDogJ25vdC1mb3VuZCcsXHJcbiAgICAvKipcclxuICAgICAqIFNvbWUgZW50aXR5IHRoYXQgd2UgYXR0ZW1wdGVkIHRvIGNyZWF0ZSAoZS5nLiwgZmlsZSBvciBkaXJlY3RvcnkpIGFscmVhZHlcclxuICAgICAqIGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgQUxSRUFEWV9FWElTVFM6ICdhbHJlYWR5LWV4aXN0cycsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYWxsZXIgZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGV4ZWN1dGUgdGhlIHNwZWNpZmllZCBvcGVyYXRpb24uXHJcbiAgICAgKiBQRVJNSVNTSU9OX0RFTklFRCBtdXN0IG5vdCBiZSB1c2VkIGZvciByZWplY3Rpb25zIGNhdXNlZCBieSBleGhhdXN0aW5nXHJcbiAgICAgKiBzb21lIHJlc291cmNlICh1c2UgUkVTT1VSQ0VfRVhIQVVTVEVEIGluc3RlYWQgZm9yIHRob3NlIGVycm9ycykuXHJcbiAgICAgKiBQRVJNSVNTSU9OX0RFTklFRCBtdXN0IG5vdCBiZSB1c2VkIGlmIHRoZSBjYWxsZXIgY2FuIG5vdCBiZSBpZGVudGlmaWVkXHJcbiAgICAgKiAodXNlIFVOQVVUSEVOVElDQVRFRCBpbnN0ZWFkIGZvciB0aG9zZSBlcnJvcnMpLlxyXG4gICAgICovXHJcbiAgICBQRVJNSVNTSU9OX0RFTklFRDogJ3Blcm1pc3Npb24tZGVuaWVkJyxcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlcXVlc3QgZG9lcyBub3QgaGF2ZSB2YWxpZCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBmb3IgdGhlXHJcbiAgICAgKiBvcGVyYXRpb24uXHJcbiAgICAgKi9cclxuICAgIFVOQVVUSEVOVElDQVRFRDogJ3VuYXV0aGVudGljYXRlZCcsXHJcbiAgICAvKipcclxuICAgICAqIFNvbWUgcmVzb3VyY2UgaGFzIGJlZW4gZXhoYXVzdGVkLCBwZXJoYXBzIGEgcGVyLXVzZXIgcXVvdGEsIG9yIHBlcmhhcHMgdGhlXHJcbiAgICAgKiBlbnRpcmUgZmlsZSBzeXN0ZW0gaXMgb3V0IG9mIHNwYWNlLlxyXG4gICAgICovXHJcbiAgICBSRVNPVVJDRV9FWEhBVVNURUQ6ICdyZXNvdXJjZS1leGhhdXN0ZWQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBPcGVyYXRpb24gd2FzIHJlamVjdGVkIGJlY2F1c2UgdGhlIHN5c3RlbSBpcyBub3QgaW4gYSBzdGF0ZSByZXF1aXJlZCBmb3JcclxuICAgICAqIHRoZSBvcGVyYXRpb24ncyBleGVjdXRpb24uIEZvciBleGFtcGxlLCBkaXJlY3RvcnkgdG8gYmUgZGVsZXRlZCBtYXkgYmVcclxuICAgICAqIG5vbi1lbXB0eSwgYW4gcm1kaXIgb3BlcmF0aW9uIGlzIGFwcGxpZWQgdG8gYSBub24tZGlyZWN0b3J5LCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogQSBsaXRtdXMgdGVzdCB0aGF0IG1heSBoZWxwIGEgc2VydmljZSBpbXBsZW1lbnRvciBpbiBkZWNpZGluZ1xyXG4gICAgICogYmV0d2VlbiBGQUlMRURfUFJFQ09ORElUSU9OLCBBQk9SVEVELCBhbmQgVU5BVkFJTEFCTEU6XHJcbiAgICAgKiAgKGEpIFVzZSBVTkFWQUlMQUJMRSBpZiB0aGUgY2xpZW50IGNhbiByZXRyeSBqdXN0IHRoZSBmYWlsaW5nIGNhbGwuXHJcbiAgICAgKiAgKGIpIFVzZSBBQk9SVEVEIGlmIHRoZSBjbGllbnQgc2hvdWxkIHJldHJ5IGF0IGEgaGlnaGVyLWxldmVsXHJcbiAgICAgKiAgICAgIChlLmcuLCByZXN0YXJ0aW5nIGEgcmVhZC1tb2RpZnktd3JpdGUgc2VxdWVuY2UpLlxyXG4gICAgICogIChjKSBVc2UgRkFJTEVEX1BSRUNPTkRJVElPTiBpZiB0aGUgY2xpZW50IHNob3VsZCBub3QgcmV0cnkgdW50aWxcclxuICAgICAqICAgICAgdGhlIHN5c3RlbSBzdGF0ZSBoYXMgYmVlbiBleHBsaWNpdGx5IGZpeGVkLiBFLmcuLCBpZiBhbiBcInJtZGlyXCJcclxuICAgICAqICAgICAgZmFpbHMgYmVjYXVzZSB0aGUgZGlyZWN0b3J5IGlzIG5vbi1lbXB0eSwgRkFJTEVEX1BSRUNPTkRJVElPTlxyXG4gICAgICogICAgICBzaG91bGQgYmUgcmV0dXJuZWQgc2luY2UgdGhlIGNsaWVudCBzaG91bGQgbm90IHJldHJ5IHVubGVzc1xyXG4gICAgICogICAgICB0aGV5IGhhdmUgZmlyc3QgZml4ZWQgdXAgdGhlIGRpcmVjdG9yeSBieSBkZWxldGluZyBmaWxlcyBmcm9tIGl0LlxyXG4gICAgICogIChkKSBVc2UgRkFJTEVEX1BSRUNPTkRJVElPTiBpZiB0aGUgY2xpZW50IHBlcmZvcm1zIGNvbmRpdGlvbmFsXHJcbiAgICAgKiAgICAgIFJFU1QgR2V0L1VwZGF0ZS9EZWxldGUgb24gYSByZXNvdXJjZSBhbmQgdGhlIHJlc291cmNlIG9uIHRoZVxyXG4gICAgICogICAgICBzZXJ2ZXIgZG9lcyBub3QgbWF0Y2ggdGhlIGNvbmRpdGlvbi4gRS5nLiwgY29uZmxpY3RpbmdcclxuICAgICAqICAgICAgcmVhZC1tb2RpZnktd3JpdGUgb24gdGhlIHNhbWUgcmVzb3VyY2UuXHJcbiAgICAgKi9cclxuICAgIEZBSUxFRF9QUkVDT05ESVRJT046ICdmYWlsZWQtcHJlY29uZGl0aW9uJyxcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZCwgdHlwaWNhbGx5IGR1ZSB0byBhIGNvbmN1cnJlbmN5IGlzc3VlIGxpa2VcclxuICAgICAqIHNlcXVlbmNlciBjaGVjayBmYWlsdXJlcywgdHJhbnNhY3Rpb24gYWJvcnRzLCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIGxpdG11cyB0ZXN0IGFib3ZlIGZvciBkZWNpZGluZyBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04sIEFCT1JURUQsXHJcbiAgICAgKiBhbmQgVU5BVkFJTEFCTEUuXHJcbiAgICAgKi9cclxuICAgIEFCT1JURUQ6ICdhYm9ydGVkJyxcclxuICAgIC8qKlxyXG4gICAgICogT3BlcmF0aW9uIHdhcyBhdHRlbXB0ZWQgcGFzdCB0aGUgdmFsaWQgcmFuZ2UuIEUuZy4sIHNlZWtpbmcgb3IgcmVhZGluZ1xyXG4gICAgICogcGFzdCBlbmQgb2YgZmlsZS5cclxuICAgICAqXHJcbiAgICAgKiBVbmxpa2UgSU5WQUxJRF9BUkdVTUVOVCwgdGhpcyBlcnJvciBpbmRpY2F0ZXMgYSBwcm9ibGVtIHRoYXQgbWF5IGJlIGZpeGVkXHJcbiAgICAgKiBpZiB0aGUgc3lzdGVtIHN0YXRlIGNoYW5nZXMuIEZvciBleGFtcGxlLCBhIDMyLWJpdCBmaWxlIHN5c3RlbSB3aWxsXHJcbiAgICAgKiBnZW5lcmF0ZSBJTlZBTElEX0FSR1VNRU5UIGlmIGFza2VkIHRvIHJlYWQgYXQgYW4gb2Zmc2V0IHRoYXQgaXMgbm90IGluIHRoZVxyXG4gICAgICogcmFuZ2UgWzAsMl4zMi0xXSwgYnV0IGl0IHdpbGwgZ2VuZXJhdGUgT1VUX09GX1JBTkdFIGlmIGFza2VkIHRvIHJlYWQgZnJvbVxyXG4gICAgICogYW4gb2Zmc2V0IHBhc3QgdGhlIGN1cnJlbnQgZmlsZSBzaXplLlxyXG4gICAgICpcclxuICAgICAqIFRoZXJlIGlzIGEgZmFpciBiaXQgb2Ygb3ZlcmxhcCBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04gYW5kXHJcbiAgICAgKiBPVVRfT0ZfUkFOR0UuIFdlIHJlY29tbWVuZCB1c2luZyBPVVRfT0ZfUkFOR0UgKHRoZSBtb3JlIHNwZWNpZmljIGVycm9yKVxyXG4gICAgICogd2hlbiBpdCBhcHBsaWVzIHNvIHRoYXQgY2FsbGVycyB3aG8gYXJlIGl0ZXJhdGluZyB0aHJvdWdoIGEgc3BhY2UgY2FuXHJcbiAgICAgKiBlYXNpbHkgbG9vayBmb3IgYW4gT1VUX09GX1JBTkdFIGVycm9yIHRvIGRldGVjdCB3aGVuIHRoZXkgYXJlIGRvbmUuXHJcbiAgICAgKi9cclxuICAgIE9VVF9PRl9SQU5HRTogJ291dC1vZi1yYW5nZScsXHJcbiAgICAvKiogT3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBvciBub3Qgc3VwcG9ydGVkL2VuYWJsZWQgaW4gdGhpcyBzZXJ2aWNlLiAqL1xyXG4gICAgVU5JTVBMRU1FTlRFRDogJ3VuaW1wbGVtZW50ZWQnLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbCBlcnJvcnMuIE1lYW5zIHNvbWUgaW52YXJpYW50cyBleHBlY3RlZCBieSB1bmRlcmx5aW5nIFN5c3RlbSBoYXNcclxuICAgICAqIGJlZW4gYnJva2VuLiBJZiB5b3Ugc2VlIG9uZSBvZiB0aGVzZSBlcnJvcnMsIFNvbWV0aGluZyBpcyB2ZXJ5IGJyb2tlbi5cclxuICAgICAqL1xyXG4gICAgSU5URVJOQUw6ICdpbnRlcm5hbCcsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXJ2aWNlIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZS4gVGhpcyBpcyBhIG1vc3QgbGlrZWx5IGEgdHJhbnNpZW50XHJcbiAgICAgKiBjb25kaXRpb24gYW5kIG1heSBiZSBjb3JyZWN0ZWQgYnkgcmV0cnlpbmcgd2l0aCBhIGJhY2tvZmYuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIGxpdG11cyB0ZXN0IGFib3ZlIGZvciBkZWNpZGluZyBiZXR3ZWVuIEZBSUxFRF9QUkVDT05ESVRJT04sIEFCT1JURUQsXHJcbiAgICAgKiBhbmQgVU5BVkFJTEFCTEUuXHJcbiAgICAgKi9cclxuICAgIFVOQVZBSUxBQkxFOiAndW5hdmFpbGFibGUnLFxyXG4gICAgLyoqIFVucmVjb3ZlcmFibGUgZGF0YSBsb3NzIG9yIGNvcnJ1cHRpb24uICovXHJcbiAgICBEQVRBX0xPU1M6ICdkYXRhLWxvc3MnXHJcbn07XHJcbi8qKiBBbiBlcnJvciByZXR1cm5lZCBieSBhIEZpcmVzdG9yZSBvcGVyYXRpb24uICovXHJcbmNsYXNzIEZpcmVzdG9yZUVycm9yIGV4dGVuZHMgRmlyZWJhc2VFcnJvciB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYWNrZW5kIGVycm9yIGNvZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGNvZGUsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGN1c3RvbSBlcnJvciBkZXNjcmlwdGlvbi5cclxuICAgICAqL1xyXG4gICAgbWVzc2FnZSkge1xyXG4gICAgICAgIHN1cGVyKGNvZGUsIG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICAvLyBIQUNLOiBXZSB3cml0ZSBhIHRvU3RyaW5nIHByb3BlcnR5IGRpcmVjdGx5IGJlY2F1c2UgRXJyb3IgaXMgbm90IGEgcmVhbFxyXG4gICAgICAgIC8vIGNsYXNzIGFuZCBzbyBpbmhlcml0YW5jZSBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseS4gV2UgY291bGQgYWx0ZXJuYXRpdmVseVxyXG4gICAgICAgIC8vIGRvIHRoZSBzYW1lIFwiYmFjay1kb29yIGluaGVyaXRhbmNlXCIgdHJpY2sgdGhhdCBGaXJlYmFzZUVycm9yIGRvZXMuXHJcbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IGAke3RoaXMubmFtZX06IFtjb2RlPSR7dGhpcy5jb2RlfV06ICR7dGhpcy5tZXNzYWdlfWA7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRGVmZXJyZWQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBPQXV0aFRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB1c2VyKSB7XHJcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnT0F1dGgnO1xyXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke3ZhbHVlfWApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIENyZWRlbnRpYWxzUHJvdmlkZXIgdGhhdCBhbHdheXMgeWllbGRzIGFuIGVtcHR5IHRva2VuLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIge1xyXG4gICAgZ2V0VG9rZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgIH1cclxuICAgIGludmFsaWRhdGVUb2tlbigpIHsgfVxyXG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBGaXJlIHdpdGggaW5pdGlhbCB1c2VyLlxyXG4gICAgICAgIGFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiBjaGFuZ2VMaXN0ZW5lcihVc2VyLlVOQVVUSEVOVElDQVRFRCkpO1xyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7IH1cclxufVxyXG4vKipcclxuICogQSBDcmVkZW50aWFsc1Byb3ZpZGVyIHRoYXQgYWx3YXlzIHJldHVybnMgYSBjb25zdGFudCB0b2tlbi4gVXNlZCBmb3JcclxuICogZW11bGF0b3IgdG9rZW4gbW9ja2luZy5cclxuICovXHJcbmNsYXNzIEVtdWxhdG9yQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IodG9rZW4pIHtcclxuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcmVzIHRoZSBsaXN0ZW5lciByZWdpc3RlcmVkIHdpdGggc2V0Q2hhbmdlTGlzdGVuZXIoKVxyXG4gICAgICAgICAqIFRoaXMgaXNuJ3QgYWN0dWFsbHkgbmVjZXNzYXJ5IHNpbmNlIHRoZSBVSUQgbmV2ZXIgY2hhbmdlcywgYnV0IHdlIHVzZSB0aGlzXHJcbiAgICAgICAgICogdG8gdmVyaWZ5IHRoZSBsaXN0ZW4gY29udHJhY3QgaXMgYWRoZXJlZCB0byBpbiB0ZXN0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldFRva2VuKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy50b2tlbik7XHJcbiAgICB9XHJcbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7IH1cclxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IGNoYW5nZUxpc3RlbmVyO1xyXG4gICAgICAgIC8vIEZpcmUgd2l0aCBpbml0aWFsIHVzZXIuXHJcbiAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IGNoYW5nZUxpc3RlbmVyKHRoaXMudG9rZW4udXNlcikpO1xyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VMaXN0ZW5lciA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRmlyZWJhc2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmF1dGhQcm92aWRlciA9IGF1dGhQcm92aWRlcjtcclxuICAgICAgICAvKiogVHJhY2tzIHRoZSBjdXJyZW50IFVzZXIuICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IFVzZXIuVU5BVVRIRU5USUNBVEVEO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvdW50ZXIgdXNlZCB0byBkZXRlY3QgaWYgdGhlIHRva2VuIGNoYW5nZWQgd2hpbGUgYSBnZXRUb2tlbiByZXF1ZXN0IHdhc1xyXG4gICAgICAgICAqIG91dHN0YW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG9rZW5Db3VudGVyID0gMDtcclxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGFydChhc3luY1F1ZXVlLCBjaGFuZ2VMaXN0ZW5lcikge1xyXG4gICAgICAgIGxldCBsYXN0VG9rZW5JZCA9IHRoaXMudG9rZW5Db3VudGVyO1xyXG4gICAgICAgIC8vIEEgY2hhbmdlIGxpc3RlbmVyIHRoYXQgcHJldmVudHMgZG91YmxlLWZpcmluZyBmb3IgdGhlIHNhbWUgdG9rZW4gY2hhbmdlLlxyXG4gICAgICAgIGNvbnN0IGd1YXJkZWRDaGFuZ2VMaXN0ZW5lciA9IHVzZXIgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbkNvdW50ZXIgIT09IGxhc3RUb2tlbklkKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW5JZCA9IHRoaXMudG9rZW5Db3VudGVyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUxpc3RlbmVyKHVzZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBBIHByb21pc2UgdGhhdCBjYW4gYmUgd2FpdGVkIG9uIHRvIGJsb2NrIG9uIHRoZSBuZXh0IHRva2VuIGNoYW5nZS5cclxuICAgICAgICAvLyBUaGlzIHByb21pc2UgaXMgcmUtY3JlYXRlZCBhZnRlciBlYWNoIGNoYW5nZS5cclxuICAgICAgICBsZXQgbmV4dFRva2VuID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy50b2tlbkxpc3RlbmVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRva2VuQ291bnRlcisrO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gdGhpcy5nZXRVc2VyKCk7XHJcbiAgICAgICAgICAgIG5leHRUb2tlbi5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIG5leHRUb2tlbiA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoKCkgPT4gZ3VhcmRlZENoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudFVzZXIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGF3YWl0TmV4dFRva2VuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VG9rZW5BdHRlbXB0ID0gbmV4dFRva2VuO1xyXG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVSZXRyeWFibGUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY3VycmVudFRva2VuQXR0ZW1wdC5wcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZ3VhcmRlZENoYW5nZUxpc3RlbmVyKHRoaXMuY3VycmVudFVzZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyQXV0aCA9IChhdXRoKSA9PiB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyJywgJ0F1dGggZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcclxuICAgICAgICAgICAgdGhpcy5hdXRoLmFkZEF1dGhUb2tlbkxpc3RlbmVyKHRoaXMudG9rZW5MaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIGF3YWl0TmV4dFRva2VuKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmF1dGhQcm92aWRlci5vbkluaXQoYXV0aCA9PiByZWdpc3RlckF1dGgoYXV0aCkpO1xyXG4gICAgICAgIC8vIE91ciB1c2VycyBjYW4gaW5pdGlhbGl6ZSBBdXRoIHJpZ2h0IGFmdGVyIEZpcmVzdG9yZSwgc28gd2UgZ2l2ZSBpdFxyXG4gICAgICAgIC8vIGEgY2hhbmNlIHRvIHJlZ2lzdGVyIGl0c2VsZiB3aXRoIHRoZSBjb21wb25lbnQgZnJhbWV3b3JrIGJlZm9yZSB3ZVxyXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRvIHN0YXJ0IHVwIGluIHVuYXV0aGVudGljYXRlZCBtb2RlLlxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXV0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aCA9IHRoaXMuYXV0aFByb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF1dGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWdpc3RlckF1dGgoYXV0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhdXRoIGlzIHN0aWxsIG5vdCBhdmFpbGFibGUsIHByb2NlZWQgd2l0aCBgbnVsbGAgdXNlclxyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyJywgJ0F1dGggbm90IHlldCBkZXRlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbi5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAwKTtcclxuICAgICAgICBhd2FpdE5leHRUb2tlbigpO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oKSB7XHJcbiAgICAgICAgLy8gVGFrZSBub3RlIG9mIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB0b2tlbkNvdW50ZXIgc28gdGhhdCB0aGlzIG1ldGhvZFxyXG4gICAgICAgIC8vIGNhbiBmYWlsICh3aXRoIGFuIEFCT1JURUQgZXJyb3IpIGlmIHRoZXJlIGlzIGEgdG9rZW4gY2hhbmdlIHdoaWxlIHRoZVxyXG4gICAgICAgIC8vIHJlcXVlc3QgaXMgb3V0c3RhbmRpbmcuXHJcbiAgICAgICAgY29uc3QgaW5pdGlhbFRva2VuQ291bnRlciA9IHRoaXMudG9rZW5Db3VudGVyO1xyXG4gICAgICAgIGNvbnN0IGZvcmNlUmVmcmVzaCA9IHRoaXMuZm9yY2VSZWZyZXNoO1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aC5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4odG9rZW5EYXRhID0+IHtcclxuICAgICAgICAgICAgLy8gQ2FuY2VsIHRoZSByZXF1ZXN0IHNpbmNlIHRoZSB0b2tlbiBjaGFuZ2VkIHdoaWxlIHRoZSByZXF1ZXN0IHdhc1xyXG4gICAgICAgICAgICAvLyBvdXRzdGFuZGluZyBzbyB0aGUgcmVzcG9uc2UgaXMgcG90ZW50aWFsbHkgZm9yIGEgcHJldmlvdXMgdXNlciAod2hpY2hcclxuICAgICAgICAgICAgLy8gdXNlciwgd2UgY2FuJ3QgYmUgc3VyZSkuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuQ291bnRlciAhPT0gaW5pdGlhbFRva2VuQ291bnRlcikge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXInLCAnZ2V0VG9rZW4gYWJvcnRlZCBkdWUgdG8gdG9rZW4gY2hhbmdlLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbkRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KHR5cGVvZiB0b2tlbkRhdGEuYWNjZXNzVG9rZW4gPT09ICdzdHJpbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9BdXRoVG9rZW4odG9rZW5EYXRhLmFjY2Vzc1Rva2VuLCB0aGlzLmN1cnJlbnRVc2VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7XHJcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGgucmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIodGhpcy50b2tlbkxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBBdXRoLmdldFVpZCgpIGNhbiByZXR1cm4gbnVsbCBldmVuIHdpdGggYSB1c2VyIGxvZ2dlZCBpbi4gSXQgaXMgYmVjYXVzZVxyXG4gICAgLy8gZ2V0VWlkKCkgaXMgc3luY2hyb25vdXMsIGJ1dCB0aGUgYXV0aCBjb2RlIHBvcHVsYXRpbmcgVWlkIGlzIGFzeW5jaHJvbm91cy5cclxuICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpbiB0aGUgQXV0aFRva2VuTGlzdGVuZXIgY2FsbGJhY2tcclxuICAgIC8vIHRvIGd1YXJhbnRlZSB0byBnZXQgdGhlIGFjdHVhbCB1c2VyLlxyXG4gICAgZ2V0VXNlcigpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50VWlkID0gdGhpcy5hdXRoICYmIHRoaXMuYXV0aC5nZXRVaWQoKTtcclxuICAgICAgICBoYXJkQXNzZXJ0KGN1cnJlbnRVaWQgPT09IG51bGwgfHwgdHlwZW9mIGN1cnJlbnRVaWQgPT09ICdzdHJpbmcnKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVzZXIoY3VycmVudFVpZCk7XHJcbiAgICB9XHJcbn1cclxuLypcclxuICogRmlyc3RQYXJ0eVRva2VuIHByb3ZpZGVzIGEgZnJlc2ggdG9rZW4gZWFjaCB0aW1lIGl0cyB2YWx1ZVxyXG4gKiBpcyByZXF1ZXN0ZWQsIGJlY2F1c2UgaWYgdGhlIHRva2VuIGlzIHRvbyBvbGQsIHJlcXVlc3RzIHdpbGwgYmUgcmVqZWN0ZWQuXHJcbiAqIFRlY2huaWNhbGx5IHRoaXMgbWF5IG5vIGxvbmdlciBiZSBuZWNlc3Nhcnkgc2luY2UgdGhlIFNESyBzaG91bGQgZ3JhY2VmdWxseVxyXG4gKiByZWNvdmVyIGZyb20gdW5hdXRoZW50aWNhdGVkIGVycm9ycyAoc2VlIGIvMzMxNDc4MTggZm9yIGNvbnRleHQpLCBidXQgaXQnc1xyXG4gKiBzYWZlciB0byBrZWVwIHRoZSBpbXBsZW1lbnRhdGlvbiBhcy1pcy5cclxuICovXHJcbmNsYXNzIEZpcnN0UGFydHlUb2tlbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihnYXBpLCBzZXNzaW9uSW5kZXgsIGlhbVRva2VuKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0ZpcnN0UGFydHknO1xyXG4gICAgICAgIHRoaXMudXNlciA9IFVzZXIuRklSU1RfUEFSVFk7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ1gtR29vZy1BdXRoVXNlcicsIHNlc3Npb25JbmRleCk7XHJcbiAgICAgICAgY29uc3QgYXV0aEhlYWRlciA9IGdhcGlbJ2F1dGgnXVsnZ2V0QXV0aEhlYWRlclZhbHVlRm9yRmlyc3RQYXJ0eSddKFtdKTtcclxuICAgICAgICBpZiAoYXV0aEhlYWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYXV0aEhlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpYW1Ub2tlbikge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdYLUdvb2ctSWFtLUF1dGhvcml6YXRpb24tVG9rZW4nLCBpYW1Ub2tlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qXHJcbiAqIFByb3ZpZGVzIHVzZXIgY3JlZGVudGlhbHMgcmVxdWlyZWQgZm9yIHRoZSBGaXJlc3RvcmUgSmF2YVNjcmlwdCBTREtcclxuICogdG8gYXV0aGVudGljYXRlIHRoZSB1c2VyLCB1c2luZyB0ZWNobmlxdWUgdGhhdCBpcyBvbmx5IGF2YWlsYWJsZVxyXG4gKiB0byBhcHBsaWNhdGlvbnMgaG9zdGVkIGJ5IEdvb2dsZS5cclxuICovXHJcbmNsYXNzIEZpcnN0UGFydHlBdXRoQ3JlZGVudGlhbHNQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnYXBpLCBzZXNzaW9uSW5kZXgsIGlhbVRva2VuKSB7XHJcbiAgICAgICAgdGhpcy5nYXBpID0gZ2FwaTtcclxuICAgICAgICB0aGlzLnNlc3Npb25JbmRleCA9IHNlc3Npb25JbmRleDtcclxuICAgICAgICB0aGlzLmlhbVRva2VuID0gaWFtVG9rZW47XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbigpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBGaXJzdFBhcnR5VG9rZW4odGhpcy5nYXBpLCB0aGlzLnNlc3Npb25JbmRleCwgdGhpcy5pYW1Ub2tlbikpO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBGaXJlIHdpdGggaW5pdGlhbCB1aWQuXHJcbiAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IGNoYW5nZUxpc3RlbmVyKFVzZXIuRklSU1RfUEFSVFkpKTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkgeyB9XHJcbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7IH1cclxufVxyXG5jbGFzcyBBcHBDaGVja1Rva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdBcHBDaGVjayc7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ3gtZmlyZWJhc2UtYXBwY2hlY2snLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRmlyZWJhc2VBcHBDaGVja1Rva2VuUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXBwQ2hlY2tQcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tQcm92aWRlciA9IGFwcENoZWNrUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFwcENoZWNrID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW4gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoYXN5bmNRdWV1ZSwgY2hhbmdlTGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCBvblRva2VuQ2hhbmdlZCA9IHRva2VuUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgaWYgKHRva2VuUmVzdWx0LmVycm9yICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcicsIGBFcnJvciBnZXR0aW5nIEFwcCBDaGVjayB0b2tlbjsgdXNpbmcgcGxhY2Vob2xkZXIgdG9rZW4gaW5zdGVhZC4gRXJyb3I6ICR7dG9rZW5SZXN1bHQuZXJyb3IubWVzc2FnZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0b2tlblVwZGF0ZWQgPSB0b2tlblJlc3VsdC50b2tlbiAhPT0gdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuO1xyXG4gICAgICAgICAgICB0aGlzLmxhdGVzdEFwcENoZWNrVG9rZW4gPSB0b2tlblJlc3VsdC50b2tlbjtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyJywgYFJlY2VpdmVkICR7dG9rZW5VcGRhdGVkID8gJ25ldycgOiAnZXhpc3RpbmcnfSB0b2tlbi5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRva2VuVXBkYXRlZFxyXG4gICAgICAgICAgICAgICAgPyBjaGFuZ2VMaXN0ZW5lcih0b2tlblJlc3VsdC50b2tlbilcclxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnRva2VuTGlzdGVuZXIgPSAodG9rZW5SZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgYXN5bmNRdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IG9uVG9rZW5DaGFuZ2VkKHRva2VuUmVzdWx0KSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCByZWdpc3RlckFwcENoZWNrID0gKGFwcENoZWNrKSA9PiB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdGaXJlYmFzZUFwcENoZWNrVG9rZW5Qcm92aWRlcicsICdBcHBDaGVjayBkZXRlY3RlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrID0gYXBwQ2hlY2s7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2suYWRkVG9rZW5MaXN0ZW5lcih0aGlzLnRva2VuTGlzdGVuZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyLm9uSW5pdChhcHBDaGVjayA9PiByZWdpc3RlckFwcENoZWNrKGFwcENoZWNrKSk7XHJcbiAgICAgICAgLy8gT3VyIHVzZXJzIGNhbiBpbml0aWFsaXplIEFwcENoZWNrIGFmdGVyIEZpcmVzdG9yZSwgc28gd2UgZ2l2ZSBpdFxyXG4gICAgICAgIC8vIGEgY2hhbmNlIHRvIHJlZ2lzdGVyIGl0c2VsZiB3aXRoIHRoZSBjb21wb25lbnQgZnJhbWV3b3JrLlxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFwcENoZWNrID0gdGhpcy5hcHBDaGVja1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJBcHBDaGVjayhhcHBDaGVjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBBcHBDaGVjayBpcyBzdGlsbCBub3QgYXZhaWxhYmxlLCBwcm9jZWVkIHdpdGhvdXQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoJ0ZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyJywgJ0FwcENoZWNrIG5vdCB5ZXQgZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oKSB7XHJcbiAgICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVJlZnJlc2g7XHJcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2ggPSBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwQ2hlY2suZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS50aGVuKHRva2VuUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgaWYgKHRva2VuUmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KHR5cGVvZiB0b2tlblJlc3VsdC50b2tlbiA9PT0gJ3N0cmluZycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RBcHBDaGVja1Rva2VuID0gdG9rZW5SZXN1bHQudG9rZW47XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFwcENoZWNrVG9rZW4odG9rZW5SZXN1bHQudG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGludmFsaWRhdGVUb2tlbigpIHtcclxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzaHV0ZG93bigpIHtcclxuICAgICAgICBpZiAodGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrLnJlbW92ZVRva2VuTGlzdGVuZXIodGhpcy50b2tlbkxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIEFwcENoZWNrIHRva2VuIHByb3ZpZGVyIHRoYXQgYWx3YXlzIHlpZWxkcyBhbiBlbXB0eSB0b2tlbi5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBFbXB0eUFwcENoZWNrVG9rZW5Qcm92aWRlciB7XHJcbiAgICBnZXRUb2tlbigpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBcHBDaGVja1Rva2VuKCcnKSk7XHJcbiAgICB9XHJcbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7IH1cclxuICAgIHN0YXJ0KGFzeW5jUXVldWUsIGNoYW5nZUxpc3RlbmVyKSB7IH1cclxuICAgIHNodXRkb3duKCkgeyB9XHJcbn1cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIENyZWRlbnRpYWxzUHJvdmlkZXIgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mXHJcbiAqIHRoZSBjcmVkZW50aWFscyBwYXNzZWQgaW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIoY3JlZGVudGlhbHMpIHtcclxuICAgIGlmICghY3JlZGVudGlhbHMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIoKTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoY3JlZGVudGlhbHNbJ3R5cGUnXSkge1xyXG4gICAgICAgIGNhc2UgJ2dhcGknOlxyXG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSBjcmVkZW50aWFsc1snY2xpZW50J107XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHJlYWxseSBpcyBhIEdhcGkgY2xpZW50LlxyXG4gICAgICAgICAgICBoYXJkQXNzZXJ0KCEhKHR5cGVvZiBjbGllbnQgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgICAgICBjbGllbnQgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIGNsaWVudFsnYXV0aCddICYmXHJcbiAgICAgICAgICAgICAgICBjbGllbnRbJ2F1dGgnXVsnZ2V0QXV0aEhlYWRlclZhbHVlRm9yRmlyc3RQYXJ0eSddKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmlyc3RQYXJ0eUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNsaWVudCwgY3JlZGVudGlhbHNbJ3Nlc3Npb25JbmRleCddIHx8ICcwJywgY3JlZGVudGlhbHNbJ2lhbVRva2VuJ10gfHwgbnVsbCk7XHJcbiAgICAgICAgY2FzZSAncHJvdmlkZXInOlxyXG4gICAgICAgICAgICByZXR1cm4gY3JlZGVudGlhbHNbJ2NsaWVudCddO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdtYWtlQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgZmFpbGVkIGR1ZSB0byBpbnZhbGlkIGNyZWRlbnRpYWwgdHlwZScpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBgTGlzdGVuU2VxdWVuY2VgIGlzIGEgbW9ub3RvbmljIHNlcXVlbmNlLiBJdCBpcyBpbml0aWFsaXplZCB3aXRoIGEgbWluaW11bSB2YWx1ZSB0b1xyXG4gKiBleGNlZWQuIEFsbCBzdWJzZXF1ZW50IGNhbGxzIHRvIG5leHQgd2lsbCByZXR1cm4gaW5jcmVhc2luZyB2YWx1ZXMuIElmIHByb3ZpZGVkIHdpdGggYVxyXG4gKiBgU2VxdWVuY2VOdW1iZXJTeW5jZXJgLCBpdCB3aWxsIGFkZGl0aW9uYWxseSBidW1wIGl0cyBuZXh0IHZhbHVlIHdoZW4gdG9sZCBvZiBhIG5ldyB2YWx1ZSwgYXNcclxuICogd2VsbCBhcyB3cml0ZSBvdXQgc2VxdWVuY2UgbnVtYmVycyB0aGF0IGl0IHByb2R1Y2VzIHZpYSBgbmV4dCgpYC5cclxuICovXHJcbmNsYXNzIExpc3RlblNlcXVlbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzVmFsdWUsIHNlcXVlbmNlTnVtYmVyU3luY2VyKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gcHJldmlvdXNWYWx1ZTtcclxuICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXJTeW5jZXIpIHtcclxuICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXJTeW5jZXIuc2VxdWVuY2VOdW1iZXJIYW5kbGVyID0gc2VxdWVuY2VOdW1iZXIgPT4gdGhpcy5zZXRQcmV2aW91c1ZhbHVlKHNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZU5ld1NlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXIgPT4gc2VxdWVuY2VOdW1iZXJTeW5jZXIud3JpdGVTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0UHJldmlvdXNWYWx1ZShleHRlcm5hbFByZXZpb3VzVmFsdWUpIHtcclxuICAgICAgICB0aGlzLnByZXZpb3VzVmFsdWUgPSBNYXRoLm1heChleHRlcm5hbFByZXZpb3VzVmFsdWUsIHRoaXMucHJldmlvdXNWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNWYWx1ZTtcclxuICAgIH1cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gKyt0aGlzLnByZXZpb3VzVmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMud3JpdGVOZXdTZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlTmV3U2VxdWVuY2VOdW1iZXIobmV4dFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcclxuICAgIH1cclxufVxyXG5MaXN0ZW5TZXF1ZW5jZS5JTlZBTElEID0gLTE7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERPQ1VNRU5UX0tFWV9OQU1FID0gJ19fbmFtZV9fJztcclxuLyoqXHJcbiAqIFBhdGggcmVwcmVzZW50cyBhbiBvcmRlcmVkIHNlcXVlbmNlIG9mIHN0cmluZyBzZWdtZW50cy5cclxuICovXHJcbmNsYXNzIEJhc2VQYXRoIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlZ21lbnRzLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvZmZzZXQgPiBzZWdtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoIC0gb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPiBzZWdtZW50cy5sZW5ndGggLSBvZmZzZXQpIHtcclxuICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlZ21lbnRzID0gc2VnbWVudHM7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5sZW4gPSBsZW5ndGg7XHJcbiAgICB9XHJcbiAgICBnZXQgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbjtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gQmFzZVBhdGguY29tcGFyYXRvcih0aGlzLCBvdGhlcikgPT09IDA7XHJcbiAgICB9XHJcbiAgICBjaGlsZChuYW1lT3JQYXRoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLmxpbWl0KCkpO1xyXG4gICAgICAgIGlmIChuYW1lT3JQYXRoIGluc3RhbmNlb2YgQmFzZVBhdGgpIHtcclxuICAgICAgICAgICAgbmFtZU9yUGF0aC5mb3JFYWNoKHNlZ21lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKG5hbWVPclBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Qoc2VnbWVudHMpO1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSBpbmRleCBvZiBvbmUgcGFzdCB0aGUgbGFzdCBzZWdtZW50IG9mIHRoZSBwYXRoLiAqL1xyXG4gICAgbGltaXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBwb3BGaXJzdChzaXplKSB7XHJcbiAgICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IDEgOiBzaXplO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdCh0aGlzLnNlZ21lbnRzLCB0aGlzLm9mZnNldCArIHNpemUsIHRoaXMubGVuZ3RoIC0gc2l6ZSk7XHJcbiAgICB9XHJcbiAgICBwb3BMYXN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdCh0aGlzLnNlZ21lbnRzLCB0aGlzLm9mZnNldCwgdGhpcy5sZW5ndGggLSAxKTtcclxuICAgIH1cclxuICAgIGZpcnN0U2VnbWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50c1t0aGlzLm9mZnNldF07XHJcbiAgICB9XHJcbiAgICBsYXN0U2VnbWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5sZW5ndGggLSAxKTtcclxuICAgIH1cclxuICAgIGdldChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRzW3RoaXMub2Zmc2V0ICsgaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICBpc1ByZWZpeE9mKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA8IHRoaXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChpKSAhPT0gb3RoZXIuZ2V0KGkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpc0ltbWVkaWF0ZVBhcmVudE9mKHBvdGVudGlhbENoaWxkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICsgMSAhPT0gcG90ZW50aWFsQ2hpbGQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldChpKSAhPT0gcG90ZW50aWFsQ2hpbGQuZ2V0KGkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoKGZuKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub2Zmc2V0LCBlbmQgPSB0aGlzLmxpbWl0KCk7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICBmbih0aGlzLnNlZ21lbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b0FycmF5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRzLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLmxpbWl0KCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbXBhcmF0b3IocDEsIHAyKSB7XHJcbiAgICAgICAgY29uc3QgbGVuID0gTWF0aC5taW4ocDEubGVuZ3RoLCBwMi5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHAxLmdldChpKTtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBwMi5nZXQoaSk7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0IDwgcmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGVmdCA+IHJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocDEubGVuZ3RoIDwgcDIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAxLmxlbmd0aCA+IHAyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgc2xhc2gtc2VwYXJhdGVkIHBhdGggZm9yIG5hdmlnYXRpbmcgcmVzb3VyY2VzIChkb2N1bWVudHMgYW5kIGNvbGxlY3Rpb25zKVxyXG4gKiB3aXRoaW4gRmlyZXN0b3JlLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFJlc291cmNlUGF0aCBleHRlbmRzIEJhc2VQYXRoIHtcclxuICAgIGNvbnN0cnVjdChzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgY2Fub25pY2FsU3RyaW5nKCkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRoZSBjbGllbnQgaXMgaWdub3JhbnQgb2YgYW55IHBhdGggc2VnbWVudHMgY29udGFpbmluZyBlc2NhcGVcclxuICAgICAgICAvLyBzZXF1ZW5jZXMgKGUuZy4gX19pZDEyM19fKSBhbmQganVzdCBwYXNzZXMgdGhlbSB0aHJvdWdoIHJhdyAodGhleSBleGlzdFxyXG4gICAgICAgIC8vIGZvciBsZWdhY3kgcmVhc29ucyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGZyZXF1ZW50bHkpLlxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5qb2luKCcvJyk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJlc291cmNlIHBhdGggZnJvbSB0aGUgZ2l2ZW4gc2xhc2gtZGVsaW1pdGVkIHN0cmluZy4gSWYgbXVsdGlwbGVcclxuICAgICAqIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIGFsbCBjb21wb25lbnRzIGFyZSBjb21iaW5lZC4gTGVhZGluZyBhbmQgdHJhaWxpbmdcclxuICAgICAqIHNsYXNoZXMgZnJvbSBhbGwgY29tcG9uZW50cyBhcmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21TdHJpbmcoLi4ucGF0aENvbXBvbmVudHMpIHtcclxuICAgICAgICAvLyBOT1RFOiBUaGUgY2xpZW50IGlzIGlnbm9yYW50IG9mIGFueSBwYXRoIHNlZ21lbnRzIGNvbnRhaW5pbmcgZXNjYXBlXHJcbiAgICAgICAgLy8gc2VxdWVuY2VzIChlLmcuIF9faWQxMjNfXykgYW5kIGp1c3QgcGFzc2VzIHRoZW0gdGhyb3VnaCByYXcgKHRoZXkgZXhpc3RcclxuICAgICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgYW5kIHNob3VsZCBub3QgYmUgdXNlZCBmcmVxdWVudGx5KS5cclxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoQ29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKCcvLycpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHNlZ21lbnQgKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBjb250YWluIC8vIGluIHRoZW0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU3RyaXAgbGVhZGluZyBhbmQgdHJhbGluZyBzbGFzaGVkLlxyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKC4uLnBhdGguc3BsaXQoJy8nKS5maWx0ZXIoc2VnbWVudCA9PiBzZWdtZW50Lmxlbmd0aCA+IDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVtcHR5UGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGF0aChbXSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaWRlbnRpZmllclJlZ0V4cCA9IC9eW19hLXpBLVpdW19hLXpBLVowLTldKiQvO1xyXG4vKipcclxuICogQSBkb3Qtc2VwYXJhdGVkIHBhdGggZm9yIG5hdmlnYXRpbmcgc3ViLW9iamVjdHMgd2l0aGluIGEgZG9jdW1lbnQuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRmllbGRQYXRoJDEgZXh0ZW5kcyBCYXNlUGF0aCB7XHJcbiAgICBjb25zdHJ1Y3Qoc2VnbWVudHMsIG9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShzZWdtZW50cywgb2Zmc2V0LCBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmluZyBjb3VsZCBiZSB1c2VkIGFzIGEgc2VnbWVudCBpbiBhIGZpZWxkIHBhdGhcclxuICAgICAqIHdpdGhvdXQgZXNjYXBpbmcuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1ZhbGlkSWRlbnRpZmllcihzZWdtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXJSZWdFeHAudGVzdChzZWdtZW50KTtcclxuICAgIH1cclxuICAgIGNhbm9uaWNhbFN0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b0FycmF5KClcclxuICAgICAgICAgICAgLm1hcChzdHIgPT4ge1xyXG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9gL2csICdcXFxcYCcpO1xyXG4gICAgICAgICAgICBpZiAoIUZpZWxkUGF0aCQxLmlzVmFsaWRJZGVudGlmaWVyKHN0cikpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9ICdgJyArIHN0ciArICdgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5qb2luKCcuJyk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZmllbGQgcmVmZXJlbmNlcyB0aGUga2V5IG9mIGEgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGlzS2V5RmllbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMuZ2V0KDApID09PSBET0NVTUVOVF9LRVlfTkFNRTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZpZWxkIGRlc2lnbmF0aW5nIHRoZSBrZXkgb2YgYSBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGtleUZpZWxkKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRQYXRoJDEoW0RPQ1VNRU5UX0tFWV9OQU1FXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIGZpZWxkIHN0cmluZyBmcm9tIHRoZSBnaXZlbiBzZXJ2ZXItZm9ybWF0dGVkIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiAtIFNwbGl0dGluZyB0aGUgZW1wdHkgc3RyaW5nIGlzIG5vdCBhbGxvd2VkIChmb3Igbm93IGF0IGxlYXN0KS5cclxuICAgICAqIC0gRW1wdHkgc2VnbWVudHMgd2l0aGluIHRoZSBzdHJpbmcgKGUuZy4gaWYgdGhlcmUgYXJlIHR3byBjb25zZWN1dGl2ZVxyXG4gICAgICogICBzZXBhcmF0b3JzKSBhcmUgbm90IGFsbG93ZWQuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyhiLzM3MjQ0MTU3KTogd2Ugc2hvdWxkIG1ha2UgdGhpcyBtb3JlIHN0cmljdC4gUmlnaHQgbm93LCBpdCBhbGxvd3NcclxuICAgICAqIG5vbi1pZGVudGlmaWVyIHBhdGggY29tcG9uZW50cywgZXZlbiBpZiB0aGV5IGFyZW4ndCBlc2NhcGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVNlcnZlckZvcm1hdChwYXRoKSB7XHJcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcclxuICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBjb25zdCBhZGRDdXJyZW50U2VnbWVudCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBmaWVsZCBwYXRoICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgYmUgZW1wdHksIGJlZ2luIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGB3aXRoICcuJywgZW5kIHdpdGggJy4nLCBvciBjb250YWluICcuLidgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgaW5CYWNrdGlja3MgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBwYXRoW2ldO1xyXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPT09IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1BhdGggaGFzIHRyYWlsaW5nIGVzY2FwZSBjaGFyYWN0ZXI6ICcgKyBwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwYXRoW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGlmICghKG5leHQgPT09ICdcXFxcJyB8fCBuZXh0ID09PSAnLicgfHwgbmV4dCA9PT0gJ2AnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdQYXRoIGhhcyBpbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZTogJyArIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdgJykge1xyXG4gICAgICAgICAgICAgICAgaW5CYWNrdGlja3MgPSAhaW5CYWNrdGlja3M7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJy4nICYmICFpbkJhY2t0aWNrcykge1xyXG4gICAgICAgICAgICAgICAgYWRkQ3VycmVudFNlZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRDdXJyZW50U2VnbWVudCgpO1xyXG4gICAgICAgIGlmIChpbkJhY2t0aWNrcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVW50ZXJtaW5hdGVkIGAgaW4gcGF0aDogJyArIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCQxKHNlZ21lbnRzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eVBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgkMShbXSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgZXNjYXBlQ2hhciA9ICdcXHUwMDAxJztcclxuY29uc3QgZW5jb2RlZFNlcGFyYXRvckNoYXIgPSAnXFx1MDAwMSc7XHJcbmNvbnN0IGVuY29kZWROdWwgPSAnXFx1MDAxMCc7XHJcbmNvbnN0IGVuY29kZWRFc2NhcGUgPSAnXFx1MDAxMSc7XHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgcmVzb3VyY2UgcGF0aCBpbnRvIGEgSW5kZXhlZERiLWNvbXBhdGlibGUgc3RyaW5nIGZvcm0uXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmNvZGVSZXNvdXJjZVBhdGgocGF0aCkge1xyXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGVuY29kZVNlcGFyYXRvcihyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSBlbmNvZGVTZWdtZW50KHBhdGguZ2V0KGkpLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVuY29kZVNlcGFyYXRvcihyZXN1bHQpO1xyXG59XHJcbi8qKiBFbmNvZGVzIGEgc2luZ2xlIHNlZ21lbnQgb2YgYSByZXNvdXJjZSBwYXRoIGludG8gdGhlIGdpdmVuIHJlc3VsdCAqL1xyXG5mdW5jdGlvbiBlbmNvZGVTZWdtZW50KHNlZ21lbnQsIHJlc3VsdEJ1Zikge1xyXG4gICAgbGV0IHJlc3VsdCA9IHJlc3VsdEJ1ZjtcclxuICAgIGNvbnN0IGxlbmd0aCA9IHNlZ21lbnQubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGMgPSBzZWdtZW50LmNoYXJBdChpKTtcclxuICAgICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICAgICAgY2FzZSAnXFwwJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVDaGFyICsgZW5jb2RlZE51bDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGVzY2FwZUNoYXI6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZXNjYXBlQ2hhciArIGVuY29kZWRFc2NhcGU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqIEVuY29kZXMgYSBwYXRoIHNlcGFyYXRvciBpbnRvIHRoZSBnaXZlbiByZXN1bHQgKi9cclxuZnVuY3Rpb24gZW5jb2RlU2VwYXJhdG9yKHJlc3VsdCkge1xyXG4gICAgcmV0dXJuIHJlc3VsdCArIGVzY2FwZUNoYXIgKyBlbmNvZGVkU2VwYXJhdG9yQ2hhcjtcclxufVxyXG4vKipcclxuICogRGVjb2RlcyB0aGUgZ2l2ZW4gSW5kZXhlZERiLWNvbXBhdGlibGUgc3RyaW5nIGZvcm0gb2YgYSByZXNvdXJjZSBwYXRoIGludG9cclxuICogYSBSZXNvdXJjZVBhdGggaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBub3Qgc3VpdGFibGUgZm9yIHVzZSB3aXRoXHJcbiAqIGRlY29kaW5nIHJlc291cmNlIG5hbWVzIGZyb20gdGhlIHNlcnZlcjsgdGhvc2UgYXJlIE9uZSBQbGF0Zm9ybSBmb3JtYXRcclxuICogc3RyaW5ncy5cclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZVJlc291cmNlUGF0aChwYXRoKSB7XHJcbiAgICAvLyBFdmVudCB0aGUgZW1wdHkgcGF0aCBtdXN0IGVuY29kZSBhcyBhIHBhdGggb2YgYXQgbGVhc3QgbGVuZ3RoIDIuIEEgcGF0aFxyXG4gICAgLy8gd2l0aCBleGFjdGx5IDIgbXVzdCBiZSB0aGUgZW1wdHkgcGF0aC5cclxuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xyXG4gICAgaGFyZEFzc2VydChsZW5ndGggPj0gMik7XHJcbiAgICBpZiAobGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgaGFyZEFzc2VydChwYXRoLmNoYXJBdCgwKSA9PT0gZXNjYXBlQ2hhciAmJiBwYXRoLmNoYXJBdCgxKSA9PT0gZW5jb2RlZFNlcGFyYXRvckNoYXIpO1xyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCk7XHJcbiAgICB9XHJcbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyBjYW5ub3QgZXhpc3QgcGFzdCB0aGUgc2Vjb25kLXRvLWxhc3QgcG9zaXRpb24gaW4gdGhlXHJcbiAgICAvLyBzb3VyY2UgdmFsdWUuXHJcbiAgICBjb25zdCBsYXN0UmVhc29uYWJsZUVzY2FwZUluZGV4ID0gbGVuZ3RoIC0gMjtcclxuICAgIGNvbnN0IHNlZ21lbnRzID0gW107XHJcbiAgICBsZXQgc2VnbWVudEJ1aWxkZXIgPSAnJztcclxuICAgIGZvciAobGV0IHN0YXJ0ID0gMDsgc3RhcnQgPCBsZW5ndGg7KSB7XHJcbiAgICAgICAgLy8gVGhlIGxhc3QgdHdvIGNoYXJhY3RlcnMgb2YgYSB2YWxpZCBlbmNvZGVkIHBhdGggbXVzdCBiZSBhIHNlcGFyYXRvciwgc29cclxuICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIGFuIGVuZCB0byB0aGlzIHNlZ21lbnQuXHJcbiAgICAgICAgY29uc3QgZW5kID0gcGF0aC5pbmRleE9mKGVzY2FwZUNoYXIsIHN0YXJ0KTtcclxuICAgICAgICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBsYXN0UmVhc29uYWJsZUVzY2FwZUluZGV4KSB7XHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IHBhdGguY2hhckF0KGVuZCArIDEpO1xyXG4gICAgICAgIHN3aXRjaCAobmV4dCkge1xyXG4gICAgICAgICAgICBjYXNlIGVuY29kZWRTZXBhcmF0b3JDaGFyOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBpZWNlID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50QnVpbGRlci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBjb3B5aW5nIGZvciB0aGUgY29tbW9uIGNhc2Ugb2YgYSBzZWdtZW50IHRoYXQgZXhjbHVkZXMgXFwwXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIFxcMDAxXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IGN1cnJlbnRQaWVjZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRCdWlsZGVyICs9IGN1cnJlbnRQaWVjZTtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudEJ1aWxkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBlbmNvZGVkTnVsOlxyXG4gICAgICAgICAgICAgICAgc2VnbWVudEJ1aWxkZXIgKz0gcGF0aC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciArPSAnXFwwJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIGVuY29kZWRFc2NhcGU6XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXNjYXBlIGNoYXJhY3RlciBjYW4gYmUgdXNlZCBpbiB0aGUgb3V0cHV0IHRvIGVuY29kZSBpdHNlbGYuXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50QnVpbGRlciArPSBwYXRoLnN1YnN0cmluZyhzdGFydCwgZW5kICsgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhcnQgPSBlbmQgKyAyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBhdGgoc2VnbWVudHMpO1xyXG59XG4vKipcclxuICogU2NoZW1hIFZlcnNpb24gZm9yIHRoZSBXZWIgY2xpZW50OlxyXG4gKiAxLiAgSW5pdGlhbCB2ZXJzaW9uIGluY2x1ZGluZyBNdXRhdGlvbiBRdWV1ZSwgUXVlcnkgQ2FjaGUsIGFuZCBSZW1vdGVcclxuICogICAgIERvY3VtZW50IENhY2hlXHJcbiAqIDIuICBVc2VkIHRvIGVuc3VyZSBhIHRhcmdldEdsb2JhbCBvYmplY3QgZXhpc3RzIGFuZCBhZGQgdGFyZ2V0Q291bnQgdG8gaXQuIE5vXHJcbiAqICAgICBsb25nZXIgcmVxdWlyZWQgYmVjYXVzZSBtaWdyYXRpb24gMyB1bmNvbmRpdGlvbmFsbHkgY2xlYXJzIGl0LlxyXG4gKiAzLiAgRHJvcHBlZCBhbmQgcmUtY3JlYXRlZCBRdWVyeSBDYWNoZSB0byBkZWFsIHdpdGggY2FjaGUgY29ycnVwdGlvbiByZWxhdGVkXHJcbiAqICAgICB0byBsaW1ibyByZXNvbHV0aW9uLiBBZGRyZXNzZXNcclxuICogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1pb3Mtc2RrL2lzc3Vlcy8xNTQ4XHJcbiAqIDQuICBNdWx0aS1UYWIgU3VwcG9ydC5cclxuICogNS4gIFJlbW92YWwgb2YgaGVsZCB3cml0ZSBhY2tzLlxyXG4gKiA2LiAgQ3JlYXRlIGRvY3VtZW50IGdsb2JhbCBmb3IgdHJhY2tpbmcgZG9jdW1lbnQgY2FjaGUgc2l6ZS5cclxuICogNy4gIEVuc3VyZSBldmVyeSBjYWNoZWQgZG9jdW1lbnQgaGFzIGEgc2VudGluZWwgcm93IHdpdGggYSBzZXF1ZW5jZSBudW1iZXIuXHJcbiAqIDguICBBZGQgY29sbGVjdGlvbi1wYXJlbnQgaW5kZXggZm9yIENvbGxlY3Rpb24gR3JvdXAgcXVlcmllcy5cclxuICogOS4gIENoYW5nZSBSZW1vdGVEb2N1bWVudENoYW5nZXMgc3RvcmUgdG8gYmUga2V5ZWQgYnkgcmVhZFRpbWUgcmF0aGVyIHRoYW5cclxuICogICAgIGFuIGF1dG8taW5jcmVtZW50aW5nIElELiBUaGlzIGlzIHJlcXVpcmVkIGZvciBJbmRleC1GcmVlIHF1ZXJpZXMuXHJcbiAqIDEwLiBSZXdyaXRlIHRoZSBjYW5vbmljYWwgSURzIHRvIHRoZSBleHBsaWNpdCBQcm90b2J1Zi1iYXNlZCBmb3JtYXQuXHJcbiAqIDExLiBBZGQgYnVuZGxlcyBhbmQgbmFtZWRfcXVlcmllcyBmb3IgYnVuZGxlIHN1cHBvcnQuXHJcbiAqIDEyLiBBZGQgZG9jdW1lbnQgb3ZlcmxheXMuXHJcbiAqIDEzLiBBZGQgaW5kZXhpbmcgc3VwcG9ydC5cclxuICovXHJcbmNvbnN0IFNDSEVNQV9WRVJTSU9OID0gMTI7XHJcbi8qKlxyXG4gKiBXcmFwcGVyIGNsYXNzIHRvIHN0b3JlIHRpbWVzdGFtcHMgKHNlY29uZHMgYW5kIG5hbm9zKSBpbiBJbmRleGVkRGIgb2JqZWN0cy5cclxuICovXHJcbmNsYXNzIERiVGltZXN0YW1wIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlY29uZHMsIG5hbm9zZWNvbmRzKSB7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRzID0gc2Vjb25kcztcclxuICAgICAgICB0aGlzLm5hbm9zZWNvbmRzID0gbmFub3NlY29uZHM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgc2luZ2xldG9uIG9iamVjdCB0byBiZSBzdG9yZWQgaW4gdGhlICdvd25lcicgc3RvcmUgaW4gSW5kZXhlZERiLlxyXG4gKlxyXG4gKiBBIGdpdmVuIGRhdGFiYXNlIGNhbiBoYXZlIGEgc2luZ2xlIHByaW1hcnkgdGFiIGFzc2lnbmVkIGF0IGEgZ2l2ZW4gdGltZS4gVGhhdFxyXG4gKiB0YWIgbXVzdCB2YWxpZGF0ZSB0aGF0IGl0IGlzIHN0aWxsIGhvbGRpbmcgdGhlIHByaW1hcnkgbGVhc2UgYmVmb3JlIGV2ZXJ5XHJcbiAqIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIGxvY2tlZCBhY2Nlc3MuIFRoZSBwcmltYXJ5IHRhYiBzaG91bGQgcmVndWxhcmx5XHJcbiAqIHdyaXRlIGFuIHVwZGF0ZWQgdGltZXN0YW1wIHRvIHRoaXMgbGVhc2UgdG8gcHJldmVudCBvdGhlciB0YWJzIGZyb21cclxuICogXCJzdGVhbGluZ1wiIHRoZSBwcmltYXJ5IGxlYXNlXHJcbiAqL1xyXG5jbGFzcyBEYlByaW1hcnlDbGllbnQge1xyXG4gICAgY29uc3RydWN0b3Iob3duZXJJZCwgXHJcbiAgICAvKiogV2hldGhlciB0byBhbGxvdyBzaGFyZWQgYWNjZXNzIGZyb20gbXVsdGlwbGUgdGFicy4gKi9cclxuICAgIGFsbG93VGFiU3luY2hyb25pemF0aW9uLCBsZWFzZVRpbWVzdGFtcE1zKSB7XHJcbiAgICAgICAgdGhpcy5vd25lcklkID0gb3duZXJJZDtcclxuICAgICAgICB0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uID0gYWxsb3dUYWJTeW5jaHJvbml6YXRpb247XHJcbiAgICAgICAgdGhpcy5sZWFzZVRpbWVzdGFtcE1zID0gbGVhc2VUaW1lc3RhbXBNcztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS5cclxuICpcclxuICogTm90ZSB0aGF0IHRoZSBuYW1lICdvd25lcicgaXMgY2hvc2VuIHRvIGVuc3VyZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoXHJcbiAqIG9sZGVyIGNsaWVudHMgdGhhdCBvbmx5IHN1cHBvcnRlZCBzaW5nbGUgbG9ja2VkIGFjY2VzcyB0byB0aGUgcGVyc2lzdGVuY2VcclxuICogbGF5ZXIuXHJcbiAqL1xyXG5EYlByaW1hcnlDbGllbnQuc3RvcmUgPSAnb3duZXInO1xyXG4vKipcclxuICogVGhlIGtleSBzdHJpbmcgdXNlZCBmb3IgdGhlIHNpbmdsZSBvYmplY3QgdGhhdCBleGlzdHMgaW4gdGhlXHJcbiAqIERiUHJpbWFyeUNsaWVudCBzdG9yZS5cclxuICovXHJcbkRiUHJpbWFyeUNsaWVudC5rZXkgPSAnb3duZXInO1xyXG4vKipcclxuICogQW4gb2JqZWN0IHRvIGJlIHN0b3JlZCBpbiB0aGUgJ211dGF0aW9uUXVldWVzJyBzdG9yZSBpbiBJbmRleGVkRGIuXHJcbiAqXHJcbiAqIEVhY2ggdXNlciBnZXRzIGEgc2luZ2xlIHF1ZXVlIG9mIE11dGF0aW9uQmF0Y2hlcyB0byBhcHBseSB0byB0aGUgc2VydmVyLlxyXG4gKiBEYk11dGF0aW9uUXVldWUgdHJhY2tzIHRoZSBtZXRhZGF0YSBhYm91dCB0aGUgcXVldWUuXHJcbiAqL1xyXG5jbGFzcyBEYk11dGF0aW9uUXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBub3JtYWxpemVkIHVzZXIgSUQgdG8gd2hpY2ggdGhpcyBxdWV1ZSBiZWxvbmdzLlxyXG4gICAgICovXHJcbiAgICB1c2VySWQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBpZGVudGlmaWVyIGZvciB0aGUgaGlnaGVzdCBudW1iZXJlZCBiYXRjaCB0aGF0IGhhcyBiZWVuIGFja25vd2xlZGdlZFxyXG4gICAgICogYnkgdGhlIHNlcnZlci4gQWxsIE11dGF0aW9uQmF0Y2hlcyBpbiB0aGlzIHF1ZXVlIHdpdGggYmF0Y2hJZHMgbGVzc1xyXG4gICAgICogdGhhbiBvciBlcXVhbCB0byB0aGlzIHZhbHVlIGFyZSBjb25zaWRlcmVkIHRvIGhhdmUgYmVlbiBhY2tub3dsZWRnZWQgYnlcclxuICAgICAqIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogdGhpcyBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgdXNlZCBieSB0aGUgY29kZS5cclxuICAgICAqL1xyXG4gICAgbGFzdEFja25vd2xlZGdlZEJhdGNoSWQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHN0cmVhbSB0b2tlbiB0aGF0IHdhcyBwcmV2aW91c2x5IHNlbnQgYnkgdGhlIHNlcnZlci5cclxuICAgICAqXHJcbiAgICAgKiBTZWUgU3RyZWFtaW5nV3JpdGVSZXF1ZXN0IGluIGRhdGFzdG9yZS5wcm90byBmb3IgbW9yZSBkZXRhaWxzIGFib3V0XHJcbiAgICAgKiB1c2FnZS5cclxuICAgICAqXHJcbiAgICAgKiBBZnRlciBzZW5kaW5nIHRoaXMgdG9rZW4sIGVhcmxpZXIgdG9rZW5zIG1heSBub3QgYmUgdXNlZCBhbnltb3JlIHNvXHJcbiAgICAgKiBvbmx5IGEgc2luZ2xlIHN0cmVhbSB0b2tlbiBpcyByZXRhaW5lZC5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiB0aGlzIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciB1c2VkIGJ5IHRoZSBjb2RlLlxyXG4gICAgICovXHJcbiAgICBsYXN0U3RyZWFtVG9rZW4pIHtcclxuICAgICAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcclxuICAgICAgICB0aGlzLmxhc3RBY2tub3dsZWRnZWRCYXRjaElkID0gbGFzdEFja25vd2xlZGdlZEJhdGNoSWQ7XHJcbiAgICAgICAgdGhpcy5sYXN0U3RyZWFtVG9rZW4gPSBsYXN0U3RyZWFtVG9rZW47XHJcbiAgICB9XHJcbn1cclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICAqL1xyXG5EYk11dGF0aW9uUXVldWUuc3RvcmUgPSAnbXV0YXRpb25RdWV1ZXMnO1xyXG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHVzZXJJZCBwcm9wZXJ0eS4gKi9cclxuRGJNdXRhdGlvblF1ZXVlLmtleVBhdGggPSAndXNlcklkJztcclxuLyoqXHJcbiAqIEFuIG9iamVjdCB0byBiZSBzdG9yZWQgaW4gdGhlICdtdXRhdGlvbnMnIHN0b3JlIGluIEluZGV4ZWREYi5cclxuICpcclxuICogUmVwcmVzZW50cyBhIGJhdGNoIG9mIHVzZXItbGV2ZWwgbXV0YXRpb25zIGludGVuZGVkIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlclxyXG4gKiBpbiBhIHNpbmdsZSB3cml0ZS4gRWFjaCB1c2VyLWxldmVsIGJhdGNoIGdldHMgYSBzZXBhcmF0ZSBEYk11dGF0aW9uQmF0Y2hcclxuICogd2l0aCBhIG5ldyBiYXRjaElkLlxyXG4gKi9cclxuY2xhc3MgRGJNdXRhdGlvbkJhdGNoIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbm9ybWFsaXplZCB1c2VyIElEIHRvIHdoaWNoIHRoaXMgYmF0Y2ggYmVsb25ncy5cclxuICAgICAqL1xyXG4gICAgdXNlcklkLCBcclxuICAgIC8qKlxyXG4gICAgICogQW4gaWRlbnRpZmllciBmb3IgdGhpcyBiYXRjaCwgYWxsb2NhdGVkIHVzaW5nIGFuIGF1dG8tZ2VuZXJhdGVkIGtleS5cclxuICAgICAqL1xyXG4gICAgYmF0Y2hJZCwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb2NhbCB3cml0ZSB0aW1lIG9mIHRoZSBiYXRjaCwgc3RvcmVkIGFzIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGVcclxuICAgICAqIGVwb2NoLlxyXG4gICAgICovXHJcbiAgICBsb2NhbFdyaXRlVGltZU1zLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBsaXN0IG9mIFwibXV0YXRpb25zXCIgdGhhdCByZXByZXNlbnQgYSBwYXJ0aWFsIGJhc2Ugc3RhdGUgZnJvbSB3aGVuIHRoaXNcclxuICAgICAqIHdyaXRlIGJhdGNoIHdhcyBpbml0aWFsbHkgY3JlYXRlZC4gRHVyaW5nIGxvY2FsIGFwcGxpY2F0aW9uIG9mIHRoZSB3cml0ZVxyXG4gICAgICogYmF0Y2gsIHRoZXNlIGJhc2VNdXRhdGlvbnMgYXJlIGFwcGxpZWQgcHJpb3IgdG8gdGhlIHJlYWwgd3JpdGVzIGluIG9yZGVyXHJcbiAgICAgKiB0byBvdmVycmlkZSBjZXJ0YWluIGRvY3VtZW50IGZpZWxkcyBmcm9tIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUuIFRoaXNcclxuICAgICAqIGlzIG5lY2Vzc2FyeSBpbiB0aGUgY2FzZSBvZiBub24taWRlbXBvdGVudCB3cml0ZXMgKGUuZy4gYGluY3JlbWVudCgpYFxyXG4gICAgICogdHJhbnNmb3JtcykgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGxvY2FsIHZpZXcgb2YgdGhlIG1vZGlmaWVkIGRvY3VtZW50c1xyXG4gICAgICogZG9lc24ndCBmbGlja2VyIGlmIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUgcmVjZWl2ZXMgdGhlIHJlc3VsdCBvZiB0aGVcclxuICAgICAqIG5vbi1pZGVtcG90ZW50IHdyaXRlIGJlZm9yZSB0aGUgd3JpdGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGVzZSBtdXRhdGlvbnMgYXJlIG5ldmVyIHNlbnQgdG8gdGhlIGJhY2tlbmQuXHJcbiAgICAgKi9cclxuICAgIGJhc2VNdXRhdGlvbnMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGxpc3Qgb2YgbXV0YXRpb25zIHRvIGFwcGx5LiBBbGwgbXV0YXRpb25zIHdpbGwgYmUgYXBwbGllZCBhdG9taWNhbGx5LlxyXG4gICAgICpcclxuICAgICAqIE11dGF0aW9ucyBhcmUgc2VyaWFsaXplZCB2aWEgdG9NdXRhdGlvbigpLlxyXG4gICAgICovXHJcbiAgICBtdXRhdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcclxuICAgICAgICB0aGlzLmJhdGNoSWQgPSBiYXRjaElkO1xyXG4gICAgICAgIHRoaXMubG9jYWxXcml0ZVRpbWVNcyA9IGxvY2FsV3JpdGVUaW1lTXM7XHJcbiAgICAgICAgdGhpcy5iYXNlTXV0YXRpb25zID0gYmFzZU11dGF0aW9ucztcclxuICAgICAgICB0aGlzLm11dGF0aW9ucyA9IG11dGF0aW9ucztcclxuICAgIH1cclxufVxyXG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gICovXHJcbkRiTXV0YXRpb25CYXRjaC5zdG9yZSA9ICdtdXRhdGlvbnMnO1xyXG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHVzZXJJZCwgYmF0Y2hJZCBwcm9wZXJ0aWVzLiAqL1xyXG5EYk11dGF0aW9uQmF0Y2gua2V5UGF0aCA9ICdiYXRjaElkJztcclxuLyoqIFRoZSBpbmRleCBuYW1lIGZvciBsb29rdXAgb2YgbXV0YXRpb25zIGJ5IHVzZXIuICovXHJcbkRiTXV0YXRpb25CYXRjaC51c2VyTXV0YXRpb25zSW5kZXggPSAndXNlck11dGF0aW9uc0luZGV4JztcclxuLyoqIFRoZSB1c2VyIG11dGF0aW9ucyBpbmRleCBpcyBrZXllZCBieSBbdXNlcklkLCBiYXRjaElkXSBwYWlycy4gKi9cclxuRGJNdXRhdGlvbkJhdGNoLnVzZXJNdXRhdGlvbnNLZXlQYXRoID0gWyd1c2VySWQnLCAnYmF0Y2hJZCddO1xyXG4vKipcclxuICogQW4gb2JqZWN0IHRvIGJlIHN0b3JlZCBpbiB0aGUgJ2RvY3VtZW50TXV0YXRpb25zJyBzdG9yZSBpbiBJbmRleGVkRGIuXHJcbiAqXHJcbiAqIEEgbWFudWFsbHkgbWFpbnRhaW5lZCBpbmRleCBvZiBhbGwgdGhlIG11dGF0aW9uIGJhdGNoZXMgdGhhdCBhZmZlY3QgYSBnaXZlblxyXG4gKiBkb2N1bWVudCBrZXkuIFRoZSByb3dzIGluIHRoaXMgdGFibGUgYXJlIHJlZmVyZW5jZXMgYmFzZWQgb24gdGhlIGNvbnRlbnRzIG9mXHJcbiAqIERiTXV0YXRpb25CYXRjaC5tdXRhdGlvbnMuXHJcbiAqL1xyXG5jbGFzcyBEYkRvY3VtZW50TXV0YXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFt1c2VySWRdIGtleSBmb3IgdXNlIGluIHRoZSBEYkRvY3VtZW50TXV0YXRpb25zIGluZGV4IHRvIGl0ZXJhdGVcclxuICAgICAqIG92ZXIgYWxsIG9mIGEgdXNlcidzIGRvY3VtZW50IG11dGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHByZWZpeEZvclVzZXIodXNlcklkKSB7XHJcbiAgICAgICAgcmV0dXJuIFt1c2VySWRdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgW3VzZXJJZCwgZW5jb2RlZFBhdGhdIGtleSBmb3IgdXNlIGluIHRoZSBEYkRvY3VtZW50TXV0YXRpb25zXHJcbiAgICAgKiBpbmRleCB0byBpdGVyYXRlIG92ZXIgYWxsIGF0IGRvY3VtZW50IG11dGF0aW9ucyBmb3IgYSBnaXZlbiBwYXRoIG9yIGxvd2VyLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcHJlZml4Rm9yUGF0aCh1c2VySWQsIHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gW3VzZXJJZCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bGwgaW5kZXgga2V5IG9mIFt1c2VySWQsIGVuY29kZWRQYXRoLCBiYXRjaElkXSBmb3IgaW5zZXJ0aW5nXHJcbiAgICAgKiBhbmQgZGVsZXRpbmcgaW50byB0aGUgRGJEb2N1bWVudE11dGF0aW9ucyBpbmRleC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGtleSh1c2VySWQsIHBhdGgsIGJhdGNoSWQpIHtcclxuICAgICAgICByZXR1cm4gW3VzZXJJZCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpLCBiYXRjaElkXTtcclxuICAgIH1cclxufVxyXG5EYkRvY3VtZW50TXV0YXRpb24uc3RvcmUgPSAnZG9jdW1lbnRNdXRhdGlvbnMnO1xyXG4vKipcclxuICogQmVjYXVzZSB3ZSBzdG9yZSBhbGwgdGhlIHVzZWZ1bCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBzdG9yZSBpbiB0aGUga2V5LFxyXG4gKiB0aGVyZSBpcyBubyB1c2VmdWwgaW5mb3JtYXRpb24gdG8gc3RvcmUgYXMgdGhlIHZhbHVlLiBUaGUgcmF3ICh1bmVuY29kZWQpXHJcbiAqIHBhdGggY2Fubm90IGJlIHN0b3JlZCBiZWNhdXNlIEluZGV4ZWREYiBkb2Vzbid0IHN0b3JlIHByb3RvdHlwZVxyXG4gKiBpbmZvcm1hdGlvbi5cclxuICovXHJcbkRiRG9jdW1lbnRNdXRhdGlvbi5QTEFDRUhPTERFUiA9IG5ldyBEYkRvY3VtZW50TXV0YXRpb24oKTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGtub3duIGFic2VuY2Ugb2YgYSBkb2N1bWVudCBhdCBhIHBhcnRpY3VsYXIgdmVyc2lvbi5cclxuICogU3RvcmVkIGluIEluZGV4ZWREYiBhcyBwYXJ0IG9mIGEgRGJSZW1vdGVEb2N1bWVudCBvYmplY3QuXHJcbiAqL1xyXG5jbGFzcyBEYk5vRG9jdW1lbnQge1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgcmVhZFRpbWUpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMucmVhZFRpbWUgPSByZWFkVGltZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGRvY3VtZW50IHRoYXQgaXMga25vd24gdG8gZXhpc3QgYnV0IHdob3NlIGRhdGEgaXMgdW5rbm93bi5cclxuICogU3RvcmVkIGluIEluZGV4ZWREYiBhcyBwYXJ0IG9mIGEgRGJSZW1vdGVEb2N1bWVudCBvYmplY3QuXHJcbiAqL1xyXG5jbGFzcyBEYlVua25vd25Eb2N1bWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgdG8gYmUgc3RvcmVkIGluIHRoZSAncmVtb3RlRG9jdW1lbnRzJyBzdG9yZSBpbiBJbmRleGVkRGIuXHJcbiAqIEl0IHJlcHJlc2VudHMgZWl0aGVyOlxyXG4gKlxyXG4gKiAtIEEgY29tcGxldGUgZG9jdW1lbnQuXHJcbiAqIC0gQSBcIm5vIGRvY3VtZW50XCIgcmVwcmVzZW50aW5nIGEgZG9jdW1lbnQgdGhhdCBpcyBrbm93biBub3QgdG8gZXhpc3QgKGF0XHJcbiAqIHNvbWUgdmVyc2lvbikuXHJcbiAqIC0gQW4gXCJ1bmtub3duIGRvY3VtZW50XCIgcmVwcmVzZW50aW5nIGEgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCAoYXRcclxuICogc29tZSB2ZXJzaW9uKSBidXQgd2hvc2UgY29udGVudHMgYXJlIHVua25vd24uXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgaXMgdGhlIHBlcnNpc3RlZCBlcXVpdmFsZW50IG9mIGEgTWF5YmVEb2N1bWVudCBhbmQgY291bGQgcGVyaGFwc1xyXG4gKiBiZSBtYWRlIG1vcmUgZ2VuZXJhbCBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5jbGFzcyBEYlJlbW90ZURvY3VtZW50IHtcclxuICAgIC8vIFRPRE86IFdlIGFyZSBjdXJyZW50bHkgc3RvcmluZyBmdWxsIGRvY3VtZW50IGtleXMgYWxtb3N0IHRocmVlIHRpbWVzXHJcbiAgICAvLyAob25jZSBhcyBwYXJ0IG9mIHRoZSBwcmltYXJ5IGtleSwgb25jZSAtIHBhcnRseSAtIGFzIGBwYXJlbnRQYXRoYCBhbmQgb25jZVxyXG4gICAgLy8gaW5zaWRlIHRoZSBlbmNvZGVkIGRvY3VtZW50cykuIER1cmluZyBvdXIgbmV4dCBtaWdyYXRpb24sIHdlIHNob3VsZFxyXG4gICAgLy8gcmV3cml0ZSB0aGUgcHJpbWFyeSBrZXkgYXMgcGFyZW50UGF0aCArIGRvY3VtZW50IElEIHdoaWNoIHdvdWxkIGFsbG93IHVzXHJcbiAgICAvLyB0byBkcm9wIG9uZSB2YWx1ZS5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdG8gYW4gaW5zdGFuY2Ugb2YgRGJVbmtub3duRG9jdW1lbnQgaWYgdGhlIGRhdGEgZm9yIGEgZG9jdW1lbnQgaXNcclxuICAgICAqIG5vdCBrbm93biwgYnV0IGl0IGlzIGtub3duIHRoYXQgYSBkb2N1bWVudCBleGlzdHMgYXQgdGhlIHNwZWNpZmllZFxyXG4gICAgICogdmVyc2lvbiAoZS5nLiBpdCBoYWQgYSBzdWNjZXNzZnVsIHVwZGF0ZSBhcHBsaWVkIHRvIGl0KVxyXG4gICAgICovXHJcbiAgICB1bmtub3duRG9jdW1lbnQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdG8gYW4gaW5zdGFuY2Ugb2YgYSBEYk5vRG9jdW1lbnQgaWYgaXQgaXMga25vd24gdGhhdCBubyBkb2N1bWVudFxyXG4gICAgICogZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBub0RvY3VtZW50LCBcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRvIGFuIGluc3RhbmNlIG9mIGEgRG9jdW1lbnQgaWYgdGhlcmUncyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZVxyXG4gICAgICogZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGRvY3VtZW50LCBcclxuICAgIC8qKlxyXG4gICAgICogRG9jdW1lbnRzIHRoYXQgd2VyZSB3cml0dGVuIHRvIHRoZSByZW1vdGUgZG9jdW1lbnQgc3RvcmUgYmFzZWQgb25cclxuICAgICAqIGEgd3JpdGUgYWNrbm93bGVkZ21lbnQgYXJlIG1hcmtlZCB3aXRoIGBoYXNDb21taXR0ZWRNdXRhdGlvbnNgLiBUaGVzZVxyXG4gICAgICogZG9jdW1lbnRzIGFyZSBwb3RlbnRpYWxseSBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgYmFja2VuZCdzIGNvcHkgYW5kIHVzZVxyXG4gICAgICogdGhlIHdyaXRlJ3MgY29tbWl0IHZlcnNpb24gYXMgdGhlaXIgZG9jdW1lbnQgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgaGFzQ29tbWl0dGVkTXV0YXRpb25zLCBcclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGUgZG9jdW1lbnQgd2FzIHJlYWQgZnJvbSB0aGUgYmFja2VuZC4gVW5kZWZpbmVkIGZvciBkYXRhIHdyaXR0ZW5cclxuICAgICAqIHByaW9yIHRvIHNjaGVtYSB2ZXJzaW9uIDkuXHJcbiAgICAgKi9cclxuICAgIHJlYWRUaW1lLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhdGggb2YgdGhlIGNvbGxlY3Rpb24gdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLiBVbmRlZmluZWQgZm9yIGRhdGFcclxuICAgICAqIHdyaXR0ZW4gcHJpb3IgdG8gc2NoZW1hIHZlcnNpb24gOS5cclxuICAgICAqL1xyXG4gICAgcGFyZW50UGF0aCkge1xyXG4gICAgICAgIHRoaXMudW5rbm93bkRvY3VtZW50ID0gdW5rbm93bkRvY3VtZW50O1xyXG4gICAgICAgIHRoaXMubm9Eb2N1bWVudCA9IG5vRG9jdW1lbnQ7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgICAgIHRoaXMuaGFzQ29tbWl0dGVkTXV0YXRpb25zID0gaGFzQ29tbWl0dGVkTXV0YXRpb25zO1xyXG4gICAgICAgIHRoaXMucmVhZFRpbWUgPSByZWFkVGltZTtcclxuICAgICAgICB0aGlzLnBhcmVudFBhdGggPSBwYXJlbnRQYXRoO1xyXG4gICAgfVxyXG59XHJcbkRiUmVtb3RlRG9jdW1lbnQuc3RvcmUgPSAncmVtb3RlRG9jdW1lbnRzJztcclxuLyoqXHJcbiAqIEFuIGluZGV4IHRoYXQgcHJvdmlkZXMgYWNjZXNzIHRvIGFsbCBlbnRyaWVzIHNvcnRlZCBieSByZWFkIHRpbWUgKHdoaWNoXHJcbiAqIGNvcnJlc3BvbmRzIHRvIHRoZSBsYXN0IG1vZGlmaWNhdGlvbiB0aW1lIG9mIGVhY2ggcm93KS5cclxuICpcclxuICogVGhpcyBpbmRleCBpcyB1c2VkIHRvIHByb3ZpZGUgYSBjaGFuZ2Vsb2cgZm9yIE11bHRpLVRhYi5cclxuICovXHJcbkRiUmVtb3RlRG9jdW1lbnQucmVhZFRpbWVJbmRleCA9ICdyZWFkVGltZUluZGV4JztcclxuRGJSZW1vdGVEb2N1bWVudC5yZWFkVGltZUluZGV4UGF0aCA9ICdyZWFkVGltZSc7XHJcbi8qKlxyXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgaW4gYSBjb2xsZWN0aW9uIHNvcnRlZCBieSByZWFkXHJcbiAqIHRpbWUuXHJcbiAqXHJcbiAqIFRoaXMgaW5kZXggaXMgdXNlZCB0byBhbGxvdyB0aGUgUmVtb3RlRG9jdW1lbnRDYWNoZSB0byBmZXRjaCBuZXdseSBjaGFuZ2VkXHJcbiAqIGRvY3VtZW50cyBpbiBhIGNvbGxlY3Rpb24uXHJcbiAqL1xyXG5EYlJlbW90ZURvY3VtZW50LmNvbGxlY3Rpb25SZWFkVGltZUluZGV4ID0gJ2NvbGxlY3Rpb25SZWFkVGltZUluZGV4JztcclxuRGJSZW1vdGVEb2N1bWVudC5jb2xsZWN0aW9uUmVhZFRpbWVJbmRleFBhdGggPSBbJ3BhcmVudFBhdGgnLCAncmVhZFRpbWUnXTtcclxuLyoqXHJcbiAqIENvbnRhaW5zIGEgc2luZ2xlIGVudHJ5IHRoYXQgaGFzIG1ldGFkYXRhIGFib3V0IHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGUuXHJcbiAqL1xyXG5jbGFzcyBEYlJlbW90ZURvY3VtZW50R2xvYmFsIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIC0gQXBwcm94aW1hdGVseSB0aGUgdG90YWwgc2l6ZSBpbiBieXRlcyBvZiBhbGwgdGhlXHJcbiAgICAgKiBkb2N1bWVudHMgaW4gdGhlIGRvY3VtZW50IGNhY2hlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihieXRlU2l6ZSkge1xyXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSBieXRlU2l6ZTtcclxuICAgIH1cclxufVxyXG5EYlJlbW90ZURvY3VtZW50R2xvYmFsLnN0b3JlID0gJ3JlbW90ZURvY3VtZW50R2xvYmFsJztcclxuRGJSZW1vdGVEb2N1bWVudEdsb2JhbC5rZXkgPSAncmVtb3RlRG9jdW1lbnRHbG9iYWxLZXknO1xyXG4vKipcclxuICogQW4gb2JqZWN0IHRvIGJlIHN0b3JlZCBpbiB0aGUgJ3RhcmdldHMnIHN0b3JlIGluIEluZGV4ZWREYi5cclxuICpcclxuICogVGhpcyBpcyBiYXNlZCBvbiBhbmQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBwcm90byB1c2VkIGluIHRoZSBpT1NcclxuICogY2xpZW50LlxyXG4gKlxyXG4gKiBFYWNoIHF1ZXJ5IHRoZSBjbGllbnQgbGlzdGVucyB0byBhZ2FpbnN0IHRoZSBzZXJ2ZXIgaXMgdHJhY2tlZCBvbiBkaXNrIHNvXHJcbiAqIHRoYXQgdGhlIHF1ZXJ5IGNhbiBiZSBlZmZpY2llbnRseSByZXN1bWVkIG9uIHJlc3RhcnQuXHJcbiAqL1xyXG5jbGFzcyBEYlRhcmdldCB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogQW4gYXV0by1nZW5lcmF0ZWQgc2VxdWVudGlhbCBudW1lcmljIGlkZW50aWZpZXIgZm9yIHRoZSBxdWVyeS5cclxuICAgICAqXHJcbiAgICAgKiBRdWVyaWVzIGFyZSBzdG9yZWQgdXNpbmcgdGhlaXIgY2Fub25pY2FsSWQgYXMgdGhlIGtleSwgYnV0IHRoZXNlXHJcbiAgICAgKiBjYW5vbmljYWxJZHMgY2FuIGJlIHF1aXRlIGxvbmcgc28gd2UgYWRkaXRpb25hbGx5IGFzc2lnbiBhIHVuaXF1ZVxyXG4gICAgICogcXVlcnlJZCB3aGljaCBjYW4gYmUgdXNlZCBieSByZWZlcmVuY2VkIGRhdGEgc3RydWN0dXJlcyAoZS5nLlxyXG4gICAgICogaW5kZXhlcykgdG8gbWluaW1pemUgdGhlIG9uLWRpc2sgY29zdC5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0SWQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2Fub25pY2FsIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBxdWVyeS4gVGhpcyBpcyBub3QgdW5pcXVlLlxyXG4gICAgICovXHJcbiAgICBjYW5vbmljYWxJZCwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYXN0IHJlYWRUaW1lIHJlY2VpdmVkIGZyb20gdGhlIFdhdGNoIFNlcnZpY2UgZm9yIHRoaXMgcXVlcnkuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyB0aGUgc2FtZSB2YWx1ZSBhcyBUYXJnZXRDaGFuZ2UucmVhZF90aW1lIGluIHRoZSBwcm90b3MuXHJcbiAgICAgKi9cclxuICAgIHJlYWRUaW1lLCBcclxuICAgIC8qKlxyXG4gICAgICogQW4gb3BhcXVlLCBzZXJ2ZXItYXNzaWduZWQgdG9rZW4gdGhhdCBhbGxvd3Mgd2F0Y2hpbmcgYSBxdWVyeSB0byBiZVxyXG4gICAgICogcmVzdW1lZCBhZnRlciBkaXNjb25uZWN0aW5nIHdpdGhvdXQgcmV0cmFuc21pdHRpbmcgYWxsIHRoZSBkYXRhXHJcbiAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5LiBUaGUgcmVzdW1lIHRva2VuIGVzc2VudGlhbGx5IGlkZW50aWZpZXMgYVxyXG4gICAgICogcG9pbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBzZXJ2ZXIgc2hvdWxkIHJlc3VtZSBzZW5kaW5nIHJlc3VsdHMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBpcyByZWxhdGVkIHRvIHRoZSBzbmFwc2hvdFZlcnNpb24gaW4gdGhhdCB0aGUgcmVzdW1lVG9rZW5cclxuICAgICAqIGVmZmVjdGl2ZWx5IGFsc28gZW5jb2RlcyB0aGF0IHZhbHVlLCBidXQgdGhlIHJlc3VtZVRva2VuIGlzIG9wYXF1ZVxyXG4gICAgICogYW5kIHNvbWV0aW1lcyBlbmNvZGVzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQSBjb25zZXF1ZW5jZSBvZiB0aGlzIGlzIHRoYXQgdGhlIHJlc3VtZVRva2VuIHNob3VsZCBiZSB1c2VkIHdoZW5cclxuICAgICAqIGFza2luZyB0aGUgc2VydmVyIHRvIHJlYXNvbiBhYm91dCB3aGVyZSB0aGlzIGNsaWVudCBpcyBpbiB0aGUgd2F0Y2hcclxuICAgICAqIHN0cmVhbSwgYnV0IHRoZSBjbGllbnQgc2hvdWxkIHVzZSB0aGUgc25hcHNob3RWZXJzaW9uIGZvciBpdHMgb3duXHJcbiAgICAgKiBwdXJwb3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBzYW1lIHZhbHVlIGFzIFRhcmdldENoYW5nZS5yZXN1bWVfdG9rZW4gaW4gdGhlIHByb3Rvcy5cclxuICAgICAqL1xyXG4gICAgcmVzdW1lVG9rZW4sIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNlcXVlbmNlIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGxhc3QgdGltZSB0aGlzIHF1ZXJ5IHdhc1xyXG4gICAgICogbGlzdGVuZWQgdG8sIHVzZWQgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBwdXJwb3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBDb252ZW50aW9uYWxseSB0aGlzIHdvdWxkIGJlIGEgdGltZXN0YW1wIHZhbHVlLCBidXQgZGV2aWNlLWxvY2FsXHJcbiAgICAgKiBjbG9ja3MgYXJlIHVucmVsaWFibGUgYW5kIHRoZXkgbXVzdCBiZSBhYmxlIHRvIGNyZWF0ZSBuZXcgbGlzdGVuc1xyXG4gICAgICogZXZlbiB3aGlsZSBkaXNjb25uZWN0ZWQuIEluc3RlYWQgdGhpcyBzaG91bGQgYmUgYSBtb25vdG9uaWNhbGx5XHJcbiAgICAgKiBpbmNyZWFzaW5nIG51bWJlciB0aGF0J3MgaW5jcmVtZW50ZWQgb24gZWFjaCBsaXN0ZW4gY2FsbC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBxdWVyeUlkIHNpbmNlIHRoZSBxdWVyeUlkIGlzIGFuXHJcbiAgICAgKiBpbW11dGFibGUgaWRlbnRpZmllciBhc3NpZ25lZCB0byB0aGUgUXVlcnkgb24gZmlyc3QgdXNlIHdoaWxlXHJcbiAgICAgKiBsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgaXMgdXBkYXRlZCBldmVyeSB0aW1lIHRoZSBxdWVyeSBpc1xyXG4gICAgICogbGlzdGVuZWQgdG8uXHJcbiAgICAgKi9cclxuICAgIGxhc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgXHJcbiAgICAvKipcclxuICAgICAqIERlbm90ZXMgdGhlIG1heGltdW0gc25hcHNob3QgdmVyc2lvbiBhdCB3aGljaCB0aGUgYXNzb2NpYXRlZCBxdWVyeSB2aWV3XHJcbiAgICAgKiBjb250YWluZWQgbm8gbGltYm8gZG9jdW1lbnRzLiAgVW5kZWZpbmVkIGZvciBkYXRhIHdyaXR0ZW4gcHJpb3IgdG9cclxuICAgICAqIHNjaGVtYSB2ZXJzaW9uIDkuXHJcbiAgICAgKi9cclxuICAgIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcXVlcnkgZm9yIHRoaXMgdGFyZ2V0LlxyXG4gICAgICpcclxuICAgICAqIEJlY2F1c2UgY2Fub25pY2FsIGlkcyBhcmUgbm90IHVuaXF1ZSB3ZSBtdXN0IHN0b3JlIHRoZSBhY3R1YWwgcXVlcnkuIFdlXHJcbiAgICAgKiB1c2UgdGhlIHByb3RvIHRvIGhhdmUgYW4gb2JqZWN0IHdlIGNhbiBwZXJzaXN0IHdpdGhvdXQgaGF2aW5nIHRvXHJcbiAgICAgKiBkdXBsaWNhdGUgdHJhbnNsYXRpb24gbG9naWMgdG8gYW5kIGZyb20gYSBgUXVlcnlgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcXVlcnkpIHtcclxuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgdGhpcy5jYW5vbmljYWxJZCA9IGNhbm9uaWNhbElkO1xyXG4gICAgICAgIHRoaXMucmVhZFRpbWUgPSByZWFkVGltZTtcclxuICAgICAgICB0aGlzLnJlc3VtZVRva2VuID0gcmVzdW1lVG9rZW47XHJcbiAgICAgICAgdGhpcy5sYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSBsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID0gbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbjtcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICB9XHJcbn1cclxuRGJUYXJnZXQuc3RvcmUgPSAndGFyZ2V0cyc7XHJcbi8qKiBLZXlzIGFyZSBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHZpYSB0aGUgdGFyZ2V0SWQgcHJvcGVydHkuICovXHJcbkRiVGFyZ2V0LmtleVBhdGggPSAndGFyZ2V0SWQnO1xyXG4vKiogVGhlIG5hbWUgb2YgdGhlIHF1ZXJ5VGFyZ2V0cyBpbmRleC4gKi9cclxuRGJUYXJnZXQucXVlcnlUYXJnZXRzSW5kZXhOYW1lID0gJ3F1ZXJ5VGFyZ2V0c0luZGV4JztcclxuLyoqXHJcbiAqIFRoZSBpbmRleCBvZiBhbGwgY2Fub25pY2FsSWRzIHRvIHRoZSB0YXJnZXRzIHRoYXQgdGhleSBtYXRjaC4gVGhpcyBpcyBub3RcclxuICogYSB1bmlxdWUgbWFwcGluZyBiZWNhdXNlIGNhbm9uaWNhbElkIGRvZXMgbm90IHByb21pc2UgYSB1bmlxdWUgbmFtZSBmb3IgYWxsXHJcbiAqIHBvc3NpYmxlIHF1ZXJpZXMsIHNvIHdlIGFwcGVuZCB0aGUgdGFyZ2V0SWQgdG8gbWFrZSB0aGUgbWFwcGluZyB1bmlxdWUuXHJcbiAqL1xyXG5EYlRhcmdldC5xdWVyeVRhcmdldHNLZXlQYXRoID0gWydjYW5vbmljYWxJZCcsICd0YXJnZXRJZCddO1xyXG4vKipcclxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhbiBhc3NvY2lhdGlvbiBiZXR3ZWVuIGEgdGFyZ2V0IGFuZCBhIGRvY3VtZW50LCBvciBhXHJcbiAqIHNlbnRpbmVsIHJvdyBtYXJraW5nIHRoZSBsYXN0IHNlcXVlbmNlIG51bWJlciBhdCB3aGljaCBhIGRvY3VtZW50IHdhcyB1c2VkLlxyXG4gKiBFYWNoIGRvY3VtZW50IGNhY2hlZCBtdXN0IGhhdmUgYSBjb3JyZXNwb25kaW5nIHNlbnRpbmVsIHJvdyBiZWZvcmUgbHJ1XHJcbiAqIGdhcmJhZ2UgY29sbGVjdGlvbiBpcyBlbmFibGVkLlxyXG4gKlxyXG4gKiBUaGUgdGFyZ2V0IGFzc29jaWF0aW9ucyBhbmQgc2VudGluZWwgcm93cyBhcmUgY28tbG9jYXRlZCBzbyB0aGF0IG9ycGhhbmVkXHJcbiAqIGRvY3VtZW50cyBhbmQgdGhlaXIgc2VxdWVuY2UgbnVtYmVycyBjYW4gYmUgaWRlbnRpZmllZCBlZmZpY2llbnRseSB2aWEgYSBzY2FuXHJcbiAqIG9mIHRoaXMgc3RvcmUuXHJcbiAqL1xyXG5jbGFzcyBEYlRhcmdldERvY3VtZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGFyZ2V0SWQgaWRlbnRpZnlpbmcgYSB0YXJnZXQgb3IgMCBmb3IgYSBzZW50aW5lbCByb3cuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldElkLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhdGggdG8gdGhlIGRvY3VtZW50LCBhcyBlbmNvZGVkIGluIHRoZSBrZXkuXHJcbiAgICAgKi9cclxuICAgIHBhdGgsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGlzIGlzIGEgc2VudGluZWwgcm93LCB0aGlzIHNob3VsZCBiZSB0aGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBsYXN0XHJcbiAgICAgKiB0aW1lIHRoZSBkb2N1bWVudCBzcGVjaWZpZWQgYnkgYHBhdGhgIHdhcyB1c2VkLiBPdGhlcndpc2UsIGl0IHNob3VsZCBiZVxyXG4gICAgICogYHVuZGVmaW5lZGAuXHJcbiAgICAgKi9cclxuICAgIHNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXRJZCA9IHRhcmdldElkO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xyXG4gICAgfVxyXG59XHJcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAgKi9cclxuRGJUYXJnZXREb2N1bWVudC5zdG9yZSA9ICd0YXJnZXREb2N1bWVudHMnO1xyXG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIHRhcmdldElkLCBwYXRoIHByb3BlcnRpZXMuICovXHJcbkRiVGFyZ2V0RG9jdW1lbnQua2V5UGF0aCA9IFsndGFyZ2V0SWQnLCAncGF0aCddO1xyXG4vKiogVGhlIGluZGV4IG5hbWUgZm9yIHRoZSByZXZlcnNlIGluZGV4LiAqL1xyXG5EYlRhcmdldERvY3VtZW50LmRvY3VtZW50VGFyZ2V0c0luZGV4ID0gJ2RvY3VtZW50VGFyZ2V0c0luZGV4JztcclxuLyoqIFdlIGFsc28gbmVlZCB0byBjcmVhdGUgdGhlIHJldmVyc2UgaW5kZXggZm9yIHRoZXNlIHByb3BlcnRpZXMuICovXHJcbkRiVGFyZ2V0RG9jdW1lbnQuZG9jdW1lbnRUYXJnZXRzS2V5UGF0aCA9IFsncGF0aCcsICd0YXJnZXRJZCddO1xyXG4vKipcclxuICogQSByZWNvcmQgb2YgZ2xvYmFsIHN0YXRlIHRyYWNrZWQgYWNyb3NzIGFsbCBUYXJnZXRzLCB0cmFja2VkIHNlcGFyYXRlbHlcclxuICogdG8gYXZvaWQgdGhlIG5lZWQgZm9yIGV4dHJhIGluZGV4ZXMuXHJcbiAqXHJcbiAqIFRoaXMgc2hvdWxkIGJlIGtlcHQgaW4tc3luYyB3aXRoIHRoZSBwcm90byB1c2VkIGluIHRoZSBpT1MgY2xpZW50LlxyXG4gKi9cclxuY2xhc3MgRGJUYXJnZXRHbG9iYWwge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaWdoZXN0IG51bWJlcmVkIHRhcmdldCBpZCBhY3Jvc3MgYWxsIHRhcmdldHMuXHJcbiAgICAgKlxyXG4gICAgICogU2VlIERiVGFyZ2V0LnRhcmdldElkLlxyXG4gICAgICovXHJcbiAgICBoaWdoZXN0VGFyZ2V0SWQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGlnaGVzdCBudW1iZXJlZCBsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgYWNyb3NzIGFsbCB0YXJnZXRzLlxyXG4gICAgICpcclxuICAgICAqIFNlZSBEYlRhcmdldC5sYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgXHJcbiAgICAvKipcclxuICAgICAqIEEgZ2xvYmFsIHNuYXBzaG90IHZlcnNpb24gcmVwcmVzZW50aW5nIHRoZSBsYXN0IGNvbnNpc3RlbnQgc25hcHNob3Qgd2VcclxuICAgICAqIHJlY2VpdmVkIGZyb20gdGhlIGJhY2tlbmQuIFRoaXMgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIGFuZCBhbnlcclxuICAgICAqIHNuYXBzaG90cyByZWNlaXZlZCBmcm9tIHRoZSBiYWNrZW5kIHByaW9yIHRvIHRoaXMgdmVyc2lvbiAoZS5nLiBmb3JcclxuICAgICAqIHRhcmdldHMgcmVzdW1lZCB3aXRoIGEgcmVzdW1lVG9rZW4pIHNob3VsZCBiZSBzdXBwcmVzc2VkIChidWZmZXJlZClcclxuICAgICAqIHVudGlsIHRoZSBiYWNrZW5kIGhhcyBjYXVnaHQgdXAgdG8gdGhpcyBzbmFwc2hvdCB2ZXJzaW9uIGFnYWluLiBUaGlzXHJcbiAgICAgKiBwcmV2ZW50cyBvdXIgY2FjaGUgZnJvbSBldmVyIGdvaW5nIGJhY2t3YXJkcyBpbiB0aW1lLlxyXG4gICAgICovXHJcbiAgICBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB0YXJnZXRzIHBlcnNpc3RlZC5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0Q291bnQpIHtcclxuICAgICAgICB0aGlzLmhpZ2hlc3RUYXJnZXRJZCA9IGhpZ2hlc3RUYXJnZXRJZDtcclxuICAgICAgICB0aGlzLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA9IGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcjtcclxuICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0Q291bnQgPSB0YXJnZXRDb3VudDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGtleSBzdHJpbmcgdXNlZCBmb3IgdGhlIHNpbmdsZSBvYmplY3QgdGhhdCBleGlzdHMgaW4gdGhlXHJcbiAqIERiVGFyZ2V0R2xvYmFsIHN0b3JlLlxyXG4gKi9cclxuRGJUYXJnZXRHbG9iYWwua2V5ID0gJ3RhcmdldEdsb2JhbEtleSc7XHJcbkRiVGFyZ2V0R2xvYmFsLnN0b3JlID0gJ3RhcmdldEdsb2JhbCc7XHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGFuIGFzc29jaWF0aW9uIGJldHdlZW4gYSBDb2xsZWN0aW9uIGlkIChlLmcuICdtZXNzYWdlcycpXHJcbiAqIHRvIGEgcGFyZW50IHBhdGggKGUuZy4gJy9jaGF0cy8xMjMnKSB0aGF0IGNvbnRhaW5zIGl0IGFzIGEgKHN1Yiljb2xsZWN0aW9uLlxyXG4gKiBUaGlzIGlzIHVzZWQgdG8gZWZmaWNpZW50bHkgZmluZCBhbGwgY29sbGVjdGlvbnMgdG8gcXVlcnkgd2hlbiBwZXJmb3JtaW5nXHJcbiAqIGEgQ29sbGVjdGlvbiBHcm91cCBxdWVyeS5cclxuICovXHJcbmNsYXNzIERiQ29sbGVjdGlvblBhcmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbGxlY3Rpb25JZCAoZS5nLiAnbWVzc2FnZXMnKVxyXG4gICAgICovXHJcbiAgICBjb2xsZWN0aW9uSWQsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgcGFyZW50IChlaXRoZXIgYSBkb2N1bWVudCBsb2NhdGlvbiBvciBhbiBlbXB0eSBwYXRoIGZvclxyXG4gICAgICogYSByb290LWxldmVsIGNvbGxlY3Rpb24pLlxyXG4gICAgICovXHJcbiAgICBwYXJlbnQpIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25JZCA9IGNvbGxlY3Rpb25JZDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgIH1cclxufVxyXG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cclxuRGJDb2xsZWN0aW9uUGFyZW50LnN0b3JlID0gJ2NvbGxlY3Rpb25QYXJlbnRzJztcclxuLyoqIEtleXMgYXJlIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdmlhIHRoZSBjb2xsZWN0aW9uSWQsIHBhcmVudCBwcm9wZXJ0aWVzLiAqL1xyXG5EYkNvbGxlY3Rpb25QYXJlbnQua2V5UGF0aCA9IFsnY29sbGVjdGlvbklkJywgJ3BhcmVudCddO1xyXG4vKipcclxuICogQSByZWNvcmQgb2YgdGhlIG1ldGFkYXRhIHN0YXRlIG9mIGVhY2ggY2xpZW50LlxyXG4gKlxyXG4gKiBQT1JUSU5HIE5PVEU6IFRoaXMgaXMgdXNlZCB0byBzeW5jaHJvbml6ZSBtdWx0aS10YWIgc3RhdGUgYW5kIGRvZXMgbm90IG5lZWRcclxuICogdG8gYmUgcG9ydGVkIHRvIGlPUyBvciBBbmRyb2lkLlxyXG4gKi9cclxuY2xhc3MgRGJDbGllbnRNZXRhZGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8vIE5vdGU6IFByZXZpb3VzIHNjaGVtYSB2ZXJzaW9ucyBpbmNsdWRlZCBhIGZpZWxkXHJcbiAgICAvLyBcImxhc3RQcm9jZXNzZWREb2N1bWVudENoYW5nZUlkXCIuIERvbid0IHVzZSBhbnltb3JlLlxyXG4gICAgLyoqIFRoZSBhdXRvLWdlbmVyYXRlZCBjbGllbnQgaWQgYXNzaWduZWQgYXQgY2xpZW50IHN0YXJ0dXAuICovXHJcbiAgICBjbGllbnRJZCwgXHJcbiAgICAvKiogVGhlIGxhc3QgdGltZSB0aGlzIHN0YXRlIHdhcyB1cGRhdGVkLiAqL1xyXG4gICAgdXBkYXRlVGltZU1zLCBcclxuICAgIC8qKiBXaGV0aGVyIHRoZSBjbGllbnQncyBuZXR3b3JrIGNvbm5lY3Rpb24gaXMgZW5hYmxlZC4gKi9cclxuICAgIG5ldHdvcmtFbmFibGVkLCBcclxuICAgIC8qKiBXaGV0aGVyIHRoaXMgY2xpZW50IGlzIHJ1bm5pbmcgaW4gYSBmb3JlZ3JvdW5kIHRhYi4gKi9cclxuICAgIGluRm9yZWdyb3VuZCkge1xyXG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVNcyA9IHVwZGF0ZVRpbWVNcztcclxuICAgICAgICB0aGlzLm5ldHdvcmtFbmFibGVkID0gbmV0d29ya0VuYWJsZWQ7XHJcbiAgICAgICAgdGhpcy5pbkZvcmVncm91bmQgPSBpbkZvcmVncm91bmQ7XHJcbiAgICB9XHJcbn1cclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbkRiQ2xpZW50TWV0YWRhdGEuc3RvcmUgPSAnY2xpZW50TWV0YWRhdGEnO1xyXG4vKiogS2V5cyBhcmUgYXV0b21hdGljYWxseSBhc3NpZ25lZCB2aWEgdGhlIGNsaWVudElkIHByb3BlcnRpZXMuICovXHJcbkRiQ2xpZW50TWV0YWRhdGEua2V5UGF0aCA9ICdjbGllbnRJZCc7XHJcbi8qKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgYnVuZGxlIGxvYWRlZCBieSB0aGUgU0RLLiAqL1xyXG5jbGFzcyBEYkJ1bmRsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgSUQgb2YgdGhlIGxvYWRlZCBidW5kbGUuICovXHJcbiAgICBidW5kbGVJZCwgXHJcbiAgICAvKiogVGhlIGNyZWF0ZSB0aW1lIG9mIHRoZSBsb2FkZWQgYnVuZGxlLiAqL1xyXG4gICAgY3JlYXRlVGltZSwgXHJcbiAgICAvKiogVGhlIHNjaGVtYSB2ZXJzaW9uIG9mIHRoZSBsb2FkZWQgYnVuZGxlLiAqL1xyXG4gICAgdmVyc2lvbikge1xyXG4gICAgICAgIHRoaXMuYnVuZGxlSWQgPSBidW5kbGVJZDtcclxuICAgICAgICB0aGlzLmNyZWF0ZVRpbWUgPSBjcmVhdGVUaW1lO1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB9XHJcbn1cclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbkRiQnVuZGxlLnN0b3JlID0gJ2J1bmRsZXMnO1xyXG5EYkJ1bmRsZS5rZXlQYXRoID0gJ2J1bmRsZUlkJztcclxuLyoqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBuYW1lZCBxdWVyeSBsb2FkZWQgYnkgdGhlIFNESyB2aWEgYSBidW5kbGUuICovXHJcbmNsYXNzIERiTmFtZWRRdWVyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgcXVlcnkuICovXHJcbiAgICBuYW1lLCBcclxuICAgIC8qKiBUaGUgcmVhZCB0aW1lIG9mIHRoZSByZXN1bHRzIHNhdmVkIGluIHRoZSBidW5kbGUgZnJvbSB0aGUgbmFtZWQgcXVlcnkuICovXHJcbiAgICByZWFkVGltZSwgXHJcbiAgICAvKiogVGhlIHF1ZXJ5IHNhdmVkIGluIHRoZSBidW5kbGUuICovXHJcbiAgICBidW5kbGVkUXVlcnkpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucmVhZFRpbWUgPSByZWFkVGltZTtcclxuICAgICAgICB0aGlzLmJ1bmRsZWRRdWVyeSA9IGJ1bmRsZWRRdWVyeTtcclxuICAgIH1cclxufVxyXG4vKiogTmFtZSBvZiB0aGUgSW5kZXhlZERiIG9iamVjdCBzdG9yZS4gKi9cclxuRGJOYW1lZFF1ZXJ5LnN0b3JlID0gJ25hbWVkUXVlcmllcyc7XHJcbkRiTmFtZWRRdWVyeS5rZXlQYXRoID0gJ25hbWUnO1xyXG4vKiogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yIGEgZmllbGQgaW5kZXguICovXHJcbmNsYXNzIERiSW5kZXhDb25maWd1cmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW5kZXggaWQgZm9yIHRoaXMgZW50cnkuIFVuZGVmaW5lZCBmb3IgaW5kZXhlcyB0aGF0IGFyZSBub3QgeWV0XHJcbiAgICAgKiBwZXJzaXN0ZWQuXHJcbiAgICAgKi9cclxuICAgIGluZGV4SWQsIFxyXG4gICAgLyoqIFRoZSBjb2xsZWN0aW9uIGdyb3VwIHRoaXMgaW5kZXggYmVsb25ncyB0by4gKi9cclxuICAgIGNvbGxlY3Rpb25Hcm91cCwgXHJcbiAgICAvKiogVGhlIGZpZWxkcyB0byBpbmRleCBmb3IgdGhpcyBpbmRleC4gKi9cclxuICAgIGZpZWxkcykge1xyXG4gICAgICAgIHRoaXMuaW5kZXhJZCA9IGluZGV4SWQ7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XHJcbiAgICB9XHJcbn1cclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbkRiSW5kZXhDb25maWd1cmF0aW9uLnN0b3JlID0gJ2luZGV4Q29uZmlndXJhdGlvbic7XHJcbkRiSW5kZXhDb25maWd1cmF0aW9uLmtleVBhdGggPSAnaW5kZXhJZCc7XHJcbi8qKlxyXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgaW5kZXggY29uZmlndXJhdGlvbnMgYnkgY29sbGVjdGlvblxyXG4gKiBncm91cC5cclxuICpcclxuICogUE9SVElORyBOT1RFOiBpT1MgYW5kIEFuZHJvaWQgbWFpbnRhaW4gdGhpcyBpbmRleCBpbi1tZW1vcnksIGJ1dCB0aGlzIGlzXHJcbiAqIG5vdCBwb3NzaWJsZSBoZXJlIGFzIHRoZSBXZWIgY2xpZW50IHN1cHBvcnRzIGNvbmN1cnJlbnQgYWNjZXNzIHRvXHJcbiAqIHBlcnNpc3RlbmNlIHZpYSBtdWx0aS10YWIuXHJcbiAqL1xyXG5EYkluZGV4Q29uZmlndXJhdGlvbi5jb2xsZWN0aW9uR3JvdXBJbmRleCA9ICdjb2xsZWN0aW9uR3JvdXBJbmRleCc7XHJcbkRiSW5kZXhDb25maWd1cmF0aW9uLmNvbGxlY3Rpb25Hcm91cEluZGV4UGF0aCA9ICdjb2xsZWN0aW9uR3JvdXAnO1xyXG4vKipcclxuICogQW4gb2JqZWN0IGRlc2NyaWJpbmcgaG93IHVwLXRvLWRhdGUgdGhlIGluZGV4IGJhY2tmaWxsIGlzIGZvciBlYWNoIHVzZXIgYW5kXHJcbiAqIGluZGV4LlxyXG4gKi9cclxuY2xhc3MgRGJJbmRleFN0YXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSBpbmRleCBpZCBmb3IgdGhpcyBlbnRyeS4gKi9cclxuICAgIGluZGV4SWQsIFxyXG4gICAgLyoqIFRoZSB1c2VyIGlkIGZvciB0aGlzIGVudHJ5LiAqL1xyXG4gICAgdWlkLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBudW1iZXIgdGhhdCBpbmRpY2F0ZXMgd2hlbiB0aGUgaW5kZXggd2FzIGxhc3QgdXBkYXRlZCAocmVsYXRpdmUgdG9cclxuICAgICAqIG90aGVyIGluZGV4ZXMpLlxyXG4gICAgICovXHJcbiAgICBzZXF1ZW5jZU51bWJlciwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsYXRlc3QgcmVhZCB0aW1lIHRoYXQgaGFzIGJlZW4gaW5kZXhlZCBieSBGaXJlc3RvcmUgZm9yIHRoaXMgZmllbGRcclxuICAgICAqIGluZGV4LiBTZXQgdG8gYHtzZWNvbmRzOiAwLCBuYW5vczogMH1gIGlmIG5vIGRvY3VtZW50cyBoYXZlIGJlZW4gaW5kZXhlZC5cclxuICAgICAqL1xyXG4gICAgcmVhZFRpbWUsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFzdCBkb2N1bWVudCB0aGF0IGhhcyBiZWVuIGluZGV4ZWQgZm9yIHRoaXMgZmllbGQgaW5kZXguIEVtcHR5IGlmXHJcbiAgICAgKiBubyBkb2N1bWVudHMgaGF2ZSBiZWVuIGluZGV4ZWQuXHJcbiAgICAgKi9cclxuICAgIGRvY3VtZW50S2V5LCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxhcmdlc3QgbXV0YXRpb24gYmF0Y2ggaWQgdGhhdCBoYXMgYmVlbiBwcm9jZXNzZWQgZm9yIHRoaXMgaW5kZXguIC0xXHJcbiAgICAgKiBpZiBubyBtdXRhdGlvbnMgaGF2ZSBiZWVuIGluZGV4ZWQuXHJcbiAgICAgKi9cclxuICAgIGxhcmdlc3RCYXRjaElkKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleElkID0gaW5kZXhJZDtcclxuICAgICAgICB0aGlzLnVpZCA9IHVpZDtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgdGhpcy5yZWFkVGltZSA9IHJlYWRUaW1lO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRLZXkgPSBkb2N1bWVudEtleTtcclxuICAgICAgICB0aGlzLmxhcmdlc3RCYXRjaElkID0gbGFyZ2VzdEJhdGNoSWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqIE5hbWUgb2YgdGhlIEluZGV4ZWREYiBvYmplY3Qgc3RvcmUuICovXHJcbkRiSW5kZXhTdGF0ZS5zdG9yZSA9ICdpbmRleFN0YXRlJztcclxuRGJJbmRleFN0YXRlLmtleVBhdGggPSBbJ2luZGV4SWQnLCAndWlkJ107XHJcbi8qKlxyXG4gKiBBbiBpbmRleCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byBkb2N1bWVudHMgaW4gYSBjb2xsZWN0aW9uIHNvcnRlZCBieSBsYXN0XHJcbiAqIHVwZGF0ZSB0aW1lLiBVc2VkIGJ5IHRoZSBiYWNrZmlsbGVyLlxyXG4gKlxyXG4gKiBQT1JUSU5HIE5PVEU6IGlPUyBhbmQgQW5kcm9pZCBtYWludGFpbiB0aGlzIGluZGV4IGluLW1lbW9yeSwgYnV0IHRoaXMgaXNcclxuICogbm90IHBvc3NpYmxlIGhlcmUgYXMgdGhlIFdlYiBjbGllbnQgc3VwcG9ydHMgY29uY3VycmVudCBhY2Nlc3MgdG9cclxuICogcGVyc2lzdGVuY2UgdmlhIG11bHRpLXRhYi5cclxuICovXHJcbkRiSW5kZXhTdGF0ZS5zZXF1ZW5jZU51bWJlckluZGV4ID0gJ3NlcXVlbmNlTnVtYmVySW5kZXgnO1xyXG5EYkluZGV4U3RhdGUuc2VxdWVuY2VOdW1iZXJJbmRleFBhdGggPSBbJ3VpZCcsICdzZXF1ZW5jZU51bWJlciddO1xyXG4vKiogQW4gb2JqZWN0IHRoYXQgc3RvcmVzIHRoZSBlbmNvZGVkIGVudHJpZXMgZm9yIGFsbCBkb2N1bWVudHMgYW5kIGZpZWxkcy4gKi9cclxuY2xhc3MgRGJJbmRleEVudHJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSBpbmRleCBpZCBmb3IgdGhpcyBlbnRyeS4gKi9cclxuICAgIGluZGV4SWQsIFxyXG4gICAgLyoqIFRoZSB1c2VyIGlkIGZvciB0aGlzIGVudHJ5LiAqL1xyXG4gICAgdWlkLCBcclxuICAgIC8qKiBUaGUgZW5jb2RlZCBhcnJheSBpbmRleCB2YWx1ZSBmb3IgdGhpcyBlbnRyeS4gKi9cclxuICAgIGFycmF5VmFsdWUsIFxyXG4gICAgLyoqIFRoZSBlbmNvZGVkIGRpcmVjdGlvbmFsIHZhbHVlIGZvciBlcXVhbGl0eSBhbmQgaW5lcXVhbGl0eSBmaWx0ZXJzLiAqL1xyXG4gICAgZGlyZWN0aW9uYWxWYWx1ZSwgXHJcbiAgICAvKiogVGhlIGRvY3VtZW50IGtleSB0aGlzIGVudHJ5IHBvaW50cyB0by4gKi9cclxuICAgIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgdGhpcy5pbmRleElkID0gaW5kZXhJZDtcclxuICAgICAgICB0aGlzLnVpZCA9IHVpZDtcclxuICAgICAgICB0aGlzLmFycmF5VmFsdWUgPSBhcnJheVZhbHVlO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uYWxWYWx1ZSA9IGRpcmVjdGlvbmFsVmFsdWU7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudEtleSA9IGRvY3VtZW50S2V5O1xyXG4gICAgfVxyXG59XHJcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xyXG5EYkluZGV4RW50cnkuc3RvcmUgPSAnaW5kZXhFbnRyaWVzJztcclxuRGJJbmRleEVudHJ5LmtleVBhdGggPSBbXHJcbiAgICAnaW5kZXhJZCcsXHJcbiAgICAndWlkJyxcclxuICAgICdhcnJheVZhbHVlJyxcclxuICAgICdkaXJlY3Rpb25hbFZhbHVlJyxcclxuICAgICdkb2N1bWVudEtleSdcclxuXTtcclxuRGJJbmRleEVudHJ5LmRvY3VtZW50S2V5SW5kZXggPSAnZG9jdW1lbnRLZXlJbmRleCc7XHJcbkRiSW5kZXhFbnRyeS5kb2N1bWVudEtleUluZGV4UGF0aCA9IFsnaW5kZXhJZCcsICd1aWQnLCAnZG9jdW1lbnRLZXknXTtcclxuLyoqXHJcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBkb2N1bWVudCBvdmVybGF5LlxyXG4gKi9cclxuY2xhc3MgRGJEb2N1bWVudE92ZXJsYXkge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIHVzZXIgSUQgdG8gd2hvbSB0aGlzIG92ZXJsYXkgYmVsb25ncy4gKi9cclxuICAgIHVzZXJJZCwgXHJcbiAgICAvKiogVGhlIHBhdGggdG8gdGhlIGNvbGxlY3Rpb24gdGhhdCBjb250YWlucyB0aGUgZG9jdW1lbnQuICovXHJcbiAgICBjb2xsZWN0aW9uUGF0aCwgXHJcbiAgICAvKiogVGhlIElEIChrZXkpIG9mIHRoZSBkb2N1bWVudCB3aXRoaW4gdGhlIGNvbGxlY3Rpb24uICovXHJcbiAgICBkb2N1bWVudElkLCBcclxuICAgIC8qKiBUaGUgY29sbGVjdGlvbiBncm91cCB0byB3aGljaCB0aGUgZG9jdW1lbnQgYmVsb25ncy4gKi9cclxuICAgIGNvbGxlY3Rpb25Hcm91cCwgXHJcbiAgICAvKiogVGhlIGxhcmdlc3QgYmF0Y2ggSUQgdGhhdCdzIGJlZW4gYXBwbGllZCBmb3IgdGhpcyBvdmVybGF5LiAqL1xyXG4gICAgbGFyZ2VzdEJhdGNoSWQsIFxyXG4gICAgLyoqIFRoZSBvdmVybGF5IG11dGF0aW9uLiAqL1xyXG4gICAgb3ZlcmxheU11dGF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy51c2VySWQgPSB1c2VySWQ7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGF0aCA9IGNvbGxlY3Rpb25QYXRoO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRJZCA9IGRvY3VtZW50SWQ7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgdGhpcy5sYXJnZXN0QmF0Y2hJZCA9IGxhcmdlc3RCYXRjaElkO1xyXG4gICAgICAgIHRoaXMub3ZlcmxheU11dGF0aW9uID0gb3ZlcmxheU11dGF0aW9uO1xyXG4gICAgfVxyXG59XHJcbi8qKiBOYW1lIG9mIHRoZSBJbmRleGVkRGIgb2JqZWN0IHN0b3JlLiAqL1xyXG5EYkRvY3VtZW50T3ZlcmxheS5zdG9yZSA9ICdkb2N1bWVudE92ZXJsYXlzJztcclxuRGJEb2N1bWVudE92ZXJsYXkua2V5UGF0aCA9IFsndXNlcklkJywgJ2NvbGxlY3Rpb25QYXRoJywgJ2RvY3VtZW50SWQnXTtcclxuRGJEb2N1bWVudE92ZXJsYXkuY29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXggPSAnY29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXgnO1xyXG5EYkRvY3VtZW50T3ZlcmxheS5jb2xsZWN0aW9uUGF0aE92ZXJsYXlJbmRleFBhdGggPSBbXHJcbiAgICAndXNlcklkJyxcclxuICAgICdjb2xsZWN0aW9uUGF0aCcsXHJcbiAgICAnbGFyZ2VzdEJhdGNoSWQnXHJcbl07XHJcbkRiRG9jdW1lbnRPdmVybGF5LmNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleCA9ICdjb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXgnO1xyXG5EYkRvY3VtZW50T3ZlcmxheS5jb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXhQYXRoID0gW1xyXG4gICAgJ3VzZXJJZCcsXHJcbiAgICAnY29sbGVjdGlvbkdyb3VwJyxcclxuICAgICdsYXJnZXN0QmF0Y2hJZCdcclxuXTtcclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5jb25zdCBWMV9TVE9SRVMgPSBbXHJcbiAgICBEYk11dGF0aW9uUXVldWUuc3RvcmUsXHJcbiAgICBEYk11dGF0aW9uQmF0Y2guc3RvcmUsXHJcbiAgICBEYkRvY3VtZW50TXV0YXRpb24uc3RvcmUsXHJcbiAgICBEYlJlbW90ZURvY3VtZW50LnN0b3JlLFxyXG4gICAgRGJUYXJnZXQuc3RvcmUsXHJcbiAgICBEYlByaW1hcnlDbGllbnQuc3RvcmUsXHJcbiAgICBEYlRhcmdldEdsb2JhbC5zdG9yZSxcclxuICAgIERiVGFyZ2V0RG9jdW1lbnQuc3RvcmVcclxuXTtcclxuLy8gVjIgaXMgbm8gbG9uZ2VyIHVzYWJsZSAoc2VlIGNvbW1lbnQgYXQgdG9wIG9mIGZpbGUpXHJcbi8vIFZpc2libGUgZm9yIHRlc3RpbmdcclxuY29uc3QgVjNfU1RPUkVTID0gVjFfU1RPUkVTO1xyXG4vLyBOb3RlOiBEYlJlbW90ZURvY3VtZW50Q2hhbmdlcyBpcyBubyBsb25nZXIgdXNlZCBhbmQgZHJvcHBlZCB3aXRoIHY5LlxyXG5jb25zdCBWNF9TVE9SRVMgPSBbLi4uVjNfU1RPUkVTLCBEYkNsaWVudE1ldGFkYXRhLnN0b3JlXTtcclxuLy8gVjUgZG9lcyBub3QgY2hhbmdlIHRoZSBzZXQgb2Ygc3RvcmVzLlxyXG5jb25zdCBWNl9TVE9SRVMgPSBbLi4uVjRfU1RPUkVTLCBEYlJlbW90ZURvY3VtZW50R2xvYmFsLnN0b3JlXTtcclxuLy8gVjcgZG9lcyBub3QgY2hhbmdlIHRoZSBzZXQgb2Ygc3RvcmVzLlxyXG5jb25zdCBWOF9TVE9SRVMgPSBbLi4uVjZfU1RPUkVTLCBEYkNvbGxlY3Rpb25QYXJlbnQuc3RvcmVdO1xyXG4vLyBWOSBkb2VzIG5vdCBjaGFuZ2UgdGhlIHNldCBvZiBzdG9yZXMuXHJcbi8vIFYxMCBkb2VzIG5vdCBjaGFuZ2UgdGhlIHNldCBvZiBzdG9yZXMuXHJcbmNvbnN0IFYxMV9TVE9SRVMgPSBbLi4uVjhfU1RPUkVTLCBEYkJ1bmRsZS5zdG9yZSwgRGJOYW1lZFF1ZXJ5LnN0b3JlXTtcclxuY29uc3QgVjEyX1NUT1JFUyA9IFsuLi5WMTFfU1RPUkVTLCBEYkRvY3VtZW50T3ZlcmxheS5zdG9yZV07XHJcbmNvbnN0IFYxM19TVE9SRVMgPSBbXHJcbiAgICAuLi5WMTJfU1RPUkVTLFxyXG4gICAgRGJJbmRleENvbmZpZ3VyYXRpb24uc3RvcmUsXHJcbiAgICBEYkluZGV4U3RhdGUuc3RvcmUsXHJcbiAgICBEYkluZGV4RW50cnkuc3RvcmVcclxuXTtcclxuLyoqIFJldHVybnMgdGhlIG9iamVjdCBzdG9yZXMgZm9yIHRoZSBwcm92aWRlZCBzY2hlbWEuICovXHJcbmZ1bmN0aW9uIGdldE9iamVjdFN0b3JlcyhzY2hlbWFWZXJzaW9uKSB7XHJcbiAgICBpZiAoc2NoZW1hVmVyc2lvbiA9PT0gMTMpIHtcclxuICAgICAgICByZXR1cm4gVjEzX1NUT1JFUztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjaGVtYVZlcnNpb24gPT09IDEyKSB7XHJcbiAgICAgICAgcmV0dXJuIFYxMl9TVE9SRVM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzY2hlbWFWZXJzaW9uID09PSAxMSkge1xyXG4gICAgICAgIHJldHVybiBWMTFfU1RPUkVTO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFpbCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFBSSU1BUllfTEVBU0VfTE9TVF9FUlJPUl9NU0cgPSAnVGhlIGN1cnJlbnQgdGFiIGlzIG5vdCBpbiB0aGUgcmVxdWlyZWQgc3RhdGUgdG8gcGVyZm9ybSB0aGlzIG9wZXJhdGlvbi4gJyArXHJcbiAgICAnSXQgbWlnaHQgYmUgbmVjZXNzYXJ5IHRvIHJlZnJlc2ggdGhlIGJyb3dzZXIgdGFiLic7XHJcbi8qKlxyXG4gKiBBIGJhc2UgY2xhc3MgcmVwcmVzZW50aW5nIGEgcGVyc2lzdGVuY2UgdHJhbnNhY3Rpb24sIGVuY2Fwc3VsYXRpbmcgYm90aCB0aGVcclxuICogdHJhbnNhY3Rpb24ncyBzZXF1ZW5jZSBudW1iZXJzIGFzIHdlbGwgYXMgYSBsaXN0IG9mIG9uQ29tbWl0dGVkIGxpc3RlbmVycy5cclxuICpcclxuICogV2hlbiB5b3UgY2FsbCBQZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbigpLCBpdCB3aWxsIGNyZWF0ZSBhIHRyYW5zYWN0aW9uIGFuZFxyXG4gKiBwYXNzIGl0IHRvIHlvdXIgY2FsbGJhY2suIFlvdSB0aGVuIHBhc3MgaXQgdG8gYW55IG1ldGhvZCB0aGF0IG9wZXJhdGVzXHJcbiAqIG9uIHBlcnNpc3RlbmNlLlxyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVuY2VUcmFuc2FjdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm9uQ29tbWl0dGVkTGlzdGVuZXJzID0gW107XHJcbiAgICB9XHJcbiAgICBhZGRPbkNvbW1pdHRlZExpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5vbkNvbW1pdHRlZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIHJhaXNlT25Db21taXR0ZWRFdmVudCgpIHtcclxuICAgICAgICB0aGlzLm9uQ29tbWl0dGVkTGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFBlcnNpc3RlbmNlUHJvbWlzZSBpcyBlc3NlbnRpYWxseSBhIHJlLWltcGxlbWVudGF0aW9uIG9mIFByb21pc2UgZXhjZXB0XHJcbiAqIGl0IGhhcyBhIC5uZXh0KCkgbWV0aG9kIGluc3RlYWQgb2YgLnRoZW4oKSBhbmQgLm5leHQoKSBhbmQgLmNhdGNoKCkgY2FsbGJhY2tzXHJcbiAqIGFyZSBleGVjdXRlZCBzeW5jaHJvbm91c2x5IHdoZW4gYSBQZXJzaXN0ZW5jZVByb21pc2UgcmVzb2x2ZXMgcmF0aGVyIHRoYW5cclxuICogYXN5bmNocm9ub3VzbHkgKFByb21pc2UgaW1wbGVtZW50YXRpb25zIHVzZSBzZXRJbW1lZGlhdGUoKSBvciBzaW1pbGFyKS5cclxuICpcclxuICogVGhpcyBpcyBuZWNlc3NhcnkgdG8gaW50ZXJvcGVyYXRlIHdpdGggSW5kZXhlZERCIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseVxyXG4gKiBjb21taXQgdHJhbnNhY3Rpb25zIGlmIGNvbnRyb2wgaXMgcmV0dXJuZWQgdG8gdGhlIGV2ZW50IGxvb3Agd2l0aG91dFxyXG4gKiBzeW5jaHJvbm91c2x5IGluaXRpYXRpbmcgYW5vdGhlciBvcGVyYXRpb24gb24gdGhlIHRyYW5zYWN0aW9uLlxyXG4gKlxyXG4gKiBOT1RFOiAudGhlbigpIGFuZCAuY2F0Y2goKSBvbmx5IGFsbG93IGEgc2luZ2xlIGNvbnN1bWVyLCB1bmxpa2Ugbm9ybWFsXHJcbiAqIFByb21pc2VzLlxyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVuY2VQcm9taXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgLy8gTk9URTogbmV4dC9jYXRjaENhbGxiYWNrIHdpbGwgYWx3YXlzIHBvaW50IHRvIG91ciBvd24gd3JhcHBlciBmdW5jdGlvbnMsXHJcbiAgICAgICAgLy8gbm90IHRoZSB1c2VyJ3MgcmF3IG5leHQoKSBvciBjYXRjaCgpIGNhbGxiYWNrcy5cclxuICAgICAgICB0aGlzLm5leHRDYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jYXRjaENhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAvLyBXaGVuIHRoZSBvcGVyYXRpb24gcmVzb2x2ZXMsIHdlJ2xsIHNldCByZXN1bHQgb3IgZXJyb3IgYW5kIG1hcmsgaXNEb25lLlxyXG4gICAgICAgIHRoaXMucmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5pc0RvbmUgPSBmYWxzZTtcclxuICAgICAgICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIC50aGVuKCkgb3IgLmNhdGNoKCkgYXJlIGNhbGxlZCBhbmQgcHJldmVudHMgYWRkaXRpb25hbFxyXG4gICAgICAgIC8vIGNoYWluaW5nLlxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tBdHRhY2hlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNhbGxiYWNrKHZhbHVlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlIHNob3VsZCBiZSBkZWZpbmVkIHVubGVzcyBUIGlzIFZvaWQsIGJ1dCB3ZSBjYW4ndCBleHByZXNzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGluIHRoZSB0eXBlIHN5c3RlbS5cclxuICAgICAgICAgICAgICAgIHRoaXMubmV4dENhbGxiYWNrKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhdGNoQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2F0Y2hDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNhdGNoKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCh1bmRlZmluZWQsIGZuKTtcclxuICAgIH1cclxuICAgIG5leHQobmV4dEZuLCBjYXRjaEZuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tBdHRhY2hlZCkge1xyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tBdHRhY2hlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcFN1Y2Nlc3MobmV4dEZuLCB0aGlzLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwRmFpbHVyZShjYXRjaEZuLCB0aGlzLmVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbGJhY2sgPSAodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBTdWNjZXNzKG5leHRGbiwgdmFsdWUpLm5leHQocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhdGNoQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndyYXBGYWlsdXJlKGNhdGNoRm4sIGVycm9yKS5uZXh0KHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1Byb21pc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0KHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB3cmFwVXNlckZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFBlcnNpc3RlbmNlUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdyYXBTdWNjZXNzKG5leHRGbiwgdmFsdWUpIHtcclxuICAgICAgICBpZiAobmV4dEZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBVc2VyRnVuY3Rpb24oKCkgPT4gbmV4dEZuKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG5leHRGbiwgdGhlbiBSIG11c3QgYmUgdGhlIHNhbWUgYXMgVFxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdyYXBGYWlsdXJlKGNhdGNoRm4sIGVycm9yKSB7XHJcbiAgICAgICAgaWYgKGNhdGNoRm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcFVzZXJGdW5jdGlvbigoKSA9PiBjYXRjaEZuKGVycm9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHJlc29sdmUocmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcmVqZWN0KGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHdhaXRGb3IoXHJcbiAgICAvLyBBY2NlcHQgYWxsIFByb21pc2UgdHlwZXMgaW4gd2FpdEZvcigpLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGFsbCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgbGV0IGV4cGVjdGVkQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGFsbC5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgKytleHBlY3RlZENvdW50O1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICArK3Jlc29sdmVkQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUgJiYgcmVzb2x2ZWRDb3VudCA9PT0gZXhwZWN0ZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgZXJyID0+IHJlamVjdChlcnIpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRDb3VudCA9PT0gZXhwZWN0ZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIHByZWRpY2F0ZSBmdW5jdGlvbnMgdGhhdCBhc3luY2hyb25vdXNseSBldmFsdWF0ZSB0byBhXHJcbiAgICAgKiBib29sZWFuLCBpbXBsZW1lbnRzIGEgc2hvcnQtY2lyY3VpdGluZyBgb3JgIGJldHdlZW4gdGhlIHJlc3VsdHMuIFByZWRpY2F0ZXNcclxuICAgICAqIHdpbGwgYmUgZXZhbHVhdGVkIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYHRydWVgLCB0aGVuIHN0b3AuIFRoZSBmaW5hbFxyXG4gICAgICogcmVzdWx0IHdpbGwgYmUgd2hldGhlciBhbnkgb2YgdGhlbSByZXR1cm5lZCBgdHJ1ZWAuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBvcihwcmVkaWNhdGVzKSB7XHJcbiAgICAgICAgbGV0IHAgPSBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmVkaWNhdGUgb2YgcHJlZGljYXRlcykge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KGlzVHJ1ZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGlzVHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmb3JFYWNoKGNvbGxlY3Rpb24sIGYpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaCgociwgcykgPT4ge1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGYuY2FsbCh0aGlzLCByLCBzKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2FpdEZvcihwcm9taXNlcyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gUmVmZXJlbmNlcyB0byBgd2luZG93YCBhcmUgZ3VhcmRlZCBieSBTaW1wbGVEYi5pc0F2YWlsYWJsZSgpXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG5jb25zdCBMT0dfVEFHJGggPSAnU2ltcGxlRGInO1xyXG4vKipcclxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIGZvciBhbiBJbmRleGVkRGIgdHJhbnNhY3Rpb24gdGhhdCBmYWlsc1xyXG4gKiB3aXRoIGEgRE9NRXhjZXB0aW9uLlxyXG4gKi9cclxuY29uc3QgVFJBTlNBQ1RJT05fUkVUUllfQ09VTlQgPSAzO1xyXG4vKipcclxuICogV3JhcHMgYW4gSURCVHJhbnNhY3Rpb24gYW5kIGV4cG9zZXMgYSBzdG9yZSgpIG1ldGhvZCB0byBnZXQgYSBoYW5kbGUgdG8gYVxyXG4gKiBzcGVjaWZpYyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5jbGFzcyBTaW1wbGVEYlRyYW5zYWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGFjdGlvbiwgdHJhbnNhY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcclxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XHJcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIEluZGV4ZWREYiB0cmFuc2FjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5vbmFib3J0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnJlamVjdChuZXcgSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihhY3Rpb24sIHRyYW5zYWN0aW9uLmVycm9yKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9uRGVmZXJyZWQucmVqZWN0KG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGFjdGlvbiwgZXJyb3IpKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG9wZW4oZGIsIGFjdGlvbiwgbW9kZSwgb2JqZWN0U3RvcmVOYW1lcykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlRGJUcmFuc2FjdGlvbihhY3Rpb24sIGRiLnRyYW5zYWN0aW9uKG9iamVjdFN0b3JlTmFtZXMsIG1vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgY29tcGxldGlvblByb21pc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGlvbkRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBhYm9ydChlcnJvcikge1xyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25EZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuYWJvcnRlZCkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsICdBYm9ydGluZyB0cmFuc2FjdGlvbjonLCBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnQ2xpZW50LWluaXRpYXRlZCBhYm9ydCcpO1xyXG4gICAgICAgICAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLmFib3J0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF5YmVDb21taXQoKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgVjMgSW5kZXhlZERCLCB3ZSBpbnZva2UgY29tbWl0KCkgZXhwbGljaXRseSB0b1xyXG4gICAgICAgIC8vIHNwZWVkIHVwIGluZGV4IERCIHByb2Nlc3NpbmcgaWYgdGhlIGV2ZW50IGxvb3AgcmVtYWlucyBibG9ja3MuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBjb25zdCBtYXliZVYzSW5kZXhlZERiID0gdGhpcy50cmFuc2FjdGlvbjtcclxuICAgICAgICBpZiAoIXRoaXMuYWJvcnRlZCAmJiB0eXBlb2YgbWF5YmVWM0luZGV4ZWREYi5jb21taXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgbWF5YmVWM0luZGV4ZWREYi5jb21taXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBTaW1wbGVEYlN0b3JlPEtleVR5cGUsIFZhbHVlVHlwZT4gZm9yIHRoZSBzcGVjaWZpZWQgc3RvcmUuIEFsbFxyXG4gICAgICogb3BlcmF0aW9ucyBwZXJmb3JtZWQgb24gdGhlIFNpbXBsZURiU3RvcmUgaGFwcGVuIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGlzXHJcbiAgICAgKiB0cmFuc2FjdGlvbiBhbmQgaXQgY2Fubm90IGJlIHVzZWQgYW55bW9yZSBvbmNlIHRoZSB0cmFuc2FjdGlvbiBpc1xyXG4gICAgICogY29tcGxldGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCB3ZSBjYW4ndCBhY3R1YWxseSBlbmZvcmNlIHRoYXQgdGhlIEtleVR5cGUgYW5kIFZhbHVlVHlwZSBhcmVcclxuICAgICAqIGNvcnJlY3QsIGJ1dCB0aGV5IGFsbG93IHR5cGUgc2FmZXR5IHRocm91Z2ggdGhlIHJlc3Qgb2YgdGhlIGNvbnN1bWluZyBjb2RlLlxyXG4gICAgICovXHJcbiAgICBzdG9yZShzdG9yZU5hbWUpIHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHRoaXMudHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcclxuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZURiU3RvcmUoc3RvcmUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIEluZGV4ZWREYiB3aXRoIGEgc2ltcGxpZmllZCBpbnRlcmZhY2UgdGhhdCB1c2VzXHJcbiAqIFByb21pc2UtbGlrZSByZXR1cm4gdmFsdWVzIHRvIGNoYWluIG9wZXJhdGlvbnMuIFJlYWwgcHJvbWlzZXMgY2Fubm90IGJlIHVzZWRcclxuICogc2luY2UgLnRoZW4oKSBjb250aW51YXRpb25zIGFyZSBleGVjdXRlZCBhc3luY2hyb25vdXNseSAoZS5nLiB2aWFcclxuICogLnNldEltbWVkaWF0ZSksIHdoaWNoIHdvdWxkIGNhdXNlIEluZGV4ZWREQiB0byBlbmQgdGhlIHRyYW5zYWN0aW9uLlxyXG4gKiBTZWUgUGVyc2lzdGVuY2VQcm9taXNlIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqL1xyXG5jbGFzcyBTaW1wbGVEYiB7XHJcbiAgICAvKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTaW1wbGVEYiB3cmFwcGVyIGZvciBJbmRleGVkRGIgZGF0YWJhc2UgYG5hbWVgLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCBgdmVyc2lvbmAgbXVzdCBub3QgYmUgYSBkb3duZ3JhZGUuIEluZGV4ZWREQiBkb2VzIG5vdCBzdXBwb3J0XHJcbiAgICAgKiBkb3duZ3JhZGluZyB0aGUgc2NoZW1hIHZlcnNpb24uIFdlIGN1cnJlbnRseSBkbyBub3Qgc3VwcG9ydCBhbnkgd2F5IHRvIGRvXHJcbiAgICAgKiB2ZXJzaW9uaW5nIG91dHNpZGUgb2YgSW5kZXhlZERCJ3MgdmVyc2lvbmluZyBtZWNoYW5pc20sIGFzIG9ubHlcclxuICAgICAqIHZlcnNpb24tdXBncmFkZSB0cmFuc2FjdGlvbnMgYXJlIGFsbG93ZWQgdG8gZG8gdGhpbmdzIGxpa2UgY3JlYXRlXHJcbiAgICAgKiBvYmplY3RzdG9yZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZlcnNpb24sIHNjaGVtYUNvbnZlcnRlcikge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICB0aGlzLnNjaGVtYUNvbnZlcnRlciA9IHNjaGVtYUNvbnZlcnRlcjtcclxuICAgICAgICBjb25zdCBpT1NWZXJzaW9uID0gU2ltcGxlRGIuZ2V0SU9TVmVyc2lvbihnZXRVQSgpKTtcclxuICAgICAgICAvLyBOT1RFOiBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NzA1MCwgdGhlXHJcbiAgICAgICAgLy8gYnVnIHdlJ3JlIGNoZWNraW5nIGZvciBzaG91bGQgZXhpc3QgaW4gaU9TID49IDEyLjIgYW5kIDwgMTMsIGJ1dCBmb3JcclxuICAgICAgICAvLyB3aGF0ZXZlciByZWFzb24gaXQncyBtdWNoIGhhcmRlciB0byBoaXQgYWZ0ZXIgMTIuMiBzbyB3ZSBvbmx5IHByb2FjdGl2ZWx5XHJcbiAgICAgICAgLy8gbG9nIG9uIDEyLjIuXHJcbiAgICAgICAgaWYgKGlPU1ZlcnNpb24gPT09IDEyLjIpIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoJ0ZpcmVzdG9yZSBwZXJzaXN0ZW5jZSBzdWZmZXJzIGZyb20gYSBidWcgaW4gaU9TIDEyLjIgJyArXHJcbiAgICAgICAgICAgICAgICAnU2FmYXJpIHRoYXQgbWF5IGNhdXNlIHlvdXIgYXBwIHRvIHN0b3Agd29ya2luZy4gU2VlICcgK1xyXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS81NjQ5NjI5Ni8xMTA5MTUgZm9yIGRldGFpbHMgJyArXHJcbiAgICAgICAgICAgICAgICAnYW5kIGEgcG90ZW50aWFsIHdvcmthcm91bmQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBkYXRhYmFzZS4gKi9cclxuICAgIHN0YXRpYyBkZWxldGUobmFtZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ1JlbW92aW5nIGRhdGFiYXNlOicsIG5hbWUpO1xyXG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdCh3aW5kb3cuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpKS50b1Byb21pc2UoKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgSW5kZXhlZERCIGlzIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gKi9cclxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoU2ltcGxlRGIuaXNNb2NrUGVyc2lzdGVuY2UoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgZXh0ZW5zaXZlbHkgdXNlIGluZGV4ZWQgYXJyYXkgdmFsdWVzIGFuZCBjb21wb3VuZCBrZXlzLFxyXG4gICAgICAgIC8vIHdoaWNoIElFIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0LiBIb3dldmVyLCB0aGV5IHN0aWxsIGhhdmUgaW5kZXhlZERCXHJcbiAgICAgICAgLy8gZGVmaW5lZCBvbiB0aGUgd2luZG93LCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciB0aGVtIGhlcmUgYW5kIG1ha2Ugc3VyZVxyXG4gICAgICAgIC8vIHRvIHJldHVybiB0aGF0IHBlcnNpc3RlbmNlIGlzIG5vdCBlbmFibGVkIGZvciB0aG9zZSBicm93c2Vycy5cclxuICAgICAgICAvLyBGb3IgdHJhY2tpbmcgc3VwcG9ydCBvZiB0aGlzIGZlYXR1cmUsIHNlZSBoZXJlOlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vc3RhdHVzL2luZGV4ZWRkYmFycmF5c2FuZG11bHRpZW50cnlzdXBwb3J0L1xyXG4gICAgICAgIC8vIENoZWNrIHRoZSBVQSBzdHJpbmcgdG8gZmluZCBvdXQgdGhlIGJyb3dzZXIuXHJcbiAgICAgICAgY29uc3QgdWEgPSBnZXRVQSgpO1xyXG4gICAgICAgIC8vIElFIDEwXHJcbiAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKGNvbXBhdGlibGU7IE1TSUUgMTAuMDsgV2luZG93cyBOVCA2LjI7IFRyaWRlbnQvNi4wKSc7XHJcbiAgICAgICAgLy8gSUUgMTFcclxuICAgICAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCA2LjM7IFRyaWRlbnQvNy4wOyBydjoxMS4wKSBsaWtlIEdlY2tvJztcclxuICAgICAgICAvLyBFZGdlXHJcbiAgICAgICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV09XNjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsXHJcbiAgICAgICAgLy8gbGlrZSBHZWNrbykgQ2hyb21lLzM5LjAuMjE3MS43MSBTYWZhcmkvNTM3LjM2IEVkZ2UvMTIuMCc7XHJcbiAgICAgICAgLy8gaU9TIFNhZmFyaTogRGlzYWJsZSBmb3IgdXNlcnMgcnVubmluZyBpT1MgdmVyc2lvbiA8IDEwLlxyXG4gICAgICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKHVhKTtcclxuICAgICAgICBjb25zdCBpc1Vuc3VwcG9ydGVkSU9TID0gMCA8IGlPU1ZlcnNpb24gJiYgaU9TVmVyc2lvbiA8IDEwO1xyXG4gICAgICAgIC8vIEFuZHJvaWQgYnJvd3NlcjogRGlzYWJsZSBmb3IgdXNlcnNlIHJ1bm5pbmcgdmVyc2lvbiA8IDQuNS5cclxuICAgICAgICBjb25zdCBhbmRyb2lkVmVyc2lvbiA9IFNpbXBsZURiLmdldEFuZHJvaWRWZXJzaW9uKHVhKTtcclxuICAgICAgICBjb25zdCBpc1Vuc3VwcG9ydGVkQW5kcm9pZCA9IDAgPCBhbmRyb2lkVmVyc2lvbiAmJiBhbmRyb2lkVmVyc2lvbiA8IDQuNTtcclxuICAgICAgICBpZiAodWEuaW5kZXhPZignTVNJRSAnKSA+IDAgfHxcclxuICAgICAgICAgICAgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+IDAgfHxcclxuICAgICAgICAgICAgdWEuaW5kZXhPZignRWRnZS8nKSA+IDAgfHxcclxuICAgICAgICAgICAgaXNVbnN1cHBvcnRlZElPUyB8fFxyXG4gICAgICAgICAgICBpc1Vuc3VwcG9ydGVkQW5kcm9pZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYmFja2luZyBJbmRleGVkREIgc3RvcmUgaXMgdGhlIE5vZGUgSW5kZXhlZERCU2hpbVxyXG4gICAgICogKHNlZSBodHRwczovL2dpdGh1Yi5jb20vYXhlbWNsaW9uL0luZGV4ZWREQlNoaW0pLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNNb2NrUGVyc2lzdGVuY2UoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgICgoX2EgPSBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLlVTRV9NT0NLX1BFUlNJU1RFTkNFKSA9PT0gJ1lFUycpO1xyXG4gICAgfVxyXG4gICAgLyoqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZyb20gYSB0cmFuc2FjdGlvbi4gKi9cclxuICAgIHN0YXRpYyBnZXRTdG9yZSh0eG4sIHN0b3JlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4bi5zdG9yZShzdG9yZSk7XHJcbiAgICB9XHJcbiAgICAvLyB2aXNpYmxlIGZvciB0ZXN0aW5nXHJcbiAgICAvKiogUGFyc2UgVXNlciBBZ2VudCB0byBkZXRlcm1pbmUgaU9TIHZlcnNpb24uIFJldHVybnMgLTEgaWYgbm90IGZvdW5kLiAqL1xyXG4gICAgc3RhdGljIGdldElPU1ZlcnNpb24odWEpIHtcclxuICAgICAgICBjb25zdCBpT1NWZXJzaW9uUmVnZXggPSB1YS5tYXRjaCgvaSg/OnBob25lfHBhZHxwb2QpIG9zIChbXFxkX10rKS9pKTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gaU9TVmVyc2lvblJlZ2V4XHJcbiAgICAgICAgICAgID8gaU9TVmVyc2lvblJlZ2V4WzFdLnNwbGl0KCdfJykuc2xpY2UoMCwgMikuam9pbignLicpXHJcbiAgICAgICAgICAgIDogJy0xJztcclxuICAgICAgICByZXR1cm4gTnVtYmVyKHZlcnNpb24pO1xyXG4gICAgfVxyXG4gICAgLy8gdmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gICAgLyoqIFBhcnNlIFVzZXIgQWdlbnQgdG8gZGV0ZXJtaW5lIEFuZHJvaWQgdmVyc2lvbi4gUmV0dXJucyAtMSBpZiBub3QgZm91bmQuICovXHJcbiAgICBzdGF0aWMgZ2V0QW5kcm9pZFZlcnNpb24odWEpIHtcclxuICAgICAgICBjb25zdCBhbmRyb2lkVmVyc2lvblJlZ2V4ID0gdWEubWF0Y2goL0FuZHJvaWQgKFtcXGQuXSspL2kpO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBhbmRyb2lkVmVyc2lvblJlZ2V4XHJcbiAgICAgICAgICAgID8gYW5kcm9pZFZlcnNpb25SZWdleFsxXS5zcGxpdCgnLicpLnNsaWNlKDAsIDIpLmpvaW4oJy4nKVxyXG4gICAgICAgICAgICA6ICctMSc7XHJcbiAgICAgICAgcmV0dXJuIE51bWJlcih2ZXJzaW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3BlbnMgdGhlIHNwZWNpZmllZCBkYXRhYmFzZSwgY3JlYXRpbmcgb3IgdXBncmFkaW5nIGl0IGlmIG5lY2Vzc2FyeS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZW5zdXJlRGIoYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRiKSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ09wZW5pbmcgZGF0YWJhc2U6JywgdGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5kYiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8obWlrZWxlaGVuKTogSW52ZXN0aWdhdGUgYnJvd3NlciBjb21wYXRpYmlsaXR5LlxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0luZGV4ZWREQl9BUEkvVXNpbmdfSW5kZXhlZERCXHJcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0cyBJRTkgYW5kIG9sZGVyIFdlYktpdCBicm93c2VycyBoYW5kbGUgdXBncmFkZVxyXG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50bHkuIFRoZXkgZXhwZWN0IHNldFZlcnNpb24sIGFzIGRlc2NyaWJlZCBoZXJlOlxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lEQlZlcnNpb25DaGFuZ2VSZXF1ZXN0L3NldFZlcnNpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLm5hbWUsIHRoaXMudmVyc2lvbik7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRiKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uYmxvY2tlZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCAnQ2Fubm90IHVwZ3JhZGUgSW5kZXhlZERCIHNjaGVtYSB3aGlsZSBhbm90aGVyIHRhYiBpcyBvcGVuLiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0Nsb3NlIGFsbCB0YWJzIHRoYXQgYWNjZXNzIEZpcmVzdG9yZSBhbmQgcmVsb2FkIHRoaXMgcGFnZSB0byBwcm9jZWVkLicpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGV2ZW50LnRhcmdldC5lcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1ZlcnNpb25FcnJvcicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdBIG5ld2VyIHZlcnNpb24gb2YgdGhlIEZpcmVzdG9yZSBTREsgd2FzIHByZXZpb3VzbHkgdXNlZCBhbmQgc28gdGhlIHBlcnNpc3RlZCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHZlcnNpb24gb2YgdGhlIFNESyB5b3UgYXJlIG5vdyB1c2luZy4gVGhlIFNESyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3aWxsIG9wZXJhdGUgd2l0aCBwZXJzaXN0ZW5jZSBkaXNhYmxlZC4gSWYgeW91IG5lZWQgcGVyc2lzdGVuY2UsIHBsZWFzZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZS11cGdyYWRlIHRvIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgU0RLIG9yIGVsc2UgY2xlYXIgdGhlIHBlcnNpc3RlZCBJbmRleGVkREIgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YSBmb3IgeW91ciBhcHAgdG8gc3RhcnQgZnJlc2guJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnVW5hYmxlIHRvIG9wZW4gYW4gSW5kZXhlZERCIGNvbm5lY3Rpb24uIFRoaXMgY291bGQgYmUgZHVlIHRvIHJ1bm5pbmcgaW4gYSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcml2YXRlIGJyb3dzaW5nIHNlc3Npb24gb24gYSBicm93c2VyIHdob3NlIHByaXZhdGUgYnJvd3Npbmcgc2Vzc2lvbnMgZG8gbm90ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1cHBvcnQgSW5kZXhlZERCOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoYWN0aW9uLCBlcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ0RhdGFiYXNlIFwiJyArIHRoaXMubmFtZSArICdcIiByZXF1aXJlcyB1cGdyYWRlIGZyb20gdmVyc2lvbjonLCBldmVudC5vbGRWZXJzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlbWFDb252ZXJ0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNyZWF0ZU9yVXBncmFkZShkYiwgcmVxdWVzdC50cmFuc2FjdGlvbiwgZXZlbnQub2xkVmVyc2lvbiwgdGhpcy52ZXJzaW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ0RhdGFiYXNlIHVwZ3JhZGUgdG8gdmVyc2lvbiAnICsgdGhpcy52ZXJzaW9uICsgJyBjb21wbGV0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25jaGFuZ2VsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRiLm9udmVyc2lvbmNoYW5nZSA9IGV2ZW50ID0+IHRoaXMudmVyc2lvbmNoYW5nZWxpc3RlbmVyKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGI7XHJcbiAgICB9XHJcbiAgICBzZXRWZXJzaW9uQ2hhbmdlTGlzdGVuZXIodmVyc2lvbkNoYW5nZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uY2hhbmdlbGlzdGVuZXIgPSB2ZXJzaW9uQ2hhbmdlTGlzdGVuZXI7XHJcbiAgICAgICAgaWYgKHRoaXMuZGIpIHtcclxuICAgICAgICAgICAgdGhpcy5kYi5vbnZlcnNpb25jaGFuZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uQ2hhbmdlTGlzdGVuZXIoZXZlbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIHJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgbW9kZSwgb2JqZWN0U3RvcmVzLCB0cmFuc2FjdGlvbkZuKSB7XHJcbiAgICAgICAgY29uc3QgcmVhZG9ubHkgPSBtb2RlID09PSAncmVhZG9ubHknO1xyXG4gICAgICAgIGxldCBhdHRlbXB0TnVtYmVyID0gMDtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICArK2F0dGVtcHROdW1iZXI7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRiID0gYXdhaXQgdGhpcy5lbnN1cmVEYihhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBTaW1wbGVEYlRyYW5zYWN0aW9uLm9wZW4odGhpcy5kYiwgYWN0aW9uLCByZWFkb25seSA/ICdyZWFkb25seScgOiAncmVhZHdyaXRlJywgb2JqZWN0U3RvcmVzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRm5SZXN1bHQgPSB0cmFuc2FjdGlvbkZuKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ubWF5YmVDb21taXQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3J0IHRoZSB0cmFuc2FjdGlvbiBpZiB0aGVyZSB3YXMgYW4gZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWJvcnQoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBhY3R1YWxseSByZWNvdmVyLCBhbmQgY2FsbGluZyBgYWJvcnQoKWAgd2lsbCBjYXVzZSB0aGUgdHJhbnNhY3Rpb24nc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gcHJvbWlzZSB0byBiZSByZWplY3RlZC4gVGhpcyBpbiB0dXJuIG1lYW5zIHRoYXQgd2Ugd29uJ3QgdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYHRyYW5zYWN0aW9uRm5SZXN1bHRgIGJlbG93LiBXZSByZXR1cm4gYSByZWplY3Rpb24gaGVyZSBzbyB0aGF0IHdlIGRvbid0IGFkZCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3NzaWJpbGl0eSBvZiByZXR1cm5pbmcgYHZvaWRgIHRvIHRoZSB0eXBlIG9mIGB0cmFuc2FjdGlvbkZuUmVzdWx0YC5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50b1Byb21pc2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIEFzIG5vdGVkIGFib3ZlLCBlcnJvcnMgYXJlIHByb3BhZ2F0ZWQgYnkgYWJvcnRpbmcgdGhlIHRyYW5zYWN0aW9uLiBTb1xyXG4gICAgICAgICAgICAgICAgLy8gd2Ugc3dhbGxvdyBhbnkgZXJyb3IgaGVyZSB0byBhdm9pZCB0aGUgYnJvd3NlciBsb2dnaW5nIGl0IGFzIHVuaGFuZGxlZC5cclxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uRm5SZXN1bHQuY2F0Y2goKCkgPT4geyB9KTtcclxuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSAoaS5lLiBJbmRleGVkRGIncyBvbnN1Y2Nlc3MgZXZlbnQgdG9cclxuICAgICAgICAgICAgICAgIC8vIGZpcmUpLCBidXQgc3RpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCB0cmFuc2FjdGlvbkZuUmVzdWx0IGJhY2sgdG8gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjYWxsZXIuXHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5jb21wbGV0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkZuUmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhzY2htaWR0LXNlYmFzdGlhbik6IFdlIGNvdWxkIHByb2JhYmx5IGJlIHNtYXJ0ZXIgYWJvdXQgdGhpcyBhbmRcclxuICAgICAgICAgICAgICAgIC8vIG5vdCByZXRyeSBleGNlcHRpb25zIHRoYXQgYXJlIGxpa2VseSB1bnJlY292ZXJhYmxlIChzdWNoIGFzIHF1b3RhXHJcbiAgICAgICAgICAgICAgICAvLyBleGNlZWRlZCBlcnJvcnMpLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgY2Fubm90IHVzZSBhbiBpbnN0YW5jZW9mIGNoZWNrIGZvciBGaXJlc3RvcmVFeGNlcHRpb24sIHNpbmNlIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGlzIHdyYXBwZWQgaW4gYSBnZW5lcmljIGVycm9yIGJ5IG91ciBhc3luYy9hd2FpdCBoYW5kbGluZy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5YWJsZSA9IGVycm9yLm5hbWUgIT09ICdGaXJlYmFzZUVycm9yJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHROdW1iZXIgPCBUUkFOU0FDVElPTl9SRVRSWV9DT1VOVDtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ1RyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIGVycm9yOicsIGVycm9yLm1lc3NhZ2UsICdSZXRyeWluZzonLCByZXRyeWFibGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeWFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGIpIHtcclxuICAgICAgICAgICAgdGhpcy5kYi5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRiID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGNvbnRyb2xsZXIgZm9yIGl0ZXJhdGluZyBvdmVyIGEga2V5IHJhbmdlIG9yIGluZGV4LiBJdCBhbGxvd3MgYW4gaXRlcmF0ZVxyXG4gKiBjYWxsYmFjayB0byBkZWxldGUgdGhlIGN1cnJlbnRseS1yZWZlcmVuY2VkIG9iamVjdCwgb3IganVtcCB0byBhIG5ldyBrZXlcclxuICogd2l0aGluIHRoZSBrZXkgcmFuZ2Ugb3IgaW5kZXguXHJcbiAqL1xyXG5jbGFzcyBJdGVyYXRpb25Db250cm9sbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRiQ3Vyc29yKSB7XHJcbiAgICAgICAgdGhpcy5kYkN1cnNvciA9IGRiQ3Vyc29yO1xyXG4gICAgICAgIHRoaXMuc2hvdWxkU3RvcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubmV4dEtleSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEb25lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNob3VsZFN0b3A7XHJcbiAgICB9XHJcbiAgICBnZXQgc2tpcFRvS2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRLZXk7XHJcbiAgICB9XHJcbiAgICBzZXQgY3Vyc29yKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5kYkN1cnNvciA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdG8gc3RvcCBpdGVyYXRpb24gYXQgYW55IHBvaW50LlxyXG4gICAgICovXHJcbiAgICBkb25lKCkge1xyXG4gICAgICAgIHRoaXMuc2hvdWxkU3RvcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB0byBza2lwIHRvIHRoYXQgbmV4dCBrZXksIHdoaWNoIGNvdWxkIGJlXHJcbiAgICAgKiBhbiBpbmRleCBvciBhIHByaW1hcnkga2V5LlxyXG4gICAgICovXHJcbiAgICBza2lwKGtleSkge1xyXG4gICAgICAgIHRoaXMubmV4dEtleSA9IGtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIHRoZSBjdXJyZW50IGN1cnNvciB2YWx1ZSBmcm9tIHRoZSBvYmplY3Qgc3RvcmUuXHJcbiAgICAgKlxyXG4gICAgICogTk9URTogWW91IENBTk5PVCBkbyB0aGlzIHdpdGggYSBrZXlzT25seSBxdWVyeS5cclxuICAgICAqL1xyXG4gICAgZGVsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdCh0aGlzLmRiQ3Vyc29yLmRlbGV0ZSgpKTtcclxuICAgIH1cclxufVxyXG4vKiogQW4gZXJyb3IgdGhhdCB3cmFwcyBleGNlcHRpb25zIHRoYXQgdGhyb3duIGR1cmluZyBJbmRleGVkREIgZXhlY3V0aW9uLiAqL1xyXG5jbGFzcyBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgRmlyZXN0b3JlRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoYWN0aW9uTmFtZSwgY2F1c2UpIHtcclxuICAgICAgICBzdXBlcihDb2RlLlVOQVZBSUxBQkxFLCBgSW5kZXhlZERCIHRyYW5zYWN0aW9uICcke2FjdGlvbk5hbWV9JyBmYWlsZWQ6ICR7Y2F1c2V9YCk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3InO1xyXG4gICAgfVxyXG59XHJcbi8qKiBWZXJpZmllcyB3aGV0aGVyIGBlYCBpcyBhbiBJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yLiAqL1xyXG5mdW5jdGlvbiBpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkge1xyXG4gICAgLy8gVXNlIG5hbWUgZXF1YWxpdHksIGFzIGluc3RhbmNlb2YgY2hlY2tzIG9uIGVycm9ycyBkb24ndCB3b3JrIHdpdGggZXJyb3JzXHJcbiAgICAvLyB0aGF0IHdyYXAgb3RoZXIgZXJyb3JzLlxyXG4gICAgcmV0dXJuIGUubmFtZSA9PT0gJ0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3InO1xyXG59XHJcbi8qKlxyXG4gKiBBIHdyYXBwZXIgYXJvdW5kIGFuIElEQk9iamVjdFN0b3JlIHByb3ZpZGluZyBhbiBBUEkgdGhhdDpcclxuICpcclxuICogMSkgSGFzIGdlbmVyaWMgS2V5VHlwZSAvIFZhbHVlVHlwZSBwYXJhbWV0ZXJzIHRvIHByb3ZpZGUgc3Ryb25nbHktdHlwZWRcclxuICogbWV0aG9kcyBmb3IgYWN0aW5nIGFnYWluc3QgdGhlIG9iamVjdCBzdG9yZS5cclxuICogMikgRGVhbHMgd2l0aCBJbmRleGVkREIncyBvbnN1Y2Nlc3MgLyBvbmVycm9yIGV2ZW50IGNhbGxiYWNrcywgbWFraW5nIGV2ZXJ5XHJcbiAqIG1ldGhvZCByZXR1cm4gYSBQZXJzaXN0ZW5jZVByb21pc2UgaW5zdGVhZC5cclxuICogMykgUHJvdmlkZXMgYSBoaWdoZXItbGV2ZWwgQVBJIHRvIGF2b2lkIG5lZWRpbmcgdG8gZG8gZXhjZXNzaXZlIHdyYXBwaW5nIG9mXHJcbiAqIGludGVybWVkaWF0ZSBJbmRleGVkREIgdHlwZXMgKElEQkN1cnNvcldpdGhWYWx1ZSwgZXRjLilcclxuICovXHJcbmNsYXNzIFNpbXBsZURiU3RvcmUge1xyXG4gICAgY29uc3RydWN0b3Ioc3RvcmUpIHtcclxuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XHJcbiAgICB9XHJcbiAgICBwdXQoa2V5T3JWYWx1ZSwgdmFsdWUpIHtcclxuICAgICAgICBsZXQgcmVxdWVzdDtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsICdQVVQnLCB0aGlzLnN0b3JlLm5hbWUsIGtleU9yVmFsdWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMuc3RvcmUucHV0KHZhbHVlLCBrZXlPclZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ1BVVCcsIHRoaXMuc3RvcmUubmFtZSwgJzxhdXRvLWtleT4nLCBrZXlPclZhbHVlKTtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMuc3RvcmUucHV0KGtleU9yVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgdmFsdWUgaW50byBhbiBPYmplY3QgU3RvcmUgYW5kIHJldHVybnMgdGhlIG5ldyBrZXkuIFNpbWlsYXIgdG9cclxuICAgICAqIEluZGV4ZWREYidzIGBhZGQoKWAsIHRoaXMgbWV0aG9kIHdpbGwgZmFpbCBvbiBwcmltYXJ5IGtleSBjb2xsaXNpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBvYmplY3QgdG8gd3JpdGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIGFkZCh2YWx1ZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ0FERCcsIHRoaXMuc3RvcmUubmFtZSwgdmFsdWUsIHZhbHVlKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5hZGQodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBrZXkgZnJvbSB0aGUgc3BlY2lmaWVkIHN0b3JlLCBvciBudWxsXHJcbiAgICAgKiBpZiBubyBvYmplY3QgZXhpc3RzIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQGtleSBUaGUga2V5IG9mIHRoZSBvYmplY3QgdG8gZ2V0LlxyXG4gICAgICogQHJldHVybnMgVGhlIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IG9yIG51bGwgaWYgbm8gb2JqZWN0IGV4aXN0cy5cclxuICAgICAqL1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmdldChrZXkpO1xyXG4gICAgICAgIC8vIFdlJ3JlIGRvaW5nIGFuIHVuc2FmZSBjYXN0IHRvIFZhbHVlVHlwZS5cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiB3cmFwUmVxdWVzdChyZXF1ZXN0KS5uZXh0KHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBub25leGlzdGVuY2UgdG8gbnVsbC5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ0dFVCcsIHRoaXMuc3RvcmUubmFtZSwga2V5LCByZXN1bHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckaCwgJ0RFTEVURScsIHRoaXMuc3RvcmUubmFtZSwga2V5KTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5zdG9yZS5kZWxldGUoa2V5KTtcclxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHdlIGV2ZXIgbmVlZCBtb3JlIG9mIHRoZSBjb3VudCB2YXJpYW50cywgd2UgY2FuIGFkZCBvdmVybG9hZHMuIEZvciBub3csXHJcbiAgICAgKiBhbGwgd2UgbmVlZCBpcyB0byBjb3VudCBldmVyeXRoaW5nIGluIGEgc3RvcmUuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHN0b3JlLlxyXG4gICAgICovXHJcbiAgICBjb3VudCgpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsICdDT1VOVCcsIHRoaXMuc3RvcmUubmFtZSk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuc3RvcmUuY291bnQoKTtcclxuICAgICAgICByZXR1cm4gd3JhcFJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICBsb2FkQWxsKGluZGV4T3JSYW5nZSwgcmFuZ2UpIHtcclxuICAgICAgICBjb25zdCBpdGVyYXRlT3B0aW9ucyA9IHRoaXMub3B0aW9ucyhpbmRleE9yUmFuZ2UsIHJhbmdlKTtcclxuICAgICAgICAvLyBVc2UgYGdldEFsbCgpYCBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyBJbmRleGVkREIgdjMsIGFzIGl0IGlzIHJvdWdobHlcclxuICAgICAgICAvLyAyMCUgZmFzdGVyLiBVbmZvcnR1bmF0ZWx5LCBnZXRBbGwoKSBkb2VzIG5vdCBzdXBwb3J0IGN1c3RvbSBpbmRpY2VzLlxyXG4gICAgICAgIGlmICghaXRlcmF0ZU9wdGlvbnMuaW5kZXggJiYgdHlwZW9mIHRoaXMuc3RvcmUuZ2V0QWxsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnN0b3JlLmdldEFsbChpdGVyYXRlT3B0aW9ucy5yYW5nZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5jdXJzb3IoaXRlcmF0ZU9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGVDdXJzb3IoY3Vyc29yLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgfSkubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVsZXRlQWxsKGluZGV4T3JSYW5nZSwgcmFuZ2UpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGgsICdERUxFVEUgQUxMJywgdGhpcy5zdG9yZS5uYW1lKTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zKGluZGV4T3JSYW5nZSwgcmFuZ2UpO1xyXG4gICAgICAgIG9wdGlvbnMua2V5c09ubHkgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmN1cnNvcihvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlQ3Vyc29yKGN1cnNvciwgKGtleSwgdmFsdWUsIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgLy8gTk9URTogQ2FsbGluZyBkZWxldGUoKSBvbiBhIGN1cnNvciBpcyBkb2N1bWVudGVkIGFzIG1vcmUgZWZmaWNpZW50IHRoYW5cclxuICAgICAgICAgICAgLy8gY2FsbGluZyBkZWxldGUoKSBvbiBhbiBvYmplY3Qgc3RvcmUgd2l0aCBhIHNpbmdsZSBrZXlcclxuICAgICAgICAgICAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JREJPYmplY3RTdG9yZS9kZWxldGUpLFxyXG4gICAgICAgICAgICAvLyBob3dldmVyLCB0aGlzIHJlcXVpcmVzIHVzICpub3QqIHRvIHVzZSBhIGtleXNPbmx5IGN1cnNvclxyXG4gICAgICAgICAgICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0lEQkN1cnNvci9kZWxldGUpLiBXZVxyXG4gICAgICAgICAgICAvLyBtYXkgd2FudCB0byBjb21wYXJlIHRoZSBwZXJmb3JtYW5jZSBvZiBlYWNoIG1ldGhvZC5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wuZGVsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpdGVyYXRlKG9wdGlvbnNPckNhbGxiYWNrLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGxldCBvcHRpb25zO1xyXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNPckNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmN1cnNvcihvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlQ3Vyc29yKGN1cnNvciwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGEgc3RvcmUsIGJ1dCB3YWl0cyBmb3IgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIGNvbXBsZXRlIGZvclxyXG4gICAgICogZWFjaCBlbnRyeSBiZWZvcmUgaXRlcmF0aW5nIHRoZSBuZXh0IGVudHJ5LiBUaGlzIGFsbG93cyB0aGUgY2FsbGJhY2sgdG8gZG9cclxuICAgICAqIGFzeW5jaHJvbm91cyB3b3JrIHRvIGRldGVybWluZSBpZiB0aGlzIGl0ZXJhdGlvbiBzaG91bGQgY29udGludWUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHByb3ZpZGVkIGNhbGxiYWNrIHNob3VsZCByZXR1cm4gYHRydWVgIHRvIGNvbnRpbnVlIGl0ZXJhdGlvbiwgYW5kXHJcbiAgICAgKiBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXRlcmF0ZVNlcmlhbChjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGN1cnNvclJlcXVlc3QgPSB0aGlzLmN1cnNvcih7fSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tGb3JBbmRSZXBvcnRpT1NFcnJvcihldmVudC50YXJnZXQuZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yLnZhbHVlKS5uZXh0KHNob3VsZENvbnRpbnVlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQ29udGludWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpdGVyYXRlQ3Vyc29yKGN1cnNvclJlcXVlc3QsIGZuKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdC5vbnN1Y2Nlc3MgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEl0ZXJhdGlvbkNvbnRyb2xsZXIoY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZXN1bHQgPSBmbihjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yLnZhbHVlLCBjb250cm9sbGVyKTtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VyUmVzdWx0IGluc3RhbmNlb2YgUGVyc2lzdGVuY2VQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclByb21pc2UgPSB1c2VyUmVzdWx0LmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh1c2VyUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5pc0RvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250cm9sbGVyLnNraXBUb0tleSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKGNvbnRyb2xsZXIuc2tpcFRvS2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KS5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHJlc3VsdHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb3B0aW9ucyhpbmRleE9yUmFuZ2UsIHJhbmdlKSB7XHJcbiAgICAgICAgbGV0IGluZGV4TmFtZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAoaW5kZXhPclJhbmdlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yUmFuZ2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleE5hbWUgPSBpbmRleE9yUmFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByYW5nZSA9IGluZGV4T3JSYW5nZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBpbmRleDogaW5kZXhOYW1lLCByYW5nZSB9O1xyXG4gICAgfVxyXG4gICAgY3Vyc29yKG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgZGlyZWN0aW9uID0gJ25leHQnO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3ByZXYnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5pbmRleCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RvcmUuaW5kZXgob3B0aW9ucy5pbmRleCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleXNPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXgub3BlbktleUN1cnNvcihvcHRpb25zLnJhbmdlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4Lm9wZW5DdXJzb3Iob3B0aW9ucy5yYW5nZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUub3BlbkN1cnNvcihvcHRpb25zLnJhbmdlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogV3JhcHMgYW4gSURCUmVxdWVzdCBpbiBhIFBlcnNpc3RlbmNlUHJvbWlzZSwgdXNpbmcgdGhlIG9uc3VjY2VzcyAvIG9uZXJyb3JcclxuICogaGFuZGxlcnMgdG8gcmVzb2x2ZSAvIHJlamVjdCB0aGUgUGVyc2lzdGVuY2VQcm9taXNlIGFzIGFwcHJvcHJpYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JhcFJlcXVlc3QocmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKTtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cclxuLy8gR3VhcmQgc28gd2Ugb25seSByZXBvcnQgdGhlIGVycm9yIG9uY2UuXHJcbmxldCByZXBvcnRlZElPU0Vycm9yID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGNoZWNrRm9yQW5kUmVwb3J0aU9TRXJyb3IoZXJyb3IpIHtcclxuICAgIGNvbnN0IGlPU1ZlcnNpb24gPSBTaW1wbGVEYi5nZXRJT1NWZXJzaW9uKGdldFVBKCkpO1xyXG4gICAgaWYgKGlPU1ZlcnNpb24gPj0gMTIuMiAmJiBpT1NWZXJzaW9uIDwgMTMpIHtcclxuICAgICAgICBjb25zdCBJT1NfRVJST1IgPSAnQW4gaW50ZXJuYWwgZXJyb3Igd2FzIGVuY291bnRlcmVkIGluIHRoZSBJbmRleGVkIERhdGFiYXNlIHNlcnZlcic7XHJcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5kZXhPZihJT1NfRVJST1IpID49IDApIHtcclxuICAgICAgICAgICAgLy8gV3JhcCBlcnJvciBpbiBhIG1vcmUgZGVzY3JpcHRpdmUgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBuZXdFcnJvciA9IG5ldyBGaXJlc3RvcmVFcnJvcignaW50ZXJuYWwnLCBgSU9TX0lOREVYRUREQl9CVUcxOiBJbmRleGVkRGIgaGFzIHRocm93biAnJHtJT1NfRVJST1J9Jy4gVGhpcyBpcyBsaWtlbHkgYCArXHJcbiAgICAgICAgICAgICAgICBgZHVlIHRvIGFuIHVuYXZvaWRhYmxlIGJ1ZyBpbiBpT1MuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvNTY0OTYyOTYvMTEwOTE1IGAgK1xyXG4gICAgICAgICAgICAgICAgYGZvciBkZXRhaWxzIGFuZCBhIHBvdGVudGlhbCB3b3JrYXJvdW5kLmApO1xyXG4gICAgICAgICAgICBpZiAoIXJlcG9ydGVkSU9TRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlcG9ydGVkSU9TRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYSBnbG9iYWwgZXhjZXB0aW9uIG91dHNpZGUgb2YgdGhpcyBwcm9taXNlIGNoYWluLCBmb3IgdGhlIHVzZXIgdG9cclxuICAgICAgICAgICAgICAgIC8vIHBvdGVudGlhbGx5IGNhdGNoLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3RXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3RXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVycm9yO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEluZGV4ZWREYlRyYW5zYWN0aW9uIGV4dGVuZHMgUGVyc2lzdGVuY2VUcmFuc2FjdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihzaW1wbGVEYlRyYW5zYWN0aW9uLCBjdXJyZW50U2VxdWVuY2VOdW1iZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc2ltcGxlRGJUcmFuc2FjdGlvbiA9IHNpbXBsZURiVHJhbnNhY3Rpb247XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2VOdW1iZXIgPSBjdXJyZW50U2VxdWVuY2VOdW1iZXI7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3RvcmUodHhuLCBzdG9yZSkge1xyXG4gICAgY29uc3QgaW5kZXhlZERiVHJhbnNhY3Rpb24gPSBkZWJ1Z0Nhc3QodHhuKTtcclxuICAgIHJldHVybiBTaW1wbGVEYi5nZXRTdG9yZShpbmRleGVkRGJUcmFuc2FjdGlvbi5zaW1wbGVEYlRyYW5zYWN0aW9uLCBzdG9yZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBgbkJ5dGVzYCBvZiByYW5kb20gYnl0ZXMuXHJcbiAqXHJcbiAqIElmIGBuQnl0ZXMgPCAwYCAsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG4gKi9cclxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMobkJ5dGVzKSB7XHJcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMkMShuQnl0ZXMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEF1dG9JZCB7XHJcbiAgICBzdGF0aWMgbmV3SWQoKSB7XHJcbiAgICAgICAgLy8gQWxwaGFudW1lcmljIGNoYXJhY3RlcnNcclxuICAgICAgICBjb25zdCBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XHJcbiAgICAgICAgLy8gVGhlIGxhcmdlc3QgYnl0ZSB2YWx1ZSB0aGF0IGlzIGEgbXVsdGlwbGUgb2YgYGNoYXIubGVuZ3RoYC5cclxuICAgICAgICBjb25zdCBtYXhNdWx0aXBsZSA9IE1hdGguZmxvb3IoMjU2IC8gY2hhcnMubGVuZ3RoKSAqIGNoYXJzLmxlbmd0aDtcclxuICAgICAgICBsZXQgYXV0b0lkID0gJyc7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0TGVuZ3RoID0gMjA7XHJcbiAgICAgICAgd2hpbGUgKGF1dG9JZC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByYW5kb21CeXRlcyg0MCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWNjZXB0IHZhbHVlcyB0aGF0IGFyZSBbMCwgbWF4TXVsdGlwbGUpLCB0aGlzIGVuc3VyZXMgdGhleSBjYW5cclxuICAgICAgICAgICAgICAgIC8vIGJlIGV2ZW5seSBtYXBwZWQgdG8gaW5kaWNlcyBvZiBgY2hhcnNgIHZpYSBhIG1vZHVsbyBvcGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICBpZiAoYXV0b0lkLmxlbmd0aCA8IHRhcmdldExlbmd0aCAmJiBieXRlc1tpXSA8IG1heE11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b0lkICs9IGNoYXJzLmNoYXJBdChieXRlc1tpXSAlIGNoYXJzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF1dG9JZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdCA8IHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQgPiByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuLyoqIEhlbHBlciB0byBjb21wYXJlIGFycmF5cyB1c2luZyBpc0VxdWFsKCkuICovXHJcbmZ1bmN0aW9uIGFycmF5RXF1YWxzKGxlZnQsIHJpZ2h0LCBjb21wYXJhdG9yKSB7XHJcbiAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWZ0LmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IGNvbXBhcmF0b3IodmFsdWUsIHJpZ2h0W2luZGV4XSkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbW1lZGlhdGUgbGV4aWNvZ3JhcGhpY2FsbHktZm9sbG93aW5nIHN0cmluZy4gVGhpcyBpcyB1c2VmdWwgdG9cclxuICogY29uc3RydWN0IGFuIGluY2x1c2l2ZSByYW5nZSBmb3IgaW5kZXhlZGRiIGl0ZXJhdG9ycy5cclxuICovXHJcbmZ1bmN0aW9uIGltbWVkaWF0ZVN1Y2Nlc3NvcihzKSB7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGlucHV0IHN0cmluZywgd2l0aCBhbiBhZGRpdGlvbmFsIE5VTCBieXRlIGFwcGVuZGVkLlxyXG4gICAgcmV0dXJuIHMgKyAnXFwwJztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBUaGUgZWFybGllc3QgZGF0ZSBzdXBwb3J0ZWQgYnkgRmlyZXN0b3JlIHRpbWVzdGFtcHMgKDAwMDEtMDEtMDFUMDA6MDA6MDBaKS5cclxuY29uc3QgTUlOX1NFQ09ORFMgPSAtNjIxMzU1OTY4MDA7XHJcbi8vIE51bWJlciBvZiBuYW5vc2Vjb25kcyBpbiBhIG1pbGxpc2Vjb25kLlxyXG5jb25zdCBNU19UT19OQU5PUyA9IDFlNjtcclxuLyoqXHJcbiAqIEEgYFRpbWVzdGFtcGAgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUgaW5kZXBlbmRlbnQgb2YgYW55IHRpbWUgem9uZSBvclxyXG4gKiBjYWxlbmRhciwgcmVwcmVzZW50ZWQgYXMgc2Vjb25kcyBhbmQgZnJhY3Rpb25zIG9mIHNlY29uZHMgYXQgbmFub3NlY29uZFxyXG4gKiByZXNvbHV0aW9uIGluIFVUQyBFcG9jaCB0aW1lLlxyXG4gKlxyXG4gKiBJdCBpcyBlbmNvZGVkIHVzaW5nIHRoZSBQcm9sZXB0aWMgR3JlZ29yaWFuIENhbGVuZGFyIHdoaWNoIGV4dGVuZHMgdGhlXHJcbiAqIEdyZWdvcmlhbiBjYWxlbmRhciBiYWNrd2FyZHMgdG8geWVhciBvbmUuIEl0IGlzIGVuY29kZWQgYXNzdW1pbmcgYWxsIG1pbnV0ZXNcclxuICogYXJlIDYwIHNlY29uZHMgbG9uZywgaS5lLiBsZWFwIHNlY29uZHMgYXJlIFwic21lYXJlZFwiIHNvIHRoYXQgbm8gbGVhcCBzZWNvbmRcclxuICogdGFibGUgaXMgbmVlZGVkIGZvciBpbnRlcnByZXRhdGlvbi4gUmFuZ2UgaXMgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0b1xyXG4gKiA5OTk5LTEyLTMxVDIzOjU5OjU5Ljk5OTk5OTk5OVouXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlcyBhbmQgZnVydGhlciBzcGVjaWZpY2F0aW9ucywgcmVmZXIgdG8gdGhlXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL3Byb3RvYnVmL2Jsb2IvbWFzdGVyL3NyYy9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvIHwgVGltZXN0YW1wIGRlZmluaXRpb259LlxyXG4gKi9cclxuY2xhc3MgVGltZXN0YW1wIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0aW1lc3RhbXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNlY29uZHMgLSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaFxyXG4gICAgICogICAgIDE5NzAtMDEtMDFUMDA6MDA6MDBaLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cclxuICAgICAqICAgICA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuXHJcbiAgICAgKiBAcGFyYW0gbmFub3NlY29uZHMgLSBUaGUgbm9uLW5lZ2F0aXZlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kXHJcbiAgICAgKiAgICAgcmVzb2x1dGlvbi4gTmVnYXRpdmUgc2Vjb25kIHZhbHVlcyB3aXRoIGZyYWN0aW9ucyBtdXN0IHN0aWxsIGhhdmVcclxuICAgICAqICAgICBub24tbmVnYXRpdmUgbmFub3NlY29uZHMgdmFsdWVzIHRoYXQgY291bnQgZm9yd2FyZCBpbiB0aW1lLiBNdXN0IGJlXHJcbiAgICAgKiAgICAgZnJvbSAwIHRvIDk5OSw5OTksOTk5IGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBvZiBVVEMgdGltZSBzaW5jZSBVbml4IGVwb2NoIDE5NzAtMDEtMDFUMDA6MDA6MDBaLlxyXG4gICAgICovXHJcbiAgICBzZWNvbmRzLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyYWN0aW9ucyBvZiBhIHNlY29uZCBhdCBuYW5vc2Vjb25kIHJlc29sdXRpb24uKlxyXG4gICAgICovXHJcbiAgICBuYW5vc2Vjb25kcykge1xyXG4gICAgICAgIHRoaXMuc2Vjb25kcyA9IHNlY29uZHM7XHJcbiAgICAgICAgdGhpcy5uYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzO1xyXG4gICAgICAgIGlmIChuYW5vc2Vjb25kcyA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBuYW5vc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBuYW5vc2Vjb25kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuYW5vc2Vjb25kcyA+PSAxZTkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBuYW5vc2Vjb25kcyBvdXQgb2YgcmFuZ2U6ICcgKyBuYW5vc2Vjb25kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWNvbmRzIDwgTUlOX1NFQ09ORFMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1RpbWVzdGFtcCBzZWNvbmRzIG91dCBvZiByYW5nZTogJyArIHNlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGlzIHdpbGwgYnJlYWsgaW4gdGhlIHllYXIgMTAsMDAwLlxyXG4gICAgICAgIGlmIChzZWNvbmRzID49IDI1MzQwMjMwMDgwMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVGltZXN0YW1wIHNlY29uZHMgb3V0IG9mIHJhbmdlOiAnICsgc2Vjb25kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCB3aXRoIHRoZSBjdXJyZW50IGRhdGUsIHdpdGggbWlsbGlzZWNvbmQgcHJlY2lzaW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGEgbmV3IHRpbWVzdGFtcCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgZGF0ZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5vdygpIHtcclxuICAgICAgICByZXR1cm4gVGltZXN0YW1wLmZyb21NaWxsaXMoRGF0ZS5ub3coKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGltZXN0YW1wIGZyb20gdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBpbml0aWFsaXplIHRoZSBgVGltZXN0YW1wYCBmcm9tLlxyXG4gICAgICogQHJldHVybnMgQSBuZXcgYFRpbWVzdGFtcGAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXMgdGhlIGdpdmVuXHJcbiAgICAgKiAgICAgZGF0ZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21EYXRlKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gVGltZXN0YW1wLmZyb21NaWxsaXMoZGF0ZS5nZXRUaW1lKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRpbWVzdGFtcCBmcm9tIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtaWxsaXNlY29uZHMgLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2hcclxuICAgICAqICAgICAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cclxuICAgICAqIEByZXR1cm5zIEEgbmV3IGBUaW1lc3RhbXBgIHJlcHJlc2VudGluZyB0aGUgc2FtZSBwb2ludCBpbiB0aW1lIGFzIHRoZSBnaXZlblxyXG4gICAgICogICAgIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tTWlsbGlzKG1pbGxpc2Vjb25kcykge1xyXG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xyXG4gICAgICAgIGNvbnN0IG5hbm9zID0gTWF0aC5mbG9vcigobWlsbGlzZWNvbmRzIC0gc2Vjb25kcyAqIDEwMDApICogTVNfVE9fTkFOT1MpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHNlY29uZHMsIG5hbm9zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBgVGltZXN0YW1wYCB0byBhIEphdmFTY3JpcHQgYERhdGVgIG9iamVjdC4gVGhpcyBjb252ZXJzaW9uXHJcbiAgICAgKiBjYXVzZXMgYSBsb3NzIG9mIHByZWNpc2lvbiBzaW5jZSBgRGF0ZWAgb2JqZWN0cyBvbmx5IHN1cHBvcnQgbWlsbGlzZWNvbmRcclxuICAgICAqIHByZWNpc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBKYXZhU2NyaXB0IGBEYXRlYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHBvaW50IGluIHRpbWUgYXNcclxuICAgICAqICAgICB0aGlzIGBUaW1lc3RhbXBgLCB3aXRoIG1pbGxpc2Vjb25kIHByZWNpc2lvbi5cclxuICAgICAqL1xyXG4gICAgdG9EYXRlKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnRvTWlsbGlzKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIGBUaW1lc3RhbXBgIHRvIGEgbnVtZXJpYyB0aW1lc3RhbXAgKGluIG1pbGxpc2Vjb25kcyBzaW5jZVxyXG4gICAgICogZXBvY2gpLiBUaGlzIG9wZXJhdGlvbiBjYXVzZXMgYSBsb3NzIG9mIHByZWNpc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcG9pbnQgaW4gdGltZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgdGltZXN0YW1wLCByZXByZXNlbnRlZCBhc1xyXG4gICAgICogICAgIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2ggMTk3MC0wMS0wMVQwMDowMDowMFouXHJcbiAgICAgKi9cclxuICAgIHRvTWlsbGlzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlY29uZHMgKiAxMDAwICsgdGhpcy5uYW5vc2Vjb25kcyAvIE1TX1RPX05BTk9TO1xyXG4gICAgfVxyXG4gICAgX2NvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZHMgPT09IG90aGVyLnNlY29uZHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IodGhpcy5uYW5vc2Vjb25kcywgb3RoZXIubmFub3NlY29uZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLnNlY29uZHMsIG90aGVyLnNlY29uZHMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgVGltZXN0YW1wYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBgVGltZXN0YW1wYCB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYFRpbWVzdGFtcGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cclxuICAgICAqL1xyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIuc2Vjb25kcyA9PT0gdGhpcy5zZWNvbmRzICYmIG90aGVyLm5hbm9zZWNvbmRzID09PSB0aGlzLm5hbm9zZWNvbmRzKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGBUaW1lc3RhbXBgLiAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgnVGltZXN0YW1wKHNlY29uZHM9JyArXHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcyArXHJcbiAgICAgICAgICAgICcsIG5hbm9zZWNvbmRzPScgK1xyXG4gICAgICAgICAgICB0aGlzLm5hbm9zZWNvbmRzICtcclxuICAgICAgICAgICAgJyknKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgVGltZXN0YW1wYC4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBzZWNvbmRzOiB0aGlzLnNlY29uZHMsIG5hbm9zZWNvbmRzOiB0aGlzLm5hbm9zZWNvbmRzIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgb2JqZWN0IHRvIGEgcHJpbWl0aXZlIHN0cmluZywgd2hpY2ggYWxsb3dzIGBUaW1lc3RhbXBgIG9iamVjdHNcclxuICAgICAqIHRvIGJlIGNvbXBhcmVkIHVzaW5nIHRoZSBgPmAsIGA8PWAsIGA+PWAgYW5kIGA+YCBvcGVyYXRvcnMuXHJcbiAgICAgKi9cclxuICAgIHZhbHVlT2YoKSB7XHJcbiAgICAgICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBvZiB0aGUgZm9ybSA8c2Vjb25kcz4uPG5hbm9zZWNvbmRzPiB3aGVyZVxyXG4gICAgICAgIC8vIDxzZWNvbmRzPiBpcyB0cmFuc2xhdGVkIHRvIGhhdmUgYSBub24tbmVnYXRpdmUgdmFsdWUgYW5kIGJvdGggPHNlY29uZHM+XHJcbiAgICAgICAgLy8gYW5kIDxuYW5vc2Vjb25kcz4gYXJlIGxlZnQtcGFkZGVkIHdpdGggemVyb2VzIHRvIGJlIGEgY29uc2lzdGVudCBsZW5ndGguXHJcbiAgICAgICAgLy8gU3RyaW5ncyB3aXRoIHRoaXMgZm9ybWF0IHRoZW4gaGF2ZSBhIGxleGlvZ3JhcGhpY2FsIG9yZGVyaW5nIHRoYXQgbWF0Y2hlc1xyXG4gICAgICAgIC8vIHRoZSBleHBlY3RlZCBvcmRlcmluZy4gVGhlIDxzZWNvbmRzPiB0cmFuc2xhdGlvbiBpcyBkb25lIHRvIGF2b2lkIGhhdmluZ1xyXG4gICAgICAgIC8vIGEgbGVhZGluZyBuZWdhdGl2ZSBzaWduIChpLmUuIGEgbGVhZGluZyAnLScgY2hhcmFjdGVyKSBpbiBpdHMgc3RyaW5nXHJcbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdoaWNoIHdvdWxkIGFmZmVjdCBpdHMgbGV4aW9ncmFwaGljYWwgb3JkZXJpbmcuXHJcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRTZWNvbmRzID0gdGhpcy5zZWNvbmRzIC0gTUlOX1NFQ09ORFM7XHJcbiAgICAgICAgLy8gTm90ZTogVXAgdG8gMTIgZGVjaW1hbCBkaWdpdHMgYXJlIHJlcXVpcmVkIHRvIHJlcHJlc2VudCBhbGwgdmFsaWRcclxuICAgICAgICAvLyAnc2Vjb25kcycgdmFsdWVzLlxyXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFNlY29uZHMgPSBTdHJpbmcoYWRqdXN0ZWRTZWNvbmRzKS5wYWRTdGFydCgxMiwgJzAnKTtcclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWROYW5vc2Vjb25kcyA9IFN0cmluZyh0aGlzLm5hbm9zZWNvbmRzKS5wYWRTdGFydCg5LCAnMCcpO1xyXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTZWNvbmRzICsgJy4nICsgZm9ybWF0dGVkTmFub3NlY29uZHM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGluIEZpcmVzdG9yZS4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgdmVyc2lvblxyXG4gKiB0aW1lc3RhbXAsIHN1Y2ggYXMgdXBkYXRlX3RpbWUgb3IgcmVhZF90aW1lLlxyXG4gKi9cclxuY2xhc3MgU25hcHNob3RWZXJzaW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHRpbWVzdGFtcCkge1xyXG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21UaW1lc3RhbXAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNuYXBzaG90VmVyc2lvbih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWluKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU25hcHNob3RWZXJzaW9uKG5ldyBUaW1lc3RhbXAoMCwgMCkpO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLl9jb21wYXJlVG8ob3RoZXIudGltZXN0YW1wKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXAuaXNFcXVhbChvdGhlci50aW1lc3RhbXApO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlcnNpb24gZm9yIHVzZSBpbiBzcGVjIHRlc3RzLiAqL1xyXG4gICAgdG9NaWNyb3NlY29uZHMoKSB7XHJcbiAgICAgICAgLy8gQ29udmVydCB0byBtaWNyb3NlY29uZHMuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wLnNlY29uZHMgKiAxZTYgKyB0aGlzLnRpbWVzdGFtcC5uYW5vc2Vjb25kcyAvIDEwMDA7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJ1NuYXBzaG90VmVyc2lvbignICsgdGhpcy50aW1lc3RhbXAudG9TdHJpbmcoKSArICcpJztcclxuICAgIH1cclxuICAgIHRvVGltZXN0YW1wKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVzdGFtcDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBvYmplY3RTaXplKG9iaikge1xyXG4gICAgbGV0IGNvdW50ID0gMDtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvdW50O1xyXG59XHJcbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgZm4oa2V5LCBvYmpba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgc2V0IG9mIGZpZWxkcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHBhcnRpYWxseSBwYXRjaCBhIGRvY3VtZW50LlxyXG4gKiBGaWVsZE1hc2sgaXMgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIE9iamVjdFZhbHVlLlxyXG4gKiBFeGFtcGxlczpcclxuICogICBmb28gLSBPdmVyd3JpdGVzIGZvbyBlbnRpcmVseSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS4gSWYgZm9vIGlzIG5vdFxyXG4gKiAgICAgICAgIHByZXNlbnQgaW4gdGhlIGNvbXBhbmlvbiBPYmplY3RWYWx1ZSwgdGhlIGZpZWxkIGlzIGRlbGV0ZWQuXHJcbiAqICAgZm9vLmJhciAtIE92ZXJ3cml0ZXMgb25seSB0aGUgZmllbGQgYmFyIG9mIHRoZSBvYmplY3QgZm9vLlxyXG4gKiAgICAgICAgICAgICBJZiBmb28gaXMgbm90IGFuIG9iamVjdCwgZm9vIGlzIHJlcGxhY2VkIHdpdGggYW4gb2JqZWN0XHJcbiAqICAgICAgICAgICAgIGNvbnRhaW5pbmcgZm9vXHJcbiAqL1xyXG5jbGFzcyBGaWVsZE1hc2sge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XHJcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiB2YWxpZGF0aW9uIG9mIEZpZWxkTWFza1xyXG4gICAgICAgIC8vIFNvcnQgdGhlIGZpZWxkIG1hc2sgdG8gc3VwcG9ydCBgRmllbGRNYXNrLmlzRXF1YWwoKWAgYW5kIGFzc2VydCBiZWxvdy5cclxuICAgICAgICBmaWVsZHMuc29ydChGaWVsZFBhdGgkMS5jb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgdGhhdCBgZmllbGRQYXRoYCBpcyBpbmNsdWRlZCBieSBhdCBsZWFzdCBvbmUgZmllbGQgaW4gdGhpcyBmaWVsZFxyXG4gICAgICogbWFzay5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIGFuIE8obikgb3BlcmF0aW9uLCB3aGVyZSBgbmAgaXMgdGhlIHNpemUgb2YgdGhlIGZpZWxkIG1hc2suXHJcbiAgICAgKi9cclxuICAgIGNvdmVycyhmaWVsZFBhdGgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkTWFza1BhdGggb2YgdGhpcy5maWVsZHMpIHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkTWFza1BhdGguaXNQcmVmaXhPZihmaWVsZFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKHRoaXMuZmllbGRzLCBvdGhlci5maWVsZHMsIChsLCByKSA9PiBsLmlzRXF1YWwocikpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChlbmNvZGVkKSB7XHJcbiAgICAvLyBOb2RlIGFjdHVhbGx5IGRvZXNuJ3QgdmFsaWRhdGUgYmFzZTY0IHN0cmluZ3MuXHJcbiAgICAvLyBBIHF1aWNrIHNhbml0eSBjaGVjayB0aGF0IGlzIG5vdCBhIGZvb2wtcHJvb2YgdmFsaWRhdGlvblxyXG4gICAgaWYgKC9bXi1BLVphLXowLTkrLz1dLy50ZXN0KGVuY29kZWQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ05vdCBhIHZhbGlkIEJhc2U2NCBzdHJpbmc6ICcgKyBlbmNvZGVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQnVmZmVyKGVuY29kZWQsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5Jyk7XHJcbn1cclxuLyoqIENvbnZlcnRzIGEgYmluYXJ5IHN0cmluZyB0byBhIEJhc2U2NCBlbmNvZGVkIHN0cmluZy4gKi9cclxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0KHJhdykge1xyXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIocmF3LCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG59XHJcbi8qKiBUcnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBCYXNlNjQgY29udmVyc2lvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZS4gKi9cclxuZnVuY3Rpb24gaXNCYXNlNjRBdmFpbGFibGUoKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW1tdXRhYmxlIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIFwicHJvdG9cIiBieXRlIHN0cmluZy5cclxuICpcclxuICogUHJvdG8gYnl0ZSBzdHJpbmdzIGNhbiBlaXRoZXIgYmUgQmFzZTY0LWVuY29kZWQgc3RyaW5ncyBvciBVaW50OEFycmF5cyB3aGVuXHJcbiAqIHNlbnQgb24gdGhlIHdpcmUuIFRoaXMgY2xhc3MgYWJzdHJhY3RzIGF3YXkgdGhpcyBkaWZmZXJlbnRpYXRpb24gYnkgaG9sZGluZ1xyXG4gKiB0aGUgcHJvdG8gYnl0ZSBzdHJpbmcgaW4gYSBjb21tb24gY2xhc3MgdGhhdCBtdXN0IGJlIGNvbnZlcnRlZCBpbnRvIGEgc3RyaW5nXHJcbiAqIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgcHJvdG8uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgQnl0ZVN0cmluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihiaW5hcnlTdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmJpbmFyeVN0cmluZyA9IGJpbmFyeVN0cmluZztcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tQmFzZTY0U3RyaW5nKGJhc2U2NCkge1xyXG4gICAgICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGRlY29kZUJhc2U2NChiYXNlNjQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQnl0ZVN0cmluZyhiaW5hcnlTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycmF5KSB7XHJcbiAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYmluYXJ5U3RyaW5nRnJvbVVpbnQ4QXJyYXkoYXJyYXkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQnl0ZVN0cmluZyhiaW5hcnlTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgdGhpcy5iaW5hcnlTdHJpbmcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMuYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSsrKSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB0b0Jhc2U2NCgpIHtcclxuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTY0KHRoaXMuYmluYXJ5U3RyaW5nKTtcclxuICAgIH1cclxuICAgIHRvVWludDhBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gdWludDhBcnJheUZyb21CaW5hcnlTdHJpbmcodGhpcy5iaW5hcnlTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgYXBwcm94aW1hdGVCeXRlU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlTdHJpbmcubGVuZ3RoICogMjtcclxuICAgIH1cclxuICAgIGNvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuYmluYXJ5U3RyaW5nLCBvdGhlci5iaW5hcnlTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVN0cmluZyA9PT0gb3RoZXIuYmluYXJ5U3RyaW5nO1xyXG4gICAgfVxyXG59XHJcbkJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcgPSBuZXcgQnl0ZVN0cmluZygnJyk7XHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBhbiBVaW50OGFycmF5IHRvIGEgYmluYXJ5IHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGJpbmFyeVN0cmluZ0Zyb21VaW50OEFycmF5KGFycmF5KSB7XHJcbiAgICBsZXQgYmluYXJ5U3RyaW5nID0gJyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYmluYXJ5U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJpbmFyeVN0cmluZztcclxufVxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBiaW5hcnkgc3RyaW5nIHRvIGFuIFVpbnQ4QXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB1aW50OEFycmF5RnJvbUJpbmFyeVN0cmluZyhiaW5hcnlTdHJpbmcpIHtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBidWZmZXJbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBidWZmZXI7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQSBSZWdFeHAgbWF0Y2hpbmcgSVNPIDg2MDEgVVRDIHRpbWVzdGFtcHMgd2l0aCBvcHRpb25hbCBmcmFjdGlvbi5cclxuY29uc3QgSVNPX1RJTUVTVEFNUF9SRUdfRVhQID0gbmV3IFJlZ0V4cCgvXlxcZHs0fS1cXGRcXGQtXFxkXFxkVFxcZFxcZDpcXGRcXGQ6XFxkXFxkKD86XFwuKFxcZCspKT9aJC8pO1xyXG4vKipcclxuICogQ29udmVydHMgdGhlIHBvc3NpYmxlIFByb3RvIHZhbHVlcyBmb3IgYSB0aW1lc3RhbXAgdmFsdWUgaW50byBhIFwic2Vjb25kcyBhbmRcclxuICogbmFub3NcIiByZXByZXNlbnRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWVzdGFtcChkYXRlKSB7XHJcbiAgICBoYXJkQXNzZXJ0KCEhZGF0ZSk7XHJcbiAgICAvLyBUaGUganNvbiBpbnRlcmZhY2UgKGZvciB0aGUgYnJvd3Nlcikgd2lsbCByZXR1cm4gYW4gaXNvIHRpbWVzdGFtcCBzdHJpbmcsXHJcbiAgICAvLyB3aGlsZSB0aGUgcHJvdG8ganMgbGlicmFyeSAoZm9yIG5vZGUpIHdpbGwgcmV0dXJuIGFcclxuICAgIC8vIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgaW5zdGFuY2UuXHJcbiAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gVGhlIGRhdGUgc3RyaW5nIGNhbiBoYXZlIGhpZ2hlciBwcmVjaXNpb24gKG5hbm9zKSB0aGFuIHRoZSBEYXRlIGNsYXNzXHJcbiAgICAgICAgLy8gKG1pbGxpcyksIHNvIHdlIGRvIHNvbWUgY3VzdG9tIHBhcnNpbmcgaGVyZS5cclxuICAgICAgICAvLyBQYXJzZSB0aGUgbmFub3MgcmlnaHQgb3V0IG9mIHRoZSBzdHJpbmcuXHJcbiAgICAgICAgbGV0IG5hbm9zID0gMDtcclxuICAgICAgICBjb25zdCBmcmFjdGlvbiA9IElTT19USU1FU1RBTVBfUkVHX0VYUC5leGVjKGRhdGUpO1xyXG4gICAgICAgIGhhcmRBc3NlcnQoISFmcmFjdGlvbik7XHJcbiAgICAgICAgaWYgKGZyYWN0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgIC8vIFBhZCB0aGUgZnJhY3Rpb24gb3V0IHRvIDkgZGlnaXRzIChuYW5vcykuXHJcbiAgICAgICAgICAgIGxldCBuYW5vU3RyID0gZnJhY3Rpb25bMV07XHJcbiAgICAgICAgICAgIG5hbm9TdHIgPSAobmFub1N0ciArICcwMDAwMDAwMDAnKS5zdWJzdHIoMCwgOSk7XHJcbiAgICAgICAgICAgIG5hbm9zID0gTnVtYmVyKG5hbm9TdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQYXJzZSB0aGUgZGF0ZSB0byBnZXQgdGhlIHNlY29uZHMuXHJcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLmZsb29yKHBhcnNlZERhdGUuZ2V0VGltZSgpIC8gMTAwMCk7XHJcbiAgICAgICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFRPRE8oYi8zNzI4MjIzNyk6IFVzZSBzdHJpbmdzIGZvciBQcm90bzMgdGltZXN0YW1wc1xyXG4gICAgICAgIC8vIGFzc2VydCghdGhpcy5vcHRpb25zLnVzZVByb3RvM0pzb24sXHJcbiAgICAgICAgLy8gICAnVGhlIHRpbWVzdGFtcCBpbnN0YW5jZSBmb3JtYXQgcmVxdWlyZXMgUHJvdG8gSlMuJyk7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IG5vcm1hbGl6ZU51bWJlcihkYXRlLnNlY29uZHMpO1xyXG4gICAgICAgIGNvbnN0IG5hbm9zID0gbm9ybWFsaXplTnVtYmVyKGRhdGUubmFub3MpO1xyXG4gICAgICAgIHJldHVybiB7IHNlY29uZHMsIG5hbm9zIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBwb3NzaWJsZSBQcm90byB0eXBlcyBmb3IgbnVtYmVycyBpbnRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXHJcbiAqIFJldHVybnMgMCBpZiB0aGUgdmFsdWUgaXMgbm90IG51bWVyaWMuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVOdW1iZXIodmFsdWUpIHtcclxuICAgIC8vIFRPRE8oYmpvcm5pY2spOiBIYW5kbGUgaW50NjQgZ3JlYXRlciB0aGFuIDUzIGJpdHMuXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcbi8qKiBDb252ZXJ0cyB0aGUgcG9zc2libGUgUHJvdG8gdHlwZXMgZm9yIEJsb2JzIGludG8gYSBCeXRlU3RyaW5nLiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVCeXRlU3RyaW5nKGJsb2IpIHtcclxuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gQnl0ZVN0cmluZy5mcm9tQmFzZTY0U3RyaW5nKGJsb2IpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkoYmxvYik7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBsb2NhbGx5LWFwcGxpZWQgU2VydmVyVGltZXN0YW1wLlxyXG4gKlxyXG4gKiBTZXJ2ZXIgVGltZXN0YW1wcyBhcmUgYmFja2VkIGJ5IE1hcFZhbHVlcyB0aGF0IGNvbnRhaW4gYW4gaW50ZXJuYWwgZmllbGRcclxuICogYF9fdHlwZV9fYCB3aXRoIGEgdmFsdWUgb2YgYHNlcnZlcl90aW1lc3RhbXBgLiBUaGUgcHJldmlvdXMgdmFsdWUgYW5kIGxvY2FsXHJcbiAqIHdyaXRlIHRpbWUgYXJlIHN0b3JlZCBpbiBpdHMgYF9fcHJldmlvdXNfdmFsdWVfX2AgYW5kIGBfX2xvY2FsX3dyaXRlX3RpbWVfX2BcclxuICogZmllbGRzIHJlc3BlY3RpdmVseS5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gU2VydmVyVGltZXN0YW1wVmFsdWUgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIGFzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYVxyXG4gKiAgIHRyYW5zZm9ybS4gVGhleSBjYW4gb25seSBleGlzdCBpbiB0aGUgbG9jYWwgdmlldyBvZiBhIGRvY3VtZW50LiBUaGVyZWZvcmVcclxuICogICB0aGV5IGRvIG5vdCBuZWVkIHRvIGJlIHBhcnNlZCBvciBzZXJpYWxpemVkLlxyXG4gKiAtIFdoZW4gZXZhbHVhdGVkIGxvY2FsbHkgKGUuZy4gZm9yIHNuYXBzaG90LmRhdGEoKSksIHRoZXkgYnkgZGVmYXVsdFxyXG4gKiAgIGV2YWx1YXRlIHRvIGBudWxsYC4gVGhpcyBiZWhhdmlvciBjYW4gYmUgY29uZmlndXJlZCBieSBwYXNzaW5nIGN1c3RvbVxyXG4gKiAgIEZpZWxkVmFsdWVPcHRpb25zIHRvIHZhbHVlKCkuXHJcbiAqIC0gV2l0aCByZXNwZWN0IHRvIG90aGVyIFNlcnZlclRpbWVzdGFtcFZhbHVlcywgdGhleSBzb3J0IGJ5IHRoZWlyXHJcbiAqICAgbG9jYWxXcml0ZVRpbWUuXHJcbiAqL1xyXG5jb25zdCBTRVJWRVJfVElNRVNUQU1QX1NFTlRJTkVMID0gJ3NlcnZlcl90aW1lc3RhbXAnO1xyXG5jb25zdCBUWVBFX0tFWSA9ICdfX3R5cGVfXyc7XHJcbmNvbnN0IFBSRVZJT1VTX1ZBTFVFX0tFWSA9ICdfX3ByZXZpb3VzX3ZhbHVlX18nO1xyXG5jb25zdCBMT0NBTF9XUklURV9USU1FX0tFWSA9ICdfX2xvY2FsX3dyaXRlX3RpbWVfXyc7XHJcbmZ1bmN0aW9uIGlzU2VydmVyVGltZXN0YW1wKHZhbHVlKSB7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgY29uc3QgdHlwZSA9IChfYiA9ICgoKF9hID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLm1hcFZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmllbGRzKSB8fCB7fSlbVFlQRV9LRVldKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RyaW5nVmFsdWU7XHJcbiAgICByZXR1cm4gdHlwZSA9PT0gU0VSVkVSX1RJTUVTVEFNUF9TRU5USU5FTDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBTZXJ2ZXJUaW1lc3RhbXAgcHJvdG8gdmFsdWUgKHVzaW5nIHRoZSBpbnRlcm5hbCBmb3JtYXQpLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VydmVyVGltZXN0YW1wJDEobG9jYWxXcml0ZVRpbWUsIHByZXZpb3VzVmFsdWUpIHtcclxuICAgIGNvbnN0IG1hcFZhbHVlID0ge1xyXG4gICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICBbVFlQRV9LRVldOiB7XHJcbiAgICAgICAgICAgICAgICBzdHJpbmdWYWx1ZTogU0VSVkVSX1RJTUVTVEFNUF9TRU5USU5FTFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBbTE9DQUxfV1JJVEVfVElNRV9LRVldOiB7XHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXBWYWx1ZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHM6IGxvY2FsV3JpdGVUaW1lLnNlY29uZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFub3M6IGxvY2FsV3JpdGVUaW1lLm5hbm9zZWNvbmRzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcclxuICAgICAgICBtYXBWYWx1ZS5maWVsZHNbUFJFVklPVVNfVkFMVUVfS0VZXSA9IHByZXZpb3VzVmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBtYXBWYWx1ZSB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmllbGQgYmVmb3JlIHRoaXMgU2VydmVyVGltZXN0YW1wIHdhcyBzZXQuXHJcbiAqXHJcbiAqIFByZXNlcnZpbmcgdGhlIHByZXZpb3VzIHZhbHVlcyBhbGxvd3MgdGhlIHVzZXIgdG8gZGlzcGxheSB0aGUgbGFzdCByZXNvbGVkXHJcbiAqIHZhbHVlIHVudGlsIHRoZSBiYWNrZW5kIHJlc3BvbmRzIHdpdGggdGhlIHRpbWVzdGFtcC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFByZXZpb3VzVmFsdWUodmFsdWUpIHtcclxuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB2YWx1ZS5tYXBWYWx1ZS5maWVsZHNbUFJFVklPVVNfVkFMVUVfS0VZXTtcclxuICAgIGlmIChpc1NlcnZlclRpbWVzdGFtcChwcmV2aW91c1ZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRQcmV2aW91c1ZhbHVlKHByZXZpb3VzVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGxvY2FsIHRpbWUgYXQgd2hpY2ggdGhpcyB0aW1lc3RhbXAgd2FzIGZpcnN0IHNldC5cclxuICovXHJcbmZ1bmN0aW9uIGdldExvY2FsV3JpdGVUaW1lKHZhbHVlKSB7XHJcbiAgICBjb25zdCBsb2NhbFdyaXRlVGltZSA9IG5vcm1hbGl6ZVRpbWVzdGFtcCh2YWx1ZS5tYXBWYWx1ZS5maWVsZHNbTE9DQUxfV1JJVEVfVElNRV9LRVldLnRpbWVzdGFtcFZhbHVlKTtcclxuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKGxvY2FsV3JpdGVUaW1lLnNlY29uZHMsIGxvY2FsV3JpdGVUaW1lLm5hbm9zKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBEYXRhYmFzZUluZm8ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgRGF0YWJhc2VJbmZvIHVzaW5nIHRoZSBwcm92aWRlZCBob3N0LCBkYXRhYmFzZUlkIGFuZFxyXG4gICAgICogcGVyc2lzdGVuY2VLZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGFiYXNlSWQgLSBUaGUgZGF0YWJhc2UgdG8gdXNlLlxyXG4gICAgICogQHBhcmFtIGFwcElkIC0gVGhlIEZpcmViYXNlIEFwcCBJZC5cclxuICAgICAqIEBwYXJhbSBwZXJzaXN0ZW5jZUtleSAtIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgRmlyZXN0b3JlJ3MgbG9jYWxcclxuICAgICAqIHN0b3JhZ2UgKHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgZGF0YWJhc2VJZCkuXHJcbiAgICAgKiBAcGFyYW0gaG9zdCAtIFRoZSBGaXJlc3RvcmUgYmFja2VuZCBob3N0IHRvIGNvbm5lY3QgdG8uXHJcbiAgICAgKiBAcGFyYW0gc3NsIC0gV2hldGhlciB0byB1c2UgU1NMIHdoZW4gY29ubmVjdGluZy5cclxuICAgICAqIEBwYXJhbSBmb3JjZUxvbmdQb2xsaW5nIC0gV2hldGhlciB0byB1c2UgdGhlIGZvcmNlTG9uZ1BvbGxpbmcgb3B0aW9uXHJcbiAgICAgKiB3aGVuIHVzaW5nIFdlYkNoYW5uZWwgYXMgdGhlIG5ldHdvcmsgdHJhbnNwb3J0LlxyXG4gICAgICogQHBhcmFtIGF1dG9EZXRlY3RMb25nUG9sbGluZyAtIFdoZXRoZXIgdG8gdXNlIHRoZSBkZXRlY3RCdWZmZXJpbmdQcm94eVxyXG4gICAgICogb3B0aW9uIHdoZW4gdXNpbmcgV2ViQ2hhbm5lbCBhcyB0aGUgbmV0d29yayB0cmFuc3BvcnQuXHJcbiAgICAgKiBAcGFyYW0gdXNlRmV0Y2hTdHJlYW1zIFdoZXRoZXIgdG8gdXNlIHRoZSBGZXRjaCBBUEkgaW5zdGVhZCBvZlxyXG4gICAgICogWE1MSFRUUFJlcXVlc3RcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgYXBwSWQsIHBlcnNpc3RlbmNlS2V5LCBob3N0LCBzc2wsIGZvcmNlTG9uZ1BvbGxpbmcsIGF1dG9EZXRlY3RMb25nUG9sbGluZywgdXNlRmV0Y2hTdHJlYW1zKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcclxuICAgICAgICB0aGlzLmFwcElkID0gYXBwSWQ7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xyXG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgdGhpcy5zc2wgPSBzc2w7XHJcbiAgICAgICAgdGhpcy5mb3JjZUxvbmdQb2xsaW5nID0gZm9yY2VMb25nUG9sbGluZztcclxuICAgICAgICB0aGlzLmF1dG9EZXRlY3RMb25nUG9sbGluZyA9IGF1dG9EZXRlY3RMb25nUG9sbGluZztcclxuICAgICAgICB0aGlzLnVzZUZldGNoU3RyZWFtcyA9IHVzZUZldGNoU3RyZWFtcztcclxuICAgIH1cclxufVxyXG4vKiogVGhlIGRlZmF1bHQgZGF0YWJhc2UgbmFtZSBmb3IgYSBwcm9qZWN0LiAqL1xyXG5jb25zdCBERUZBVUxUX0RBVEFCQVNFX05BTUUgPSAnKGRlZmF1bHQpJztcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIGRhdGFiYXNlIElEIGEgRmlyZXN0b3JlIGNsaWVudCBpcyBhc3NvY2lhdGVkIHdpdGguXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgRGF0YWJhc2VJZCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9qZWN0SWQsIGRhdGFiYXNlKSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZSA9IGRhdGFiYXNlID8gZGF0YWJhc2UgOiBERUZBVUxUX0RBVEFCQVNFX05BTUU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhYmFzZUlkKCcnLCAnJyk7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEZWZhdWx0RGF0YWJhc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YWJhc2UgPT09IERFRkFVTFRfREFUQUJBU0VfTkFNRTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgRGF0YWJhc2VJZCAmJlxyXG4gICAgICAgICAgICBvdGhlci5wcm9qZWN0SWQgPT09IHRoaXMucHJvamVjdElkICYmXHJcbiAgICAgICAgICAgIG90aGVyLmRhdGFiYXNlID09PSB0aGlzLmRhdGFiYXNlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogU2VudGluZWwgdmFsdWUgdGhhdCBzb3J0cyBiZWZvcmUgYW55IE11dGF0aW9uIEJhdGNoIElELiAqL1xyXG5jb25zdCBCQVRDSElEX1VOS05PV04gPSAtMTtcclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBhIHZhcmlhYmxlIGlzIGVpdGhlciB1bmRlZmluZWQgb3IgbnVsbC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcclxufVxyXG4vKiogUmV0dXJucyB3aGV0aGVyIHRoZSB2YWx1ZSByZXByZXNlbnRzIC0wLiAqL1xyXG5mdW5jdGlvbiBpc05lZ2F0aXZlWmVybyh2YWx1ZSkge1xyXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSB2YWx1ZSBpcyAtMC4wLiBCYXNlZCBvbiBwb2x5ZmlsbCBmcm9tXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPT09IDEgLyAtMDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gaW50ZWdlciBhbmQgaW4gdGhlIHNhZmUgaW50ZWdlciByYW5nZVxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdCBmb3IgYmVpbmcgYW4gaW50ZWdlciBhbmQgaW4gdGhlIHNhZmUgcmFuZ2VcclxuICovXHJcbmZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmXHJcbiAgICAgICAgIWlzTmVnYXRpdmVaZXJvKHZhbHVlKSAmJlxyXG4gICAgICAgIHZhbHVlIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmXHJcbiAgICAgICAgdmFsdWUgPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIERvY3VtZW50S2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdGgpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21QYXRoKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50S2V5KFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHBhdGgpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhuYW1lKS5wb3BGaXJzdCg1KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShSZXNvdXJjZVBhdGguZW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbGxlY3Rpb25Hcm91cCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnBvcExhc3QoKS5sYXN0U2VnbWVudCgpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZG9jdW1lbnQgaXMgaW4gdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uSWQuICovXHJcbiAgICBoYXNDb2xsZWN0aW9uSWQoY29sbGVjdGlvbklkKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBhdGgubGVuZ3RoID49IDIgJiZcclxuICAgICAgICAgICAgdGhpcy5wYXRoLmdldCh0aGlzLnBhdGgubGVuZ3RoIC0gMikgPT09IGNvbGxlY3Rpb25JZCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBncm91cCAoaS5lLiB0aGUgbmFtZSBvZiB0aGUgcGFyZW50IGNvbGxlY3Rpb24pIGZvciB0aGlzIGtleS4gKi9cclxuICAgIGdldENvbGxlY3Rpb25Hcm91cCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLmdldCh0aGlzLnBhdGgubGVuZ3RoIC0gMik7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIHBhcmVudCBjb2xsZWN0aW9uLiAqL1xyXG4gICAgZ2V0Q29sbGVjdGlvblBhdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5wb3BMYXN0KCk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJiBSZXNvdXJjZVBhdGguY29tcGFyYXRvcih0aGlzLnBhdGgsIG90aGVyLnBhdGgpID09PSAwKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb21wYXJhdG9yKGsxLCBrMikge1xyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZVBhdGguY29tcGFyYXRvcihrMS5wYXRoLCBrMi5wYXRoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc0RvY3VtZW50S2V5KHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggJSAyID09PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGRvY3VtZW50IGtleSB3aXRoIHRoZSBnaXZlbiBzZWdtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VnbWVudHMgLSBUaGUgc2VnbWVudHMgb2YgdGhlIHBhdGggdG8gdGhlIGRvY3VtZW50XHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiBEb2N1bWVudEtleVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVNlZ21lbnRzKHNlZ21lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKHNlZ21lbnRzLnNsaWNlKCkpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBNQVhfVkFMVUUgPSB7XHJcbiAgICBtYXBWYWx1ZToge1xyXG4gICAgICAgIGZpZWxkczoge1xyXG4gICAgICAgICAgICAnX190eXBlX18nOiB7IHN0cmluZ1ZhbHVlOiAnX19tYXhfX18nIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKiBFeHRyYWN0cyB0aGUgYmFja2VuZCdzIHR5cGUgb3JkZXIgZm9yIHRoZSBwcm92aWRlZCB2YWx1ZS4gKi9cclxuZnVuY3Rpb24gdHlwZU9yZGVyKHZhbHVlKSB7XHJcbiAgICBpZiAoJ251bGxWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gMCAvKiBOdWxsVmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYm9vbGVhblZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAxIC8qIEJvb2xlYW5WYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlIHx8ICdkb3VibGVWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gMiAvKiBOdW1iZXJWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCd0aW1lc3RhbXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gMyAvKiBUaW1lc3RhbXBWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdzdHJpbmdWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gNSAvKiBTdHJpbmdWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiA2IC8qIEJsb2JWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gNyAvKiBSZWZWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiA4IC8qIEdlb1BvaW50VmFsdWUgKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gOSAvKiBBcnJheVZhbHVlICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ21hcFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDQgLyogU2VydmVyVGltZXN0YW1wVmFsdWUgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAxMCAvKiBPYmplY3RWYWx1ZSAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqIFRlc3RzIGBsZWZ0YCBhbmQgYHJpZ2h0YCBmb3IgZXF1YWxpdHkgYmFzZWQgb24gdGhlIGJhY2tlbmQgc2VtYW50aWNzLiAqL1xyXG5mdW5jdGlvbiB2YWx1ZUVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWZ0VHlwZSA9IHR5cGVPcmRlcihsZWZ0KTtcclxuICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHR5cGVPcmRlcihyaWdodCk7XHJcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAobGVmdFR5cGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogTnVsbFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjYXNlIDEgLyogQm9vbGVhblZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdC5ib29sZWFuVmFsdWUgPT09IHJpZ2h0LmJvb2xlYW5WYWx1ZTtcclxuICAgICAgICBjYXNlIDQgLyogU2VydmVyVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRMb2NhbFdyaXRlVGltZShsZWZ0KS5pc0VxdWFsKGdldExvY2FsV3JpdGVUaW1lKHJpZ2h0KSk7XHJcbiAgICAgICAgY2FzZSAzIC8qIFRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wRXF1YWxzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICBjYXNlIDUgLyogU3RyaW5nVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnN0cmluZ1ZhbHVlID09PSByaWdodC5zdHJpbmdWYWx1ZTtcclxuICAgICAgICBjYXNlIDYgLyogQmxvYlZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gYmxvYkVxdWFscyhsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgY2FzZSA3IC8qIFJlZlZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdC5yZWZlcmVuY2VWYWx1ZSA9PT0gcmlnaHQucmVmZXJlbmNlVmFsdWU7XHJcbiAgICAgICAgY2FzZSA4IC8qIEdlb1BvaW50VmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBnZW9Qb2ludEVxdWFscyhsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgY2FzZSAyIC8qIE51bWJlclZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyRXF1YWxzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICBjYXNlIDkgLyogQXJyYXlWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5RXF1YWxzKGxlZnQuYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10sIHJpZ2h0LmFycmF5VmFsdWUudmFsdWVzIHx8IFtdLCB2YWx1ZUVxdWFscyk7XHJcbiAgICAgICAgY2FzZSAxMCAvKiBPYmplY3RWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdEVxdWFscyhsZWZ0LCByaWdodCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0aW1lc3RhbXBFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmICh0eXBlb2YgbGVmdC50aW1lc3RhbXBWYWx1ZSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICB0eXBlb2YgcmlnaHQudGltZXN0YW1wVmFsdWUgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgbGVmdC50aW1lc3RhbXBWYWx1ZS5sZW5ndGggPT09IHJpZ2h0LnRpbWVzdGFtcFZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIFVzZSBzdHJpbmcgZXF1YWxpdHkgZm9yIElTTyA4NjAxIHRpbWVzdGFtcHNcclxuICAgICAgICByZXR1cm4gbGVmdC50aW1lc3RhbXBWYWx1ZSA9PT0gcmlnaHQudGltZXN0YW1wVmFsdWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWZ0VGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKGxlZnQudGltZXN0YW1wVmFsdWUpO1xyXG4gICAgY29uc3QgcmlnaHRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAocmlnaHQudGltZXN0YW1wVmFsdWUpO1xyXG4gICAgcmV0dXJuIChsZWZ0VGltZXN0YW1wLnNlY29uZHMgPT09IHJpZ2h0VGltZXN0YW1wLnNlY29uZHMgJiZcclxuICAgICAgICBsZWZ0VGltZXN0YW1wLm5hbm9zID09PSByaWdodFRpbWVzdGFtcC5uYW5vcyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VvUG9pbnRFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiAobm9ybWFsaXplTnVtYmVyKGxlZnQuZ2VvUG9pbnRWYWx1ZS5sYXRpdHVkZSkgPT09XHJcbiAgICAgICAgbm9ybWFsaXplTnVtYmVyKHJpZ2h0Lmdlb1BvaW50VmFsdWUubGF0aXR1ZGUpICYmXHJcbiAgICAgICAgbm9ybWFsaXplTnVtYmVyKGxlZnQuZ2VvUG9pbnRWYWx1ZS5sb25naXR1ZGUpID09PVxyXG4gICAgICAgICAgICBub3JtYWxpemVOdW1iZXIocmlnaHQuZ2VvUG9pbnRWYWx1ZS5sb25naXR1ZGUpKTtcclxufVxyXG5mdW5jdGlvbiBibG9iRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplQnl0ZVN0cmluZyhsZWZ0LmJ5dGVzVmFsdWUpLmlzRXF1YWwobm9ybWFsaXplQnl0ZVN0cmluZyhyaWdodC5ieXRlc1ZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gbnVtYmVyRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAoJ2ludGVnZXJWYWx1ZScgaW4gbGVmdCAmJiAnaW50ZWdlclZhbHVlJyBpbiByaWdodCkge1xyXG4gICAgICAgIHJldHVybiAobm9ybWFsaXplTnVtYmVyKGxlZnQuaW50ZWdlclZhbHVlKSA9PT0gbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmludGVnZXJWYWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiBsZWZ0ICYmICdkb3VibGVWYWx1ZScgaW4gcmlnaHQpIHtcclxuICAgICAgICBjb25zdCBuMSA9IG5vcm1hbGl6ZU51bWJlcihsZWZ0LmRvdWJsZVZhbHVlKTtcclxuICAgICAgICBjb25zdCBuMiA9IG5vcm1hbGl6ZU51bWJlcihyaWdodC5kb3VibGVWYWx1ZSk7XHJcbiAgICAgICAgaWYgKG4xID09PSBuMikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOZWdhdGl2ZVplcm8objEpID09PSBpc05lZ2F0aXZlWmVybyhuMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4objEpICYmIGlzTmFOKG4yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gb2JqZWN0RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBsZWZ0TWFwID0gbGVmdC5tYXBWYWx1ZS5maWVsZHMgfHwge307XHJcbiAgICBjb25zdCByaWdodE1hcCA9IHJpZ2h0Lm1hcFZhbHVlLmZpZWxkcyB8fCB7fTtcclxuICAgIGlmIChvYmplY3RTaXplKGxlZnRNYXApICE9PSBvYmplY3RTaXplKHJpZ2h0TWFwKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGxlZnRNYXApIHtcclxuICAgICAgICBpZiAobGVmdE1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodE1hcFtrZXldID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgICF2YWx1ZUVxdWFscyhsZWZ0TWFwW2tleV0sIHJpZ2h0TWFwW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBBcnJheVZhbHVlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudC4gKi9cclxuZnVuY3Rpb24gYXJyYXlWYWx1ZUNvbnRhaW5zKGhheXN0YWNrLCBuZWVkbGUpIHtcclxuICAgIHJldHVybiAoKGhheXN0YWNrLnZhbHVlcyB8fCBbXSkuZmluZCh2ID0+IHZhbHVlRXF1YWxzKHYsIG5lZWRsZSkpICE9PSB1bmRlZmluZWQpO1xyXG59XHJcbmZ1bmN0aW9uIHZhbHVlQ29tcGFyZShsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWZ0VHlwZSA9IHR5cGVPcmRlcihsZWZ0KTtcclxuICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHR5cGVPcmRlcihyaWdodCk7XHJcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRUeXBlLCByaWdodFR5cGUpO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xyXG4gICAgICAgIGNhc2UgMCAvKiBOdWxsVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIGNhc2UgMSAvKiBCb29sZWFuVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQuYm9vbGVhblZhbHVlLCByaWdodC5ib29sZWFuVmFsdWUpO1xyXG4gICAgICAgIGNhc2UgMiAvKiBOdW1iZXJWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICBjYXNlIDMgLyogVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVGltZXN0YW1wcyhsZWZ0LnRpbWVzdGFtcFZhbHVlLCByaWdodC50aW1lc3RhbXBWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSA0IC8qIFNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVRpbWVzdGFtcHMoZ2V0TG9jYWxXcml0ZVRpbWUobGVmdCksIGdldExvY2FsV3JpdGVUaW1lKHJpZ2h0KSk7XHJcbiAgICAgICAgY2FzZSA1IC8qIFN0cmluZ1ZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LnN0cmluZ1ZhbHVlLCByaWdodC5zdHJpbmdWYWx1ZSk7XHJcbiAgICAgICAgY2FzZSA2IC8qIEJsb2JWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVCbG9icyhsZWZ0LmJ5dGVzVmFsdWUsIHJpZ2h0LmJ5dGVzVmFsdWUpO1xyXG4gICAgICAgIGNhc2UgNyAvKiBSZWZWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVSZWZlcmVuY2VzKGxlZnQucmVmZXJlbmNlVmFsdWUsIHJpZ2h0LnJlZmVyZW5jZVZhbHVlKTtcclxuICAgICAgICBjYXNlIDggLyogR2VvUG9pbnRWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVHZW9Qb2ludHMobGVmdC5nZW9Qb2ludFZhbHVlLCByaWdodC5nZW9Qb2ludFZhbHVlKTtcclxuICAgICAgICBjYXNlIDkgLyogQXJyYXlWYWx1ZSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheXMobGVmdC5hcnJheVZhbHVlLCByaWdodC5hcnJheVZhbHVlKTtcclxuICAgICAgICBjYXNlIDEwIC8qIE9iamVjdFZhbHVlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZU1hcHMobGVmdC5tYXBWYWx1ZSwgcmlnaHQubWFwVmFsdWUpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhsZWZ0LCByaWdodCkge1xyXG4gICAgY29uc3QgbGVmdE51bWJlciA9IG5vcm1hbGl6ZU51bWJlcihsZWZ0LmludGVnZXJWYWx1ZSB8fCBsZWZ0LmRvdWJsZVZhbHVlKTtcclxuICAgIGNvbnN0IHJpZ2h0TnVtYmVyID0gbm9ybWFsaXplTnVtYmVyKHJpZ2h0LmludGVnZXJWYWx1ZSB8fCByaWdodC5kb3VibGVWYWx1ZSk7XHJcbiAgICBpZiAobGVmdE51bWJlciA8IHJpZ2h0TnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGVmdE51bWJlciA+IHJpZ2h0TnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsZWZ0TnVtYmVyID09PSByaWdodE51bWJlcikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gb25lIG9yIGJvdGggYXJlIE5hTi5cclxuICAgICAgICBpZiAoaXNOYU4obGVmdE51bWJlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHJpZ2h0TnVtYmVyKSA/IDAgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wYXJlVGltZXN0YW1wcyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIHR5cGVvZiByaWdodCA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICBsZWZ0Lmxlbmd0aCA9PT0gcmlnaHQubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdCwgcmlnaHQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVmdFRpbWVzdGFtcCA9IG5vcm1hbGl6ZVRpbWVzdGFtcChsZWZ0KTtcclxuICAgIGNvbnN0IHJpZ2h0VGltZXN0YW1wID0gbm9ybWFsaXplVGltZXN0YW1wKHJpZ2h0KTtcclxuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRUaW1lc3RhbXAuc2Vjb25kcywgcmlnaHRUaW1lc3RhbXAuc2Vjb25kcyk7XHJcbiAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjb21wYXJpc29uO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdFRpbWVzdGFtcC5uYW5vcywgcmlnaHRUaW1lc3RhbXAubmFub3MpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVSZWZlcmVuY2VzKGxlZnRQYXRoLCByaWdodFBhdGgpIHtcclxuICAgIGNvbnN0IGxlZnRTZWdtZW50cyA9IGxlZnRQYXRoLnNwbGl0KCcvJyk7XHJcbiAgICBjb25zdCByaWdodFNlZ21lbnRzID0gcmlnaHRQYXRoLnNwbGl0KCcvJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRTZWdtZW50cy5sZW5ndGggJiYgaSA8IHJpZ2h0U2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjb21wYXJpc29uID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0U2VnbWVudHNbaV0sIHJpZ2h0U2VnbWVudHNbaV0pO1xyXG4gICAgICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKGxlZnRTZWdtZW50cy5sZW5ndGgsIHJpZ2h0U2VnbWVudHMubGVuZ3RoKTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlR2VvUG9pbnRzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBjb21wYXJpc29uID0gcHJpbWl0aXZlQ29tcGFyYXRvcihub3JtYWxpemVOdW1iZXIobGVmdC5sYXRpdHVkZSksIG5vcm1hbGl6ZU51bWJlcihyaWdodC5sYXRpdHVkZSkpO1xyXG4gICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcclxuICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcclxuICAgIH1cclxuICAgIHJldHVybiBwcmltaXRpdmVDb21wYXJhdG9yKG5vcm1hbGl6ZU51bWJlcihsZWZ0LmxvbmdpdHVkZSksIG5vcm1hbGl6ZU51bWJlcihyaWdodC5sb25naXR1ZGUpKTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlQmxvYnMobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGxlZnRCeXRlcyA9IG5vcm1hbGl6ZUJ5dGVTdHJpbmcobGVmdCk7XHJcbiAgICBjb25zdCByaWdodEJ5dGVzID0gbm9ybWFsaXplQnl0ZVN0cmluZyhyaWdodCk7XHJcbiAgICByZXR1cm4gbGVmdEJ5dGVzLmNvbXBhcmVUbyhyaWdodEJ5dGVzKTtcclxufVxyXG5mdW5jdGlvbiBjb21wYXJlQXJyYXlzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBsZWZ0QXJyYXkgPSBsZWZ0LnZhbHVlcyB8fCBbXTtcclxuICAgIGNvbnN0IHJpZ2h0QXJyYXkgPSByaWdodC52YWx1ZXMgfHwgW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRBcnJheS5sZW5ndGggJiYgaSA8IHJpZ2h0QXJyYXkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCBjb21wYXJlID0gdmFsdWVDb21wYXJlKGxlZnRBcnJheVtpXSwgcmlnaHRBcnJheVtpXSk7XHJcbiAgICAgICAgaWYgKGNvbXBhcmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEFycmF5Lmxlbmd0aCwgcmlnaHRBcnJheS5sZW5ndGgpO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXBhcmVNYXBzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBjb25zdCBsZWZ0TWFwID0gbGVmdC5maWVsZHMgfHwge307XHJcbiAgICBjb25zdCBsZWZ0S2V5cyA9IE9iamVjdC5rZXlzKGxlZnRNYXApO1xyXG4gICAgY29uc3QgcmlnaHRNYXAgPSByaWdodC5maWVsZHMgfHwge307XHJcbiAgICBjb25zdCByaWdodEtleXMgPSBPYmplY3Qua2V5cyhyaWdodE1hcCk7XHJcbiAgICAvLyBFdmVuIHRob3VnaCBNYXBWYWx1ZXMgYXJlIGxpa2VseSBzb3J0ZWQgY29ycmVjdGx5IGJhc2VkIG9uIHRoZWlyIGluc2VydGlvblxyXG4gICAgLy8gb3JkZXIgKGUuZy4gd2hlbiByZWNlaXZlZCBmcm9tIHRoZSBiYWNrZW5kKSwgbG9jYWwgbW9kaWZpY2F0aW9ucyBjYW4gYnJpbmdcclxuICAgIC8vIGVsZW1lbnRzIG91dCBvZiBvcmRlci4gV2UgbmVlZCB0byByZS1zb3J0IHRoZSBlbGVtZW50cyB0byBlbnN1cmUgdGhhdFxyXG4gICAgLy8gY2Fub25pY2FsIElEcyBhcmUgaW5kZXBlbmRlbnQgb2YgaW5zZXJ0aW9uIG9yZGVyLlxyXG4gICAgbGVmdEtleXMuc29ydCgpO1xyXG4gICAgcmlnaHRLZXlzLnNvcnQoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCBrZXlDb21wYXJlID0gcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcclxuICAgICAgICBpZiAoa2V5Q29tcGFyZSAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5Q29tcGFyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29tcGFyZSA9IHZhbHVlQ29tcGFyZShsZWZ0TWFwW2xlZnRLZXlzW2ldXSwgcmlnaHRNYXBbcmlnaHRLZXlzW2ldXSk7XHJcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IobGVmdEtleXMubGVuZ3RoLCByaWdodEtleXMubGVuZ3RoKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGVzIHRoZSBjYW5vbmljYWwgSUQgZm9yIHRoZSBwcm92aWRlZCBmaWVsZCB2YWx1ZSAoYXMgdXNlZCBpbiBUYXJnZXRcclxuICogc2VyaWFsaXphdGlvbikuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYW5vbmljYWxJZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNhbm9uaWZ5VmFsdWUodmFsdWUpO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5VmFsdWUodmFsdWUpIHtcclxuICAgIGlmICgnbnVsbFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYm9vbGVhblZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlLmJvb2xlYW5WYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuICcnICsgdmFsdWUuaW50ZWdlclZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlLmRvdWJsZVZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ3RpbWVzdGFtcFZhbHVlJyBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBjYW5vbmlmeVRpbWVzdGFtcCh2YWx1ZS50aW1lc3RhbXBWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnc3RyaW5nVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZ1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2J5dGVzVmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5Qnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gY2Fub25pZnlSZWZlcmVuY2UodmFsdWUucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2dlb1BvaW50VmFsdWUnIGluIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbm9uaWZ5R2VvUG9pbnQodmFsdWUuZ2VvUG9pbnRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gY2Fub25pZnlBcnJheSh2YWx1ZS5hcnJheVZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdtYXBWYWx1ZScgaW4gdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gY2Fub25pZnlNYXAodmFsdWUubWFwVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeUJ5dGVTdHJpbmcoYnl0ZVN0cmluZykge1xyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZUJ5dGVTdHJpbmcoYnl0ZVN0cmluZykudG9CYXNlNjQoKTtcclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeVRpbWVzdGFtcCh0aW1lc3RhbXApIHtcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRUaW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAodGltZXN0YW1wKTtcclxuICAgIHJldHVybiBgdGltZSgke25vcm1hbGl6ZWRUaW1lc3RhbXAuc2Vjb25kc30sJHtub3JtYWxpemVkVGltZXN0YW1wLm5hbm9zfSlgO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5R2VvUG9pbnQoZ2VvUG9pbnQpIHtcclxuICAgIHJldHVybiBgZ2VvKCR7Z2VvUG9pbnQubGF0aXR1ZGV9LCR7Z2VvUG9pbnQubG9uZ2l0dWRlfSlgO1xyXG59XHJcbmZ1bmN0aW9uIGNhbm9uaWZ5UmVmZXJlbmNlKHJlZmVyZW5jZVZhbHVlKSB7XHJcbiAgICByZXR1cm4gRG9jdW1lbnRLZXkuZnJvbU5hbWUocmVmZXJlbmNlVmFsdWUpLnRvU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gY2Fub25pZnlNYXAobWFwVmFsdWUpIHtcclxuICAgIC8vIEl0ZXJhdGlvbiBvcmRlciBpbiBKYXZhU2NyaXB0IGlzIG5vdCBndWFyYW50ZWVkLiBUbyBlbnN1cmUgdGhhdCB3ZSBnZW5lcmF0ZVxyXG4gICAgLy8gbWF0Y2hpbmcgY2Fub25pY2FsIElEcyBmb3IgaWRlbnRpY2FsIG1hcHMsIHdlIG5lZWQgdG8gc29ydCB0aGUga2V5cy5cclxuICAgIGNvbnN0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhtYXBWYWx1ZS5maWVsZHMgfHwge30pLnNvcnQoKTtcclxuICAgIGxldCByZXN1bHQgPSAneyc7XHJcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc29ydGVkS2V5cykge1xyXG4gICAgICAgIGlmICghZmlyc3QpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSBgJHtrZXl9OiR7Y2Fub25pZnlWYWx1ZShtYXBWYWx1ZS5maWVsZHNba2V5XSl9YDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQgKyAnfSc7XHJcbn1cclxuZnVuY3Rpb24gY2Fub25pZnlBcnJheShhcnJheVZhbHVlKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gJ1snO1xyXG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcclxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXlWYWx1ZS52YWx1ZXMgfHwgW10pIHtcclxuICAgICAgICBpZiAoIWZpcnN0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgKz0gY2Fub25pZnlWYWx1ZSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0ICsgJ10nO1xyXG59XHJcbi8qKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHZhbHVlIGZvciB0aGUgcHJvdmlkZWQgZGF0YWJhc2UgYW5kIGtleS4gKi9cclxuZnVuY3Rpb24gcmVmVmFsdWUoZGF0YWJhc2VJZCwga2V5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlZmVyZW5jZVZhbHVlOiBgcHJvamVjdHMvJHtkYXRhYmFzZUlkLnByb2plY3RJZH0vZGF0YWJhc2VzLyR7ZGF0YWJhc2VJZC5kYXRhYmFzZX0vZG9jdW1lbnRzLyR7a2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKCl9YFxyXG4gICAgfTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gSW50ZWdlclZhbHVlIC4gKi9cclxuZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAnaW50ZWdlclZhbHVlJyBpbiB2YWx1ZTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBEb3VibGVWYWx1ZS4gKi9cclxuZnVuY3Rpb24gaXNEb3VibGUodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlICYmICdkb3VibGVWYWx1ZScgaW4gdmFsdWU7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGVpdGhlciBhbiBJbnRlZ2VyVmFsdWUgb3IgYSBEb3VibGVWYWx1ZS4gKi9cclxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcclxuICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpIHx8IGlzRG91YmxlKHZhbHVlKTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gQXJyYXlWYWx1ZS4gKi9cclxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhdmFsdWUgJiYgJ2FycmF5VmFsdWUnIGluIHZhbHVlO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIE51bGxWYWx1ZS4gKi9cclxuZnVuY3Rpb24gaXNOdWxsVmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlICYmICdudWxsVmFsdWUnIGluIHZhbHVlO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBOYU4uICovXHJcbmZ1bmN0aW9uIGlzTmFuVmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlICYmICdkb3VibGVWYWx1ZScgaW4gdmFsdWUgJiYgaXNOYU4oTnVtYmVyKHZhbHVlLmRvdWJsZVZhbHVlKSk7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgTWFwVmFsdWUuICovXHJcbmZ1bmN0aW9uIGlzTWFwVmFsdWUodmFsdWUpIHtcclxuICAgIHJldHVybiAhIXZhbHVlICYmICdtYXBWYWx1ZScgaW4gdmFsdWU7XHJcbn1cclxuLyoqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgYHNvdXJjZWAuICovXHJcbmZ1bmN0aW9uIGRlZXBDbG9uZShzb3VyY2UpIHtcclxuICAgIGlmIChzb3VyY2UuZ2VvUG9pbnRWYWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB7IGdlb1BvaW50VmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5nZW9Qb2ludFZhbHVlKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc291cmNlLnRpbWVzdGFtcFZhbHVlICYmXHJcbiAgICAgICAgdHlwZW9mIHNvdXJjZS50aW1lc3RhbXBWYWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4geyB0aW1lc3RhbXBWYWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLnRpbWVzdGFtcFZhbHVlKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc291cmNlLm1hcFZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0geyBtYXBWYWx1ZTogeyBmaWVsZHM6IHt9IH0gfTtcclxuICAgICAgICBmb3JFYWNoKHNvdXJjZS5tYXBWYWx1ZS5maWVsZHMsIChrZXksIHZhbCkgPT4gKHRhcmdldC5tYXBWYWx1ZS5maWVsZHNba2V5XSA9IGRlZXBDbG9uZSh2YWwpKSk7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNvdXJjZS5hcnJheVZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0geyBhcnJheVZhbHVlOiB7IHZhbHVlczogW10gfSB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNvdXJjZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmFycmF5VmFsdWUudmFsdWVzW2ldID0gZGVlcENsb25lKHNvdXJjZS5hcnJheVZhbHVlLnZhbHVlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlKTtcclxuICAgIH1cclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBWYWx1ZSByZXByZXNlbnRzIHRoZSBjYW5vbmljYWwge0BsaW5rICNNQVhfVkFMVUV9IC4gKi9cclxuZnVuY3Rpb24gaXNNYXhWYWx1ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlRXF1YWxzKHZhbHVlLCBNQVhfVkFMVUUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBPYmplY3RWYWx1ZSByZXByZXNlbnRzIGEgTWFwVmFsdWUgaW4gdGhlIEZpcmVzdG9yZSBQcm90byBhbmQgb2ZmZXJzIHRoZVxyXG4gKiBhYmlsaXR5IHRvIGFkZCBhbmQgcmVtb3ZlIGZpZWxkcyAodmlhIHRoZSBPYmplY3RWYWx1ZUJ1aWxkZXIpLlxyXG4gKi9cclxuY2xhc3MgT2JqZWN0VmFsdWUge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7fSB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGggb3IgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIHRoZSBwYXRoIHRvIHNlYXJjaFxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIGF0IHRoZSBwYXRoIG9yIG51bGwgaWYgdGhlIHBhdGggaXMgbm90IHNldC5cclxuICAgICAqL1xyXG4gICAgZmllbGQocGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50TGV2ZWwgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAoY3VycmVudExldmVsLm1hcFZhbHVlLmZpZWxkcyB8fCB7fSlbcGF0aC5nZXQoaSldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01hcFZhbHVlKGN1cnJlbnRMZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSAoY3VycmVudExldmVsLm1hcFZhbHVlLmZpZWxkcyB8fCB7fSlbcGF0aC5sYXN0U2VnbWVudCgpXTtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbCB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZmllbGQgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZpZWxkIHBhdGggdG8gc2V0LlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAqL1xyXG4gICAgc2V0KHBhdGgsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIGZpZWxkc01hcFtwYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcHJvdmlkZWQgZmllbGRzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBBIG1hcCBvZiBmaWVsZHMgdG8gdmFsdWVzIChvciBudWxsIGZvciBkZWxldGVzKS5cclxuICAgICAqL1xyXG4gICAgc2V0QWxsKGRhdGEpIHtcclxuICAgICAgICBsZXQgcGFyZW50ID0gRmllbGRQYXRoJDEuZW1wdHlQYXRoKCk7XHJcbiAgICAgICAgbGV0IHVwc2VydHMgPSB7fTtcclxuICAgICAgICBsZXQgZGVsZXRlcyA9IFtdO1xyXG4gICAgICAgIGRhdGEuZm9yRWFjaCgodmFsdWUsIHBhdGgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnQuaXNJbW1lZGlhdGVQYXJlbnRPZihwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBhY2N1bXVsYXRlZCBjaGFuZ2VzIGF0IHRoaXMgcGFyZW50IGxvY2F0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHNNYXAgPSB0aGlzLmdldEZpZWxkc01hcChwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUNoYW5nZXMoZmllbGRzTWFwLCB1cHNlcnRzLCBkZWxldGVzKTtcclxuICAgICAgICAgICAgICAgIHVwc2VydHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdXBzZXJ0c1twYXRoLmxhc3RTZWdtZW50KCldID0gZGVlcENsb25lKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZXMucHVzaChwYXRoLmxhc3RTZWdtZW50KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZmllbGRzTWFwID0gdGhpcy5nZXRGaWVsZHNNYXAocGFyZW50KTtcclxuICAgICAgICB0aGlzLmFwcGx5Q2hhbmdlcyhmaWVsZHNNYXAsIHVwc2VydHMsIGRlbGV0ZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBmaWVsZCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguIElmIHRoZXJlIGlzIG5vIGZpZWxkIGF0IHRoZVxyXG4gICAgICogc3BlY2lmaWVkIHBhdGgsIG5vdGhpbmcgaXMgY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmaWVsZCBwYXRoIHRvIHJlbW92ZS5cclxuICAgICAqL1xyXG4gICAgZGVsZXRlKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBuZXN0ZWRWYWx1ZSA9IHRoaXMuZmllbGQocGF0aC5wb3BMYXN0KCkpO1xyXG4gICAgICAgIGlmIChpc01hcFZhbHVlKG5lc3RlZFZhbHVlKSAmJiBuZXN0ZWRWYWx1ZS5tYXBWYWx1ZS5maWVsZHMpIHtcclxuICAgICAgICAgICAgZGVsZXRlIG5lc3RlZFZhbHVlLm1hcFZhbHVlLmZpZWxkc1twYXRoLmxhc3RTZWdtZW50KCldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVFcXVhbHModGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAgdGhhdCBjb250YWlucyB0aGUgbGVhZiBlbGVtZW50IG9mIGBwYXRoYC4gSWYgdGhlIHBhcmVudFxyXG4gICAgICogZW50cnkgZG9lcyBub3QgeWV0IGV4aXN0LCBvciBpZiBpdCBpcyBub3QgYSBtYXAsIGEgbmV3IG1hcCB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldEZpZWxkc01hcChwYXRoKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICghY3VycmVudC5tYXBWYWx1ZS5maWVsZHMpIHtcclxuICAgICAgICAgICAgY3VycmVudC5tYXBWYWx1ZSA9IHsgZmllbGRzOiB7fSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgbGV0IG5leHQgPSBjdXJyZW50Lm1hcFZhbHVlLmZpZWxkc1twYXRoLmdldChpKV07XHJcbiAgICAgICAgICAgIGlmICghaXNNYXBWYWx1ZShuZXh0KSB8fCAhbmV4dC5tYXBWYWx1ZS5maWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSB7IG1hcFZhbHVlOiB7IGZpZWxkczoge30gfSB9O1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5tYXBWYWx1ZS5maWVsZHNbcGF0aC5nZXQoaSldID0gbmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQubWFwVmFsdWUuZmllbGRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZmllcyBgZmllbGRzTWFwYCBieSBhZGRpbmcsIHJlcGxhY2luZyBvciBkZWxldGluZyB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiBlbnRyaWVzLlxyXG4gICAgICovXHJcbiAgICBhcHBseUNoYW5nZXMoZmllbGRzTWFwLCBpbnNlcnRzLCBkZWxldGVzKSB7XHJcbiAgICAgICAgZm9yRWFjaChpbnNlcnRzLCAoa2V5LCB2YWwpID0+IChmaWVsZHNNYXBba2V5XSA9IHZhbCkpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZGVsZXRlcykge1xyXG4gICAgICAgICAgICBkZWxldGUgZmllbGRzTWFwW2ZpZWxkXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFZhbHVlKGRlZXBDbG9uZSh0aGlzLnZhbHVlKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBGaWVsZE1hc2sgYnVpbHQgZnJvbSBhbGwgZmllbGRzIGluIGEgTWFwVmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0RmllbGRNYXNrKHZhbHVlKSB7XHJcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcclxuICAgIGZvckVhY2godmFsdWUuZmllbGRzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gbmV3IEZpZWxkUGF0aCQxKFtrZXldKTtcclxuICAgICAgICBpZiAoaXNNYXBWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgbmVzdGVkTWFzayA9IGV4dHJhY3RGaWVsZE1hc2sodmFsdWUubWFwVmFsdWUpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRGaWVsZHMgPSBuZXN0ZWRNYXNrLmZpZWxkcztcclxuICAgICAgICAgICAgaWYgKG5lc3RlZEZpZWxkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBlbXB0eSBtYXAgYnkgYWRkaW5nIGl0IHRvIHRoZSBGaWVsZE1hc2suXHJcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChjdXJyZW50UGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgbmVzdGVkIGFuZCBub24tZW1wdHkgT2JqZWN0VmFsdWVzLCBhZGQgdGhlIEZpZWxkUGF0aCBvZiB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGxlYWYgbm9kZXMuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5lc3RlZFBhdGggb2YgbmVzdGVkRmllbGRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnB1c2goY3VycmVudFBhdGguY2hpbGQobmVzdGVkUGF0aCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGb3IgbmVzdGVkIGFuZCBub24tZW1wdHkgT2JqZWN0VmFsdWVzLCBhZGQgdGhlIEZpZWxkUGF0aCBvZiB0aGUgbGVhZlxyXG4gICAgICAgICAgICAvLyBub2Rlcy5cclxuICAgICAgICAgICAgZmllbGRzLnB1c2goY3VycmVudFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBGaWVsZE1hc2soZmllbGRzKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGRvY3VtZW50IGluIEZpcmVzdG9yZSB3aXRoIGEga2V5LCB2ZXJzaW9uLCBkYXRhIGFuZCB3aGV0aGVyIGl0XHJcbiAqIGhhcyBsb2NhbCBtdXRhdGlvbnMgYXBwbGllZCB0byBpdC5cclxuICpcclxuICogRG9jdW1lbnRzIGNhbiB0cmFuc2l0aW9uIGJldHdlZW4gc3RhdGVzIHZpYSBgY29udmVydFRvRm91bmREb2N1bWVudCgpYCxcclxuICogYGNvbnZlcnRUb05vRG9jdW1lbnQoKWAgYW5kIGBjb252ZXJ0VG9Vbmtub3duRG9jdW1lbnQoKWAuIElmIGEgZG9jdW1lbnQgZG9lc1xyXG4gKiBub3QgdHJhbnNpdGlvbiB0byBvbmUgb2YgdGhlc2Ugc3RhdGVzIGV2ZW4gYWZ0ZXIgYWxsIG11dGF0aW9ucyBoYXZlIGJlZW5cclxuICogYXBwbGllZCwgYGlzVmFsaWREb2N1bWVudCgpYCByZXR1cm5zIGZhbHNlIGFuZCB0aGUgZG9jdW1lbnQgc2hvdWxkIGJlIHJlbW92ZWRcclxuICogZnJvbSBhbGwgdmlld3MuXHJcbiAqL1xyXG5jbGFzcyBNdXRhYmxlRG9jdW1lbnQge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBkb2N1bWVudFR5cGUsIHZlcnNpb24sIHJlYWRUaW1lLCBkYXRhLCBkb2N1bWVudFN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFR5cGUgPSBkb2N1bWVudFR5cGU7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICB0aGlzLnJlYWRUaW1lID0gcmVhZFRpbWU7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSBkb2N1bWVudFN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZG9jdW1lbnQgd2l0aCBubyBrbm93biB2ZXJzaW9uIG9yIGRhdGEsIGJ1dCB3aGljaCBjYW4gc2VydmUgYXNcclxuICAgICAqIGJhc2UgZG9jdW1lbnQgZm9yIG11dGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KGRvY3VtZW50S2V5LCAwIC8qIElOVkFMSUQgKi8sIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgU25hcHNob3RWZXJzaW9uLm1pbigpLCBPYmplY3RWYWx1ZS5lbXB0eSgpLCAwIC8qIFNZTkNFRCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCB3aXRoIHRoZSBnaXZlbiBkYXRhIGF0IHRoZVxyXG4gICAgICogZ2l2ZW4gdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld0ZvdW5kRG9jdW1lbnQoZG9jdW1lbnRLZXksIHZlcnNpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDEgLyogRk9VTkRfRE9DVU1FTlQgKi8sIHZlcnNpb24sIFNuYXBzaG90VmVyc2lvbi5taW4oKSwgdmFsdWUsIDAgLyogU1lOQ0VEICovKTtcclxuICAgIH1cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IGRvY3VtZW50IHRoYXQgaXMga25vd24gdG8gbm90IGV4aXN0IGF0IHRoZSBnaXZlbiB2ZXJzaW9uLiAqL1xyXG4gICAgc3RhdGljIG5ld05vRG9jdW1lbnQoZG9jdW1lbnRLZXksIHZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IE11dGFibGVEb2N1bWVudChkb2N1bWVudEtleSwgMiAvKiBOT19ET0NVTUVOVCAqLywgdmVyc2lvbiwgU25hcHNob3RWZXJzaW9uLm1pbigpLCBPYmplY3RWYWx1ZS5lbXB0eSgpLCAwIC8qIFNZTkNFRCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgdGhhdCBpcyBrbm93biB0byBleGlzdCBhdCB0aGUgZ2l2ZW4gdmVyc2lvbiBidXRcclxuICAgICAqIHdob3NlIGRhdGEgaXMgbm90IGtub3duIChlLmcuIGEgZG9jdW1lbnQgdGhhdCB3YXMgdXBkYXRlZCB3aXRob3V0IGEga25vd25cclxuICAgICAqIGJhc2UgZG9jdW1lbnQpLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbmV3VW5rbm93bkRvY3VtZW50KGRvY3VtZW50S2V5LCB2ZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdXRhYmxlRG9jdW1lbnQoZG9jdW1lbnRLZXksIDMgLyogVU5LTk9XTl9ET0NVTUVOVCAqLywgdmVyc2lvbiwgU25hcHNob3RWZXJzaW9uLm1pbigpLCBPYmplY3RWYWx1ZS5lbXB0eSgpLCAyIC8qIEhBU19DT01NSVRURURfTVVUQVRJT05TICovKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgZG9jdW1lbnQgdHlwZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGV4aXN0cyBhbmQgdGhhdCBpdHMgdmVyc2lvblxyXG4gICAgICogYW5kIGRhdGEgYXJlIGtub3duLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9Gb3VuZERvY3VtZW50KHZlcnNpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9IDEgLyogRk9VTkRfRE9DVU1FTlQgKi87XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMCAvKiBTWU5DRUQgKi87XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGRvY3VtZW50IHR5cGUgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2Vzbid0IGV4aXN0IGF0IHRoZSBnaXZlblxyXG4gICAgICogdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgY29udmVydFRvTm9Eb2N1bWVudCh2ZXJzaW9uKSB7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICB0aGlzLmRvY3VtZW50VHlwZSA9IDIgLyogTk9fRE9DVU1FTlQgKi87XHJcbiAgICAgICAgdGhpcy5kYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAwIC8qIFNZTkNFRCAqLztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgZG9jdW1lbnQgdHlwZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGV4aXN0cyBhdCBhIGdpdmVuIHZlcnNpb24gYnV0XHJcbiAgICAgKiB0aGF0IGl0cyBkYXRhIGlzIG5vdCBrbm93biAoZS5nLiBhIGRvY3VtZW50IHRoYXQgd2FzIHVwZGF0ZWQgd2l0aG91dCBhIGtub3duXHJcbiAgICAgKiBiYXNlIGRvY3VtZW50KS5cclxuICAgICAqL1xyXG4gICAgY29udmVydFRvVW5rbm93bkRvY3VtZW50KHZlcnNpb24pIHtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID0gMyAvKiBVTktOT1dOX0RPQ1VNRU5UICovO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMiAvKiBIQVNfQ09NTUlUVEVEX01VVEFUSU9OUyAqLztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmRvY3VtZW50U3RhdGUgPSAyIC8qIEhBU19DT01NSVRURURfTVVUQVRJT05TICovO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SGFzTG9jYWxNdXRhdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID0gMSAvKiBIQVNfTE9DQUxfTVVUQVRJT05TICovO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0UmVhZFRpbWUocmVhZFRpbWUpIHtcclxuICAgICAgICB0aGlzLnJlYWRUaW1lID0gcmVhZFRpbWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzTG9jYWxNdXRhdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRTdGF0ZSA9PT0gMSAvKiBIQVNfTE9DQUxfTVVUQVRJT05TICovO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc0NvbW1pdHRlZE11dGF0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFN0YXRlID09PSAyIC8qIEhBU19DT01NSVRURURfTVVUQVRJT05TICovO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc1BlbmRpbmdXcml0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTG9jYWxNdXRhdGlvbnMgfHwgdGhpcy5oYXNDb21taXR0ZWRNdXRhdGlvbnM7XHJcbiAgICB9XHJcbiAgICBpc1ZhbGlkRG9jdW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlICE9PSAwIC8qIElOVkFMSUQgKi87XHJcbiAgICB9XHJcbiAgICBpc0ZvdW5kRG9jdW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUeXBlID09PSAxIC8qIEZPVU5EX0RPQ1VNRU5UICovO1xyXG4gICAgfVxyXG4gICAgaXNOb0RvY3VtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSA9PT0gMiAvKiBOT19ET0NVTUVOVCAqLztcclxuICAgIH1cclxuICAgIGlzVW5rbm93bkRvY3VtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50VHlwZSA9PT0gMyAvKiBVTktOT1dOX0RPQ1VNRU5UICovO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBNdXRhYmxlRG9jdW1lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5rZXkuaXNFcXVhbChvdGhlci5rZXkpICYmXHJcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbi5pc0VxdWFsKG90aGVyLnZlcnNpb24pICYmXHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRUeXBlID09PSBvdGhlci5kb2N1bWVudFR5cGUgJiZcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudFN0YXRlID09PSBvdGhlci5kb2N1bWVudFN0YXRlICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YS5pc0VxdWFsKG90aGVyLmRhdGEpKTtcclxuICAgIH1cclxuICAgIG11dGFibGVDb3B5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTXV0YWJsZURvY3VtZW50KHRoaXMua2V5LCB0aGlzLmRvY3VtZW50VHlwZSwgdGhpcy52ZXJzaW9uLCB0aGlzLnJlYWRUaW1lLCB0aGlzLmRhdGEuY2xvbmUoKSwgdGhpcy5kb2N1bWVudFN0YXRlKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAoYERvY3VtZW50KCR7dGhpcy5rZXl9LCAke3RoaXMudmVyc2lvbn0sICR7SlNPTi5zdHJpbmdpZnkodGhpcy5kYXRhLnZhbHVlKX0sIGAgK1xyXG4gICAgICAgICAgICBge2RvY3VtZW50VHlwZTogJHt0aGlzLmRvY3VtZW50VHlwZX19KSwgYCArXHJcbiAgICAgICAgICAgIGB7ZG9jdW1lbnRTdGF0ZTogJHt0aGlzLmRvY3VtZW50U3RhdGV9fSlgKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29tcGFyZXMgdGhlIHZhbHVlIGZvciBmaWVsZCBgZmllbGRgIGluIHRoZSBwcm92aWRlZCBkb2N1bWVudHMuIFRocm93cyBpZlxyXG4gKiB0aGUgZmllbGQgZG9lcyBub3QgZXhpc3QgaW4gYm90aCBkb2N1bWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wYXJlRG9jdW1lbnRzQnlGaWVsZChmaWVsZCwgZDEsIGQyKSB7XHJcbiAgICBjb25zdCB2MSA9IGQxLmRhdGEuZmllbGQoZmllbGQpO1xyXG4gICAgY29uc3QgdjIgPSBkMi5kYXRhLmZpZWxkKGZpZWxkKTtcclxuICAgIGlmICh2MSAhPT0gbnVsbCAmJiB2MiAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZUNvbXBhcmUodjEsIHYyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBpbml0aWFsIG11dGF0aW9uIGJhdGNoIGlkIGZvciBlYWNoIGluZGV4LiBHZXRzIHVwZGF0ZWQgZHVyaW5nIGluZGV4XHJcbiAqIGJhY2tmaWxsLlxyXG4gKi9cclxuY29uc3QgSU5JVElBTF9MQVJHRVNUX0JBVENIX0lEID0gLTE7XHJcbi8qKlxyXG4gKiBUaGUgaW5pdGlhbCBzZXF1ZW5jZSBudW1iZXIgZm9yIGVhY2ggaW5kZXguIEdldHMgdXBkYXRlZCBkdXJpbmcgaW5kZXhcclxuICogYmFja2ZpbGwuXHJcbiAqL1xyXG5jb25zdCBJTklUSUFMX1NFUVVFTkNFX05VTUJFUiA9IDA7XHJcbi8qKlxyXG4gKiBBbiBpbmRleCBkZWZpbml0aW9uIGZvciBmaWVsZCBpbmRleGVzIGluIEZpcmVzdG9yZS5cclxuICpcclxuICogRXZlcnkgaW5kZXggaXMgYXNzb2NpYXRlZCB3aXRoIGEgY29sbGVjdGlvbi4gVGhlIGRlZmluaXRpb24gY29udGFpbnMgYSBsaXN0XHJcbiAqIG9mIGZpZWxkcyBhbmQgdGhlaXIgaW5kZXgga2luZCAod2hpY2ggY2FuIGJlIGBBU0NFTkRJTkdgLCBgREVTQ0VORElOR2Agb3JcclxuICogYENPTlRBSU5TYCBmb3IgQXJyYXlDb250YWlucy9BcnJheUNvbnRhaW5zQW55IHF1ZXJpZXMpLlxyXG4gKlxyXG4gKiBVbmxpa2UgdGhlIGJhY2tlbmQsIHRoZSBTREsgZG9lcyBub3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGNvbGxlY3Rpb24gb3JcclxuICogY29sbGVjdGlvbiBncm91cC1zY29wZWQgaW5kaWNlcy4gRXZlcnkgaW5kZXggY2FuIGJlIHVzZWQgZm9yIGJvdGggc2luZ2xlXHJcbiAqIGNvbGxlY3Rpb24gYW5kIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcmllcy5cclxuICovXHJcbmNsYXNzIEZpZWxkSW5kZXgge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbmRleCBJRC4gUmV0dXJucyAtMSBpZiB0aGUgaW5kZXggSUQgaXMgbm90IGF2YWlsYWJsZSAoZS5nLiB0aGUgaW5kZXhcclxuICAgICAqIGhhcyBub3QgeWV0IGJlZW4gcGVyc2lzdGVkKS5cclxuICAgICAqL1xyXG4gICAgaW5kZXhJZCwgXHJcbiAgICAvKiogVGhlIGNvbGxlY3Rpb24gSUQgdGhpcyBpbmRleCBhcHBsaWVzIHRvLiAqL1xyXG4gICAgY29sbGVjdGlvbkdyb3VwLCBcclxuICAgIC8qKiBUaGUgZmllbGQgc2VnbWVudHMgZm9yIHRoaXMgaW5kZXguICovXHJcbiAgICBmaWVsZHMsIFxyXG4gICAgLyoqIFNob3dzIGhvdyB1cC10by1kYXRlIHRoZSBpbmRleCBpcyBmb3IgdGhlIGN1cnJlbnQgdXNlci4gKi9cclxuICAgIGluZGV4U3RhdGUpIHtcclxuICAgICAgICB0aGlzLmluZGV4SWQgPSBpbmRleElkO1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3VwID0gY29sbGVjdGlvbkdyb3VwO1xyXG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xyXG4gICAgICAgIHRoaXMuaW5kZXhTdGF0ZSA9IGluZGV4U3RhdGU7XHJcbiAgICB9XHJcbn1cclxuLyoqIEFuIElEIGZvciBhbiBpbmRleCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gYWRkZWQgdG8gcGVyc2lzdGVuY2UuICAqL1xyXG5GaWVsZEluZGV4LlVOS05PV05fSUQgPSAtMTtcclxuLyoqIFJldHVybnMgdGhlIEFycmF5Q29udGFpbnMvQXJyYXlDb250YWluc0FueSBzZWdtZW50IGZvciB0aGlzIGluZGV4LiAqL1xyXG5mdW5jdGlvbiBmaWVsZEluZGV4R2V0QXJyYXlTZWdtZW50KGZpZWxkSW5kZXgpIHtcclxuICAgIHJldHVybiBmaWVsZEluZGV4LmZpZWxkcy5maW5kKHMgPT4gcy5raW5kID09PSAyIC8qIENPTlRBSU5TICovKTtcclxufVxyXG4vKiogUmV0dXJucyBhbGwgZGlyZWN0aW9uYWwgKGFzY2VuZGluZy9kZXNjZW5kaW5nKSBzZWdtZW50cyBmb3IgdGhpcyBpbmRleC4gKi9cclxuZnVuY3Rpb24gZmllbGRJbmRleEdldERpcmVjdGlvbmFsU2VnbWVudHMoZmllbGRJbmRleCkge1xyXG4gICAgcmV0dXJuIGZpZWxkSW5kZXguZmllbGRzLmZpbHRlcihzID0+IHMua2luZCAhPT0gMiAvKiBDT05UQUlOUyAqLyk7XHJcbn1cclxuLyoqIEFuIGluZGV4IGNvbXBvbmVudCBjb25zaXN0aW5nIG9mIGZpZWxkIHBhdGggYW5kIGluZGV4IHR5cGUuICAqL1xyXG5jbGFzcyBJbmRleFNlZ21lbnQge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogVGhlIGZpZWxkIHBhdGggb2YgdGhlIGNvbXBvbmVudC4gKi9cclxuICAgIGZpZWxkUGF0aCwgXHJcbiAgICAvKiogVGhlIGZpZWxkcyBzb3J0aW5nIG9yZGVyLiAqL1xyXG4gICAga2luZCkge1xyXG4gICAgICAgIHRoaXMuZmllbGRQYXRoID0gZmllbGRQYXRoO1xyXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFN0b3JlcyB0aGUgXCJoaWdoIHdhdGVyIG1hcmtcIiB0aGF0IGluZGljYXRlcyBob3cgdXBkYXRlZCB0aGUgSW5kZXggaXMgZm9yIHRoZVxyXG4gKiBjdXJyZW50IHVzZXIuXHJcbiAqL1xyXG5jbGFzcyBJbmRleFN0YXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hlbiB0aGUgaW5kZXggd2FzIGxhc3QgdXBkYXRlZCAocmVsYXRpdmUgdG8gb3RoZXIgaW5kZXhlcykuXHJcbiAgICAgKi9cclxuICAgIHNlcXVlbmNlTnVtYmVyLCBcclxuICAgIC8qKiBUaGUgdGhlIGxhdGVzdCBpbmRleGVkIHJlYWQgdGltZSwgZG9jdW1lbnQgYW5kIGJhdGNoIGlkLiAqL1xyXG4gICAgb2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlciA9IHNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSBzdGF0ZSBvZiBhbiBpbmRleCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gYmFja2ZpbGxlZC4gKi9cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4U3RhdGUoSU5JVElBTF9TRVFVRU5DRV9OVU1CRVIsIEluZGV4T2Zmc2V0Lm1pbigpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3RvcmVzIHRoZSBsYXRlc3QgcmVhZCB0aW1lLCBkb2N1bWVudCBhbmQgYmF0Y2ggSUQgdGhhdCB3ZXJlIHByb2Nlc3NlZCBmb3IgYW5cclxuICogaW5kZXguXHJcbiAqL1xyXG5jbGFzcyBJbmRleE9mZnNldCB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxhdGVzdCByZWFkIHRpbWUgdmVyc2lvbiB0aGF0IGhhcyBiZWVuIGluZGV4ZWQgYnkgRmlyZXN0b3JlIGZvciB0aGlzXHJcbiAgICAgKiBmaWVsZCBpbmRleC5cclxuICAgICAqL1xyXG4gICAgcmVhZFRpbWUsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUga2V5IG9mIHRoZSBsYXN0IGRvY3VtZW50IHRoYXQgd2FzIGluZGV4ZWQgZm9yIHRoaXMgcXVlcnkuIFVzZVxyXG4gICAgICogYERvY3VtZW50S2V5LmVtcHR5KClgIGlmIG5vIGRvY3VtZW50IGhhcyBiZWVuIGluZGV4ZWQuXHJcbiAgICAgKi9cclxuICAgIGRvY3VtZW50S2V5LCBcclxuICAgIC8qXHJcbiAgICAgKiBUaGUgbGFyZ2VzdCBtdXRhdGlvbiBiYXRjaCBpZCB0aGF0J3MgYmVlbiBwcm9jZXNzZWQgYnkgRmlyZXN0b3JlLlxyXG4gICAgICovXHJcbiAgICBsYXJnZXN0QmF0Y2hJZCkge1xyXG4gICAgICAgIHRoaXMucmVhZFRpbWUgPSByZWFkVGltZTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50S2V5ID0gZG9jdW1lbnRLZXk7XHJcbiAgICAgICAgdGhpcy5sYXJnZXN0QmF0Y2hJZCA9IGxhcmdlc3RCYXRjaElkO1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSBzdGF0ZSBvZiBhbiBpbmRleCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gYmFja2ZpbGxlZC4gKi9cclxuICAgIHN0YXRpYyBtaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mZnNldChTbmFwc2hvdFZlcnNpb24ubWluKCksIERvY3VtZW50S2V5LmVtcHR5KCksIElOSVRJQUxfTEFSR0VTVF9CQVRDSF9JRCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZ1xyXG5jbGFzcyBUYXJnZXRJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCA9IG51bGwsIG9yZGVyQnkgPSBbXSwgZmlsdGVycyA9IFtdLCBsaW1pdCA9IG51bGwsIHN0YXJ0QXQgPSBudWxsLCBlbmRBdCA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuY29sbGVjdGlvbkdyb3VwID0gY29sbGVjdGlvbkdyb3VwO1xyXG4gICAgICAgIHRoaXMub3JkZXJCeSA9IG9yZGVyQnk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcclxuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XHJcbiAgICAgICAgdGhpcy5zdGFydEF0ID0gc3RhcnRBdDtcclxuICAgICAgICB0aGlzLmVuZEF0ID0gZW5kQXQ7XHJcbiAgICAgICAgdGhpcy5tZW1vaXplZENhbm9uaWNhbElkID0gbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgYSBUYXJnZXQgd2l0aCBhIHBhdGggYW5kIG9wdGlvbmFsIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXHJcbiAqIFBhdGggbXVzdCBjdXJyZW50bHkgYmUgZW1wdHkgaWYgdGhpcyBpcyBhIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcnkuXHJcbiAqXHJcbiAqIE5PVEU6IHlvdSBzaG91bGQgYWx3YXlzIGNvbnN0cnVjdCBgVGFyZ2V0YCBmcm9tIGBRdWVyeS50b1RhcmdldGAgaW5zdGVhZCBvZlxyXG4gKiB1c2luZyB0aGlzIGZhY3RvcnkgbWV0aG9kLCBiZWNhdXNlIGBRdWVyeWAgcHJvdmlkZXMgYW4gaW1wbGljaXQgYG9yZGVyQnlgXHJcbiAqIHByb3BlcnR5LlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3VGFyZ2V0KHBhdGgsIGNvbGxlY3Rpb25Hcm91cCA9IG51bGwsIG9yZGVyQnkgPSBbXSwgZmlsdGVycyA9IFtdLCBsaW1pdCA9IG51bGwsIHN0YXJ0QXQgPSBudWxsLCBlbmRBdCA9IG51bGwpIHtcclxuICAgIHJldHVybiBuZXcgVGFyZ2V0SW1wbChwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIG9yZGVyQnksIGZpbHRlcnMsIGxpbWl0LCBzdGFydEF0LCBlbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gY2Fub25pZnlUYXJnZXQodGFyZ2V0KSB7XHJcbiAgICBjb25zdCB0YXJnZXRJbXBsID0gZGVidWdDYXN0KHRhcmdldCk7XHJcbiAgICBpZiAodGFyZ2V0SW1wbC5tZW1vaXplZENhbm9uaWNhbElkID09PSBudWxsKSB7XHJcbiAgICAgICAgbGV0IHN0ciA9IHRhcmdldEltcGwucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgICAgICBpZiAodGFyZ2V0SW1wbC5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RyICs9ICd8Y2c6JyArIHRhcmdldEltcGwuY29sbGVjdGlvbkdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHIgKz0gJ3xmOic7XHJcbiAgICAgICAgc3RyICs9IHRhcmdldEltcGwuZmlsdGVycy5tYXAoZiA9PiBjYW5vbmlmeUZpbHRlcihmKSkuam9pbignLCcpO1xyXG4gICAgICAgIHN0ciArPSAnfG9iOic7XHJcbiAgICAgICAgc3RyICs9IHRhcmdldEltcGwub3JkZXJCeS5tYXAobyA9PiBjYW5vbmlmeU9yZGVyQnkobykpLmpvaW4oJywnKTtcclxuICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHRhcmdldEltcGwubGltaXQpKSB7XHJcbiAgICAgICAgICAgIHN0ciArPSAnfGw6JztcclxuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwubGltaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXRJbXBsLnN0YXJ0QXQpIHtcclxuICAgICAgICAgICAgc3RyICs9ICd8bGI6JztcclxuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuc3RhcnRBdC5pbmNsdXNpdmUgPyAnYjonIDogJ2E6JztcclxuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuc3RhcnRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0SW1wbC5lbmRBdCkge1xyXG4gICAgICAgICAgICBzdHIgKz0gJ3x1YjonO1xyXG4gICAgICAgICAgICBzdHIgKz0gdGFyZ2V0SW1wbC5lbmRBdC5pbmNsdXNpdmUgPyAnYTonIDogJ2I6JztcclxuICAgICAgICAgICAgc3RyICs9IHRhcmdldEltcGwuZW5kQXQucG9zaXRpb24ubWFwKHAgPT4gY2Fub25pY2FsSWQocCkpLmpvaW4oJywnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0SW1wbC5tZW1vaXplZENhbm9uaWNhbElkID0gc3RyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldEltcGwubWVtb2l6ZWRDYW5vbmljYWxJZDtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlUYXJnZXQodGFyZ2V0KSB7XHJcbiAgICBsZXQgc3RyID0gdGFyZ2V0LnBhdGguY2Fub25pY2FsU3RyaW5nKCk7XHJcbiAgICBpZiAodGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciArPSAnIGNvbGxlY3Rpb25Hcm91cD0nICsgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuZmlsdGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgc3RyICs9IGAsIGZpbHRlcnM6IFske3RhcmdldC5maWx0ZXJzXHJcbiAgICAgICAgICAgIC5tYXAoZiA9PiBzdHJpbmdpZnlGaWx0ZXIoZikpXHJcbiAgICAgICAgICAgIC5qb2luKCcsICcpfV1gO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCh0YXJnZXQubGltaXQpKSB7XHJcbiAgICAgICAgc3RyICs9ICcsIGxpbWl0OiAnICsgdGFyZ2V0LmxpbWl0O1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5vcmRlckJ5Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICBzdHIgKz0gYCwgb3JkZXJCeTogWyR7dGFyZ2V0Lm9yZGVyQnlcclxuICAgICAgICAgICAgLm1hcChvID0+IHN0cmluZ2lmeU9yZGVyQnkobykpXHJcbiAgICAgICAgICAgIC5qb2luKCcsICcpfV1gO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5zdGFydEF0KSB7XHJcbiAgICAgICAgc3RyICs9ICcsIHN0YXJ0QXQ6ICc7XHJcbiAgICAgICAgc3RyICs9IHRhcmdldC5zdGFydEF0LmluY2x1c2l2ZSA/ICdiOicgOiAnYTonO1xyXG4gICAgICAgIHN0ciArPSB0YXJnZXQuc3RhcnRBdC5wb3NpdGlvbi5tYXAocCA9PiBjYW5vbmljYWxJZChwKSkuam9pbignLCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldC5lbmRBdCkge1xyXG4gICAgICAgIHN0ciArPSAnLCBlbmRBdDogJztcclxuICAgICAgICBzdHIgKz0gdGFyZ2V0LmVuZEF0LmluY2x1c2l2ZSA/ICdhOicgOiAnYjonO1xyXG4gICAgICAgIHN0ciArPSB0YXJnZXQuZW5kQXQucG9zaXRpb24ubWFwKHAgPT4gY2Fub25pY2FsSWQocCkpLmpvaW4oJywnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBgVGFyZ2V0KCR7c3RyfSlgO1xyXG59XHJcbmZ1bmN0aW9uIHRhcmdldEVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQubGltaXQgIT09IHJpZ2h0LmxpbWl0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQub3JkZXJCeS5sZW5ndGggIT09IHJpZ2h0Lm9yZGVyQnkubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0Lm9yZGVyQnkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIW9yZGVyQnlFcXVhbHMobGVmdC5vcmRlckJ5W2ldLCByaWdodC5vcmRlckJ5W2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQuZmlsdGVycy5sZW5ndGggIT09IHJpZ2h0LmZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0LmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoIWZpbHRlckVxdWFscyhsZWZ0LmZpbHRlcnNbaV0sIHJpZ2h0LmZpbHRlcnNbaV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC5jb2xsZWN0aW9uR3JvdXAgIT09IHJpZ2h0LmNvbGxlY3Rpb25Hcm91cCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghbGVmdC5wYXRoLmlzRXF1YWwocmlnaHQucGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWJvdW5kRXF1YWxzKGxlZnQuc3RhcnRBdCwgcmlnaHQuc3RhcnRBdCkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYm91bmRFcXVhbHMobGVmdC5lbmRBdCwgcmlnaHQuZW5kQXQpO1xyXG59XHJcbmZ1bmN0aW9uIHRhcmdldElzRG9jdW1lbnRUYXJnZXQodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gKERvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkodGFyZ2V0LnBhdGgpICYmXHJcbiAgICAgICAgdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCA9PT0gbnVsbCAmJlxyXG4gICAgICAgIHRhcmdldC5maWx0ZXJzLmxlbmd0aCA9PT0gMCk7XHJcbn1cclxuY2xhc3MgRmlsdGVyIHtcclxufVxyXG5jbGFzcyBGaWVsZEZpbHRlciBleHRlbmRzIEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZpbHRlciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlKGZpZWxkLCBvcCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoZmllbGQuaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJpblwiIC8qIElOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE5PVF9JTiAqLykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlS2V5RmllbGRJbkZpbHRlcihmaWVsZCwgb3AsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS2V5RmllbGRGaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiYXJyYXktY29udGFpbnNcIiAvKiBBUlJBWV9DT05UQUlOUyAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29udGFpbnNGaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3AgPT09IFwiaW5cIiAvKiBJTiAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcIm5vdC1pblwiIC8qIE5PVF9JTiAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vdEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wID09PSBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIEFSUkFZX0NPTlRBSU5TX0FOWSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Q29udGFpbnNBbnlGaWx0ZXIoZmllbGQsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmllbGRGaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZUtleUZpZWxkSW5GaWx0ZXIoZmllbGQsIG9wLCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBvcCA9PT0gXCJpblwiIC8qIElOICovXHJcbiAgICAgICAgICAgID8gbmV3IEtleUZpZWxkSW5GaWx0ZXIoZmllbGQsIHZhbHVlKVxyXG4gICAgICAgICAgICA6IG5ldyBLZXlGaWVsZE5vdEluRmlsdGVyKGZpZWxkLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XHJcbiAgICAgICAgLy8gVHlwZXMgZG8gbm90IGhhdmUgdG8gbWF0Y2ggaW4gTk9UX0VRVUFMIGZpbHRlcnMuXHJcbiAgICAgICAgaWYgKHRoaXMub3AgPT09IFwiIT1cIiAvKiBOT1RfRVFVQUwgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIChvdGhlciAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzQ29tcGFyaXNvbih2YWx1ZUNvbXBhcmUob3RoZXIsIHRoaXMudmFsdWUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE9ubHkgY29tcGFyZSB0eXBlcyB3aXRoIG1hdGNoaW5nIGJhY2tlbmQgb3JkZXIgKHN1Y2ggYXMgZG91YmxlIGFuZCBpbnQpLlxyXG4gICAgICAgIHJldHVybiAob3RoZXIgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgdHlwZU9yZGVyKHRoaXMudmFsdWUpID09PSB0eXBlT3JkZXIob3RoZXIpICYmXHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlc0NvbXBhcmlzb24odmFsdWVDb21wYXJlKG90aGVyLCB0aGlzLnZhbHVlKSkpO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hlc0NvbXBhcmlzb24oY29tcGFyaXNvbikge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5vcCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiPFwiIC8qIExFU1NfVEhBTiAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uIDwgMDtcclxuICAgICAgICAgICAgY2FzZSBcIjw9XCIgLyogTEVTU19USEFOX09SX0VRVUFMICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPD0gMDtcclxuICAgICAgICAgICAgY2FzZSBcIj09XCIgLyogRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA9PT0gMDtcclxuICAgICAgICAgICAgY2FzZSBcIiE9XCIgLyogTk9UX0VRVUFMICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gIT09IDA7XHJcbiAgICAgICAgICAgIGNhc2UgXCI+XCIgLyogR1JFQVRFUl9USEFOICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb24gPiAwO1xyXG4gICAgICAgICAgICBjYXNlIFwiPj1cIiAvKiBHUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbiA+PSAwO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0luZXF1YWxpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIChbXHJcbiAgICAgICAgICAgIFwiPFwiIC8qIExFU1NfVEhBTiAqLyxcclxuICAgICAgICAgICAgXCI8PVwiIC8qIExFU1NfVEhBTl9PUl9FUVVBTCAqLyxcclxuICAgICAgICAgICAgXCI+XCIgLyogR1JFQVRFUl9USEFOICovLFxyXG4gICAgICAgICAgICBcIj49XCIgLyogR1JFQVRFUl9USEFOX09SX0VRVUFMICovLFxyXG4gICAgICAgICAgICBcIiE9XCIgLyogTk9UX0VRVUFMICovLFxyXG4gICAgICAgICAgICBcIm5vdC1pblwiIC8qIE5PVF9JTiAqL1xyXG4gICAgICAgIF0uaW5kZXhPZih0aGlzLm9wKSA+PSAwKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYW5vbmlmeUZpbHRlcihmaWx0ZXIpIHtcclxuICAgIC8vIFRPRE8oYi8yOTE4MzE2NSk6IFRlY2huaWNhbGx5LCB0aGlzIHdvbid0IGJlIHVuaXF1ZSBpZiB0d28gdmFsdWVzIGhhdmVcclxuICAgIC8vIHRoZSBzYW1lIGRlc2NyaXB0aW9uLCBzdWNoIGFzIHRoZSBpbnQgMyBhbmQgdGhlIHN0cmluZyBcIjNcIi4gU28gd2Ugc2hvdWxkXHJcbiAgICAvLyBhZGQgdGhlIHR5cGVzIGluIGhlcmUgc29tZWhvdywgdG9vLlxyXG4gICAgcmV0dXJuIChmaWx0ZXIuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkgK1xyXG4gICAgICAgIGZpbHRlci5vcC50b1N0cmluZygpICtcclxuICAgICAgICBjYW5vbmljYWxJZChmaWx0ZXIudmFsdWUpKTtcclxufVxyXG5mdW5jdGlvbiBmaWx0ZXJFcXVhbHMoZjEsIGYyKSB7XHJcbiAgICByZXR1cm4gKGYxLm9wID09PSBmMi5vcCAmJlxyXG4gICAgICAgIGYxLmZpZWxkLmlzRXF1YWwoZjIuZmllbGQpICYmXHJcbiAgICAgICAgdmFsdWVFcXVhbHMoZjEudmFsdWUsIGYyLnZhbHVlKSk7XHJcbn1cclxuLyoqIFJldHVybnMgYSBkZWJ1ZyBkZXNjcmlwdGlvbiBmb3IgYGZpbHRlcmAuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUZpbHRlcihmaWx0ZXIpIHtcclxuICAgIHJldHVybiBgJHtmaWx0ZXIuZmllbGQuY2Fub25pY2FsU3RyaW5nKCl9ICR7ZmlsdGVyLm9wfSAke2Nhbm9uaWNhbElkKGZpbHRlci52YWx1ZSl9YDtcclxufVxyXG4vKiogRmlsdGVyIHRoYXQgbWF0Y2hlcyBvbiBrZXkgZmllbGRzIChpLmUuICdfX25hbWVfXycpLiAqL1xyXG5jbGFzcyBLZXlGaWVsZEZpbHRlciBleHRlbmRzIEZpZWxkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBvcCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgb3AsIHZhbHVlKTtcclxuICAgICAgICB0aGlzLmtleSA9IERvY3VtZW50S2V5LmZyb21OYW1lKHZhbHVlLnJlZmVyZW5jZVZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZG9jLmtleSwgdGhpcy5rZXkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoZXNDb21wYXJpc29uKGNvbXBhcmlzb24pO1xyXG4gICAgfVxyXG59XHJcbi8qKiBGaWx0ZXIgdGhhdCBtYXRjaGVzIG9uIGtleSBmaWVsZHMgd2l0aGluIGFuIGFycmF5LiAqL1xyXG5jbGFzcyBLZXlGaWVsZEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoZmllbGQsIFwiaW5cIiAvKiBJTiAqLywgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMua2V5cyA9IGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShcImluXCIgLyogSU4gKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5zb21lKGtleSA9PiBrZXkuaXNFcXVhbChkb2Mua2V5KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIEZpbHRlciB0aGF0IG1hdGNoZXMgb24ga2V5IGZpZWxkcyBub3QgcHJlc2VudCB3aXRoaW4gYW4gYXJyYXkuICovXHJcbmNsYXNzIEtleUZpZWxkTm90SW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJub3QtaW5cIiAvKiBOT1RfSU4gKi8sIHZhbHVlKTtcclxuICAgICAgICB0aGlzLmtleXMgPSBleHRyYWN0RG9jdW1lbnRLZXlzRnJvbUFycmF5VmFsdWUoXCJub3QtaW5cIiAvKiBOT1RfSU4gKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmtleXMuc29tZShrZXkgPT4ga2V5LmlzRXF1YWwoZG9jLmtleSkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3REb2N1bWVudEtleXNGcm9tQXJyYXlWYWx1ZShvcCwgdmFsdWUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJldHVybiAoKChfYSA9IHZhbHVlLmFycmF5VmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZXMpIHx8IFtdKS5tYXAodiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIERvY3VtZW50S2V5LmZyb21OYW1lKHYucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqIEEgRmlsdGVyIHRoYXQgaW1wbGVtZW50cyB0aGUgYXJyYXktY29udGFpbnMgb3BlcmF0b3IuICovXHJcbmNsYXNzIEFycmF5Q29udGFpbnNGaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWluc1wiIC8qIEFSUkFZX0NPTlRBSU5TICovLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XHJcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkob3RoZXIpICYmIGFycmF5VmFsdWVDb250YWlucyhvdGhlci5hcnJheVZhbHVlLCB0aGlzLnZhbHVlKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBJTiBvcGVyYXRvci4gKi9cclxuY2xhc3MgSW5GaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJpblwiIC8qIElOICovLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGNvbnN0IG90aGVyID0gZG9jLmRhdGEuZmllbGQodGhpcy5maWVsZCk7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyICE9PSBudWxsICYmIGFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBub3QtaW4gb3BlcmF0b3IuICovXHJcbmNsYXNzIE5vdEluRmlsdGVyIGV4dGVuZHMgRmllbGRGaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoZmllbGQsIFwibm90LWluXCIgLyogTk9UX0lOICovLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKGRvYykge1xyXG4gICAgICAgIGlmIChhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCB7IG51bGxWYWx1ZTogJ05VTExfVkFMVUUnIH0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgIWFycmF5VmFsdWVDb250YWlucyh0aGlzLnZhbHVlLmFycmF5VmFsdWUsIG90aGVyKTtcclxuICAgIH1cclxufVxyXG4vKiogQSBGaWx0ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBhcnJheS1jb250YWlucy1hbnkgb3BlcmF0b3IuICovXHJcbmNsYXNzIEFycmF5Q29udGFpbnNBbnlGaWx0ZXIgZXh0ZW5kcyBGaWVsZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgdmFsdWUpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCwgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBBUlJBWV9DT05UQUlOU19BTlkgKi8sIHZhbHVlKTtcclxuICAgIH1cclxuICAgIG1hdGNoZXMoZG9jKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBkb2MuZGF0YS5maWVsZCh0aGlzLmZpZWxkKTtcclxuICAgICAgICBpZiAoIWlzQXJyYXkob3RoZXIpIHx8ICFvdGhlci5hcnJheVZhbHVlLnZhbHVlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdGhlci5hcnJheVZhbHVlLnZhbHVlcy5zb21lKHZhbCA9PiBhcnJheVZhbHVlQ29udGFpbnModGhpcy52YWx1ZS5hcnJheVZhbHVlLCB2YWwpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGJvdW5kIG9mIGEgcXVlcnkuXHJcbiAqXHJcbiAqIFRoZSBib3VuZCBpcyBzcGVjaWZpZWQgd2l0aCB0aGUgZ2l2ZW4gY29tcG9uZW50cyByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBhbmRcclxuICogd2hldGhlciBpdCdzIGp1c3QgYmVmb3JlIG9yIGp1c3QgYWZ0ZXIgdGhlIHBvc2l0aW9uIChyZWxhdGl2ZSB0byB3aGF0ZXZlciB0aGVcclxuICogcXVlcnkgb3JkZXIgaXMpLlxyXG4gKlxyXG4gKiBUaGUgcG9zaXRpb24gcmVwcmVzZW50cyBhIGxvZ2ljYWwgaW5kZXggcG9zaXRpb24gZm9yIGEgcXVlcnkuIEl0J3MgYSBwcmVmaXhcclxuICogb2YgdmFsdWVzIGZvciB0aGUgKHBvdGVudGlhbGx5IGltcGxpY2l0KSBvcmRlciBieSBjbGF1c2VzIG9mIGEgcXVlcnkuXHJcbiAqXHJcbiAqIEJvdW5kIHByb3ZpZGVzIGEgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkb2N1bWVudCBjb21lcyBiZWZvcmUgb3JcclxuICogYWZ0ZXIgYSBib3VuZC4gVGhpcyBpcyBpbmZsdWVuY2VkIGJ5IHdoZXRoZXIgdGhlIHBvc2l0aW9uIGlzIGp1c3QgYmVmb3JlIG9yXHJcbiAqIGp1c3QgYWZ0ZXIgdGhlIHByb3ZpZGVkIHZhbHVlcy5cclxuICovXHJcbmNsYXNzIEJvdW5kIHtcclxuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBpbmNsdXNpdmUpIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5pbmNsdXNpdmUgPSBpbmNsdXNpdmU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIG9yZGVyaW5nIG9uIGEgZmllbGQsIGluIHNvbWUgRGlyZWN0aW9uLiBEaXJlY3Rpb24gZGVmYXVsdHMgdG8gQVNDRU5ESU5HLlxyXG4gKi9cclxuY2xhc3MgT3JkZXJCeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgZGlyID0gXCJhc2NcIiAvKiBBU0NFTkRJTkcgKi8pIHtcclxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2Fub25pZnlPcmRlckJ5KG9yZGVyQnkpIHtcclxuICAgIC8vIFRPRE8oYi8yOTE4MzE2NSk6IE1ha2UgdGhpcyBjb2xsaXNpb24gcm9idXN0LlxyXG4gICAgcmV0dXJuIG9yZGVyQnkuZmllbGQuY2Fub25pY2FsU3RyaW5nKCkgKyBvcmRlckJ5LmRpcjtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlPcmRlckJ5KG9yZGVyQnkpIHtcclxuICAgIHJldHVybiBgJHtvcmRlckJ5LmZpZWxkLmNhbm9uaWNhbFN0cmluZygpfSAoJHtvcmRlckJ5LmRpcn0pYDtcclxufVxyXG5mdW5jdGlvbiBvcmRlckJ5RXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gbGVmdC5kaXIgPT09IHJpZ2h0LmRpciAmJiBsZWZ0LmZpZWxkLmlzRXF1YWwocmlnaHQuZmllbGQpO1xyXG59XHJcbmZ1bmN0aW9uIGJvdW5kQ29tcGFyZVRvRG9jdW1lbnQoYm91bmQsIG9yZGVyQnksIGRvYykge1xyXG4gICAgbGV0IGNvbXBhcmlzb24gPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZC5wb3NpdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IG9yZGVyQnlDb21wb25lbnQgPSBvcmRlckJ5W2ldO1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGJvdW5kLnBvc2l0aW9uW2ldO1xyXG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICBjb21wYXJpc29uID0gRG9jdW1lbnRLZXkuY29tcGFyYXRvcihEb2N1bWVudEtleS5mcm9tTmFtZShjb21wb25lbnQucmVmZXJlbmNlVmFsdWUpLCBkb2Mua2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY1ZhbHVlID0gZG9jLmRhdGEuZmllbGQob3JkZXJCeUNvbXBvbmVudC5maWVsZCk7XHJcbiAgICAgICAgICAgIGNvbXBhcmlzb24gPSB2YWx1ZUNvbXBhcmUoY29tcG9uZW50LCBkb2NWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmRpciA9PT0gXCJkZXNjXCIgLyogREVTQ0VORElORyAqLykge1xyXG4gICAgICAgICAgICBjb21wYXJpc29uID0gY29tcGFyaXNvbiAqIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcGFyaXNvbjtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGEgZG9jdW1lbnQgc29ydHMgYWZ0ZXIgYSBib3VuZCB1c2luZyB0aGUgcHJvdmlkZWQgc29ydFxyXG4gKiBvcmRlci5cclxuICovXHJcbmZ1bmN0aW9uIGJvdW5kU29ydHNBZnRlckRvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpIHtcclxuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBib3VuZENvbXBhcmVUb0RvY3VtZW50KGJvdW5kLCBvcmRlckJ5LCBkb2MpO1xyXG4gICAgcmV0dXJuIGJvdW5kLmluY2x1c2l2ZSA/IGNvbXBhcmlzb24gPj0gMCA6IGNvbXBhcmlzb24gPiAwO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBkb2N1bWVudCBzb3J0cyBiZWZvcmUgYSBib3VuZCB1c2luZyB0aGUgcHJvdmlkZWQgc29ydFxyXG4gKiBvcmRlci5cclxuICovXHJcbmZ1bmN0aW9uIGJvdW5kU29ydHNCZWZvcmVEb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKSB7XHJcbiAgICBjb25zdCBjb21wYXJpc29uID0gYm91bmRDb21wYXJlVG9Eb2N1bWVudChib3VuZCwgb3JkZXJCeSwgZG9jKTtcclxuICAgIHJldHVybiBib3VuZC5pbmNsdXNpdmUgPyBjb21wYXJpc29uIDw9IDAgOiBjb21wYXJpc29uIDwgMDtcclxufVxyXG5mdW5jdGlvbiBib3VuZEVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmlnaHQgPT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyaWdodCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LmluY2x1c2l2ZSAhPT0gcmlnaHQuaW5jbHVzaXZlIHx8XHJcbiAgICAgICAgbGVmdC5wb3NpdGlvbi5sZW5ndGggIT09IHJpZ2h0LnBvc2l0aW9uLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5wb3NpdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxlZnRQb3NpdGlvbiA9IGxlZnQucG9zaXRpb25baV07XHJcbiAgICAgICAgY29uc3QgcmlnaHRQb3NpdGlvbiA9IHJpZ2h0LnBvc2l0aW9uW2ldO1xyXG4gICAgICAgIGlmICghdmFsdWVFcXVhbHMobGVmdFBvc2l0aW9uLCByaWdodFBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFF1ZXJ5IGVuY2Fwc3VsYXRlcyBhbGwgdGhlIHF1ZXJ5IGF0dHJpYnV0ZXMgd2Ugc3VwcG9ydCBpbiB0aGUgU0RLLiBJdCBjYW5cclxuICogYmUgcnVuIGFnYWluc3QgdGhlIExvY2FsU3RvcmUsIGFzIHdlbGwgYXMgYmUgY29udmVydGVkIHRvIGEgYFRhcmdldGAgdG9cclxuICogcXVlcnkgdGhlIFJlbW90ZVN0b3JlIHJlc3VsdHMuXHJcbiAqXHJcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUltcGwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBhIFF1ZXJ5IHdpdGggYSBwYXRoIGFuZCBvcHRpb25hbCBhZGRpdGlvbmFsIHF1ZXJ5IGNvbnN0cmFpbnRzLlxyXG4gICAgICogUGF0aCBtdXN0IGN1cnJlbnRseSBiZSBlbXB0eSBpZiB0aGlzIGlzIGEgY29sbGVjdGlvbiBncm91cCBxdWVyeS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgY29sbGVjdGlvbkdyb3VwID0gbnVsbCwgZXhwbGljaXRPcmRlckJ5ID0gW10sIGZpbHRlcnMgPSBbXSwgbGltaXQgPSBudWxsLCBsaW1pdFR5cGUgPSBcIkZcIiAvKiBGaXJzdCAqLywgc3RhcnRBdCA9IG51bGwsIGVuZEF0ID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uR3JvdXAgPSBjb2xsZWN0aW9uR3JvdXA7XHJcbiAgICAgICAgdGhpcy5leHBsaWNpdE9yZGVyQnkgPSBleHBsaWNpdE9yZGVyQnk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcclxuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XHJcbiAgICAgICAgdGhpcy5saW1pdFR5cGUgPSBsaW1pdFR5cGU7XHJcbiAgICAgICAgdGhpcy5zdGFydEF0ID0gc3RhcnRBdDtcclxuICAgICAgICB0aGlzLmVuZEF0ID0gZW5kQXQ7XHJcbiAgICAgICAgdGhpcy5tZW1vaXplZE9yZGVyQnkgPSBudWxsO1xyXG4gICAgICAgIC8vIFRoZSBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIG9mIHRoaXMgYFF1ZXJ5YCBpbnN0YW5jZS5cclxuICAgICAgICB0aGlzLm1lbW9pemVkVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5zdGFydEF0KSA7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kQXQpIDtcclxuICAgIH1cclxufVxyXG4vKiogQ3JlYXRlcyBhIG5ldyBRdWVyeSBpbnN0YW5jZSB3aXRoIHRoZSBvcHRpb25zIHByb3ZpZGVkLiAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeShwYXRoLCBjb2xsZWN0aW9uR3JvdXAsIGV4cGxpY2l0T3JkZXJCeSwgZmlsdGVycywgbGltaXQsIGxpbWl0VHlwZSwgc3RhcnRBdCwgZW5kQXQpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHBhdGgsIGNvbGxlY3Rpb25Hcm91cCwgZXhwbGljaXRPcmRlckJ5LCBmaWx0ZXJzLCBsaW1pdCwgbGltaXRUeXBlLCBzdGFydEF0LCBlbmRBdCk7XHJcbn1cclxuLyoqIENyZWF0ZXMgYSBuZXcgUXVlcnkgZm9yIGEgcXVlcnkgdGhhdCBtYXRjaGVzIGFsbCBkb2N1bWVudHMgYXQgYHBhdGhgICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5Rm9yUGF0aChwYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChwYXRoKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGNvbnZlcnQgYSBjb2xsZWN0aW9uIGdyb3VwIHF1ZXJ5IGludG8gYSBjb2xsZWN0aW9uIHF1ZXJ5IGF0IGFcclxuICogc3BlY2lmaWMgcGF0aC4gVGhpcyBpcyB1c2VkIHdoZW4gZXhlY3V0aW5nIGNvbGxlY3Rpb24gZ3JvdXAgcXVlcmllcywgc2luY2VcclxuICogd2UgaGF2ZSB0byBzcGxpdCB0aGUgcXVlcnkgaW50byBhIHNldCBvZiBjb2xsZWN0aW9uIHF1ZXJpZXMgYXQgbXVsdGlwbGVcclxuICogcGF0aHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBhc0NvbGxlY3Rpb25RdWVyeUF0UGF0aChxdWVyeSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocGF0aCwgXHJcbiAgICAvKmNvbGxlY3Rpb25Hcm91cD0qLyBudWxsLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHF1ZXJ5IGRvZXMgbm90IHNwZWNpZnkgYW55IHF1ZXJ5IGNvbnN0cmFpbnRzIHRoYXRcclxuICogY291bGQgcmVtb3ZlIHJlc3VsdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXRjaGVzQWxsRG9jdW1lbnRzKHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gKHF1ZXJ5LmZpbHRlcnMubGVuZ3RoID09PSAwICYmXHJcbiAgICAgICAgcXVlcnkubGltaXQgPT09IG51bGwgJiZcclxuICAgICAgICBxdWVyeS5zdGFydEF0ID09IG51bGwgJiZcclxuICAgICAgICBxdWVyeS5lbmRBdCA9PSBudWxsICYmXHJcbiAgICAgICAgKHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPT09IDAgfHxcclxuICAgICAgICAgICAgKHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPT09IDEgJiZcclxuICAgICAgICAgICAgICAgIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeVswXS5maWVsZC5pc0tleUZpZWxkKCkpKSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzTGltaXRUb0ZpcnN0KHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gIWlzTnVsbE9yVW5kZWZpbmVkKHF1ZXJ5LmxpbWl0KSAmJiBxdWVyeS5saW1pdFR5cGUgPT09IFwiRlwiIC8qIEZpcnN0ICovO1xyXG59XHJcbmZ1bmN0aW9uIGhhc0xpbWl0VG9MYXN0KHF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gIWlzTnVsbE9yVW5kZWZpbmVkKHF1ZXJ5LmxpbWl0KSAmJiBxdWVyeS5saW1pdFR5cGUgPT09IFwiTFwiIC8qIExhc3QgKi87XHJcbn1cclxuZnVuY3Rpb24gZ2V0Rmlyc3RPcmRlckJ5RmllbGQocXVlcnkpIHtcclxuICAgIHJldHVybiBxdWVyeS5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID4gMFxyXG4gICAgICAgID8gcXVlcnkuZXhwbGljaXRPcmRlckJ5WzBdLmZpZWxkXHJcbiAgICAgICAgOiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGdldEluZXF1YWxpdHlGaWx0ZXJGaWVsZChxdWVyeSkge1xyXG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgcXVlcnkuZmlsdGVycykge1xyXG4gICAgICAgIGlmIChmaWx0ZXIuaXNJbmVxdWFsaXR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlci5maWVsZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFueSBvZiB0aGUgcHJvdmlkZWQgT3BlcmF0b3JzIGFyZSBpbmNsdWRlZCBpbiB0aGUgcXVlcnkgYW5kXHJcbiAqIHJldHVybnMgdGhlIGZpcnN0IG9uZSB0aGF0IGlzLCBvciBudWxsIGlmIG5vbmUgYXJlLlxyXG4gKi9cclxuZnVuY3Rpb24gZmluZEZpbHRlck9wZXJhdG9yKHF1ZXJ5LCBvcGVyYXRvcnMpIHtcclxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHF1ZXJ5LmZpbHRlcnMpIHtcclxuICAgICAgICBpZiAob3BlcmF0b3JzLmluZGV4T2YoZmlsdGVyLm9wKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIub3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgUXVlcnkgZm9yIGEgY29sbGVjdGlvbiBncm91cCBxdWVyeSB0aGF0IG1hdGNoZXMgYWxsIGRvY3VtZW50c1xyXG4gKiB3aXRoaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gZ3JvdXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeUZvckNvbGxlY3Rpb25Hcm91cChjb2xsZWN0aW9uSWQpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKFJlc291cmNlUGF0aC5lbXB0eVBhdGgoKSwgY29sbGVjdGlvbklkKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBxdWVyeSBtYXRjaGVzIGEgc2luZ2xlIGRvY3VtZW50IGJ5IHBhdGggKHJhdGhlciB0aGFuIGFcclxuICogY29sbGVjdGlvbikuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50UXVlcnkkMShxdWVyeSkge1xyXG4gICAgcmV0dXJuIChEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHF1ZXJ5LnBhdGgpICYmXHJcbiAgICAgICAgcXVlcnkuY29sbGVjdGlvbkdyb3VwID09PSBudWxsICYmXHJcbiAgICAgICAgcXVlcnkuZmlsdGVycy5sZW5ndGggPT09IDApO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgYSBjb2xsZWN0aW9uIGdyb3VwIHJhdGhlciB0aGFuIGEgc3BlY2lmaWNcclxuICogY29sbGVjdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGlzQ29sbGVjdGlvbkdyb3VwUXVlcnkocXVlcnkpIHtcclxuICAgIHJldHVybiBxdWVyeS5jb2xsZWN0aW9uR3JvdXAgIT09IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGltcGxpY2l0IG9yZGVyIGJ5IGNvbnN0cmFpbnQgdGhhdCBpcyB1c2VkIHRvIGV4ZWN1dGUgdGhlIFF1ZXJ5LFxyXG4gKiB3aGljaCBjYW4gYmUgZGlmZmVyZW50IGZyb20gdGhlIG9yZGVyIGJ5IGNvbnN0cmFpbnRzIHRoZSB1c2VyIHByb3ZpZGVkIChlLmcuXHJcbiAqIHRoZSBTREsgYW5kIGJhY2tlbmQgYWx3YXlzIG9yZGVycyBieSBgX19uYW1lX19gKS5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5T3JkZXJCeShxdWVyeSkge1xyXG4gICAgY29uc3QgcXVlcnlJbXBsID0gZGVidWdDYXN0KHF1ZXJ5KTtcclxuICAgIGlmIChxdWVyeUltcGwubWVtb2l6ZWRPcmRlckJ5ID09PSBudWxsKSB7XHJcbiAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkT3JkZXJCeSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGluZXF1YWxpdHlGaWVsZCA9IGdldEluZXF1YWxpdHlGaWx0ZXJGaWVsZChxdWVyeUltcGwpO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0T3JkZXJCeUZpZWxkID0gZ2V0Rmlyc3RPcmRlckJ5RmllbGQocXVlcnlJbXBsKTtcclxuICAgICAgICBpZiAoaW5lcXVhbGl0eUZpZWxkICE9PSBudWxsICYmIGZpcnN0T3JkZXJCeUZpZWxkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGltcGxpY2l0bHkgYWRkIGtleSBvcmRlcmluZywgd2UgbXVzdCBhbHNvIGFkZCB0aGVcclxuICAgICAgICAgICAgLy8gaW5lcXVhbGl0eSBmaWx0ZXIgZmllbGQgZm9yIGl0IHRvIGJlIGEgdmFsaWQgcXVlcnkuXHJcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgZGVmYXVsdCBpbmVxdWFsaXR5IGZpZWxkIGFuZCBrZXkgb3JkZXJpbmcgaXMgYXNjZW5kaW5nLlxyXG4gICAgICAgICAgICBpZiAoIWluZXF1YWxpdHlGaWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZE9yZGVyQnkucHVzaChuZXcgT3JkZXJCeShpbmVxdWFsaXR5RmllbGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWRPcmRlckJ5LnB1c2gobmV3IE9yZGVyQnkoRmllbGRQYXRoJDEua2V5RmllbGQoKSwgXCJhc2NcIiAvKiBBU0NFTkRJTkcgKi8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBmb3VuZEtleU9yZGVyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5KSB7XHJcbiAgICAgICAgICAgICAgICBxdWVyeUltcGwubWVtb2l6ZWRPcmRlckJ5LnB1c2gob3JkZXJCeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZEtleU9yZGVyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kS2V5T3JkZXJpbmcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgaW1wbGljaXQga2V5IG9yZGVyaW5nIGFsd2F5cyBtYXRjaGVzIHRoZSBsYXN0XHJcbiAgICAgICAgICAgICAgICAvLyBleHBsaWNpdCBvcmRlciBieVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHF1ZXJ5SW1wbC5leHBsaWNpdE9yZGVyQnkubGVuZ3RoID4gMFxyXG4gICAgICAgICAgICAgICAgICAgID8gcXVlcnlJbXBsLmV4cGxpY2l0T3JkZXJCeVtxdWVyeUltcGwuZXhwbGljaXRPcmRlckJ5Lmxlbmd0aCAtIDFdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kaXJcclxuICAgICAgICAgICAgICAgICAgICA6IFwiYXNjXCIgLyogQVNDRU5ESU5HICovO1xyXG4gICAgICAgICAgICAgICAgcXVlcnlJbXBsLm1lbW9pemVkT3JkZXJCeS5wdXNoKG5ldyBPcmRlckJ5KEZpZWxkUGF0aCQxLmtleUZpZWxkKCksIGxhc3REaXJlY3Rpb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBxdWVyeUltcGwubWVtb2l6ZWRPcmRlckJ5O1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGBRdWVyeWAgaW5zdGFuY2UgdG8gaXQncyBjb3JyZXNwb25kaW5nIGBUYXJnZXRgIHJlcHJlc2VudGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlUb1RhcmdldChxdWVyeSkge1xyXG4gICAgY29uc3QgcXVlcnlJbXBsID0gZGVidWdDYXN0KHF1ZXJ5KTtcclxuICAgIGlmICghcXVlcnlJbXBsLm1lbW9pemVkVGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5SW1wbC5saW1pdFR5cGUgPT09IFwiRlwiIC8qIEZpcnN0ICovKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZFRhcmdldCA9IG5ld1RhcmdldChxdWVyeUltcGwucGF0aCwgcXVlcnlJbXBsLmNvbGxlY3Rpb25Hcm91cCwgcXVlcnlPcmRlckJ5KHF1ZXJ5SW1wbCksIHF1ZXJ5SW1wbC5maWx0ZXJzLCBxdWVyeUltcGwubGltaXQsIHF1ZXJ5SW1wbC5zdGFydEF0LCBxdWVyeUltcGwuZW5kQXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRmxpcCB0aGUgb3JkZXJCeSBkaXJlY3Rpb25zIHNpbmNlIHdlIHdhbnQgdGhlIGxhc3QgcmVzdWx0c1xyXG4gICAgICAgICAgICBjb25zdCBvcmRlckJ5cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9yZGVyQnkgb2YgcXVlcnlPcmRlckJ5KHF1ZXJ5SW1wbCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpciA9IG9yZGVyQnkuZGlyID09PSBcImRlc2NcIiAvKiBERVNDRU5ESU5HICovXHJcbiAgICAgICAgICAgICAgICAgICAgPyBcImFzY1wiIC8qIEFTQ0VORElORyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIDogXCJkZXNjXCIgLyogREVTQ0VORElORyAqLztcclxuICAgICAgICAgICAgICAgIG9yZGVyQnlzLnB1c2gobmV3IE9yZGVyQnkob3JkZXJCeS5maWVsZCwgZGlyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzd2FwIHRoZSBjdXJzb3JzIHRvIG1hdGNoIHRoZSBub3ctZmxpcHBlZCBxdWVyeSBvcmRlcmluZy5cclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRBdCA9IHF1ZXJ5SW1wbC5lbmRBdFxyXG4gICAgICAgICAgICAgICAgPyBuZXcgQm91bmQocXVlcnlJbXBsLmVuZEF0LnBvc2l0aW9uLCAhcXVlcnlJbXBsLmVuZEF0LmluY2x1c2l2ZSlcclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgZW5kQXQgPSBxdWVyeUltcGwuc3RhcnRBdFxyXG4gICAgICAgICAgICAgICAgPyBuZXcgQm91bmQocXVlcnlJbXBsLnN0YXJ0QXQucG9zaXRpb24sICFxdWVyeUltcGwuc3RhcnRBdC5pbmNsdXNpdmUpXHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgICAgIC8vIE5vdyByZXR1cm4gYXMgYSBMaW1pdFR5cGUuRmlyc3QgcXVlcnkuXHJcbiAgICAgICAgICAgIHF1ZXJ5SW1wbC5tZW1vaXplZFRhcmdldCA9IG5ld1RhcmdldChxdWVyeUltcGwucGF0aCwgcXVlcnlJbXBsLmNvbGxlY3Rpb25Hcm91cCwgb3JkZXJCeXMsIHF1ZXJ5SW1wbC5maWx0ZXJzLCBxdWVyeUltcGwubGltaXQsIHN0YXJ0QXQsIGVuZEF0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlJbXBsLm1lbW9pemVkVGFyZ2V0O1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5V2l0aEFkZGVkRmlsdGVyKHF1ZXJ5LCBmaWx0ZXIpIHtcclxuICAgIGNvbnN0IG5ld0ZpbHRlcnMgPSBxdWVyeS5maWx0ZXJzLmNvbmNhdChbZmlsdGVyXSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBuZXdGaWx0ZXJzLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBxdWVyeS5lbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlXaXRoQWRkZWRPcmRlckJ5KHF1ZXJ5LCBvcmRlckJ5KSB7XHJcbiAgICAvLyBUT0RPKGRpbW9uZCk6IHZhbGlkYXRlIHRoYXQgb3JkZXJCeSBkb2VzIG5vdCBsaXN0IHRoZSBzYW1lIGtleSB0d2ljZS5cclxuICAgIGNvbnN0IG5ld09yZGVyQnkgPSBxdWVyeS5leHBsaWNpdE9yZGVyQnkuY29uY2F0KFtvcmRlckJ5XSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIG5ld09yZGVyQnksIHF1ZXJ5LmZpbHRlcnMuc2xpY2UoKSwgcXVlcnkubGltaXQsIHF1ZXJ5LmxpbWl0VHlwZSwgcXVlcnkuc3RhcnRBdCwgcXVlcnkuZW5kQXQpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBsaW1pdCwgbGltaXRUeXBlKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5wYXRoLCBxdWVyeS5jb2xsZWN0aW9uR3JvdXAsIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5zbGljZSgpLCBxdWVyeS5maWx0ZXJzLnNsaWNlKCksIGxpbWl0LCBsaW1pdFR5cGUsIHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5LmVuZEF0KTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeVdpdGhTdGFydEF0KHF1ZXJ5LCBib3VuZCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBib3VuZCwgcXVlcnkuZW5kQXQpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5V2l0aEVuZEF0KHF1ZXJ5LCBib3VuZCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkucGF0aCwgcXVlcnkuY29sbGVjdGlvbkdyb3VwLCBxdWVyeS5leHBsaWNpdE9yZGVyQnkuc2xpY2UoKSwgcXVlcnkuZmlsdGVycy5zbGljZSgpLCBxdWVyeS5saW1pdCwgcXVlcnkubGltaXRUeXBlLCBxdWVyeS5zdGFydEF0LCBib3VuZCk7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlFcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiAodGFyZ2V0RXF1YWxzKHF1ZXJ5VG9UYXJnZXQobGVmdCksIHF1ZXJ5VG9UYXJnZXQocmlnaHQpKSAmJlxyXG4gICAgICAgIGxlZnQubGltaXRUeXBlID09PSByaWdodC5saW1pdFR5cGUpO1xyXG59XHJcbi8vIFRPRE8oYi8yOTE4MzE2NSk6IFRoaXMgaXMgdXNlZCB0byBnZXQgYSB1bmlxdWUgc3RyaW5nIGZyb20gYSBxdWVyeSB0bywgZm9yXHJcbi8vIGV4YW1wbGUsIHVzZSBhcyBhIGRpY3Rpb25hcnkga2V5LCBidXQgdGhlIGltcGxlbWVudGF0aW9uIGlzIHN1YmplY3QgdG9cclxuLy8gY29sbGlzaW9ucy4gTWFrZSBpdCBjb2xsaXNpb24tZnJlZS5cclxuZnVuY3Rpb24gY2Fub25pZnlRdWVyeShxdWVyeSkge1xyXG4gICAgcmV0dXJuIGAke2Nhbm9uaWZ5VGFyZ2V0KHF1ZXJ5VG9UYXJnZXQocXVlcnkpKX18bHQ6JHtxdWVyeS5saW1pdFR5cGV9YDtcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeShxdWVyeSkge1xyXG4gICAgcmV0dXJuIGBRdWVyeSh0YXJnZXQ9JHtzdHJpbmdpZnlUYXJnZXQocXVlcnlUb1RhcmdldChxdWVyeSkpfTsgbGltaXRUeXBlPSR7cXVlcnkubGltaXRUeXBlfSlgO1xyXG59XHJcbi8qKiBSZXR1cm5zIHdoZXRoZXIgYGRvY2AgbWF0Y2hlcyB0aGUgY29uc3RyYWludHMgb2YgYHF1ZXJ5YC4gKi9cclxuZnVuY3Rpb24gcXVlcnlNYXRjaGVzKHF1ZXJ5LCBkb2MpIHtcclxuICAgIHJldHVybiAoZG9jLmlzRm91bmREb2N1bWVudCgpICYmXHJcbiAgICAgICAgcXVlcnlNYXRjaGVzUGF0aEFuZENvbGxlY3Rpb25Hcm91cChxdWVyeSwgZG9jKSAmJlxyXG4gICAgICAgIHF1ZXJ5TWF0Y2hlc09yZGVyQnkocXVlcnksIGRvYykgJiZcclxuICAgICAgICBxdWVyeU1hdGNoZXNGaWx0ZXJzKHF1ZXJ5LCBkb2MpICYmXHJcbiAgICAgICAgcXVlcnlNYXRjaGVzQm91bmRzKHF1ZXJ5LCBkb2MpKTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNQYXRoQW5kQ29sbGVjdGlvbkdyb3VwKHF1ZXJ5LCBkb2MpIHtcclxuICAgIGNvbnN0IGRvY1BhdGggPSBkb2Mua2V5LnBhdGg7XHJcbiAgICBpZiAocXVlcnkuY29sbGVjdGlvbkdyb3VwICE9PSBudWxsKSB7XHJcbiAgICAgICAgLy8gTk9URTogdGhpcy5wYXRoIGlzIGN1cnJlbnRseSBhbHdheXMgZW1wdHkgc2luY2Ugd2UgZG9uJ3QgZXhwb3NlIENvbGxlY3Rpb25cclxuICAgICAgICAvLyBHcm91cCBxdWVyaWVzIHJvb3RlZCBhdCBhIGRvY3VtZW50IHBhdGggeWV0LlxyXG4gICAgICAgIHJldHVybiAoZG9jLmtleS5oYXNDb2xsZWN0aW9uSWQocXVlcnkuY29sbGVjdGlvbkdyb3VwKSAmJlxyXG4gICAgICAgICAgICBxdWVyeS5wYXRoLmlzUHJlZml4T2YoZG9jUGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShxdWVyeS5wYXRoKSkge1xyXG4gICAgICAgIC8vIGV4YWN0IG1hdGNoIGZvciBkb2N1bWVudCBxdWVyaWVzXHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnBhdGguaXNFcXVhbChkb2NQYXRoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHNoYWxsb3cgYW5jZXN0b3IgcXVlcmllcyBieSBkZWZhdWx0XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnBhdGguaXNJbW1lZGlhdGVQYXJlbnRPZihkb2NQYXRoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBkb2N1bWVudCBtdXN0IGhhdmUgYSB2YWx1ZSBmb3IgZXZlcnkgb3JkZXJpbmcgY2xhdXNlIGluIG9yZGVyIHRvIHNob3cgdXBcclxuICogaW4gdGhlIHJlc3VsdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNPcmRlckJ5KHF1ZXJ5LCBkb2MpIHtcclxuICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeS5leHBsaWNpdE9yZGVyQnkpIHtcclxuICAgICAgICAvLyBvcmRlciBieSBrZXkgYWx3YXlzIG1hdGNoZXNcclxuICAgICAgICBpZiAoIW9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpICYmIGRvYy5kYXRhLmZpZWxkKG9yZGVyQnkuZmllbGQpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNGaWx0ZXJzKHF1ZXJ5LCBkb2MpIHtcclxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHF1ZXJ5LmZpbHRlcnMpIHtcclxuICAgICAgICBpZiAoIWZpbHRlci5tYXRjaGVzKGRvYykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKiBNYWtlcyBzdXJlIGEgZG9jdW1lbnQgaXMgd2l0aGluIHRoZSBib3VuZHMsIGlmIHByb3ZpZGVkLiAqL1xyXG5mdW5jdGlvbiBxdWVyeU1hdGNoZXNCb3VuZHMocXVlcnksIGRvYykge1xyXG4gICAgaWYgKHF1ZXJ5LnN0YXJ0QXQgJiZcclxuICAgICAgICAhYm91bmRTb3J0c0JlZm9yZURvY3VtZW50KHF1ZXJ5LnN0YXJ0QXQsIHF1ZXJ5T3JkZXJCeShxdWVyeSksIGRvYykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnkuZW5kQXQgJiZcclxuICAgICAgICAhYm91bmRTb3J0c0FmdGVyRG9jdW1lbnQocXVlcnkuZW5kQXQsIHF1ZXJ5T3JkZXJCeShxdWVyeSksIGRvYykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcGFyZSB0d28gZG9jdW1lbnRzXHJcbiAqIGJhc2VkIG9uIHRoZSBRdWVyeSdzIG9yZGVyaW5nIGNvbnN0cmFpbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpIHtcclxuICAgIHJldHVybiAoZDEsIGQyKSA9PiB7XHJcbiAgICAgICAgbGV0IGNvbXBhcmVkT25LZXlGaWVsZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAoY29uc3Qgb3JkZXJCeSBvZiBxdWVyeU9yZGVyQnkocXVlcnkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXAgPSBjb21wYXJlRG9jcyhvcmRlckJ5LCBkMSwgZDIpO1xyXG4gICAgICAgICAgICBpZiAoY29tcCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tcGFyZWRPbktleUZpZWxkID0gY29tcGFyZWRPbktleUZpZWxkIHx8IG9yZGVyQnkuZmllbGQuaXNLZXlGaWVsZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZURvY3Mob3JkZXJCeSwgZDEsIGQyKSB7XHJcbiAgICBjb25zdCBjb21wYXJpc29uID0gb3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKClcclxuICAgICAgICA/IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZDEua2V5LCBkMi5rZXkpXHJcbiAgICAgICAgOiBjb21wYXJlRG9jdW1lbnRzQnlGaWVsZChvcmRlckJ5LmZpZWxkLCBkMSwgZDIpO1xyXG4gICAgc3dpdGNoIChvcmRlckJ5LmRpcikge1xyXG4gICAgICAgIGNhc2UgXCJhc2NcIiAvKiBBU0NFTkRJTkcgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uO1xyXG4gICAgICAgIGNhc2UgXCJkZXNjXCIgLyogREVTQ0VORElORyAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIC0xICogY29tcGFyaXNvbjtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcclxuLy8gdHJlZS5cclxuY2xhc3MgU29ydGVkTWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IsIHJvb3QpIHtcclxuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QgPyByb290IDogTExSQk5vZGUuRU1QVFk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbWFwLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkIG9yIHJlcGxhY2VkLlxyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxyXG4gICAgICAgICAgICAuaW5zZXJ0KGtleSwgdmFsdWUsIHRoaXMuY29tcGFyYXRvcilcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3IsIHRoaXMucm9vdFxyXG4gICAgICAgICAgICAucmVtb3ZlKGtleSwgdGhpcy5jb21wYXJhdG9yKVxyXG4gICAgICAgICAgICAuY29weShudWxsLCBudWxsLCBMTFJCTm9kZS5CTEFDSywgbnVsbCwgbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsLlxyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290O1xyXG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY21wID0gdGhpcy5jb21wYXJhdG9yKGtleSwgbm9kZS5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gdGhpcyBzb3J0ZWQgbWFwLCBvciAtMSBpZiBpdCBkb2Vzbid0XHJcbiAgICAvLyBleGlzdC5cclxuICAgIGluZGV4T2Yoa2V5KSB7XHJcbiAgICAgICAgLy8gTnVtYmVyIG9mIG5vZGVzIHRoYXQgd2VyZSBwcnVuZWQgd2hlbiBkZXNjZW5kaW5nIHJpZ2h0XHJcbiAgICAgICAgbGV0IHBydW5lZE5vZGVzID0gMDtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdDtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyYXRvcihrZXksIG5vZGUua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBydW5lZE5vZGVzICsgbm9kZS5sZWZ0LnNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENvdW50IGFsbCBub2RlcyBsZWZ0IG9mIHRoZSBub2RlIHBsdXMgdGhlIG5vZGUgaXRzZWxmXHJcbiAgICAgICAgICAgICAgICBwcnVuZWROb2RlcyArPSBub2RlLmxlZnQuc2l6ZSArIDE7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb2RlIG5vdCBmb3VuZFxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIG1hcC5cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2l6ZTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5taW5LZXkoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1heGltdW0ga2V5IGluIHRoZSBtYXAuXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5tYXhLZXkoKTtcclxuICAgIH1cclxuICAgIC8vIFRyYXZlcnNlcyB0aGUgbWFwIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgIC8vIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgIC8vIFJldHVybnMgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxyXG4gICAgLy8gdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLlxyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIGZvckVhY2goZm4pIHtcclxuICAgICAgICB0aGlzLmlub3JkZXJUcmF2ZXJzYWwoKGssIHYpID0+IHtcclxuICAgICAgICAgICAgZm4oaywgdik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbnMucHVzaChgJHtrfToke3Z9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYHske2Rlc2NyaXB0aW9ucy5qb2luKCcsICcpfX1gO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhdmVyc2VzIHRoZSBtYXAgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uXHJcbiAgICAvLyBmdW5jdGlvbiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzXHJcbiAgICAvLyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBTb3J0ZWRNYXAuXHJcbiAgICBnZXRJdGVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdCwgbnVsbCwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvckZyb20oa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIGtleSwgdGhpcy5jb21wYXJhdG9yLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3QsIG51bGwsIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGtleSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290LCBrZXksIHRoaXMuY29tcGFyYXRvciwgdHJ1ZSk7XHJcbiAgICB9XHJcbn0gLy8gZW5kIFNvcnRlZE1hcFxyXG4vLyBBbiBpdGVyYXRvciBvdmVyIGFuIExMUkJOb2RlLlxyXG5jbGFzcyBTb3J0ZWRNYXBJdGVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlKSB7XHJcbiAgICAgICAgdGhpcy5pc1JldmVyc2UgPSBpc1JldmVyc2U7XHJcbiAgICAgICAgdGhpcy5ub2RlU3RhY2sgPSBbXTtcclxuICAgICAgICBsZXQgY21wID0gMTtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHN0YXJ0S2V5ID8gY29tcGFyYXRvcihub2RlLmtleSwgc3RhcnRLZXkpIDogMTtcclxuICAgICAgICAgICAgLy8gZmxpcCB0aGUgY29tcGFyaXNvbiBpZiB3ZSdyZSBnb2luZyBpbiByZXZlcnNlXHJcbiAgICAgICAgICAgIGlmIChpc1JldmVyc2UpIHtcclxuICAgICAgICAgICAgICAgIGNtcCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGxlc3MgdGhhbiBvdXIgc3RhcnQga2V5LiBpZ25vcmUgaXRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBleGFjdGx5IGVxdWFsIHRvIG91ciBzdGFydCBrZXkuIFB1c2ggaXQgb24gdGhlIHN0YWNrLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHN0b3AgaXRlcmF0aW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGdyZWF0ZXIgdGhhbiBvdXIgc3RhcnQga2V5LCBhZGQgaXQgdG8gdGhlIHN0YWNrIGFuZCBtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXROZXh0KCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlU3RhY2sucG9wKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZSkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaGFzTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2subGVuZ3RoID4gMDtcclxuICAgIH1cclxuICAgIHBlZWsoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZVN0YWNrW3RoaXMubm9kZVN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICB9XHJcbn0gLy8gZW5kIFNvcnRlZE1hcEl0ZXJhdG9yXHJcbi8vIFJlcHJlc2VudHMgYSBub2RlIGluIGEgTGVmdC1sZWFuaW5nIFJlZC1CbGFjayB0cmVlLlxyXG5jbGFzcyBMTFJCTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogTExSQk5vZGUuRU1QVFk7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IExMUkJOb2RlLkVNUFRZO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMubGVmdC5zaXplICsgMSArIHRoaXMucmlnaHQuc2l6ZTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUsIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHBpZWNlcyBvZiBpdC5cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXkgIT0gbnVsbCA/IGtleSA6IHRoaXMua2V5LCB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnZhbHVlLCBjb2xvciAhPSBudWxsID8gY29sb3IgOiB0aGlzLmNvbG9yLCBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogdGhpcy5sZWZ0LCByaWdodCAhPSBudWxsID8gcmlnaHQgOiB0aGlzLnJpZ2h0KTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgIC8vIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5sZWZ0Lmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB8fFxyXG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8vIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb25cclxuICAgIC8vIGZ1bmN0aW9uIGZvciBlYWNoIG5vZGUuIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgLy8gUmV0dXJucyB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAvLyB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24uXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5yaWdodC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cclxuICAgIG1pbigpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKCkua2V5O1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyB0aGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Lm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIGtleS92YWx1ZSBhZGRlZC5cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3Ioa2V5LCBuLmtleSk7XHJcbiAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBuLmxlZnQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgdmFsdWUsIG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNaW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIExMUkJOb2RlLkVNUFRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWQoKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW4oKSwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIG4uZml4VXAoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBpdGVtIHJlbW92ZWQuXHJcbiAgICByZW1vdmUoa2V5LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgbGV0IHNtYWxsZXN0O1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKCFuLmxlZnQuaXNFbXB0eSgpICYmICFuLmxlZnQuaXNSZWQoKSAmJiAhbi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobi5sZWZ0LmlzUmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFuLnJpZ2h0LmlzRW1wdHkoKSAmJiAhbi5yaWdodC5pc1JlZCgpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuLmtleSkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChuLnJpZ2h0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMTFJCTm9kZS5FTVBUWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0ID0gbi5yaWdodC5taW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbi5jb3B5KHNtYWxsZXN0LmtleSwgc21hbGxlc3QudmFsdWUsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlTWluKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuLmZpeFVwKCk7XHJcbiAgICB9XHJcbiAgICBpc1JlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgbmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cclxuICAgIGZpeFVwKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAobi5yaWdodC5pc1JlZCgpICYmICFuLmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLmxlZnQubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWQoKSAmJiBuLnJpZ2h0LmlzUmVkKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgbW92ZVJlZExlZnQoKSB7XHJcbiAgICAgICAgbGV0IG4gPSB0aGlzLmNvbG9yRmxpcCgpO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucm90YXRlUmlnaHQoKSk7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnQoKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgbW92ZVJlZFJpZ2h0KCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcy5jb2xvckZsaXAoKTtcclxuICAgICAgICBpZiAobi5sZWZ0LmxlZnQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodCgpO1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcbiAgICByb3RhdGVMZWZ0KCkge1xyXG4gICAgICAgIGNvbnN0IG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcclxuICAgIH1cclxuICAgIHJvdGF0ZVJpZ2h0KCkge1xyXG4gICAgICAgIGNvbnN0IG5yID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgdGhpcy5sZWZ0LnJpZ2h0LCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmNvcHkobnVsbCwgbnVsbCwgdGhpcy5jb2xvciwgbnVsbCwgbnIpO1xyXG4gICAgfVxyXG4gICAgY29sb3JGbGlwKCkge1xyXG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCAhdGhpcy5sZWZ0LmNvbG9yLCBudWxsLCBudWxsKTtcclxuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucmlnaHQuY29weShudWxsLCBudWxsLCAhdGhpcy5yaWdodC5jb2xvciwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShudWxsLCBudWxsLCAhdGhpcy5jb2xvciwgbGVmdCwgcmlnaHQpO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIHRlc3RpbmcuXHJcbiAgICBjaGVja01heERlcHRoKCkge1xyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmNoZWNrKCk7XHJcbiAgICAgICAgaWYgKE1hdGgucG93KDIuMCwgYmxhY2tEZXB0aCkgPD0gdGhpcy5zaXplICsgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJbiBhIGJhbGFuY2VkIFJCIHRyZWUsIHRoZSBibGFjay1kZXB0aCAobnVtYmVyIG9mIGJsYWNrIG5vZGVzKSBmcm9tIHJvb3QgdG9cclxuICAgIC8vIGxlYXZlcyBpcyBlcXVhbCBvbiBib3RoIHNpZGVzLiAgVGhpcyBmdW5jdGlvbiB2ZXJpZmllcyB0aGF0IG9yIGFzc2VydHMuXHJcbiAgICBjaGVjaygpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1JlZCgpICYmIHRoaXMubGVmdC5pc1JlZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNSZWQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmxlZnQuY2hlY2soKTtcclxuICAgICAgICBpZiAoYmxhY2tEZXB0aCAhPT0gdGhpcy5yaWdodC5jaGVjaygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibGFja0RlcHRoICsgKHRoaXMuaXNSZWQoKSA/IDAgOiAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0gLy8gZW5kIExMUkJOb2RlXHJcbi8vIEVtcHR5IG5vZGUgaXMgc2hhcmVkIGJldHdlZW4gYWxsIExMUkIgdHJlZXMuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbkxMUkJOb2RlLkVNUFRZID0gbnVsbDtcclxuTExSQk5vZGUuUkVEID0gdHJ1ZTtcclxuTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcclxuLy8gUmVwcmVzZW50cyBhbiBlbXB0eSBub2RlIChhIGxlYWYgbm9kZSBpbiB0aGUgUmVkLUJsYWNrIFRyZWUpLlxyXG5jbGFzcyBMTFJCRW1wdHlOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgY29sb3IoKSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxlZnQoKSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJpZ2h0KCkge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUuXHJcbiAgICBjb3B5KGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpc1JlZCgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBGb3IgdGVzdGluZy5cclxuICAgIGNoZWNrTWF4RGVwdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjaGVjaygpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufSAvLyBlbmQgTExSQkVtcHR5Tm9kZVxyXG5MTFJCTm9kZS5FTVBUWSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBTb3J0ZWRTZXQgaXMgYW4gaW1tdXRhYmxlIChjb3B5LW9uLXdyaXRlKSBjb2xsZWN0aW9uIHRoYXQgaG9sZHMgZWxlbWVudHNcclxuICogaW4gb3JkZXIgc3BlY2lmaWVkIGJ5IHRoZSBwcm92aWRlZCBjb21wYXJhdG9yLlxyXG4gKlxyXG4gKiBOT1RFOiBpZiBwcm92aWRlZCBjb21wYXJhdG9yIHJldHVybnMgMCBmb3IgdHdvIGVsZW1lbnRzLCB3ZSBjb25zaWRlciB0aGVtIHRvXHJcbiAqIGJlIGVxdWFsIVxyXG4gKi9cclxuY2xhc3MgU29ydGVkU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IpIHtcclxuICAgICAgICB0aGlzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIGhhcyhlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXQoZWxlbSkgIT09IG51bGw7XHJcbiAgICB9XHJcbiAgICBmaXJzdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1pbktleSgpO1xyXG4gICAgfVxyXG4gICAgbGFzdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1heEtleSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zaXplO1xyXG4gICAgfVxyXG4gICAgaW5kZXhPZihlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5pbmRleE9mKGVsZW0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIG9yZGVyIGRlZmluZWQgYnkgXCJjb21wYXJhdG9yXCIgKi9cclxuICAgIGZvckVhY2goY2IpIHtcclxuICAgICAgICB0aGlzLmRhdGEuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xyXG4gICAgICAgICAgICBjYihrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEl0ZXJhdGVzIG92ZXIgYGVsZW1gcyBzdWNoIHRoYXQ6IHJhbmdlWzBdICZsdDs9IGVsZW0gJmx0OyByYW5nZVsxXS4gKi9cclxuICAgIGZvckVhY2hJblJhbmdlKHJhbmdlLCBjYikge1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKHJhbmdlWzBdKTtcclxuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbSA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wYXJhdG9yKGVsZW0ua2V5LCByYW5nZVsxXSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNiKGVsZW0ua2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYGVsZW1gcyBzdWNoIHRoYXQ6IHN0YXJ0ICZsdDs9IGVsZW0gdW50aWwgZmFsc2UgaXMgcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2hXaGlsZShjYiwgc3RhcnQpIHtcclxuICAgICAgICBsZXQgaXRlcjtcclxuICAgICAgICBpZiAoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yRnJvbShzdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpdGVyID0gdGhpcy5kYXRhLmdldEl0ZXJhdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpdGVyLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNiKGVsZW0ua2V5KTtcclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBGaW5kcyB0aGUgbGVhc3QgZWxlbWVudCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYGVsZW1gLiAqL1xyXG4gICAgZmlyc3RBZnRlck9yRXF1YWwoZWxlbSkge1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3JGcm9tKGVsZW0pO1xyXG4gICAgICAgIHJldHVybiBpdGVyLmhhc05leHQoKSA/IGl0ZXIuZ2V0TmV4dCgpLmtleSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZFNldEl0ZXJhdG9yKHRoaXMuZGF0YS5nZXRJdGVyYXRvcigpKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShrZXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZFNldEl0ZXJhdG9yKHRoaXMuZGF0YS5nZXRJdGVyYXRvckZyb20oa2V5KSk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0cyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgKi9cclxuICAgIGFkZChlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmRhdGEucmVtb3ZlKGVsZW0pLmluc2VydChlbGVtLCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICAvKiogRGVsZXRlcyBhbiBlbGVtZW50ICovXHJcbiAgICBkZWxldGUoZWxlbSkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYXMoZWxlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5kYXRhLnJlbW92ZShlbGVtKSk7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgdW5pb25XaXRoKG90aGVyKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXM7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIGByZXN1bHRgIGFsd2F5cyByZWZlcnMgdG8gdGhlIGxhcmdlciBvbmUgb2YgdGhlIHR3byBzZXRzLlxyXG4gICAgICAgIGlmIChyZXN1bHQuc2l6ZSA8IG90aGVyLnNpemUpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gb3RoZXI7XHJcbiAgICAgICAgICAgIG90aGVyID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgb3RoZXIuZm9yRWFjaChlbGVtID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChlbGVtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU29ydGVkU2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNpemUgIT09IG90aGVyLnNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aGlzSXQgPSB0aGlzLmRhdGEuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICBjb25zdCBvdGhlckl0ID0gb3RoZXIuZGF0YS5nZXRJdGVyYXRvcigpO1xyXG4gICAgICAgIHdoaWxlICh0aGlzSXQuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRoaXNFbGVtID0gdGhpc0l0LmdldE5leHQoKS5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IG90aGVyRWxlbSA9IG90aGVySXQuZ2V0TmV4dCgpLmtleTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyYXRvcih0aGlzRWxlbSwgb3RoZXJFbGVtKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmZvckVhY2godGFyZ2V0SWQgPT4ge1xyXG4gICAgICAgICAgICByZXMucHVzaCh0YXJnZXRJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChlbGVtID0+IHJlc3VsdC5wdXNoKGVsZW0pKTtcclxuICAgICAgICByZXR1cm4gJ1NvcnRlZFNldCgnICsgcmVzdWx0LnRvU3RyaW5nKCkgKyAnKSc7XHJcbiAgICB9XHJcbiAgICBjb3B5KGRhdGEpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU29ydGVkU2V0KHRoaXMuY29tcGFyYXRvcik7XHJcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgU29ydGVkU2V0SXRlcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoaXRlcikge1xyXG4gICAgICAgIHRoaXMuaXRlciA9IGl0ZXI7XHJcbiAgICB9XHJcbiAgICBnZXROZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZXIuZ2V0TmV4dCgpLmtleTtcclxuICAgIH1cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlci5oYXNOZXh0KCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byBzb3J0ZWQgc2V0cyBmb3IgZXF1YWxpdHkgdXNpbmcgdGhlaXIgbmF0dXJhbCBvcmRlcmluZy4gVGhlXHJcbiAqIG1ldGhvZCBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIGFuZCBpbnZva2VzIGBvbkFkZGAgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdFxyXG4gKiBpcyBpbiBgYWZ0ZXJgIGJ1dCBub3QgYGJlZm9yZWAuIGBvblJlbW92ZWAgaXMgaW52b2tlZCBmb3IgZXZlcnkgZWxlbWVudCBpblxyXG4gKiBgYmVmb3JlYCBidXQgbWlzc2luZyBmcm9tIGBhZnRlcmAuXHJcbiAqXHJcbiAqIFRoZSBtZXRob2QgY3JlYXRlcyBhIGNvcHkgb2YgYm90aCBgYmVmb3JlYCBhbmQgYGFmdGVyYCBhbmQgcnVucyBpbiBPKG4gbG9nXHJcbiAqIG4pLCB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSB0d28gbGlzdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBiZWZvcmUgLSBUaGUgZWxlbWVudHMgdGhhdCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgc2V0LlxyXG4gKiBAcGFyYW0gYWZ0ZXIgLSBUaGUgZWxlbWVudHMgdG8gZGlmZiBhZ2FpbnN0IHRoZSBvcmlnaW5hbCBzZXQuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIC0gVGhlIGNvbXBhcmF0b3IgZm9yIHRoZSBlbGVtZW50cyBpbiBiZWZvcmUgYW5kIGFmdGVyLlxyXG4gKiBAcGFyYW0gb25BZGQgLSBBIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZXZlcnkgZWxlbWVudCB0aGF0IGlzIHBhcnQgb2YgYFxyXG4gKiBhZnRlcmAgYnV0IG5vdCBgYmVmb3JlYC5cclxuICogQHBhcmFtIG9uUmVtb3ZlIC0gQSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBpcyBwYXJ0IG9mXHJcbiAqIGBiZWZvcmVgIGJ1dCBub3QgYGFmdGVyYC5cclxuICovXHJcbmZ1bmN0aW9uIGRpZmZTb3J0ZWRTZXRzKGJlZm9yZSwgYWZ0ZXIsIGNvbXBhcmF0b3IsIG9uQWRkLCBvblJlbW92ZSkge1xyXG4gICAgY29uc3QgYmVmb3JlSXQgPSBiZWZvcmUuZ2V0SXRlcmF0b3IoKTtcclxuICAgIGNvbnN0IGFmdGVySXQgPSBhZnRlci5nZXRJdGVyYXRvcigpO1xyXG4gICAgbGV0IGJlZm9yZVZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGJlZm9yZUl0KTtcclxuICAgIGxldCBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xyXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSB0d28gc2V0cyBhdCB0aGUgc2FtZSB0aW1lLCB1c2luZyB0aGUgb3JkZXJpbmcgZGVmaW5lZCBieVxyXG4gICAgLy8gYGNvbXBhcmF0b3JgLlxyXG4gICAgd2hpbGUgKGJlZm9yZVZhbHVlIHx8IGFmdGVyVmFsdWUpIHtcclxuICAgICAgICBsZXQgYWRkZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChiZWZvcmVWYWx1ZSAmJiBhZnRlclZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtcCA9IGNvbXBhcmF0b3IoYmVmb3JlVmFsdWUsIGFmdGVyVmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQgaWYgdGhlIG5leHQgZWxlbWVudCBpbiBvdXIgb3JkZXJlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2Fsa3Rocm91Z2ggaXMgb25seSBpbiBgYmVmb3JlYC5cclxuICAgICAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyBhZGRlZCBpZiB0aGUgbmV4dCBlbGVtZW50IGluIG91ciBvcmRlcmVkIHdhbGt0aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAvLyBpcyBvbmx5IGluIGBhZnRlcmAuXHJcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYmVmb3JlVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFkZGVkKSB7XHJcbiAgICAgICAgICAgIG9uQWRkKGFmdGVyVmFsdWUpO1xyXG4gICAgICAgICAgICBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIG9uUmVtb3ZlKGJlZm9yZVZhbHVlKTtcclxuICAgICAgICAgICAgYmVmb3JlVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYmVmb3JlSXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYmVmb3JlVmFsdWUgPSBhZHZhbmNlSXRlcmF0b3IoYmVmb3JlSXQpO1xyXG4gICAgICAgICAgICBhZnRlclZhbHVlID0gYWR2YW5jZUl0ZXJhdG9yKGFmdGVySXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbmV4dCBlbGVtZW50IGZyb20gdGhlIGl0ZXJhdG9yIG9yIGB1bmRlZmluZWRgIGlmIG5vbmUgYXZhaWxhYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gYWR2YW5jZUl0ZXJhdG9yKGl0KSB7XHJcbiAgICByZXR1cm4gaXQuaGFzTmV4dCgpID8gaXQuZ2V0TmV4dCgpIDogdW5kZWZpbmVkO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IEVNUFRZX01VVEFCTEVfRE9DVU1FTlRfTUFQID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuZnVuY3Rpb24gbXV0YWJsZURvY3VtZW50TWFwKCkge1xyXG4gICAgcmV0dXJuIEVNUFRZX01VVEFCTEVfRE9DVU1FTlRfTUFQO1xyXG59XHJcbmNvbnN0IEVNUFRZX0RPQ1VNRU5UX01BUCA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbmZ1bmN0aW9uIGRvY3VtZW50TWFwKCkge1xyXG4gICAgcmV0dXJuIEVNUFRZX0RPQ1VNRU5UX01BUDtcclxufVxyXG5jb25zdCBFTVBUWV9ET0NVTUVOVF9WRVJTSU9OX01BUCA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbmZ1bmN0aW9uIGRvY3VtZW50VmVyc2lvbk1hcCgpIHtcclxuICAgIHJldHVybiBFTVBUWV9ET0NVTUVOVF9WRVJTSU9OX01BUDtcclxufVxyXG5jb25zdCBFTVBUWV9ET0NVTUVOVF9LRVlfU0VUID0gbmV3IFNvcnRlZFNldChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuZnVuY3Rpb24gZG9jdW1lbnRLZXlTZXQoLi4ua2V5cykge1xyXG4gICAgbGV0IHNldCA9IEVNUFRZX0RPQ1VNRU5UX0tFWV9TRVQ7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgc2V0ID0gc2V0LmFkZChrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNldDtcclxufVxyXG5jb25zdCBFTVBUWV9UQVJHRVRfSURfU0VUID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuZnVuY3Rpb24gdGFyZ2V0SWRTZXQoKSB7XHJcbiAgICByZXR1cm4gRU1QVFlfVEFSR0VUX0lEX1NFVDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhbiBEb3VibGVWYWx1ZSBmb3IgYHZhbHVlYCB0aGF0IGlzIGVuY29kZWQgYmFzZWQgdGhlIHNlcmlhbGl6ZXInc1xyXG4gKiBgdXNlUHJvdG8zSnNvbmAgc2V0dGluZy5cclxuICovXHJcbmZ1bmN0aW9uIHRvRG91YmxlKHNlcmlhbGl6ZXIsIHZhbHVlKSB7XHJcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBkb3VibGVWYWx1ZTogJ05hTicgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRvdWJsZVZhbHVlOiAnSW5maW5pdHknIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6ICctSW5maW5pdHknIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgZG91YmxlVmFsdWU6IGlzTmVnYXRpdmVaZXJvKHZhbHVlKSA/ICctMCcgOiB2YWx1ZSB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIEludGVnZXJWYWx1ZSBmb3IgYHZhbHVlYC5cclxuICovXHJcbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHsgaW50ZWdlclZhbHVlOiAnJyArIHZhbHVlIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSB2YWx1ZSBmb3IgYSBudW1iZXIgdGhhdCdzIGFwcHJvcHJpYXRlIHRvIHB1dCBpbnRvIGEgcHJvdG8uXHJcbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gSW50ZWdlclZhbHVlIGlmIGl0IGNhbiBzYWZlbHkgcmVwcmVzZW50IHRoZSB2YWx1ZSxcclxuICogb3RoZXJ3aXNlIGEgRG91YmxlVmFsdWUgaXMgcmV0dXJuZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b051bWJlcihzZXJpYWxpemVyLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzU2FmZUludGVnZXIodmFsdWUpID8gdG9JbnRlZ2VyKHZhbHVlKSA6IHRvRG91YmxlKHNlcmlhbGl6ZXIsIHZhbHVlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogVXNlZCB0byByZXByZXNlbnQgYSBmaWVsZCB0cmFuc2Zvcm0gb24gYSBtdXRhdGlvbi4gKi9cclxuY2xhc3MgVHJhbnNmb3JtT3BlcmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBzdHJ1Y3R1cmFsIHR5cGUgb2YgYFRyYW5zZm9ybU9wZXJhdGlvbmAgaXMgdW5pcXVlLlxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzU0NTFcclxuICAgICAgICB0aGlzLl8gPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBsb2NhbCB0cmFuc2Zvcm0gcmVzdWx0IGFnYWluc3QgdGhlIHByb3ZpZGVkIGBwcmV2aW91c1ZhbHVlYCxcclxuICogb3B0aW9uYWxseSB1c2luZyB0aGUgcHJvdmlkZWQgbG9jYWxXcml0ZVRpbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybU9wZXJhdGlvblRvTG9jYWxWaWV3KHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSwgbG9jYWxXcml0ZVRpbWUpIHtcclxuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBTZXJ2ZXJUaW1lc3RhbXBUcmFuc2Zvcm0pIHtcclxuICAgICAgICByZXR1cm4gc2VydmVyVGltZXN0YW1wJDEobG9jYWxXcml0ZVRpbWUsIHByZXZpb3VzVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhcHBseU51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhIGZpbmFsIHRyYW5zZm9ybSByZXN1bHQgYWZ0ZXIgdGhlIHRyYW5zZm9ybSBoYXMgYmVlbiBhY2tub3dsZWRnZWRcclxuICogYnkgdGhlIHNlcnZlciwgcG90ZW50aWFsbHkgdXNpbmcgdGhlIHNlcnZlci1wcm92aWRlZCB0cmFuc2Zvcm1SZXN1bHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseVRyYW5zZm9ybU9wZXJhdGlvblRvUmVtb3RlRG9jdW1lbnQodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlLCB0cmFuc2Zvcm1SZXN1bHQpIHtcclxuICAgIC8vIFRoZSBzZXJ2ZXIganVzdCBzZW5kcyBudWxsIGFzIHRoZSB0cmFuc2Zvcm0gcmVzdWx0IGZvciBhcnJheSBvcGVyYXRpb25zLFxyXG4gICAgLy8gc28gd2UgaGF2ZSB0byBjYWxjdWxhdGUgYSByZXN1bHQgdGhlIHNhbWUgYXMgd2UgZG8gZm9yIGxvY2FsXHJcbiAgICAvLyBhcHBsaWNhdGlvbnMuXHJcbiAgICBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGFwcGx5QXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIElmIHRoaXMgdHJhbnNmb3JtIG9wZXJhdGlvbiBpcyBub3QgaWRlbXBvdGVudCwgcmV0dXJucyB0aGUgYmFzZSB2YWx1ZSB0b1xyXG4gKiBwZXJzaXN0IGZvciB0aGlzIHRyYW5zZm9ybS4gSWYgYSBiYXNlIHZhbHVlIGlzIHJldHVybmVkLCB0aGUgdHJhbnNmb3JtXHJcbiAqIG9wZXJhdGlvbiBpcyBhbHdheXMgYXBwbGllZCB0byB0aGlzIGJhc2UgdmFsdWUsIGV2ZW4gaWYgZG9jdW1lbnQgaGFzXHJcbiAqIGFscmVhZHkgYmVlbiB1cGRhdGVkLlxyXG4gKlxyXG4gKiBCYXNlIHZhbHVlcyBwcm92aWRlIGNvbnNpc3RlbnQgYmVoYXZpb3IgZm9yIG5vbi1pZGVtcG90ZW50IHRyYW5zZm9ybXMgYW5kXHJcbiAqIGFsbG93IHVzIHRvIHJldHVybiB0aGUgc2FtZSBsYXRlbmN5LWNvbXBlbnNhdGVkIHZhbHVlIGV2ZW4gaWYgdGhlIGJhY2tlbmRcclxuICogaGFzIGFscmVhZHkgYXBwbGllZCB0aGUgdHJhbnNmb3JtIG9wZXJhdGlvbi4gVGhlIGJhc2UgdmFsdWUgaXMgbnVsbCBmb3JcclxuICogaWRlbXBvdGVudCB0cmFuc2Zvcm1zLCBhcyB0aGV5IGNhbiBiZSByZS1wbGF5ZWQgZXZlbiBpZiB0aGUgYmFja2VuZCBoYXNcclxuICogYWxyZWFkeSBhcHBsaWVkIHRoZW0uXHJcbiAqXHJcbiAqIEByZXR1cm5zIGEgYmFzZSB2YWx1ZSB0byBzdG9yZSBhbG9uZyB3aXRoIHRoZSBtdXRhdGlvbiwgb3IgbnVsbCBmb3JcclxuICogaWRlbXBvdGVudCB0cmFuc2Zvcm1zLlxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHV0ZVRyYW5zZm9ybU9wZXJhdGlvbkJhc2VWYWx1ZSh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUpIHtcclxuICAgIGlmICh0cmFuc2Zvcm0gaW5zdGFuY2VvZiBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyKHByZXZpb3VzVmFsdWUpID8gcHJldmlvdXNWYWx1ZSA6IHsgaW50ZWdlclZhbHVlOiAwIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1PcGVyYXRpb25FcXVhbHMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbiAmJlxyXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlVbmlvblRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhcnJheUVxdWFscyhsZWZ0LmVsZW1lbnRzLCByaWdodC5lbGVtZW50cywgdmFsdWVFcXVhbHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uICYmXHJcbiAgICAgICAgcmlnaHQgaW5zdGFuY2VvZiBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBhcnJheUVxdWFscyhsZWZ0LmVsZW1lbnRzLCByaWdodC5lbGVtZW50cywgdmFsdWVFcXVhbHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24gJiZcclxuICAgICAgICByaWdodCBpbnN0YW5jZW9mIE51bWVyaWNJbmNyZW1lbnRUcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVFcXVhbHMobGVmdC5vcGVyYW5kLCByaWdodC5vcGVyYW5kKTtcclxuICAgIH1cclxuICAgIHJldHVybiAobGVmdCBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSAmJlxyXG4gICAgICAgIHJpZ2h0IGluc3RhbmNlb2YgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtKTtcclxufVxyXG4vKiogVHJhbnNmb3JtcyBhIHZhbHVlIGludG8gYSBzZXJ2ZXItZ2VuZXJhdGVkIHRpbWVzdGFtcC4gKi9cclxuY2xhc3MgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtIGV4dGVuZHMgVHJhbnNmb3JtT3BlcmF0aW9uIHtcclxufVxyXG4vKiogVHJhbnNmb3JtcyBhbiBhcnJheSB2YWx1ZSB2aWEgYSB1bmlvbiBvcGVyYXRpb24uICovXHJcbmNsYXNzIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24gZXh0ZW5kcyBUcmFuc2Zvcm1PcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhcHBseUFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XHJcbiAgICBjb25zdCB2YWx1ZXMgPSBjb2VyY2VkRmllbGRWYWx1ZXNBcnJheShwcmV2aW91c1ZhbHVlKTtcclxuICAgIGZvciAoY29uc3QgdG9VbmlvbiBvZiB0cmFuc2Zvcm0uZWxlbWVudHMpIHtcclxuICAgICAgICBpZiAoIXZhbHVlcy5zb21lKGVsZW1lbnQgPT4gdmFsdWVFcXVhbHMoZWxlbWVudCwgdG9VbmlvbikpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRvVW5pb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHsgdmFsdWVzIH0gfTtcclxufVxyXG4vKiogVHJhbnNmb3JtcyBhbiBhcnJheSB2YWx1ZSB2aWEgYSByZW1vdmUgb3BlcmF0aW9uLiAqL1xyXG5jbGFzcyBBcnJheVJlbW92ZVRyYW5zZm9ybU9wZXJhdGlvbiBleHRlbmRzIFRyYW5zZm9ybU9wZXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFwcGx5QXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24odHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XHJcbiAgICBsZXQgdmFsdWVzID0gY29lcmNlZEZpZWxkVmFsdWVzQXJyYXkocHJldmlvdXNWYWx1ZSk7XHJcbiAgICBmb3IgKGNvbnN0IHRvUmVtb3ZlIG9mIHRyYW5zZm9ybS5lbGVtZW50cykge1xyXG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoZWxlbWVudCA9PiAhdmFsdWVFcXVhbHMoZWxlbWVudCwgdG9SZW1vdmUpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHsgdmFsdWVzIH0gfTtcclxufVxyXG4vKipcclxuICogSW1wbGVtZW50cyB0aGUgYmFja2VuZCBzZW1hbnRpY3MgZm9yIGxvY2FsbHkgY29tcHV0ZWQgTlVNRVJJQ19BREQgKGluY3JlbWVudClcclxuICogdHJhbnNmb3Jtcy4gQ29udmVydHMgYWxsIGZpZWxkIHZhbHVlcyB0byBpbnRlZ2VycyBvciBkb3VibGVzLCBidXQgdW5saWtlIHRoZVxyXG4gKiBiYWNrZW5kIGRvZXMgbm90IGNhcCBpbnRlZ2VyIHZhbHVlcyBhdCAyXjYzLiBJbnN0ZWFkLCBKYXZhU2NyaXB0IG51bWJlclxyXG4gKiBhcml0aG1ldGljIGlzIHVzZWQgYW5kIHByZWNpc2lvbiBsb3NzIGNhbiBvY2N1ciBmb3IgdmFsdWVzIGdyZWF0ZXIgdGhhbiAyXjUzLlxyXG4gKi9cclxuY2xhc3MgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbiBleHRlbmRzIFRyYW5zZm9ybU9wZXJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyLCBvcGVyYW5kKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uVG9Mb2NhbFZpZXcodHJhbnNmb3JtLCBwcmV2aW91c1ZhbHVlKSB7XHJcbiAgICAvLyBQT1JUSU5HIE5PVEU6IFNpbmNlIEphdmFTY3JpcHQncyBpbnRlZ2VyIGFyaXRobWV0aWMgaXMgbGltaXRlZCB0byA1MyBiaXRcclxuICAgIC8vIHByZWNpc2lvbiBhbmQgcmVzb2x2ZXMgb3ZlcmZsb3dzIGJ5IHJlZHVjaW5nIHByZWNpc2lvbiwgd2UgZG8gbm90XHJcbiAgICAvLyBtYW51YWxseSBjYXAgb3ZlcmZsb3dzIGF0IDJeNjMuXHJcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBjb21wdXRlVHJhbnNmb3JtT3BlcmF0aW9uQmFzZVZhbHVlKHRyYW5zZm9ybSwgcHJldmlvdXNWYWx1ZSk7XHJcbiAgICBjb25zdCBzdW0gPSBhc051bWJlcihiYXNlVmFsdWUpICsgYXNOdW1iZXIodHJhbnNmb3JtLm9wZXJhbmQpO1xyXG4gICAgaWYgKGlzSW50ZWdlcihiYXNlVmFsdWUpICYmIGlzSW50ZWdlcih0cmFuc2Zvcm0ub3BlcmFuZCkpIHtcclxuICAgICAgICByZXR1cm4gdG9JbnRlZ2VyKHN1bSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdG9Eb3VibGUodHJhbnNmb3JtLnNlcmlhbGl6ZXIsIHN1bSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXNOdW1iZXIodmFsdWUpIHtcclxuICAgIHJldHVybiBub3JtYWxpemVOdW1iZXIodmFsdWUuaW50ZWdlclZhbHVlIHx8IHZhbHVlLmRvdWJsZVZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiBjb2VyY2VkRmllbGRWYWx1ZXNBcnJheSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmFycmF5VmFsdWUudmFsdWVzXHJcbiAgICAgICAgPyB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcy5zbGljZSgpXHJcbiAgICAgICAgOiBbXTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogQSBmaWVsZCBwYXRoIGFuZCB0aGUgVHJhbnNmb3JtT3BlcmF0aW9uIHRvIHBlcmZvcm0gdXBvbiBpdC4gKi9cclxuY2xhc3MgRmllbGRUcmFuc2Zvcm0ge1xyXG4gICAgY29uc3RydWN0b3IoZmllbGQsIHRyYW5zZm9ybSkge1xyXG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaWVsZFRyYW5zZm9ybUVxdWFscyhsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIChsZWZ0LmZpZWxkLmlzRXF1YWwocmlnaHQuZmllbGQpICYmXHJcbiAgICAgICAgdHJhbnNmb3JtT3BlcmF0aW9uRXF1YWxzKGxlZnQudHJhbnNmb3JtLCByaWdodC50cmFuc2Zvcm0pKTtcclxufVxyXG5mdW5jdGlvbiBmaWVsZFRyYW5zZm9ybXNBcmVFcXVhbChsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdCAmJiByaWdodCkge1xyXG4gICAgICAgIHJldHVybiBhcnJheUVxdWFscyhsZWZ0LCByaWdodCwgKGwsIHIpID0+IGZpZWxkVHJhbnNmb3JtRXF1YWxzKGwsIHIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKiogVGhlIHJlc3VsdCBvZiBzdWNjZXNzZnVsbHkgYXBwbHlpbmcgYSBtdXRhdGlvbiB0byB0aGUgYmFja2VuZC4gKi9cclxuY2xhc3MgTXV0YXRpb25SZXN1bHQge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB2ZXJzaW9uIGF0IHdoaWNoIHRoZSBtdXRhdGlvbiB3YXMgY29tbWl0dGVkOlxyXG4gICAgICpcclxuICAgICAqIC0gRm9yIG1vc3Qgb3BlcmF0aW9ucywgdGhpcyBpcyB0aGUgdXBkYXRlVGltZSBpbiB0aGUgV3JpdGVSZXN1bHQuXHJcbiAgICAgKiAtIEZvciBkZWxldGVzLCB0aGUgY29tbWl0VGltZSBvZiB0aGUgV3JpdGVSZXNwb25zZSAoYmVjYXVzZSBkZWxldGVzIGFyZVxyXG4gICAgICogICBub3Qgc3RvcmVkIGFuZCBoYXZlIG5vIHVwZGF0ZVRpbWUpLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCB0aGVzZSB2ZXJzaW9ucyBjYW4gYmUgZGlmZmVyZW50OiBOby1vcCB3cml0ZXMgd2lsbCBub3QgY2hhbmdlXHJcbiAgICAgKiB0aGUgdXBkYXRlVGltZSBldmVuIHRob3VnaCB0aGUgY29tbWl0VGltZSBhZHZhbmNlcy5cclxuICAgICAqL1xyXG4gICAgdmVyc2lvbiwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZXN1bHRpbmcgZmllbGRzIHJldHVybmVkIGZyb20gdGhlIGJhY2tlbmQgYWZ0ZXIgYSBtdXRhdGlvblxyXG4gICAgICogY29udGFpbmluZyBmaWVsZCB0cmFuc2Zvcm1zIGhhcyBiZWVuIGNvbW1pdHRlZC4gQ29udGFpbnMgb25lIEZpZWxkVmFsdWVcclxuICAgICAqIGZvciBlYWNoIEZpZWxkVHJhbnNmb3JtIHRoYXQgd2FzIGluIHRoZSBtdXRhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBXaWxsIGJlIGVtcHR5IGlmIHRoZSBtdXRhdGlvbiBkaWQgbm90IGNvbnRhaW4gYW55IGZpZWxkIHRyYW5zZm9ybXMuXHJcbiAgICAgKi9cclxuICAgIHRyYW5zZm9ybVJlc3VsdHMpIHtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtUmVzdWx0cyA9IHRyYW5zZm9ybVJlc3VsdHM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBwcmVjb25kaXRpb24gZm9yIGEgbXV0YXRpb24uIFRoaXMgZm9sbG93cyB0aGUgbW9kZWwgdGhhdCB0aGVcclxuICogYmFja2VuZCBhY2NlcHRzIHdpdGggdGhlIHNwZWNpYWwgY2FzZSBvZiBhbiBleHBsaWNpdCBcImVtcHR5XCIgcHJlY29uZGl0aW9uXHJcbiAqIChtZWFuaW5nIG5vIHByZWNvbmRpdGlvbikuXHJcbiAqL1xyXG5jbGFzcyBQcmVjb25kaXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IodXBkYXRlVGltZSwgZXhpc3RzKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUaW1lID0gdXBkYXRlVGltZTtcclxuICAgICAgICB0aGlzLmV4aXN0cyA9IGV4aXN0cztcclxuICAgIH1cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IGVtcHR5IFByZWNvbmRpdGlvbi4gKi9cclxuICAgIHN0YXRpYyBub25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlY29uZGl0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyBQcmVjb25kaXRpb24gd2l0aCBhbiBleGlzdHMgZmxhZy4gKi9cclxuICAgIHN0YXRpYyBleGlzdHMoZXhpc3RzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVjb25kaXRpb24odW5kZWZpbmVkLCBleGlzdHMpO1xyXG4gICAgfVxyXG4gICAgLyoqIENyZWF0ZXMgYSBuZXcgUHJlY29uZGl0aW9uIGJhc2VkIG9uIGEgdmVyc2lvbiBhIGRvY3VtZW50IGV4aXN0cyBhdC4gKi9cclxuICAgIHN0YXRpYyB1cGRhdGVUaW1lKHZlcnNpb24pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZWNvbmRpdGlvbih2ZXJzaW9uKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBQcmVjb25kaXRpb24gaXMgZW1wdHkuICovXHJcbiAgICBnZXQgaXNOb25lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVRpbWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmV4aXN0cyA9PT0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5leGlzdHMgPT09IG90aGVyLmV4aXN0cyAmJlxyXG4gICAgICAgICAgICAodGhpcy51cGRhdGVUaW1lXHJcbiAgICAgICAgICAgICAgICA/ICEhb3RoZXIudXBkYXRlVGltZSAmJiB0aGlzLnVwZGF0ZVRpbWUuaXNFcXVhbChvdGhlci51cGRhdGVUaW1lKVxyXG4gICAgICAgICAgICAgICAgOiAhb3RoZXIudXBkYXRlVGltZSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByZWNvbmRpdGlvbnMgaXMgdmFsaWQgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC4gKi9cclxuZnVuY3Rpb24gcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KHByZWNvbmRpdGlvbiwgZG9jdW1lbnQpIHtcclxuICAgIGlmIChwcmVjb25kaXRpb24udXBkYXRlVGltZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIChkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSAmJlxyXG4gICAgICAgICAgICBkb2N1bWVudC52ZXJzaW9uLmlzRXF1YWwocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByZWNvbmRpdGlvbi5leGlzdHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBwcmVjb25kaXRpb24uZXhpc3RzID09PSBkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIG11dGF0aW9uIGRlc2NyaWJlcyBhIHNlbGYtY29udGFpbmVkIGNoYW5nZSB0byBhIGRvY3VtZW50LiBNdXRhdGlvbnMgY2FuXHJcbiAqIGNyZWF0ZSwgcmVwbGFjZSwgZGVsZXRlLCBhbmQgdXBkYXRlIHN1YnNldHMgb2YgZG9jdW1lbnRzLlxyXG4gKlxyXG4gKiBNdXRhdGlvbnMgbm90IG9ubHkgYWN0IG9uIHRoZSB2YWx1ZSBvZiB0aGUgZG9jdW1lbnQgYnV0IGFsc28gaXRzIHZlcnNpb24uXHJcbiAqXHJcbiAqIEZvciBsb2NhbCBtdXRhdGlvbnMgKG11dGF0aW9ucyB0aGF0IGhhdmVuJ3QgYmVlbiBjb21taXR0ZWQgeWV0KSwgd2UgcHJlc2VydmVcclxuICogdGhlIGV4aXN0aW5nIHZlcnNpb24gZm9yIFNldCBhbmQgUGF0Y2ggbXV0YXRpb25zLiBGb3IgRGVsZXRlIG11dGF0aW9ucywgd2VcclxuICogcmVzZXQgdGhlIHZlcnNpb24gdG8gMC5cclxuICpcclxuICogSGVyZSdzIHRoZSBleHBlY3RlZCB0cmFuc2l0aW9uIHRhYmxlLlxyXG4gKlxyXG4gKiBNVVRBVElPTiAgICAgICAgICAgQVBQTElFRCBUTyAgICAgICAgICAgIFJFU1VMVFMgSU5cclxuICpcclxuICogU2V0TXV0YXRpb24gICAgICAgIERvY3VtZW50KHYzKSAgICAgICAgICBEb2N1bWVudCh2MylcclxuICogU2V0TXV0YXRpb24gICAgICAgIE5vRG9jdW1lbnQodjMpICAgICAgICBEb2N1bWVudCh2MClcclxuICogU2V0TXV0YXRpb24gICAgICAgIEludmFsaWREb2N1bWVudCh2MCkgICBEb2N1bWVudCh2MClcclxuICogUGF0Y2hNdXRhdGlvbiAgICAgIERvY3VtZW50KHYzKSAgICAgICAgICBEb2N1bWVudCh2MylcclxuICogUGF0Y2hNdXRhdGlvbiAgICAgIE5vRG9jdW1lbnQodjMpICAgICAgICBOb0RvY3VtZW50KHYzKVxyXG4gKiBQYXRjaE11dGF0aW9uICAgICAgSW52YWxpZERvY3VtZW50KHYwKSAgIFVua25vd25Eb2N1bWVudCh2MylcclxuICogRGVsZXRlTXV0YXRpb24gICAgIERvY3VtZW50KHYzKSAgICAgICAgICBOb0RvY3VtZW50KHYwKVxyXG4gKiBEZWxldGVNdXRhdGlvbiAgICAgTm9Eb2N1bWVudCh2MykgICAgICAgIE5vRG9jdW1lbnQodjApXHJcbiAqIERlbGV0ZU11dGF0aW9uICAgICBJbnZhbGlkRG9jdW1lbnQodjApICAgTm9Eb2N1bWVudCh2MClcclxuICpcclxuICogRm9yIGFja25vd2xlZGdlZCBtdXRhdGlvbnMsIHdlIHVzZSB0aGUgdXBkYXRlVGltZSBvZiB0aGUgV3JpdGVSZXNwb25zZSBhc1xyXG4gKiB0aGUgcmVzdWx0aW5nIHZlcnNpb24gZm9yIFNldCBhbmQgUGF0Y2ggbXV0YXRpb25zLiBBcyBkZWxldGVzIGhhdmUgbm9cclxuICogZXhwbGljaXQgdXBkYXRlIHRpbWUsIHdlIHVzZSB0aGUgY29tbWl0VGltZSBvZiB0aGUgV3JpdGVSZXNwb25zZSBmb3JcclxuICogRGVsZXRlIG11dGF0aW9ucy5cclxuICpcclxuICogSWYgYSBtdXRhdGlvbiBpcyBhY2tub3dsZWRnZWQgYnkgdGhlIGJhY2tlbmQgYnV0IGZhaWxzIHRoZSBwcmVjb25kaXRpb24gY2hlY2tcclxuICogbG9jYWxseSwgd2UgdHJhbnNpdGlvbiB0byBhbiBgVW5rbm93bkRvY3VtZW50YCBhbmQgcmVseSBvbiBXYXRjaCB0byBzZW5kIHVzXHJcbiAqIHRoZSB1cGRhdGVkIHZlcnNpb24uXHJcbiAqXHJcbiAqIEZpZWxkIHRyYW5zZm9ybXMgYXJlIHVzZWQgb25seSB3aXRoIFBhdGNoIGFuZCBTZXQgTXV0YXRpb25zLiBXZSB1c2UgdGhlXHJcbiAqIGB1cGRhdGVUcmFuc2Zvcm1zYCBtZXNzYWdlIHRvIHN0b3JlIHRyYW5zZm9ybXMsIHJhdGhlciB0aGFuIHRoZSBgdHJhbnNmb3Jtc2BzXHJcbiAqIG1lc3NhZ2VzLlxyXG4gKlxyXG4gKiAjIyBTdWJjbGFzc2luZyBOb3Rlc1xyXG4gKlxyXG4gKiBFdmVyeSB0eXBlIG9mIG11dGF0aW9uIG5lZWRzIHRvIGltcGxlbWVudCBpdHMgb3duIGFwcGx5VG9SZW1vdGVEb2N1bWVudCgpIGFuZFxyXG4gKiBhcHBseVRvTG9jYWxWaWV3KCkgdG8gaW1wbGVtZW50IHRoZSBhY3R1YWwgYmVoYXZpb3Igb2YgYXBwbHlpbmcgdGhlIG11dGF0aW9uXHJcbiAqIHRvIHNvbWUgc291cmNlIGRvY3VtZW50IChzZWUgYHNldE11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KClgIGZvciBhblxyXG4gKiBleGFtcGxlKS5cclxuICovXHJcbmNsYXNzIE11dGF0aW9uIHtcclxufVxyXG4vKipcclxuICogQXBwbGllcyB0aGlzIG11dGF0aW9uIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBmb3IgdGhlIHB1cnBvc2VzIG9mIGNvbXB1dGluZyBhXHJcbiAqIG5ldyByZW1vdGUgZG9jdW1lbnQuIElmIHRoZSBpbnB1dCBkb2N1bWVudCBkb2Vzbid0IG1hdGNoIHRoZSBleHBlY3RlZCBzdGF0ZVxyXG4gKiAoZS5nLiBpdCBpcyBpbnZhbGlkIG9yIG91dGRhdGVkKSwgdGhlIGRvY3VtZW50IHR5cGUgbWF5IHRyYW5zaXRpb24gdG9cclxuICogdW5rbm93bi5cclxuICpcclxuICogQHBhcmFtIG11dGF0aW9uIC0gVGhlIG11dGF0aW9uIHRvIGFwcGx5LlxyXG4gKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gbXV0YXRlLiBUaGUgaW5wdXQgZG9jdW1lbnQgY2FuIGJlIGFuXHJcbiAqICAgICBpbnZhbGlkIGRvY3VtZW50IGlmIHRoZSBjbGllbnQgaGFzIG5vIGtub3dsZWRnZSBvZiB0aGUgcHJlLW11dGF0aW9uIHN0YXRlXHJcbiAqICAgICBvZiB0aGUgZG9jdW1lbnQuXHJcbiAqIEBwYXJhbSBtdXRhdGlvblJlc3VsdCAtIFRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIG11dGF0aW9uIGZyb20gdGhlIGJhY2tlbmQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KSB7XHJcbiAgICBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBTZXRNdXRhdGlvbikge1xyXG4gICAgICAgIHNldE11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XHJcbiAgICAgICAgcGF0Y2hNdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRlbGV0ZU11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoaXMgbXV0YXRpb24gdG8gdGhlIGdpdmVuIGRvY3VtZW50IGZvciB0aGUgcHVycG9zZXMgb2YgY29tcHV0aW5nXHJcbiAqIHRoZSBuZXcgbG9jYWwgdmlldyBvZiBhIGRvY3VtZW50LiBJZiB0aGUgaW5wdXQgZG9jdW1lbnQgZG9lc24ndCBtYXRjaCB0aGVcclxuICogZXhwZWN0ZWQgc3RhdGUsIHRoZSBkb2N1bWVudCBpcyBub3QgbW9kaWZpZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBtdXRhdGlvbiAtIFRoZSBtdXRhdGlvbiB0byBhcHBseS5cclxuICogQHBhcmFtIGRvY3VtZW50IC0gVGhlIGRvY3VtZW50IHRvIG11dGF0ZS4gVGhlIGlucHV0IGRvY3VtZW50IGNhbiBiZSBhblxyXG4gKiAgICAgaW52YWxpZCBkb2N1bWVudCBpZiB0aGUgY2xpZW50IGhhcyBubyBrbm93bGVkZ2Ugb2YgdGhlIHByZS1tdXRhdGlvbiBzdGF0ZVxyXG4gKiAgICAgb2YgdGhlIGRvY3VtZW50LlxyXG4gKiBAcGFyYW0gbG9jYWxXcml0ZVRpbWUgLSBBIHRpbWVzdGFtcCBpbmRpY2F0aW5nIHRoZSBsb2NhbCB3cml0ZSB0aW1lIG9mIHRoZVxyXG4gKiAgICAgYmF0Y2ggdGhpcyBtdXRhdGlvbiBpcyBhIHBhcnQgb2YuXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBsb2NhbFdyaXRlVGltZSkge1xyXG4gICAgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgU2V0TXV0YXRpb24pIHtcclxuICAgICAgICBzZXRNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBsb2NhbFdyaXRlVGltZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtdXRhdGlvbiBpbnN0YW5jZW9mIFBhdGNoTXV0YXRpb24pIHtcclxuICAgICAgICBwYXRjaE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIGxvY2FsV3JpdGVUaW1lKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRlbGV0ZU11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJZiB0aGlzIG11dGF0aW9uIGlzIG5vdCBpZGVtcG90ZW50LCByZXR1cm5zIHRoZSBiYXNlIHZhbHVlIHRvIHBlcnNpc3Qgd2l0aFxyXG4gKiB0aGlzIG11dGF0aW9uLiBJZiBhIGJhc2UgdmFsdWUgaXMgcmV0dXJuZWQsIHRoZSBtdXRhdGlvbiBpcyBhbHdheXMgYXBwbGllZFxyXG4gKiB0byB0aGlzIGJhc2UgdmFsdWUsIGV2ZW4gaWYgZG9jdW1lbnQgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkLlxyXG4gKlxyXG4gKiBUaGUgYmFzZSB2YWx1ZSBpcyBhIHNwYXJzZSBvYmplY3QgdGhhdCBjb25zaXN0cyBvZiBvbmx5IHRoZSBkb2N1bWVudFxyXG4gKiBmaWVsZHMgZm9yIHdoaWNoIHRoaXMgbXV0YXRpb24gY29udGFpbnMgYSBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1hdGlvblxyXG4gKiAoZS5nLiBhIG51bWVyaWMgaW5jcmVtZW50KS4gVGhlIHByb3ZpZGVkIHZhbHVlIGd1YXJhbnRlZXMgY29uc2lzdGVudFxyXG4gKiBiZWhhdmlvciBmb3Igbm9uLWlkZW1wb3RlbnQgdHJhbnNmb3JtcyBhbmQgYWxsb3cgdXMgdG8gcmV0dXJuIHRoZSBzYW1lXHJcbiAqIGxhdGVuY3ktY29tcGVuc2F0ZWQgdmFsdWUgZXZlbiBpZiB0aGUgYmFja2VuZCBoYXMgYWxyZWFkeSBhcHBsaWVkIHRoZVxyXG4gKiBtdXRhdGlvbi4gVGhlIGJhc2UgdmFsdWUgaXMgbnVsbCBmb3IgaWRlbXBvdGVudCBtdXRhdGlvbnMsIGFzIHRoZXkgY2FuIGJlXHJcbiAqIHJlLXBsYXllZCBldmVuIGlmIHRoZSBiYWNrZW5kIGhhcyBhbHJlYWR5IGFwcGxpZWQgdGhlbS5cclxuICpcclxuICogQHJldHVybnMgYSBiYXNlIHZhbHVlIHRvIHN0b3JlIGFsb25nIHdpdGggdGhlIG11dGF0aW9uLCBvciBudWxsIGZvclxyXG4gKiBpZGVtcG90ZW50IG11dGF0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIG11dGF0aW9uRXh0cmFjdEJhc2VWYWx1ZShtdXRhdGlvbiwgZG9jdW1lbnQpIHtcclxuICAgIGxldCBiYXNlT2JqZWN0ID0gbnVsbDtcclxuICAgIGZvciAoY29uc3QgZmllbGRUcmFuc2Zvcm0gb2YgbXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zKSB7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IGRvY3VtZW50LmRhdGEuZmllbGQoZmllbGRUcmFuc2Zvcm0uZmllbGQpO1xyXG4gICAgICAgIGNvbnN0IGNvZXJjZWRWYWx1ZSA9IGNvbXB1dGVUcmFuc2Zvcm1PcGVyYXRpb25CYXNlVmFsdWUoZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtLCBleGlzdGluZ1ZhbHVlIHx8IG51bGwpO1xyXG4gICAgICAgIGlmIChjb2VyY2VkVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZU9iamVjdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlT2JqZWN0ID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiYXNlT2JqZWN0LnNldChmaWVsZFRyYW5zZm9ybS5maWVsZCwgY29lcmNlZFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmFzZU9iamVjdCA/IGJhc2VPYmplY3QgOiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIG11dGF0aW9uRXF1YWxzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC50eXBlICE9PSByaWdodC50eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFsZWZ0LmtleS5pc0VxdWFsKHJpZ2h0LmtleSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWxlZnQucHJlY29uZGl0aW9uLmlzRXF1YWwocmlnaHQucHJlY29uZGl0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghZmllbGRUcmFuc2Zvcm1zQXJlRXF1YWwobGVmdC5maWVsZFRyYW5zZm9ybXMsIHJpZ2h0LmZpZWxkVHJhbnNmb3JtcykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC50eXBlID09PSAwIC8qIFNldCAqLykge1xyXG4gICAgICAgIHJldHVybiBsZWZ0LnZhbHVlLmlzRXF1YWwocmlnaHQudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gMSAvKiBQYXRjaCAqLykge1xyXG4gICAgICAgIHJldHVybiAobGVmdC5kYXRhLmlzRXF1YWwocmlnaHQuZGF0YSkgJiZcclxuICAgICAgICAgICAgbGVmdC5maWVsZE1hc2suaXNFcXVhbChyaWdodC5maWVsZE1hc2spKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIGZyb20gdGhlIGdpdmVuIGRvY3VtZW50IGZvciB1c2UgYXMgdGhlIHJlc3VsdCBvZiBhXHJcbiAqIG11dGF0aW9uLiBNdXRhdGlvbnMgYXJlIGRlZmluZWQgdG8gcmV0dXJuIHRoZSB2ZXJzaW9uIG9mIHRoZSBiYXNlIGRvY3VtZW50XHJcbiAqIG9ubHkgaWYgaXQgaXMgYW4gZXhpc3RpbmcgZG9jdW1lbnQuIERlbGV0ZWQgYW5kIHVua25vd24gZG9jdW1lbnRzIGhhdmUgYVxyXG4gKiBwb3N0LW11dGF0aW9uIHZlcnNpb24gb2YgU25hcHNob3RWZXJzaW9uLm1pbigpLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UG9zdE11dGF0aW9uVmVyc2lvbihkb2N1bWVudCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpID8gZG9jdW1lbnQudmVyc2lvbiA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxufVxyXG4vKipcclxuICogQSBtdXRhdGlvbiB0aGF0IGNyZWF0ZXMgb3IgcmVwbGFjZXMgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aCB0aGVcclxuICogb2JqZWN0IHZhbHVlIGNvbnRlbnRzLlxyXG4gKi9cclxuY2xhc3MgU2V0TXV0YXRpb24gZXh0ZW5kcyBNdXRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBwcmVjb25kaXRpb24sIGZpZWxkVHJhbnNmb3JtcyA9IFtdKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb24gPSBwcmVjb25kaXRpb247XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XHJcbiAgICAgICAgdGhpcy50eXBlID0gMCAvKiBTZXQgKi87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0TXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xyXG4gICAgLy8gVW5saWtlIHNldE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldywgaWYgd2UncmUgYXBwbHlpbmcgYSBtdXRhdGlvbiB0byBhXHJcbiAgICAvLyByZW1vdGUgZG9jdW1lbnQgdGhlIHNlcnZlciBoYXMgYWNjZXB0ZWQgdGhlIG11dGF0aW9uIHNvIHRoZSBwcmVjb25kaXRpb25cclxuICAgIC8vIG11c3QgaGF2ZSBoZWxkLlxyXG4gICAgY29uc3QgbmV3RGF0YSA9IG11dGF0aW9uLnZhbHVlLmNsb25lKCk7XHJcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyhtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMsIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdC50cmFuc2Zvcm1SZXN1bHRzKTtcclxuICAgIG5ld0RhdGEuc2V0QWxsKHRyYW5zZm9ybVJlc3VsdHMpO1xyXG4gICAgZG9jdW1lbnRcclxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChtdXRhdGlvblJlc3VsdC52ZXJzaW9uLCBuZXdEYXRhKVxyXG4gICAgICAgIC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcclxufVxyXG5mdW5jdGlvbiBzZXRNdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBsb2NhbFdyaXRlVGltZSkge1xyXG4gICAgaWYgKCFwcmVjb25kaXRpb25Jc1ZhbGlkRm9yRG9jdW1lbnQobXV0YXRpb24ucHJlY29uZGl0aW9uLCBkb2N1bWVudCkpIHtcclxuICAgICAgICAvLyBUaGUgbXV0YXRpb24gZmFpbGVkIHRvIGFwcGx5IChlLmcuIGEgZG9jdW1lbnQgSUQgY3JlYXRlZCB3aXRoIGFkZCgpXHJcbiAgICAgICAgLy8gY2F1c2VkIGEgbmFtZSBjb2xsaXNpb24pLlxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0RhdGEgPSBtdXRhdGlvbi52YWx1ZS5jbG9uZSgpO1xyXG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IGxvY2FsVHJhbnNmb3JtUmVzdWx0cyhtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMsIGxvY2FsV3JpdGVUaW1lLCBkb2N1bWVudCk7XHJcbiAgICBuZXdEYXRhLnNldEFsbCh0cmFuc2Zvcm1SZXN1bHRzKTtcclxuICAgIGRvY3VtZW50XHJcbiAgICAgICAgLmNvbnZlcnRUb0ZvdW5kRG9jdW1lbnQoZ2V0UG9zdE11dGF0aW9uVmVyc2lvbihkb2N1bWVudCksIG5ld0RhdGEpXHJcbiAgICAgICAgLnNldEhhc0xvY2FsTXV0YXRpb25zKCk7XHJcbn1cclxuLyoqXHJcbiAqIEEgbXV0YXRpb24gdGhhdCBtb2RpZmllcyBmaWVsZHMgb2YgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkgd2l0aCB0aGVcclxuICogZ2l2ZW4gdmFsdWVzLiBUaGUgdmFsdWVzIGFyZSBhcHBsaWVkIHRocm91Z2ggYSBmaWVsZCBtYXNrOlxyXG4gKlxyXG4gKiAgKiBXaGVuIGEgZmllbGQgaXMgaW4gYm90aCB0aGUgbWFzayBhbmQgdGhlIHZhbHVlcywgdGhlIGNvcnJlc3BvbmRpbmcgZmllbGRcclxuICogICAgaXMgdXBkYXRlZC5cclxuICogICogV2hlbiBhIGZpZWxkIGlzIGluIG5laXRoZXIgdGhlIG1hc2sgbm9yIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAqICAgIGZpZWxkIGlzIHVubW9kaWZpZWQuXHJcbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBpbiB0aGUgbWFzayBidXQgbm90IGluIHRoZSB2YWx1ZXMsIHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkXHJcbiAqICAgIGlzIGRlbGV0ZWQuXHJcbiAqICAqIFdoZW4gYSBmaWVsZCBpcyBub3QgaW4gdGhlIG1hc2sgYnV0IGlzIGluIHRoZSB2YWx1ZXMsIHRoZSB2YWx1ZXMgbWFwIGlzXHJcbiAqICAgIGlnbm9yZWQuXHJcbiAqL1xyXG5jbGFzcyBQYXRjaE11dGF0aW9uIGV4dGVuZHMgTXV0YXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBkYXRhLCBmaWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgZmllbGRUcmFuc2Zvcm1zID0gW10pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2s7XHJcbiAgICAgICAgdGhpcy5wcmVjb25kaXRpb24gPSBwcmVjb25kaXRpb247XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXM7XHJcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBQYXRjaCAqLztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXRjaE11dGF0aW9uQXBwbHlUb1JlbW90ZURvY3VtZW50KG11dGF0aW9uLCBkb2N1bWVudCwgbXV0YXRpb25SZXN1bHQpIHtcclxuICAgIGlmICghcHJlY29uZGl0aW9uSXNWYWxpZEZvckRvY3VtZW50KG11dGF0aW9uLnByZWNvbmRpdGlvbiwgZG9jdW1lbnQpKSB7XHJcbiAgICAgICAgLy8gU2luY2UgdGhlIG11dGF0aW9uIHdhcyBub3QgcmVqZWN0ZWQsIHdlIGtub3cgdGhhdCB0aGUgcHJlY29uZGl0aW9uXHJcbiAgICAgICAgLy8gbWF0Y2hlZCBvbiB0aGUgYmFja2VuZC4gV2UgdGhlcmVmb3JlIG11c3Qgbm90IGhhdmUgdGhlIGV4cGVjdGVkIHZlcnNpb25cclxuICAgICAgICAvLyBvZiB0aGUgZG9jdW1lbnQgaW4gb3VyIGNhY2hlIGFuZCBjb252ZXJ0IHRvIGFuIFVua25vd25Eb2N1bWVudCB3aXRoIGFcclxuICAgICAgICAvLyBrbm93biB1cGRhdGVUaW1lLlxyXG4gICAgICAgIGRvY3VtZW50LmNvbnZlcnRUb1Vua25vd25Eb2N1bWVudChtdXRhdGlvblJlc3VsdC52ZXJzaW9uKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyhtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMsIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdC50cmFuc2Zvcm1SZXN1bHRzKTtcclxuICAgIGNvbnN0IG5ld0RhdGEgPSBkb2N1bWVudC5kYXRhO1xyXG4gICAgbmV3RGF0YS5zZXRBbGwoZ2V0UGF0Y2gobXV0YXRpb24pKTtcclxuICAgIG5ld0RhdGEuc2V0QWxsKHRyYW5zZm9ybVJlc3VsdHMpO1xyXG4gICAgZG9jdW1lbnRcclxuICAgICAgICAuY29udmVydFRvRm91bmREb2N1bWVudChtdXRhdGlvblJlc3VsdC52ZXJzaW9uLCBuZXdEYXRhKVxyXG4gICAgICAgIC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaE11dGF0aW9uQXBwbHlUb0xvY2FsVmlldyhtdXRhdGlvbiwgZG9jdW1lbnQsIGxvY2FsV3JpdGVUaW1lKSB7XHJcbiAgICBpZiAoIXByZWNvbmRpdGlvbklzVmFsaWRGb3JEb2N1bWVudChtdXRhdGlvbi5wcmVjb25kaXRpb24sIGRvY3VtZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdHMgPSBsb2NhbFRyYW5zZm9ybVJlc3VsdHMobXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLCBsb2NhbFdyaXRlVGltZSwgZG9jdW1lbnQpO1xyXG4gICAgY29uc3QgbmV3RGF0YSA9IGRvY3VtZW50LmRhdGE7XHJcbiAgICBuZXdEYXRhLnNldEFsbChnZXRQYXRjaChtdXRhdGlvbikpO1xyXG4gICAgbmV3RGF0YS5zZXRBbGwodHJhbnNmb3JtUmVzdWx0cyk7XHJcbiAgICBkb2N1bWVudFxyXG4gICAgICAgIC5jb252ZXJ0VG9Gb3VuZERvY3VtZW50KGdldFBvc3RNdXRhdGlvblZlcnNpb24oZG9jdW1lbnQpLCBuZXdEYXRhKVxyXG4gICAgICAgIC5zZXRIYXNMb2NhbE11dGF0aW9ucygpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgRmllbGRQYXRoL1ZhbHVlIG1hcCB3aXRoIHRoZSBjb250ZW50IG9mIHRoZSBQYXRjaE11dGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGF0Y2gobXV0YXRpb24pIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuICAgIG11dGF0aW9uLmZpZWxkTWFzay5maWVsZHMuZm9yRWFjaChmaWVsZFBhdGggPT4ge1xyXG4gICAgICAgIGlmICghZmllbGRQYXRoLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG11dGF0aW9uLmRhdGEuZmllbGQoZmllbGRQYXRoKTtcclxuICAgICAgICAgICAgcmVzdWx0LnNldChmaWVsZFBhdGgsIG5ld1ZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBsaXN0IG9mIFwidHJhbnNmb3JtIHJlc3VsdHNcIiAoYSB0cmFuc2Zvcm0gcmVzdWx0IGlzIGEgZmllbGQgdmFsdWVcclxuICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYSB0cmFuc2Zvcm0pIGZvciB1c2UgYWZ0ZXIgYSBtdXRhdGlvblxyXG4gKiBjb250YWluaW5nIHRyYW5zZm9ybXMgaGFzIGJlZW4gYWNrbm93bGVkZ2VkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaWVsZFRyYW5zZm9ybXMgLSBUaGUgZmllbGQgdHJhbnNmb3JtcyB0byBhcHBseSB0aGUgcmVzdWx0IHRvLlxyXG4gKiBAcGFyYW0gbXV0YWJsZURvY3VtZW50IC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGFwcGx5aW5nIGFsbFxyXG4gKiBwcmV2aW91cyBtdXRhdGlvbnMuXHJcbiAqIEBwYXJhbSBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzIC0gVGhlIHRyYW5zZm9ybSByZXN1bHRzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuXHJcbiAqIEByZXR1cm5zIFRoZSB0cmFuc2Zvcm0gcmVzdWx0cyBsaXN0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2VydmVyVHJhbnNmb3JtUmVzdWx0cyhmaWVsZFRyYW5zZm9ybXMsIG11dGFibGVEb2N1bWVudCwgc2VydmVyVHJhbnNmb3JtUmVzdWx0cykge1xyXG4gICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0cyA9IG5ldyBNYXAoKTtcclxuICAgIGhhcmRBc3NlcnQoZmllbGRUcmFuc2Zvcm1zLmxlbmd0aCA9PT0gc2VydmVyVHJhbnNmb3JtUmVzdWx0cy5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJ2ZXJUcmFuc2Zvcm1SZXN1bHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZmllbGRUcmFuc2Zvcm0gPSBmaWVsZFRyYW5zZm9ybXNbaV07XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBtdXRhYmxlRG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFRyYW5zZm9ybS5maWVsZCk7XHJcbiAgICAgICAgdHJhbnNmb3JtUmVzdWx0cy5zZXQoZmllbGRUcmFuc2Zvcm0uZmllbGQsIGFwcGx5VHJhbnNmb3JtT3BlcmF0aW9uVG9SZW1vdGVEb2N1bWVudCh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIHNlcnZlclRyYW5zZm9ybVJlc3VsdHNbaV0pKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHRzO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbGlzdCBvZiBcInRyYW5zZm9ybSByZXN1bHRzXCIgKGEgdHJhbnNmb3JtIHJlc3VsdCBpcyBhIGZpZWxkIHZhbHVlXHJcbiAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGEgdHJhbnNmb3JtKSBmb3IgdXNlIHdoZW4gYXBwbHlpbmcgYVxyXG4gKiB0cmFuc2Zvcm0gbG9jYWxseS5cclxuICpcclxuICogQHBhcmFtIGZpZWxkVHJhbnNmb3JtcyAtIFRoZSBmaWVsZCB0cmFuc2Zvcm1zIHRvIGFwcGx5IHRoZSByZXN1bHQgdG8uXHJcbiAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIFRoZSBsb2NhbCB0aW1lIG9mIHRoZSBtdXRhdGlvbiAodXNlZCB0b1xyXG4gKiAgICAgZ2VuZXJhdGUgU2VydmVyVGltZXN0YW1wVmFsdWVzKS5cclxuICogQHBhcmFtIG11dGFibGVEb2N1bWVudCAtIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhcHBseWluZyBhbGxcclxuICogICAgIHByZXZpb3VzIG11dGF0aW9ucy5cclxuICogQHJldHVybnMgVGhlIHRyYW5zZm9ybSByZXN1bHRzIGxpc3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFRyYW5zZm9ybVJlc3VsdHMoZmllbGRUcmFuc2Zvcm1zLCBsb2NhbFdyaXRlVGltZSwgbXV0YWJsZURvY3VtZW50KSB7XHJcbiAgICBjb25zdCB0cmFuc2Zvcm1SZXN1bHRzID0gbmV3IE1hcCgpO1xyXG4gICAgZm9yIChjb25zdCBmaWVsZFRyYW5zZm9ybSBvZiBmaWVsZFRyYW5zZm9ybXMpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBmaWVsZFRyYW5zZm9ybS50cmFuc2Zvcm07XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IG11dGFibGVEb2N1bWVudC5kYXRhLmZpZWxkKGZpZWxkVHJhbnNmb3JtLmZpZWxkKTtcclxuICAgICAgICB0cmFuc2Zvcm1SZXN1bHRzLnNldChmaWVsZFRyYW5zZm9ybS5maWVsZCwgYXBwbHlUcmFuc2Zvcm1PcGVyYXRpb25Ub0xvY2FsVmlldyh0cmFuc2Zvcm0sIHByZXZpb3VzVmFsdWUsIGxvY2FsV3JpdGVUaW1lKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNmb3JtUmVzdWx0cztcclxufVxyXG4vKiogQSBtdXRhdGlvbiB0aGF0IGRlbGV0ZXMgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBrZXkuICovXHJcbmNsYXNzIERlbGV0ZU11dGF0aW9uIGV4dGVuZHMgTXV0YXRpb24ge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBwcmVjb25kaXRpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMucHJlY29uZGl0aW9uID0gcHJlY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IDIgLyogRGVsZXRlICovO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlTXV0YXRpb25BcHBseVRvUmVtb3RlRG9jdW1lbnQobXV0YXRpb24sIGRvY3VtZW50LCBtdXRhdGlvblJlc3VsdCkge1xyXG4gICAgLy8gVW5saWtlIGFwcGx5VG9Mb2NhbFZpZXcsIGlmIHdlJ3JlIGFwcGx5aW5nIGEgbXV0YXRpb24gdG8gYSByZW1vdGVcclxuICAgIC8vIGRvY3VtZW50IHRoZSBzZXJ2ZXIgaGFzIGFjY2VwdGVkIHRoZSBtdXRhdGlvbiBzbyB0aGUgcHJlY29uZGl0aW9uIG11c3RcclxuICAgIC8vIGhhdmUgaGVsZC5cclxuICAgIGRvY3VtZW50XHJcbiAgICAgICAgLmNvbnZlcnRUb05vRG9jdW1lbnQobXV0YXRpb25SZXN1bHQudmVyc2lvbilcclxuICAgICAgICAuc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XHJcbn1cclxuZnVuY3Rpb24gZGVsZXRlTXV0YXRpb25BcHBseVRvTG9jYWxWaWV3KG11dGF0aW9uLCBkb2N1bWVudCkge1xyXG4gICAgaWYgKHByZWNvbmRpdGlvbklzVmFsaWRGb3JEb2N1bWVudChtdXRhdGlvbi5wcmVjb25kaXRpb24sIGRvY3VtZW50KSkge1xyXG4gICAgICAgIC8vIFdlIGRvbid0IGNhbGwgYHNldEhhc0xvY2FsTXV0YXRpb25zKClgIHNpbmNlIHdlIHdhbnQgdG8gYmUgYmFja3dhcmRzXHJcbiAgICAgICAgLy8gY29tcGF0aWJsZSB3aXRoIHRoZSBleGlzdGluZyBTREsgYmVoYXZpb3IuXHJcbiAgICAgICAgZG9jdW1lbnQuY29udmVydFRvTm9Eb2N1bWVudChTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIG11dGF0aW9uIHRoYXQgdmVyaWZpZXMgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZG9jdW1lbnQgYXQgdGhlIGdpdmVuIGtleSB3aXRoXHJcbiAqIHRoZSBwcm92aWRlZCBwcmVjb25kaXRpb24uXHJcbiAqXHJcbiAqIFRoZSBgdmVyaWZ5YCBvcGVyYXRpb24gaXMgb25seSB1c2VkIGluIFRyYW5zYWN0aW9ucywgYW5kIHRoaXMgY2xhc3Mgc2VydmVzXHJcbiAqIHByaW1hcmlseSB0byBmYWNpbGl0YXRlIHNlcmlhbGl6YXRpb24gaW50byBwcm90b3MuXHJcbiAqL1xyXG5jbGFzcyBWZXJpZnlNdXRhdGlvbiBleHRlbmRzIE11dGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnByZWNvbmRpdGlvbiA9IHByZWNvbmRpdGlvbjtcclxuICAgICAgICB0aGlzLnR5cGUgPSAzIC8qIFZlcmlmeSAqLztcclxuICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3JtcyA9IFtdO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGJhdGNoIG9mIG11dGF0aW9ucyB0aGF0IHdpbGwgYmUgc2VudCBhcyBvbmUgdW5pdCB0byB0aGUgYmFja2VuZC5cclxuICovXHJcbmNsYXNzIE11dGF0aW9uQmF0Y2gge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYmF0Y2hJZCAtIFRoZSB1bmlxdWUgSUQgb2YgdGhpcyBtdXRhdGlvbiBiYXRjaC5cclxuICAgICAqIEBwYXJhbSBsb2NhbFdyaXRlVGltZSAtIFRoZSBvcmlnaW5hbCB3cml0ZSB0aW1lIG9mIHRoaXMgbXV0YXRpb24uXHJcbiAgICAgKiBAcGFyYW0gYmFzZU11dGF0aW9ucyAtIE11dGF0aW9ucyB0aGF0IGFyZSB1c2VkIHRvIHBvcHVsYXRlIHRoZSBiYXNlXHJcbiAgICAgKiB2YWx1ZXMgd2hlbiB0aGlzIG11dGF0aW9uIGlzIGFwcGxpZWQgbG9jYWxseS4gVGhpcyBjYW4gYmUgdXNlZCB0byBsb2NhbGx5XHJcbiAgICAgKiBvdmVyd3JpdGUgdmFsdWVzIHRoYXQgYXJlIHBlcnNpc3RlZCBpbiB0aGUgcmVtb3RlIGRvY3VtZW50IGNhY2hlLiBCYXNlXHJcbiAgICAgKiBtdXRhdGlvbnMgYXJlIG5ldmVyIHNlbnQgdG8gdGhlIGJhY2tlbmQuXHJcbiAgICAgKiBAcGFyYW0gbXV0YXRpb25zIC0gVGhlIHVzZXItcHJvdmlkZWQgbXV0YXRpb25zIGluIHRoaXMgbXV0YXRpb24gYmF0Y2guXHJcbiAgICAgKiBVc2VyLXByb3ZpZGVkIG11dGF0aW9ucyBhcmUgYXBwbGllZCBib3RoIGxvY2FsbHkgYW5kIHJlbW90ZWx5IG9uIHRoZVxyXG4gICAgICogYmFja2VuZC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYmF0Y2hJZCwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucykge1xyXG4gICAgICAgIHRoaXMuYmF0Y2hJZCA9IGJhdGNoSWQ7XHJcbiAgICAgICAgdGhpcy5sb2NhbFdyaXRlVGltZSA9IGxvY2FsV3JpdGVUaW1lO1xyXG4gICAgICAgIHRoaXMuYmFzZU11dGF0aW9ucyA9IGJhc2VNdXRhdGlvbnM7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMgPSBtdXRhdGlvbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYWxsIHRoZSBtdXRhdGlvbnMgaW4gdGhpcyBNdXRhdGlvbkJhdGNoIHRvIHRoZSBzcGVjaWZpZWQgZG9jdW1lbnRcclxuICAgICAqIHRvIGNvbXB1dGUgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgZG9jdW1lbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gYXBwbHkgbXV0YXRpb25zIHRvLlxyXG4gICAgICogQHBhcmFtIGJhdGNoUmVzdWx0IC0gVGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgTXV0YXRpb25CYXRjaCB0byB0aGVcclxuICAgICAqIGJhY2tlbmQuXHJcbiAgICAgKi9cclxuICAgIGFwcGx5VG9SZW1vdGVEb2N1bWVudChkb2N1bWVudCwgYmF0Y2hSZXN1bHQpIHtcclxuICAgICAgICBjb25zdCBtdXRhdGlvblJlc3VsdHMgPSBiYXRjaFJlc3VsdC5tdXRhdGlvblJlc3VsdHM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBtdXRhdGlvbiA9IHRoaXMubXV0YXRpb25zW2ldO1xyXG4gICAgICAgICAgICBpZiAobXV0YXRpb24ua2V5LmlzRXF1YWwoZG9jdW1lbnQua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbXV0YXRpb25SZXN1bHQgPSBtdXRhdGlvblJlc3VsdHNbaV07XHJcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9SZW1vdGVEb2N1bWVudChtdXRhdGlvbiwgZG9jdW1lbnQsIG11dGF0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGxvY2FsIHZpZXcgb2YgYSBkb2N1bWVudCBnaXZlbiBhbGwgdGhlIG11dGF0aW9ucyBpbiB0aGlzXHJcbiAgICAgKiBiYXRjaC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgLSBUaGUgZG9jdW1lbnQgdG8gYXBwbHkgbXV0YXRpb25zIHRvLlxyXG4gICAgICovXHJcbiAgICBhcHBseVRvTG9jYWxWaWV3KGRvY3VtZW50KSB7XHJcbiAgICAgICAgLy8gRmlyc3QsIGFwcGx5IHRoZSBiYXNlIHN0YXRlLiBUaGlzIGFsbG93cyB1cyB0byBhcHBseSBub24taWRlbXBvdGVudFxyXG4gICAgICAgIC8vIHRyYW5zZm9ybSBhZ2FpbnN0IGEgY29uc2lzdGVudCBzZXQgb2YgdmFsdWVzLlxyXG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgdGhpcy5iYXNlTXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5rZXkuaXNFcXVhbChkb2N1bWVudC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCB0aGlzLmxvY2FsV3JpdGVUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZWNvbmQsIGFwcGx5IGFsbCB1c2VyLXByb3ZpZGVkIG11dGF0aW9ucy5cclxuICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIHRoaXMubXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5rZXkuaXNFcXVhbChkb2N1bWVudC5rZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCB0aGlzLmxvY2FsV3JpdGVUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIGxvY2FsIHZpZXcgZm9yIGFsbCBwcm92aWRlZCBkb2N1bWVudHMgZ2l2ZW4gdGhlIG11dGF0aW9ucyBpblxyXG4gICAgICogdGhpcyBiYXRjaC5cclxuICAgICAqL1xyXG4gICAgYXBwbHlUb0xvY2FsRG9jdW1lbnRTZXQoZG9jdW1lbnRNYXApIHtcclxuICAgICAgICAvLyBUT0RPKG1yc2NobWlkdCk6IFRoaXMgaW1wbGVtZW50YXRpb24gaXMgTyhuXjIpLiBJZiB3ZSBhcHBseSB0aGUgbXV0YXRpb25zXHJcbiAgICAgICAgLy8gZGlyZWN0bHkgKGFzIGRvbmUgaW4gYGFwcGx5VG9Mb2NhbFZpZXcoKWApLCB3ZSBjYW4gcmVkdWNlIHRoZSBjb21wbGV4aXR5XHJcbiAgICAgICAgLy8gdG8gTyhuKS5cclxuICAgICAgICB0aGlzLm11dGF0aW9ucy5mb3JFYWNoKG0gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGRvY3VtZW50TWFwLmdldChtLmtleSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8obXV0YWJsZWRvY3VtZW50cyk6IFRoaXMgbWV0aG9kIHNob3VsZCB0YWtlIGEgTXV0YWJsZURvY3VtZW50TWFwXHJcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBzaG91bGQgcmVtb3ZlIHRoaXMgY2FzdC5cclxuICAgICAgICAgICAgY29uc3QgbXV0YWJsZURvY3VtZW50ID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlUb0xvY2FsVmlldyhtdXRhYmxlRG9jdW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmlzVmFsaWREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBtdXRhYmxlRG9jdW1lbnQuY29udmVydFRvTm9Eb2N1bWVudChTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBrZXlzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0aW9ucy5yZWR1Y2UoKGtleXMsIG0pID0+IGtleXMuYWRkKG0ua2V5KSwgZG9jdW1lbnRLZXlTZXQoKSk7XHJcbiAgICB9XHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhdGNoSWQgPT09IG90aGVyLmJhdGNoSWQgJiZcclxuICAgICAgICAgICAgYXJyYXlFcXVhbHModGhpcy5tdXRhdGlvbnMsIG90aGVyLm11dGF0aW9ucywgKGwsIHIpID0+IG11dGF0aW9uRXF1YWxzKGwsIHIpKSAmJlxyXG4gICAgICAgICAgICBhcnJheUVxdWFscyh0aGlzLmJhc2VNdXRhdGlvbnMsIG90aGVyLmJhc2VNdXRhdGlvbnMsIChsLCByKSA9PiBtdXRhdGlvbkVxdWFscyhsLCByKSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKiBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIGEgbXV0YXRpb24gYmF0Y2ggdG8gdGhlIGJhY2tlbmQuICovXHJcbmNsYXNzIE11dGF0aW9uQmF0Y2hSZXN1bHQge1xyXG4gICAgY29uc3RydWN0b3IoYmF0Y2gsIGNvbW1pdFZlcnNpb24sIG11dGF0aW9uUmVzdWx0cywgXHJcbiAgICAvKipcclxuICAgICAqIEEgcHJlLWNvbXB1dGVkIG1hcHBpbmcgZnJvbSBlYWNoIG11dGF0ZWQgZG9jdW1lbnQgdG8gdGhlIHJlc3VsdGluZ1xyXG4gICAgICogdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgZG9jVmVyc2lvbnMpIHtcclxuICAgICAgICB0aGlzLmJhdGNoID0gYmF0Y2g7XHJcbiAgICAgICAgdGhpcy5jb21taXRWZXJzaW9uID0gY29tbWl0VmVyc2lvbjtcclxuICAgICAgICB0aGlzLm11dGF0aW9uUmVzdWx0cyA9IG11dGF0aW9uUmVzdWx0cztcclxuICAgICAgICB0aGlzLmRvY1ZlcnNpb25zID0gZG9jVmVyc2lvbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgTXV0YXRpb25CYXRjaFJlc3VsdCBmb3IgdGhlIGdpdmVuIGJhdGNoIGFuZCByZXN1bHRzLiBUaGVyZVxyXG4gICAgICogbXVzdCBiZSBvbmUgcmVzdWx0IGZvciBlYWNoIG11dGF0aW9uIGluIHRoZSBiYXRjaC4gVGhpcyBzdGF0aWMgZmFjdG9yeVxyXG4gICAgICogY2FjaGVzIGEgZG9jdW1lbnQ9Jmd0O3ZlcnNpb24gbWFwcGluZyAoZG9jVmVyc2lvbnMpLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShiYXRjaCwgY29tbWl0VmVyc2lvbiwgcmVzdWx0cykge1xyXG4gICAgICAgIGhhcmRBc3NlcnQoYmF0Y2gubXV0YXRpb25zLmxlbmd0aCA9PT0gcmVzdWx0cy5sZW5ndGgpO1xyXG4gICAgICAgIGxldCB2ZXJzaW9uTWFwID0gZG9jdW1lbnRWZXJzaW9uTWFwKCk7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25zID0gYmF0Y2gubXV0YXRpb25zO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZlcnNpb25NYXAgPSB2ZXJzaW9uTWFwLmluc2VydChtdXRhdGlvbnNbaV0ua2V5LCByZXN1bHRzW2ldLnZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE11dGF0aW9uQmF0Y2hSZXN1bHQoYmF0Y2gsIGNvbW1pdFZlcnNpb24sIHJlc3VsdHMsIHZlcnNpb25NYXApO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhbiBvdmVybGF5IGNvbXB1dGVkIGJ5IEZpcmVzdG9yZS5cclxuICpcclxuICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgYSBtdXRhdGlvbiBhbmQgdGhlIGxhcmdlc3QgYmF0Y2ggaWQgaW4gRmlyZXN0b3JlIHdoZW5cclxuICogdGhlIG11dGF0aW9uIHdhcyBjcmVhdGVkLlxyXG4gKi9cclxuY2xhc3MgT3ZlcmxheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pIHtcclxuICAgICAgICB0aGlzLmxhcmdlc3RCYXRjaElkID0gbGFyZ2VzdEJhdGNoSWQ7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbiA9IG11dGF0aW9uO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm11dGF0aW9uLmtleTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXIgIT09IG51bGwgJiYgdGhpcy5tdXRhdGlvbiA9PT0gb3RoZXIubXV0YXRpb247XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYE92ZXJsYXl7XG4gICAgICBsYXJnZXN0QmF0Y2hJZDogJHt0aGlzLmxhcmdlc3RCYXRjaElkfSxcbiAgICAgIG11dGF0aW9uOiAke3RoaXMubXV0YXRpb24udG9TdHJpbmcoKX1cbiAgICB9YDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBFeGlzdGVuY2VGaWx0ZXIge1xyXG4gICAgLy8gVE9ETyhiLzMzMDc4MTYzKToganVzdCB1c2Ugc2ltcGxlc3QgZm9ybSBvZiBleGlzdGVuY2UgZmlsdGVyIGZvciBub3dcclxuICAgIGNvbnN0cnVjdG9yKGNvdW50KSB7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFcnJvciBDb2RlcyBkZXNjcmliaW5nIHRoZSBkaWZmZXJlbnQgd2F5cyBHUlBDIGNhbiBmYWlsLiBUaGVzZSBhcmUgY29waWVkXHJcbiAqIGRpcmVjdGx5IGZyb20gR1JQQydzIHNvdXJjZXMgaGVyZTpcclxuICpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL2JjZWVjOTRlYTRmYzVmMDA4NWQ4MTIzNWQ4ZTFjMDY3OThkYzM0MWEvaW5jbHVkZS9ncnBjJTJCJTJCL2ltcGwvY29kZWdlbi9zdGF0dXNfY29kZV9lbnVtLmhcclxuICpcclxuICogSW1wb3J0YW50ISBUaGUgbmFtZXMgb2YgdGhlc2UgaWRlbnRpZmllcnMgbWF0dGVyIGJlY2F1c2UgdGhlIHN0cmluZyBmb3Jtc1xyXG4gKiBhcmUgdXNlZCBmb3IgcmV2ZXJzZSBsb29rdXBzIGZyb20gdGhlIHdlYmNoYW5uZWwgc3RyZWFtLiBEbyBOT1QgY2hhbmdlIHRoZVxyXG4gKiBuYW1lcyBvZiB0aGVzZSBpZGVudGlmaWVycyBvciBjaGFuZ2UgdGhpcyBpbnRvIGEgY29uc3QgZW51bS5cclxuICovXHJcbnZhciBScGNDb2RlO1xyXG4oZnVuY3Rpb24gKFJwY0NvZGUpIHtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk9LXCJdID0gMF0gPSBcIk9LXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJDQU5DRUxMRURcIl0gPSAxXSA9IFwiQ0FOQ0VMTEVEXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJVTktOT1dOXCJdID0gMl0gPSBcIlVOS05PV05cIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSAzXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiREVBRExJTkVfRVhDRUVERURcIl0gPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIk5PVF9GT1VORFwiXSA9IDVdID0gXCJOT1RfRk9VTkRcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkFMUkVBRFlfRVhJU1RTXCJdID0gNl0gPSBcIkFMUkVBRFlfRVhJU1RTXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJQRVJNSVNTSU9OX0RFTklFRFwiXSA9IDddID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5BVVRIRU5USUNBVEVEXCJdID0gMTZdID0gXCJVTkFVVEhFTlRJQ0FURURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlJFU09VUkNFX0VYSEFVU1RFRFwiXSA9IDhdID0gXCJSRVNPVVJDRV9FWEhBVVNURURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIkZBSUxFRF9QUkVDT05ESVRJT05cIl0gPSA5XSA9IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiQUJPUlRFRFwiXSA9IDEwXSA9IFwiQUJPUlRFRFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiT1VUX09GX1JBTkdFXCJdID0gMTFdID0gXCJPVVRfT0ZfUkFOR0VcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIlVOSU1QTEVNRU5URURcIl0gPSAxMl0gPSBcIlVOSU1QTEVNRU5URURcIjtcclxuICAgIFJwY0NvZGVbUnBjQ29kZVtcIklOVEVSTkFMXCJdID0gMTNdID0gXCJJTlRFUk5BTFwiO1xyXG4gICAgUnBjQ29kZVtScGNDb2RlW1wiVU5BVkFJTEFCTEVcIl0gPSAxNF0gPSBcIlVOQVZBSUxBQkxFXCI7XHJcbiAgICBScGNDb2RlW1JwY0NvZGVbXCJEQVRBX0xPU1NcIl0gPSAxNV0gPSBcIkRBVEFfTE9TU1wiO1xyXG59KShScGNDb2RlIHx8IChScGNDb2RlID0ge30pKTtcclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBhbiBlcnJvciBjb2RlIHJlcHJlc2VudHMgYSBwZXJtYW5lbnQgZXJyb3Igd2hlbiByZWNlaXZlZFxyXG4gKiBpbiByZXNwb25zZSB0byBhIG5vbi13cml0ZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIFNlZSBpc1Blcm1hbmVudFdyaXRlRXJyb3IgZm9yIGNsYXNzaWZ5aW5nIHdyaXRlIGVycm9ycy5cclxuICovXHJcbmZ1bmN0aW9uIGlzUGVybWFuZW50RXJyb3IoY29kZSkge1xyXG4gICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgY2FzZSBDb2RlLk9LOlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgICAgIGNhc2UgQ29kZS5DQU5DRUxMRUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLlVOS05PV046XHJcbiAgICAgICAgY2FzZSBDb2RlLkRFQURMSU5FX0VYQ0VFREVEOlxyXG4gICAgICAgIGNhc2UgQ29kZS5SRVNPVVJDRV9FWEhBVVNURUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLklOVEVSTkFMOlxyXG4gICAgICAgIGNhc2UgQ29kZS5VTkFWQUlMQUJMRTpcclxuICAgICAgICAvLyBVbmF1dGhlbnRpY2F0ZWQgbWVhbnMgc29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCBvdXIgdG9rZW4gYW5kIHdlIG5lZWRcclxuICAgICAgICAvLyB0byByZXRyeSB3aXRoIG5ldyBjcmVkZW50aWFscyB3aGljaCB3aWxsIGhhcHBlbiBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgIGNhc2UgQ29kZS5VTkFVVEhFTlRJQ0FURUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBjYXNlIENvZGUuSU5WQUxJRF9BUkdVTUVOVDpcclxuICAgICAgICBjYXNlIENvZGUuTk9UX0ZPVU5EOlxyXG4gICAgICAgIGNhc2UgQ29kZS5BTFJFQURZX0VYSVNUUzpcclxuICAgICAgICBjYXNlIENvZGUuUEVSTUlTU0lPTl9ERU5JRUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLkZBSUxFRF9QUkVDT05ESVRJT046XHJcbiAgICAgICAgLy8gQWJvcnRlZCBtaWdodCBiZSByZXRyaWVkIGluIHNvbWUgc2NlbmFyaW9zLCBidXQgdGhhdCBpcyBkZXBlbmRhbnQgb25cclxuICAgICAgICAvLyB0aGUgY29udGV4dCBhbmQgc2hvdWxkIGhhbmRsZWQgaW5kaXZpZHVhbGx5IGJ5IHRoZSBjYWxsaW5nIGNvZGUuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9hcGlzL2Rlc2lnbi9lcnJvcnMuXHJcbiAgICAgICAgY2FzZSBDb2RlLkFCT1JURUQ6XHJcbiAgICAgICAgY2FzZSBDb2RlLk9VVF9PRl9SQU5HRTpcclxuICAgICAgICBjYXNlIENvZGUuVU5JTVBMRU1FTlRFRDpcclxuICAgICAgICBjYXNlIENvZGUuREFUQV9MT1NTOlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXJyb3IgY29kZSByZXByZXNlbnRzIGEgcGVybWFuZW50IGVycm9yIHdoZW4gcmVjZWl2ZWRcclxuICogaW4gcmVzcG9uc2UgdG8gYSB3cml0ZSBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIFdyaXRlIG9wZXJhdGlvbnMgbXVzdCBiZSBoYW5kbGVkIHNwZWNpYWxseSBiZWNhdXNlIGFzIG9mIGIvMTE5NDM3NzY0LCBBQk9SVEVEXHJcbiAqIGVycm9ycyBvbiB0aGUgd3JpdGUgc3RyZWFtIHNob3VsZCBiZSByZXRyaWVkIHRvbyAoZXZlbiB0aG91Z2ggQUJPUlRFRCBlcnJvcnNcclxuICogYXJlIG5vdCBnZW5lcmFsbHkgcmV0cnlhYmxlKS5cclxuICpcclxuICogTm90ZSB0aGF0IGR1cmluZyB0aGUgaW5pdGlhbCBoYW5kc2hha2Ugb24gdGhlIHdyaXRlIHN0cmVhbSBhbiBBQk9SVEVEIGVycm9yXHJcbiAqIHNpZ25hbHMgdGhhdCB3ZSBzaG91bGQgZGlzY2FyZCBvdXIgc3RyZWFtIHRva2VuIChpLmUuIGl0IGlzIHBlcm1hbmVudCkuIFRoaXNcclxuICogbWVhbnMgYSBoYW5kc2hha2UgZXJyb3Igc2hvdWxkIGJlIGNsYXNzaWZpZWQgd2l0aCBpc1Blcm1hbmVudEVycm9yLCBhYm92ZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzUGVybWFuZW50V3JpdGVFcnJvcihjb2RlKSB7XHJcbiAgICByZXR1cm4gaXNQZXJtYW5lbnRFcnJvcihjb2RlKSAmJiBjb2RlICE9PSBDb2RlLkFCT1JURUQ7XHJcbn1cclxuLyoqXHJcbiAqIE1hcHMgYW4gZXJyb3IgQ29kZSBmcm9tIEdSUEMgc3RhdHVzIGNvZGUgbnVtYmVyLCBsaWtlIDAsIDEsIG9yIDE0LiBUaGVzZVxyXG4gKiBhcmUgbm90IHRoZSBzYW1lIGFzIEhUVFAgc3RhdHVzIGNvZGVzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgQ29kZSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBHUlBDIHN0YXR1cyBjb2RlLiBGYWlscyBpZiB0aGVyZVxyXG4gKiAgICAgaXMgbm8gbWF0Y2guXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBDb2RlRnJvbVJwY0NvZGUoY29kZSkge1xyXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkbid0IG5vcm1hbGx5IGhhcHBlbiwgYnV0IGluIGNlcnRhaW4gZXJyb3IgY2FzZXMgKGxpa2UgdHJ5aW5nXHJcbiAgICAgICAgLy8gdG8gc2VuZCBpbnZhbGlkIHByb3RvIG1lc3NhZ2VzKSB3ZSBtYXkgZ2V0IGFuIGVycm9yIHdpdGggbm8gR1JQQyBjb2RlLlxyXG4gICAgICAgIGxvZ0Vycm9yKCdHUlBDIGVycm9yIGhhcyBubyAuY29kZScpO1xyXG4gICAgICAgIHJldHVybiBDb2RlLlVOS05PV047XHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuT0s6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk9LO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5DQU5DRUxMRUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkNBTkNFTExFRDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuVU5LTk9XTjpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5LTk9XTjtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuREVBRExJTkVfRVhDRUVERUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkRFQURMSU5FX0VYQ0VFREVEO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5SRVNPVVJDRV9FWEhBVVNURUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuSU5URVJOQUw6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLklOVEVSTkFMO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTkFWQUlMQUJMRTpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5BVkFJTEFCTEU7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLlVOQVVUSEVOVElDQVRFRDpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuVU5BVVRIRU5USUNBVEVEO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5JTlZBTElEX0FSR1VNRU5UOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5JTlZBTElEX0FSR1VNRU5UO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5OT1RfRk9VTkQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLk5PVF9GT1VORDtcclxuICAgICAgICBjYXNlIFJwY0NvZGUuQUxSRUFEWV9FWElTVFM6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkFMUkVBRFlfRVhJU1RTO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5QRVJNSVNTSU9OX0RFTklFRDpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuUEVSTUlTU0lPTl9ERU5JRUQ7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLkZBSUxFRF9QUkVDT05ESVRJT046XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkZBSUxFRF9QUkVDT05ESVRJT047XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLkFCT1JURUQ6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkFCT1JURUQ7XHJcbiAgICAgICAgY2FzZSBScGNDb2RlLk9VVF9PRl9SQU5HRTpcclxuICAgICAgICAgICAgcmV0dXJuIENvZGUuT1VUX09GX1JBTkdFO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5VTklNUExFTUVOVEVEOlxyXG4gICAgICAgICAgICByZXR1cm4gQ29kZS5VTklNUExFTUVOVEVEO1xyXG4gICAgICAgIGNhc2UgUnBjQ29kZS5EQVRBX0xPU1M6XHJcbiAgICAgICAgICAgIHJldHVybiBDb2RlLkRBVEFfTE9TUztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBldmVudCBmcm9tIHRoZSBSZW1vdGVTdG9yZS4gSXQgaXMgc3BsaXQgaW50byB0YXJnZXRDaGFuZ2VzIChjaGFuZ2VzIHRvIHRoZVxyXG4gKiBzdGF0ZSBvciB0aGUgc2V0IG9mIGRvY3VtZW50cyBpbiBvdXIgd2F0Y2hlZCB0YXJnZXRzKSBhbmQgZG9jdW1lbnRVcGRhdGVzXHJcbiAqIChjaGFuZ2VzIHRvIHRoZSBhY3R1YWwgZG9jdW1lbnRzKS5cclxuICovXHJcbmNsYXNzIFJlbW90ZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc25hcHNob3QgdmVyc2lvbiB0aGlzIGV2ZW50IGJyaW5ncyB1cyB1cCB0bywgb3IgTUlOIGlmIG5vdCBzZXQuXHJcbiAgICAgKi9cclxuICAgIHNuYXBzaG90VmVyc2lvbiwgXHJcbiAgICAvKipcclxuICAgICAqIEEgbWFwIGZyb20gdGFyZ2V0IHRvIGNoYW5nZXMgdG8gdGhlIHRhcmdldC4gU2VlIFRhcmdldENoYW5nZS5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0Q2hhbmdlcywgXHJcbiAgICAvKipcclxuICAgICAqIEEgc2V0IG9mIHRhcmdldHMgdGhhdCBpcyBrbm93biB0byBiZSBpbmNvbnNpc3RlbnQuIExpc3RlbnMgZm9yIHRoZXNlXHJcbiAgICAgKiB0YXJnZXRzIHNob3VsZCBiZSByZS1lc3RhYmxpc2hlZCB3aXRob3V0IHJlc3VtZSB0b2tlbnMuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldE1pc21hdGNoZXMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNldCBvZiB3aGljaCBkb2N1bWVudHMgaGF2ZSBjaGFuZ2VkIG9yIGJlZW4gZGVsZXRlZCwgYWxvbmcgd2l0aCB0aGVcclxuICAgICAqIGRvYydzIG5ldyB2YWx1ZXMgKGlmIG5vdCBkZWxldGVkKS5cclxuICAgICAqL1xyXG4gICAgZG9jdW1lbnRVcGRhdGVzLCBcclxuICAgIC8qKlxyXG4gICAgICogQSBzZXQgb2Ygd2hpY2ggZG9jdW1lbnQgdXBkYXRlcyBhcmUgZHVlIG9ubHkgdG8gbGltYm8gcmVzb2x1dGlvbiB0YXJnZXRzLlxyXG4gICAgICovXHJcbiAgICByZXNvbHZlZExpbWJvRG9jdW1lbnRzKSB7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdFZlcnNpb24gPSBzbmFwc2hvdFZlcnNpb247XHJcbiAgICAgICAgdGhpcy50YXJnZXRDaGFuZ2VzID0gdGFyZ2V0Q2hhbmdlcztcclxuICAgICAgICB0aGlzLnRhcmdldE1pc21hdGNoZXMgPSB0YXJnZXRNaXNtYXRjaGVzO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRVcGRhdGVzID0gZG9jdW1lbnRVcGRhdGVzO1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZWRMaW1ib0RvY3VtZW50cyA9IHJlc29sdmVkTGltYm9Eb2N1bWVudHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEhBQ0s6IFZpZXdzIHJlcXVpcmUgUmVtb3RlRXZlbnRzIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSB2aWV3IGlzXHJcbiAgICAgKiBDVVJSRU5ULCBidXQgc2Vjb25kYXJ5IHRhYnMgZG9uJ3QgcmVjZWl2ZSByZW1vdGUgZXZlbnRzLiBTbyB0aGlzIG1ldGhvZCBpc1xyXG4gICAgICogdXNlZCB0byBjcmVhdGUgYSBzeW50aGVzaXplZCBSZW1vdGVFdmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFwcGx5IGFcclxuICAgICAqIENVUlJFTlQgc3RhdHVzIGNoYW5nZSB0byBhIFZpZXcsIGZvciBxdWVyaWVzIGV4ZWN1dGVkIGluIGEgZGlmZmVyZW50IHRhYi5cclxuICAgICAqL1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seVxyXG4gICAgc3RhdGljIGNyZWF0ZVN5bnRoZXNpemVkUmVtb3RlRXZlbnRGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBjdXJyZW50KSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0YXJnZXRDaGFuZ2VzLnNldCh0YXJnZXRJZCwgVGFyZ2V0Q2hhbmdlLmNyZWF0ZVN5bnRoZXNpemVkVGFyZ2V0Q2hhbmdlRm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgY3VycmVudCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVtb3RlRXZlbnQoU25hcHNob3RWZXJzaW9uLm1pbigpLCB0YXJnZXRDaGFuZ2VzLCB0YXJnZXRJZFNldCgpLCBtdXRhYmxlRG9jdW1lbnRNYXAoKSwgZG9jdW1lbnRLZXlTZXQoKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgVGFyZ2V0Q2hhbmdlIHNwZWNpZmllcyB0aGUgc2V0IG9mIGNoYW5nZXMgZm9yIGEgc3BlY2lmaWMgdGFyZ2V0IGFzIHBhcnQgb2ZcclxuICogYSBSZW1vdGVFdmVudC4gVGhlc2UgY2hhbmdlcyB0cmFjayB3aGljaCBkb2N1bWVudHMgYXJlIGFkZGVkLCBtb2RpZmllZCBvclxyXG4gKiByZW1vdmVkLCBhcyB3ZWxsIGFzIHRoZSB0YXJnZXQncyByZXN1bWUgdG9rZW4gYW5kIHdoZXRoZXIgdGhlIHRhcmdldCBpc1xyXG4gKiBtYXJrZWQgQ1VSUkVOVC5cclxuICogVGhlIGFjdHVhbCBjaGFuZ2VzICp0byogZG9jdW1lbnRzIGFyZSBub3QgcGFydCBvZiB0aGUgVGFyZ2V0Q2hhbmdlIHNpbmNlXHJcbiAqIGRvY3VtZW50cyBtYXkgYmUgcGFydCBvZiBtdWx0aXBsZSB0YXJnZXRzLlxyXG4gKi9cclxuY2xhc3MgVGFyZ2V0Q2hhbmdlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvcGFxdWUsIHNlcnZlci1hc3NpZ25lZCB0b2tlbiB0aGF0IGFsbG93cyB3YXRjaGluZyBhIHF1ZXJ5IHRvIGJlIHJlc3VtZWRcclxuICAgICAqIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdCBtYXRjaGVzIHRoZVxyXG4gICAgICogcXVlcnkuIFRoZSByZXN1bWUgdG9rZW4gZXNzZW50aWFsbHkgaWRlbnRpZmllcyBhIHBvaW50IGluIHRpbWUgZnJvbSB3aGljaFxyXG4gICAgICogdGhlIHNlcnZlciBzaG91bGQgcmVzdW1lIHNlbmRpbmcgcmVzdWx0cy5cclxuICAgICAqL1xyXG4gICAgcmVzdW1lVG9rZW4sIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgXCJjdXJyZW50XCIgKHN5bmNlZCkgc3RhdHVzIG9mIHRoaXMgdGFyZ2V0LiBOb3RlIHRoYXQgXCJjdXJyZW50XCJcclxuICAgICAqIGhhcyBzcGVjaWFsIG1lYW5pbmcgaW4gdGhlIFJQQyBwcm90b2NvbCB0aGF0IGltcGxpZXMgdGhhdCBhIHRhcmdldCBpc1xyXG4gICAgICogYm90aCB1cC10by1kYXRlIGFuZCBjb25zaXN0ZW50IHdpdGggdGhlIHJlc3Qgb2YgdGhlIHdhdGNoIHN0cmVhbS5cclxuICAgICAqL1xyXG4gICAgY3VycmVudCwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSBuZXdseSBhc3NpZ25lZCB0byB0aGlzIHRhcmdldCBhcyBwYXJ0IG9mXHJcbiAgICAgKiB0aGlzIHJlbW90ZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgYWRkZWREb2N1bWVudHMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2V0IG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgYWxyZWFkeSBhc3NpZ25lZCB0byB0aGlzIHRhcmdldCBidXQgcmVjZWl2ZWRcclxuICAgICAqIGFuIHVwZGF0ZSBkdXJpbmcgdGhpcyByZW1vdGUgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIG1vZGlmaWVkRG9jdW1lbnRzLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBvZiBkb2N1bWVudHMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGlzIHRhcmdldCBhcyBwYXJ0IG9mIHRoaXNcclxuICAgICAqIHJlbW90ZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlZERvY3VtZW50cykge1xyXG4gICAgICAgIHRoaXMucmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xyXG4gICAgICAgIHRoaXMuYWRkZWREb2N1bWVudHMgPSBhZGRlZERvY3VtZW50cztcclxuICAgICAgICB0aGlzLm1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHM7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVkRG9jdW1lbnRzID0gcmVtb3ZlZERvY3VtZW50cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjcmVhdGUgYSBzeW50aGVzaXplZCBUYXJnZXRDaGFuZ2VzIHRoYXQgY2FuIGJlIHVzZWQgdG9cclxuICAgICAqIGFwcGx5IGEgQ1VSUkVOVCBzdGF0dXMgY2hhbmdlIHRvIGEgVmlldyAoZm9yIHF1ZXJpZXMgZXhlY3V0ZWQgaW4gYSBkaWZmZXJlbnRcclxuICAgICAqIHRhYikgb3IgZm9yIG5ldyBxdWVyaWVzICh0byByYWlzZSBzbmFwc2hvdHMgd2l0aCBjb3JyZWN0IENVUlJFTlQgc3RhdHVzKS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZVN5bnRoZXNpemVkVGFyZ2V0Q2hhbmdlRm9yQ3VycmVudENoYW5nZSh0YXJnZXRJZCwgY3VycmVudCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0Q2hhbmdlKEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIGN1cnJlbnQsIGRvY3VtZW50S2V5U2V0KCksIGRvY3VtZW50S2V5U2V0KCksIGRvY3VtZW50S2V5U2V0KCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgY2hhbmdlZCBkb2N1bWVudCBhbmQgYSBsaXN0IG9mIHRhcmdldCBpZHMgdG8gd2hpY2ggdGhpcyBjaGFuZ2VcclxuICogYXBwbGllcy5cclxuICpcclxuICogSWYgZG9jdW1lbnQgaGFzIGJlZW4gZGVsZXRlZCBOb0RvY3VtZW50IHdpbGwgYmUgcHJvdmlkZWQuXHJcbiAqL1xyXG5jbGFzcyBEb2N1bWVudFdhdGNoQ2hhbmdlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSBuZXcgZG9jdW1lbnQgYXBwbGllcyB0byBhbGwgb2YgdGhlc2UgdGFyZ2V0cy4gKi9cclxuICAgIHVwZGF0ZWRUYXJnZXRJZHMsIFxyXG4gICAgLyoqIFRoZSBuZXcgZG9jdW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGFsbCBvZiB0aGVzZSB0YXJnZXRzLiAqL1xyXG4gICAgcmVtb3ZlZFRhcmdldElkcywgXHJcbiAgICAvKiogVGhlIGtleSBvZiB0aGUgZG9jdW1lbnQgZm9yIHRoaXMgY2hhbmdlLiAqL1xyXG4gICAga2V5LCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5ldyBkb2N1bWVudCBvciBOb0RvY3VtZW50IGlmIGl0IHdhcyBkZWxldGVkLiBJcyBudWxsIGlmIHRoZVxyXG4gICAgICogZG9jdW1lbnQgd2VudCBvdXQgb2YgdmlldyB3aXRob3V0IHRoZSBzZXJ2ZXIgc2VuZGluZyBhIG5ldyBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgbmV3RG9jKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVkVGFyZ2V0SWRzID0gdXBkYXRlZFRhcmdldElkcztcclxuICAgICAgICB0aGlzLnJlbW92ZWRUYXJnZXRJZHMgPSByZW1vdmVkVGFyZ2V0SWRzO1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMubmV3RG9jID0gbmV3RG9jO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEV4aXN0ZW5jZUZpbHRlckNoYW5nZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRJZCwgZXhpc3RlbmNlRmlsdGVyKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXRJZCA9IHRhcmdldElkO1xyXG4gICAgICAgIHRoaXMuZXhpc3RlbmNlRmlsdGVyID0gZXhpc3RlbmNlRmlsdGVyO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFdhdGNoVGFyZ2V0Q2hhbmdlIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFdoYXQga2luZCBvZiBjaGFuZ2Ugb2NjdXJyZWQgdG8gdGhlIHdhdGNoIHRhcmdldC4gKi9cclxuICAgIHN0YXRlLCBcclxuICAgIC8qKiBUaGUgdGFyZ2V0IElEcyB0aGF0IHdlcmUgYWRkZWQvcmVtb3ZlZC9zZXQuICovXHJcbiAgICB0YXJnZXRJZHMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvcGFxdWUsIHNlcnZlci1hc3NpZ25lZCB0b2tlbiB0aGF0IGFsbG93cyB3YXRjaGluZyBhIHRhcmdldCB0byBiZVxyXG4gICAgICogcmVzdW1lZCBhZnRlciBkaXNjb25uZWN0aW5nIHdpdGhvdXQgcmV0cmFuc21pdHRpbmcgYWxsIHRoZSBkYXRhIHRoYXRcclxuICAgICAqIG1hdGNoZXMgdGhlIHRhcmdldC4gVGhlIHJlc3VtZSB0b2tlbiBlc3NlbnRpYWxseSBpZGVudGlmaWVzIGEgcG9pbnQgaW5cclxuICAgICAqIHRpbWUgZnJvbSB3aGljaCB0aGUgc2VydmVyIHNob3VsZCByZXN1bWUgc2VuZGluZyByZXN1bHRzLlxyXG4gICAgICovXHJcbiAgICByZXN1bWVUb2tlbiA9IEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIFxyXG4gICAgLyoqIEFuIFJQQyBlcnJvciBpbmRpY2F0aW5nIHdoeSB0aGUgd2F0Y2ggZmFpbGVkLiAqL1xyXG4gICAgY2F1c2UgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWRzID0gdGFyZ2V0SWRzO1xyXG4gICAgICAgIHRoaXMucmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcclxuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XHJcbiAgICB9XHJcbn1cclxuLyoqIFRyYWNrcyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgYSBXYXRjaCB0YXJnZXQuICovXHJcbmNsYXNzIFRhcmdldFN0YXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgcGVuZGluZyByZXNwb25zZXMgKGFkZHMgb3IgcmVtb3ZlcykgdGhhdCB3ZSBhcmUgd2FpdGluZyBvbi5cclxuICAgICAgICAgKiBXZSBvbmx5IGNvbnNpZGVyIHRhcmdldHMgYWN0aXZlIHRoYXQgaGF2ZSBubyBwZW5kaW5nIHJlc3BvbnNlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHNpbmNlIHRoZSBsYXN0IHJhaXNlZCBzbmFwc2hvdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoZXNlIGNoYW5nZXMgYXJlIGNvbnRpbnVvdXNseSB1cGRhdGVkIGFzIHdlIHJlY2VpdmUgZG9jdW1lbnQgdXBkYXRlcyBhbmRcclxuICAgICAgICAgKiBhbHdheXMgcmVmbGVjdCB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcyBhZ2FpbnN0IHRoZSBsYXN0IGlzc3VlZCBzbmFwc2hvdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRvY3VtZW50Q2hhbmdlcyA9IHNuYXBzaG90Q2hhbmdlc01hcCgpO1xyXG4gICAgICAgIC8qKiBTZWUgcHVibGljIGdldHRlcnMgZm9yIGV4cGxhbmF0aW9ucyBvZiB0aGVzZSBmaWVsZHMuICovXHJcbiAgICAgICAgdGhpcy5fcmVzdW1lVG9rZW4gPSBCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgdGFyZ2V0IHN0YXRlIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgbmV4dCBzbmFwc2hvdC4gV2VcclxuICAgICAgICAgKiBpbml0aWFsaXplIHRvIHRydWUgc28gdGhhdCBuZXdseS1hZGRlZCB0YXJnZXRzIGFyZSBpbmNsdWRlZCBpbiB0aGUgbmV4dFxyXG4gICAgICAgICAqIFJlbW90ZUV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGlzIHRhcmdldCBoYXMgYmVlbiBtYXJrZWQgJ2N1cnJlbnQnLlxyXG4gICAgICpcclxuICAgICAqICdDdXJyZW50JyBoYXMgc3BlY2lhbCBtZWFuaW5nIGluIHRoZSBSUEMgcHJvdG9jb2w6IEl0IGltcGxpZXMgdGhhdCB0aGVcclxuICAgICAqIFdhdGNoIGJhY2tlbmQgaGFzIHNlbnQgdXMgYWxsIGNoYW5nZXMgdXAgdG8gdGhlIHBvaW50IGF0IHdoaWNoIHRoZSB0YXJnZXRcclxuICAgICAqIHdhcyBhZGRlZCBhbmQgdGhhdCB0aGUgdGFyZ2V0IGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgd2F0Y2hcclxuICAgICAqIHN0cmVhbS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGN1cnJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIGxhc3QgcmVzdW1lIHRva2VuIHNlbnQgdG8gdXMgZm9yIHRoaXMgdGFyZ2V0LiAqL1xyXG4gICAgZ2V0IHJlc3VtZVRva2VuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXN1bWVUb2tlbjtcclxuICAgIH1cclxuICAgIC8qKiBXaGV0aGVyIHRoaXMgdGFyZ2V0IGhhcyBwZW5kaW5nIHRhcmdldCBhZGRzIG9yIHRhcmdldCByZW1vdmVzLiAqL1xyXG4gICAgZ2V0IGlzUGVuZGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVzcG9uc2VzICE9PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqIFdoZXRoZXIgd2UgaGF2ZSBtb2RpZmllZCBhbnkgc3RhdGUgdGhhdCBzaG91bGQgdHJpZ2dlciBhIHNuYXBzaG90LiAqL1xyXG4gICAgZ2V0IGhhc1BlbmRpbmdDaGFuZ2VzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNQZW5kaW5nQ2hhbmdlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgcmVzdW1lIHRva2VuIHRvIHRoZSBUYXJnZXRDaGFuZ2UsIGJ1dCBvbmx5IHdoZW4gaXQgaGFzIGEgbmV3XHJcbiAgICAgKiB2YWx1ZS4gRW1wdHkgcmVzdW1lVG9rZW5zIGFyZSBkaXNjYXJkZWQuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVJlc3VtZVRva2VuKHJlc3VtZVRva2VuKSB7XHJcbiAgICAgICAgaWYgKHJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXN1bWVUb2tlbiA9IHJlc3VtZVRva2VuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHRhcmdldCBjaGFuZ2UgZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcy5cclxuICAgICAqXHJcbiAgICAgKiBUbyByZXNldCB0aGUgZG9jdW1lbnQgY2hhbmdlcyBhZnRlciByYWlzaW5nIHRoaXMgc25hcHNob3QsIGNhbGxcclxuICAgICAqIGBjbGVhclBlbmRpbmdDaGFuZ2VzKClgLlxyXG4gICAgICovXHJcbiAgICB0b1RhcmdldENoYW5nZSgpIHtcclxuICAgICAgICBsZXQgYWRkZWREb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgIGxldCBtb2RpZmllZERvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgbGV0IHJlbW92ZWREb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzLmZvckVhY2goKGtleSwgY2hhbmdlVHlwZSkgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBBZGRlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICBhZGRlZERvY3VtZW50cyA9IGFkZGVkRG9jdW1lbnRzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIE1vZGlmaWVkICovOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRG9jdW1lbnRzID0gbW9kaWZpZWREb2N1bWVudHMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogUmVtb3ZlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkRG9jdW1lbnRzID0gcmVtb3ZlZERvY3VtZW50cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXRDaGFuZ2UodGhpcy5fcmVzdW1lVG9rZW4sIHRoaXMuX2N1cnJlbnQsIGFkZGVkRG9jdW1lbnRzLCBtb2RpZmllZERvY3VtZW50cywgcmVtb3ZlZERvY3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgZG9jdW1lbnQgY2hhbmdlcyBhbmQgc2V0cyBgaGFzUGVuZGluZ0NoYW5nZXNgIHRvIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBjbGVhclBlbmRpbmdDaGFuZ2VzKCkge1xyXG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENoYW5nZXMgPSBzbmFwc2hvdENoYW5nZXNNYXAoKTtcclxuICAgIH1cclxuICAgIGFkZERvY3VtZW50Q2hhbmdlKGtleSwgY2hhbmdlVHlwZSkge1xyXG4gICAgICAgIHRoaXMuX2hhc1BlbmRpbmdDaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50Q2hhbmdlcyA9IHRoaXMuZG9jdW1lbnRDaGFuZ2VzLmluc2VydChrZXksIGNoYW5nZVR5cGUpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlRG9jdW1lbnRDaGFuZ2Uoa2V5KSB7XHJcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDaGFuZ2VzID0gdGhpcy5kb2N1bWVudENoYW5nZXMucmVtb3ZlKGtleSk7XHJcbiAgICB9XHJcbiAgICByZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCgpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgKz0gMTtcclxuICAgIH1cclxuICAgIHJlY29yZFRhcmdldFJlc3BvbnNlKCkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyAtPSAxO1xyXG4gICAgfVxyXG4gICAgbWFya0N1cnJlbnQoKSB7XHJcbiAgICAgICAgdGhpcy5faGFzUGVuZGluZ0NoYW5nZXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IExPR19UQUckZyA9ICdXYXRjaENoYW5nZUFnZ3JlZ2F0b3InO1xyXG4vKipcclxuICogQSBoZWxwZXIgY2xhc3MgdG8gYWNjdW11bGF0ZSB3YXRjaCBjaGFuZ2VzIGludG8gYSBSZW1vdGVFdmVudC5cclxuICovXHJcbmNsYXNzIFdhdGNoQ2hhbmdlQWdncmVnYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YVByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YVByb3ZpZGVyID0gbWV0YWRhdGFQcm92aWRlcjtcclxuICAgICAgICAvKiogVGhlIGludGVybmFsIHN0YXRlIG9mIGFsbCB0cmFja2VkIHRhcmdldHMuICovXHJcbiAgICAgICAgdGhpcy50YXJnZXRTdGF0ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqIEtlZXBzIHRyYWNrIG9mIHRoZSBkb2N1bWVudHMgdG8gdXBkYXRlIHNpbmNlIHRoZSBsYXN0IHJhaXNlZCBzbmFwc2hvdC4gKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICAvKiogQSBtYXBwaW5nIG9mIGRvY3VtZW50IGtleXMgdG8gdGhlaXIgc2V0IG9mIHRhcmdldCBJRHMuICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID0gZG9jdW1lbnRUYXJnZXRNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgdGFyZ2V0cyB3aXRoIGV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2hlcy4gVGhlc2UgdGFyZ2V0cyBhcmVcclxuICAgICAgICAgKiBrbm93biB0byBiZSBpbmNvbnNpc3RlbnQgYW5kIHRoZWlyIGxpc3RlbnMgbmVlZHMgdG8gYmUgcmUtZXN0YWJsaXNoZWQgYnlcclxuICAgICAgICAgKiBSZW1vdGVTdG9yZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdUYXJnZXRSZXNldHMgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzZXMgYW5kIGFkZHMgdGhlIERvY3VtZW50V2F0Y2hDaGFuZ2UgdG8gdGhlIGN1cnJlbnQgc2V0IG9mIGNoYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZURvY3VtZW50Q2hhbmdlKGRvY0NoYW5nZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgZG9jQ2hhbmdlLnVwZGF0ZWRUYXJnZXRJZHMpIHtcclxuICAgICAgICAgICAgaWYgKGRvY0NoYW5nZS5uZXdEb2MgJiYgZG9jQ2hhbmdlLm5ld0RvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGREb2N1bWVudFRvVGFyZ2V0KHRhcmdldElkLCBkb2NDaGFuZ2UubmV3RG9jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBkb2NDaGFuZ2Uua2V5LCBkb2NDaGFuZ2UubmV3RG9jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIGRvY0NoYW5nZS5yZW1vdmVkVGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBkb2NDaGFuZ2Uua2V5LCBkb2NDaGFuZ2UubmV3RG9jKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogUHJvY2Vzc2VzIGFuZCBhZGRzIHRoZSBXYXRjaFRhcmdldENoYW5nZSB0byB0aGUgY3VycmVudCBzZXQgb2YgY2hhbmdlcy4gKi9cclxuICAgIGhhbmRsZVRhcmdldENoYW5nZSh0YXJnZXRDaGFuZ2UpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hUYXJnZXQodGFyZ2V0Q2hhbmdlLCB0YXJnZXRJZCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGFyZ2V0Q2hhbmdlLnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogTm9DaGFuZ2UgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIEFkZGVkICovOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVjcmVtZW50IHRoZSBudW1iZXIgb2YgcGVuZGluZyBhY2tzIG5lZWRlZCBmcm9tIHdhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoaXMgdGFyZ2V0SWQuXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUucmVjb3JkVGFyZ2V0UmVzcG9uc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFN0YXRlLmlzUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgZnJlc2hseSBhZGRlZCB0YXJnZXQsIHNvIHdlIG5lZWQgdG8gcmVzZXQgYW55IHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgd2UgaGFkIHByZXZpb3VzbHkuIFRoaXMgY2FuIGhhcHBlbiBlLmcuIHdoZW4gcmVtb3ZlIGFuZCBhZGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFjayBhIHRhcmdldCBmb3IgZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaGVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTdGF0ZS5jbGVhclBlbmRpbmdDaGFuZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogUmVtb3ZlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgcmVtb3ZlZCB0YXJnZXRzIHRvIHdlIGNhbiBwb3N0LWZpbHRlciBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgYW55IHRhcmdldCBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVjcmVtZW50IHRoZSBudW1iZXIgb2YgcGVuZGluZyBhY2tzIG5lZWRlZCBmcm9tIHdhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoaXMgdGFyZ2V0SWQuXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUucmVjb3JkVGFyZ2V0UmVzcG9uc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFN0YXRlLmlzUGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzIC8qIEN1cnJlbnQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLm1hcmtDdXJyZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLnVwZGF0ZVJlc3VtZVRva2VuKHRhcmdldENoYW5nZS5yZXN1bWVUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFJlc2V0ICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdGFyZ2V0IGFuZCBzeW50aGVzaXplcyByZW1vdmVzIGZvciBhbGwgZXhpc3RpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9jdW1lbnRzLiBUaGUgYmFja2VuZCB3aWxsIHJlLWFkZCBhbnkgZG9jdW1lbnRzIHRoYXQgc3RpbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhlIHRhcmdldCBiZWZvcmUgaXQgc2VuZHMgdGhlIG5leHQgZ2xvYmFsIHNuYXBzaG90LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0VGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U3RhdGUudXBkYXRlUmVzdW1lVG9rZW4odGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCB0YXJnZXRJZHMgdGhhdCB0aGUgd2F0Y2ggY2hhbmdlIGFwcGxpZXMgdG86IGVpdGhlciB0aGVcclxuICAgICAqIHRhcmdldElkcyBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgY2hhbmdlIG9yIHRoZSB0YXJnZXRJZHMgb2YgYWxsIGN1cnJlbnRseVxyXG4gICAgICogYWN0aXZlIHRhcmdldHMuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2hUYXJnZXQodGFyZ2V0Q2hhbmdlLCBmbikge1xyXG4gICAgICAgIGlmICh0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLnRhcmdldElkcy5mb3JFYWNoKGZuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0U3RhdGVzLmZvckVhY2goKF8sIHRhcmdldElkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZVRhcmdldCh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmbih0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBleGlzdGVuY2UgZmlsdGVycyBhbmQgc3ludGhlc2l6ZXMgZGVsZXRlcyBmb3IgZmlsdGVyIG1pc21hdGNoZXMuXHJcbiAgICAgKiBUYXJnZXRzIHRoYXQgYXJlIGludmFsaWRhdGVkIGJ5IGZpbHRlciBtaXNtYXRjaGVzIGFyZSBhZGRlZCB0b1xyXG4gICAgICogYHBlbmRpbmdUYXJnZXRSZXNldHNgLlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVFeGlzdGVuY2VGaWx0ZXIod2F0Y2hDaGFuZ2UpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHdhdGNoQ2hhbmdlLnRhcmdldElkO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQ291bnQgPSB3YXRjaENoYW5nZS5leGlzdGVuY2VGaWx0ZXIuY291bnQ7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRoaXMudGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgaWYgKHRhcmdldERhdGEpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0RGF0YS50YXJnZXQ7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRJc0RvY3VtZW50VGFyZ2V0KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZENvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4aXN0ZW5jZSBmaWx0ZXIgdG9sZCB1cyB0aGUgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3QuIFdlIGRlZHVjZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhpcyBkb2N1bWVudCBkb2VzIG5vdCBleGlzdCBhbmQgYXBwbHkgYSBkZWxldGVkIGRvY3VtZW50IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3VyIHVwZGF0ZXMuIFdpdGhvdXQgYXBwbHlpbmcgdGhpcyBkZWxldGVkIGRvY3VtZW50IHRoZXJlIG1pZ2h0IGJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5vdGhlciBxdWVyeSB0aGF0IHdpbGwgcmFpc2UgdGhpcyBkb2N1bWVudCBhcyBwYXJ0IG9mIGEgc25hcHNob3RcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bnRpbCBpdCBpcyByZXNvbHZlZCwgZXNzZW50aWFsbHkgZXhwb3NpbmcgaW5jb25zaXN0ZW5jeSBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcXVlcmllcy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkodGFyZ2V0LnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBrZXksIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgU25hcHNob3RWZXJzaW9uLm1pbigpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXJkQXNzZXJ0KGV4cGVjdGVkQ291bnQgPT09IDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpemUgPSB0aGlzLmdldEN1cnJlbnREb2N1bWVudENvdW50Rm9yVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2l6ZSAhPT0gZXhwZWN0ZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4aXN0ZW5jZSBmaWx0ZXIgbWlzbWF0Y2g6IFdlIHJlc2V0IHRoZSBtYXBwaW5nIGFuZCByYWlzZSBhIG5ld1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNuYXBzaG90IHdpdGggYGlzRnJvbUNhY2hlOnRydWVgLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cyA9IHRoaXMucGVuZGluZ1RhcmdldFJlc2V0cy5hZGQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudGx5IGFjY3VtdWxhdGVkIHN0YXRlIGludG8gYSByZW1vdGUgZXZlbnQgYXQgdGhlXHJcbiAgICAgKiBwcm92aWRlZCBzbmFwc2hvdCB2ZXJzaW9uLiBSZXNldHMgdGhlIGFjY3VtdWxhdGVkIGNoYW5nZXMgYmVmb3JlIHJldHVybmluZy5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlUmVtb3RlRXZlbnQoc25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5mb3JFYWNoKCh0YXJnZXRTdGF0ZSwgdGFyZ2V0SWQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRoaXMudGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U3RhdGUuY3VycmVudCAmJiB0YXJnZXRJc0RvY3VtZW50VGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IHF1ZXJpZXMgZm9yIGRvY3VtZW50IHRoYXQgZG9uJ3QgZXhpc3QgY2FuIHByb2R1Y2UgYW4gZW1wdHlcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgc2V0LiBUbyB1cGRhdGUgb3VyIGxvY2FsIGNhY2hlLCB3ZSBzeW50aGVzaXplIGEgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgaWYgd2UgaGF2ZSBub3QgcHJldmlvdXNseSByZWNlaXZlZCB0aGUgZG9jdW1lbnQuIFRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlcyB0aGUgbGltYm8gc3RhdGUgb2YgdGhlIGRvY3VtZW50LCByZW1vdmluZyBpdCBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGltYm9Eb2N1bWVudFJlZnMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhbiBleHBsaWNpdCBsb29rdXAgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCByZXN1bHRpbmcgaW4gYW4gZXhwbGljaXQgZGVsZXRlIG1lc3NhZ2UgYW5kIHdlIGNvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgc3BlY2lhbCBsb2dpYy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkodGFyZ2V0RGF0YS50YXJnZXQucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcy5nZXQoa2V5KSA9PT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy50YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRG9jdW1lbnRGcm9tVGFyZ2V0KHRhcmdldElkLCBrZXksIE11dGFibGVEb2N1bWVudC5uZXdOb0RvY3VtZW50KGtleSwgc25hcHNob3RWZXJzaW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFN0YXRlLmhhc1BlbmRpbmdDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlcy5zZXQodGFyZ2V0SWQsIHRhcmdldFN0YXRlLnRvVGFyZ2V0Q2hhbmdlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFN0YXRlLmNsZWFyUGVuZGluZ0NoYW5nZXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCByZXNvbHZlZExpbWJvRG9jdW1lbnRzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICAvLyBXZSBleHRyYWN0IHRoZSBzZXQgb2YgbGltYm8tb25seSBkb2N1bWVudCB1cGRhdGVzIGFzIHRoZSBHQyBsb2dpY1xyXG4gICAgICAgIC8vIHNwZWNpYWwtY2FzZXMgZG9jdW1lbnRzIHRoYXQgZG8gbm90IGFwcGVhciBpbiB0aGUgdGFyZ2V0IGNhY2hlLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVE9ETyhnc29sdGlzKTogRXhwYW5kIG9uIHRoaXMgY29tbWVudCBvbmNlIEdDIGlzIGF2YWlsYWJsZSBpbiB0aGUgSlNcclxuICAgICAgICAvLyBjbGllbnQuXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmZvckVhY2goKGtleSwgdGFyZ2V0cykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaXNPbmx5TGltYm9UYXJnZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0YXJnZXRzLmZvckVhY2hXaGlsZSh0YXJnZXRJZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXREYXRhICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGF0YS5wdXJwb3NlICE9PSAyIC8qIExpbWJvUmVzb2x1dGlvbiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzT25seUxpbWJvVGFyZ2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoaXNPbmx5TGltYm9UYXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSByZXNvbHZlZExpbWJvRG9jdW1lbnRzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRVcGRhdGVzLmZvckVhY2goKF8sIGRvYykgPT4gZG9jLnNldFJlYWRUaW1lKHNuYXBzaG90VmVyc2lvbikpO1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZUV2ZW50ID0gbmV3IFJlbW90ZUV2ZW50KHNuYXBzaG90VmVyc2lvbiwgdGFyZ2V0Q2hhbmdlcywgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzLCB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMsIHJlc29sdmVkTGltYm9Eb2N1bWVudHMpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VXBkYXRlcyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9IGRvY3VtZW50VGFyZ2V0TWFwKCk7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nVGFyZ2V0UmVzZXRzID0gbmV3IFNvcnRlZFNldChwcmltaXRpdmVDb21wYXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlRXZlbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIHByb3ZpZGVkIGRvY3VtZW50IHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGRvY3VtZW50IHVwZGF0ZXMgYW5kXHJcbiAgICAgKiBpdHMgZG9jdW1lbnQga2V5IHRvIHRoZSBnaXZlbiB0YXJnZXQncyBtYXBwaW5nLlxyXG4gICAgICovXHJcbiAgICAvLyBWaXNpYmxlIGZvciB0ZXN0aW5nLlxyXG4gICAgYWRkRG9jdW1lbnRUb1RhcmdldCh0YXJnZXRJZCwgZG9jdW1lbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hhbmdlVHlwZSA9IHRoaXMudGFyZ2V0Q29udGFpbnNEb2N1bWVudCh0YXJnZXRJZCwgZG9jdW1lbnQua2V5KVxyXG4gICAgICAgICAgICA/IDIgLyogTW9kaWZpZWQgKi9cclxuICAgICAgICAgICAgOiAwIC8qIEFkZGVkICovO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy5lbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgdGFyZ2V0U3RhdGUuYWRkRG9jdW1lbnRDaGFuZ2UoZG9jdW1lbnQua2V5LCBjaGFuZ2VUeXBlKTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZyA9XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RvY3VtZW50VGFyZ2V0TWFwcGluZy5pbnNlcnQoZG9jdW1lbnQua2V5LCB0aGlzLmVuc3VyZURvY3VtZW50VGFyZ2V0TWFwcGluZyhkb2N1bWVudC5rZXkpLmFkZCh0YXJnZXRJZCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm92aWRlZCBkb2N1bWVudCBmcm9tIHRoZSB0YXJnZXQgbWFwcGluZy4gSWYgdGhlXHJcbiAgICAgKiBkb2N1bWVudCBubyBsb25nZXIgbWF0Y2hlcyB0aGUgdGFyZ2V0LCBidXQgdGhlIGRvY3VtZW50J3Mgc3RhdGUgaXMgc3RpbGxcclxuICAgICAqIGtub3duIChlLmcuIHdlIGtub3cgdGhhdCB0aGUgZG9jdW1lbnQgd2FzIGRlbGV0ZWQgb3Igd2UgcmVjZWl2ZWQgdGhlIGNoYW5nZVxyXG4gICAgICogdGhhdCBjYXVzZWQgdGhlIGZpbHRlciBtaXNtYXRjaCksIHRoZSBuZXcgZG9jdW1lbnQgY2FuIGJlIHByb3ZpZGVkXHJcbiAgICAgKiB0byB1cGRhdGUgdGhlIHJlbW90ZSBkb2N1bWVudCBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuICAgIHJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCB1cGRhdGVkRG9jdW1lbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmVUYXJnZXQodGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0U3RhdGUgPSB0aGlzLmVuc3VyZVRhcmdldFN0YXRlKHRhcmdldElkKTtcclxuICAgICAgICBpZiAodGhpcy50YXJnZXRDb250YWluc0RvY3VtZW50KHRhcmdldElkLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFN0YXRlLmFkZERvY3VtZW50Q2hhbmdlKGtleSwgMSAvKiBSZW1vdmVkICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBtYXkgaGF2ZSBlbnRlcmVkIGFuZCBsZWZ0IHRoZSB0YXJnZXQgYmVmb3JlIHdlIHJhaXNlZCBhXHJcbiAgICAgICAgICAgIC8vIHNuYXBzaG90LCBzbyB3ZSBjYW4ganVzdCBpZ25vcmUgdGhlIGNoYW5nZS5cclxuICAgICAgICAgICAgdGFyZ2V0U3RhdGUucmVtb3ZlRG9jdW1lbnRDaGFuZ2Uoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nID1cclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmluc2VydChrZXksIHRoaXMuZW5zdXJlRG9jdW1lbnRUYXJnZXRNYXBwaW5nKGtleSkuZGVsZXRlKHRhcmdldElkKSk7XHJcbiAgICAgICAgaWYgKHVwZGF0ZWREb2N1bWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFVwZGF0ZXMuaW5zZXJ0KGtleSwgdXBkYXRlZERvY3VtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5kZWxldGUodGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvdW50IG9mIGRvY3VtZW50cyBpbiB0aGUgdGFyZ2V0LiBUaGlzIGluY2x1ZGVzIGJvdGhcclxuICAgICAqIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgdGhlIExvY2FsU3RvcmUgY29uc2lkZXJzIHRvIGJlIHBhcnQgb2YgdGhlXHJcbiAgICAgKiB0YXJnZXQgYXMgd2VsbCBhcyBhbnkgYWNjdW11bGF0ZWQgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VycmVudERvY3VtZW50Q291bnRGb3JUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5nZSA9IHRhcmdldFN0YXRlLnRvVGFyZ2V0Q2hhbmdlKCk7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLm1ldGFkYXRhUHJvdmlkZXIuZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCh0YXJnZXRJZCkuc2l6ZSArXHJcbiAgICAgICAgICAgIHRhcmdldENoYW5nZS5hZGRlZERvY3VtZW50cy5zaXplIC1cclxuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLnJlbW92ZWREb2N1bWVudHMuc2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluY3JlbWVudCB0aGUgbnVtYmVyIG9mIGFja3MgbmVlZGVkIGZyb20gd2F0Y2ggYmVmb3JlIHdlIGNhbiBjb25zaWRlciB0aGVcclxuICAgICAqIHNlcnZlciB0byBiZSAnaW4tc3luYycgd2l0aCB0aGUgY2xpZW50J3MgYWN0aXZlIHRhcmdldHMuXHJcbiAgICAgKi9cclxuICAgIHJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KHRhcmdldElkKSB7XHJcbiAgICAgICAgLy8gRm9yIGVhY2ggcmVxdWVzdCB3ZSBnZXQgd2UgbmVlZCB0byByZWNvcmQgd2UgbmVlZCBhIHJlc3BvbnNlIGZvciBpdC5cclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IHRoaXMuZW5zdXJlVGFyZ2V0U3RhdGUodGFyZ2V0SWQpO1xyXG4gICAgICAgIHRhcmdldFN0YXRlLnJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KCk7XHJcbiAgICB9XHJcbiAgICBlbnN1cmVUYXJnZXRTdGF0ZSh0YXJnZXRJZCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnRhcmdldFN0YXRlcy5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUYXJnZXRTdGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5zZXQodGFyZ2V0SWQsIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBlbnN1cmVEb2N1bWVudFRhcmdldE1hcHBpbmcoa2V5KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldE1hcHBpbmcgPSB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXRNYXBwaW5nKSB7XHJcbiAgICAgICAgICAgIHRhcmdldE1hcHBpbmcgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEb2N1bWVudFRhcmdldE1hcHBpbmcgPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRG9jdW1lbnRUYXJnZXRNYXBwaW5nLmluc2VydChrZXksIHRhcmdldE1hcHBpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0TWFwcGluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZpZXMgdGhhdCB0aGUgdXNlciBpcyBzdGlsbCBpbnRlcmVzdGVkIGluIHRoaXMgdGFyZ2V0IChieSBjYWxsaW5nXHJcbiAgICAgKiBgZ2V0VGFyZ2V0RGF0YUZvclRhcmdldCgpYCkgYW5kIHRoYXQgd2UgYXJlIG5vdCB3YWl0aW5nIGZvciBwZW5kaW5nIEFERHNcclxuICAgICAqIGZyb20gd2F0Y2guXHJcbiAgICAgKi9cclxuICAgIGlzQWN0aXZlVGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0QWN0aXZlID0gdGhpcy50YXJnZXREYXRhRm9yQWN0aXZlVGFyZ2V0KHRhcmdldElkKSAhPT0gbnVsbDtcclxuICAgICAgICBpZiAoIXRhcmdldEFjdGl2ZSkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGcsICdEZXRlY3RlZCBpbmFjdGl2ZSB0YXJnZXQnLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YXJnZXRBY3RpdmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFRhcmdldERhdGEgZm9yIGFuIGFjdGl2ZSB0YXJnZXQgKGkuZS4gYSB0YXJnZXQgdGhhdCB0aGUgdXNlclxyXG4gICAgICogaXMgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGF0IGhhcyBubyBvdXRzdGFuZGluZyB0YXJnZXQgY2hhbmdlIHJlcXVlc3RzKS5cclxuICAgICAqL1xyXG4gICAgdGFyZ2V0RGF0YUZvckFjdGl2ZVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gdGhpcy50YXJnZXRTdGF0ZXMuZ2V0KHRhcmdldElkKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0U3RhdGUgJiYgdGFyZ2V0U3RhdGUuaXNQZW5kaW5nXHJcbiAgICAgICAgICAgID8gbnVsbFxyXG4gICAgICAgICAgICA6IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRUYXJnZXREYXRhRm9yVGFyZ2V0KHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBzdGF0ZSBvZiBhIFdhdGNoIHRhcmdldCB0byBpdHMgaW5pdGlhbCBzdGF0ZSAoZS5nLiBzZXRzXHJcbiAgICAgKiAnY3VycmVudCcgdG8gZmFsc2UsIGNsZWFycyB0aGUgcmVzdW1lIHRva2VuIGFuZCByZW1vdmVzIGl0cyB0YXJnZXQgbWFwcGluZ1xyXG4gICAgICogZnJvbSBhbGwgZG9jdW1lbnRzKS5cclxuICAgICAqL1xyXG4gICAgcmVzZXRUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnRhcmdldFN0YXRlcy5zZXQodGFyZ2V0SWQsIG5ldyBUYXJnZXRTdGF0ZSgpKTtcclxuICAgICAgICAvLyBUcmlnZ2VyIHJlbW92YWwgZm9yIGFueSBkb2N1bWVudHMgY3VycmVudGx5IG1hcHBlZCB0byB0aGlzIHRhcmdldC5cclxuICAgICAgICAvLyBUaGVzZSByZW1vdmFscyB3aWxsIGJlIHBhcnQgb2YgdGhlIGluaXRpYWwgc25hcHNob3QgaWYgV2F0Y2ggZG9lcyBub3RcclxuICAgICAgICAvLyByZXNlbmQgdGhlc2UgZG9jdW1lbnRzLlxyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICBleGlzdGluZ0tleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZURvY3VtZW50RnJvbVRhcmdldCh0YXJnZXRJZCwga2V5LCAvKnVwZGF0ZWREb2N1bWVudD0qLyBudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBMb2NhbFN0b3JlIGNvbnNpZGVycyB0aGUgZG9jdW1lbnQgdG8gYmUgcGFydCBvZiB0aGVcclxuICAgICAqIHNwZWNpZmllZCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldENvbnRhaW5zRG9jdW1lbnQodGFyZ2V0SWQsIGtleSkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nS2V5cyA9IHRoaXMubWV0YWRhdGFQcm92aWRlci5nZXRSZW1vdGVLZXlzRm9yVGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdLZXlzLmhhcyhrZXkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRvY3VtZW50VGFyZ2V0TWFwKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbn1cclxuZnVuY3Rpb24gc25hcHNob3RDaGFuZ2VzTWFwKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgRElSRUNUSU9OUyA9ICgoKSA9PiB7XHJcbiAgICBjb25zdCBkaXJzID0ge307XHJcbiAgICBkaXJzW1wiYXNjXCIgLyogQVNDRU5ESU5HICovXSA9ICdBU0NFTkRJTkcnO1xyXG4gICAgZGlyc1tcImRlc2NcIiAvKiBERVNDRU5ESU5HICovXSA9ICdERVNDRU5ESU5HJztcclxuICAgIHJldHVybiBkaXJzO1xyXG59KSgpO1xyXG5jb25zdCBPUEVSQVRPUlMgPSAoKCkgPT4ge1xyXG4gICAgY29uc3Qgb3BzID0ge307XHJcbiAgICBvcHNbXCI8XCIgLyogTEVTU19USEFOICovXSA9ICdMRVNTX1RIQU4nO1xyXG4gICAgb3BzW1wiPD1cIiAvKiBMRVNTX1RIQU5fT1JfRVFVQUwgKi9dID0gJ0xFU1NfVEhBTl9PUl9FUVVBTCc7XHJcbiAgICBvcHNbXCI+XCIgLyogR1JFQVRFUl9USEFOICovXSA9ICdHUkVBVEVSX1RIQU4nO1xyXG4gICAgb3BzW1wiPj1cIiAvKiBHUkVBVEVSX1RIQU5fT1JfRVFVQUwgKi9dID0gJ0dSRUFURVJfVEhBTl9PUl9FUVVBTCc7XHJcbiAgICBvcHNbXCI9PVwiIC8qIEVRVUFMICovXSA9ICdFUVVBTCc7XHJcbiAgICBvcHNbXCIhPVwiIC8qIE5PVF9FUVVBTCAqL10gPSAnTk9UX0VRVUFMJztcclxuICAgIG9wc1tcImFycmF5LWNvbnRhaW5zXCIgLyogQVJSQVlfQ09OVEFJTlMgKi9dID0gJ0FSUkFZX0NPTlRBSU5TJztcclxuICAgIG9wc1tcImluXCIgLyogSU4gKi9dID0gJ0lOJztcclxuICAgIG9wc1tcIm5vdC1pblwiIC8qIE5PVF9JTiAqL10gPSAnTk9UX0lOJztcclxuICAgIG9wc1tcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIEFSUkFZX0NPTlRBSU5TX0FOWSAqL10gPSAnQVJSQVlfQ09OVEFJTlNfQU5ZJztcclxuICAgIHJldHVybiBvcHM7XHJcbn0pKCk7XHJcbmZ1bmN0aW9uIGFzc2VydFByZXNlbnQodmFsdWUsIGRlc2NyaXB0aW9uKSB7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZ2VuZXJhdGVzIEpzb25PYmplY3QgdmFsdWVzIGZvciB0aGUgRGF0YXN0b3JlIEFQSSBzdWl0YWJsZSBmb3JcclxuICogc2VuZGluZyB0byBlaXRoZXIgR1JQQyBzdHViIG1ldGhvZHMgb3IgdmlhIHRoZSBKU09OL0hUVFAgUkVTVCBBUEkuXHJcbiAqXHJcbiAqIFRoZSBzZXJpYWxpemVyIHN1cHBvcnRzIGJvdGggUHJvdG9idWYuanMgYW5kIFByb3RvMyBKU09OIGZvcm1hdHMuIEJ5XHJcbiAqIHNldHRpbmcgYHVzZVByb3RvM0pzb25gIHRvIHRydWUsIHRoZSBzZXJpYWxpemVyIHdpbGwgdXNlIHRoZSBQcm90bzMgSlNPTlxyXG4gKiBmb3JtYXQuXHJcbiAqXHJcbiAqIEZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBQcm90bzMgSlNPTiBmb3JtYXQgY2hlY2tcclxuICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMyNqc29uXHJcbiAqXHJcbiAqIFRPRE8oa2xpbXQpOiBXZSBjYW4gcmVtb3ZlIHRoZSBkYXRhYmFzZUlkIGFyZ3VtZW50IGlmIHdlIGtlZXAgdGhlIGZ1bGxcclxuICogcmVzb3VyY2UgbmFtZSBpbiBkb2N1bWVudHMuXHJcbiAqL1xyXG5jbGFzcyBKc29uUHJvdG9TZXJpYWxpemVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGFiYXNlSWQsIHVzZVByb3RvM0pzb24pIHtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlSWQgPSBkYXRhYmFzZUlkO1xyXG4gICAgICAgIHRoaXMudXNlUHJvdG8zSnNvbiA9IHVzZVByb3RvM0pzb247XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZnJvbVJwY1N0YXR1cyhzdGF0dXMpIHtcclxuICAgIGNvbnN0IGNvZGUgPSBzdGF0dXMuY29kZSA9PT0gdW5kZWZpbmVkID8gQ29kZS5VTktOT1dOIDogbWFwQ29kZUZyb21ScGNDb2RlKHN0YXR1cy5jb2RlKTtcclxuICAgIHJldHVybiBuZXcgRmlyZXN0b3JlRXJyb3IoY29kZSwgc3RhdHVzLm1lc3NhZ2UgfHwgJycpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGEgbnVtYmVyIChvciBudWxsKSB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGludG9cclxuICogYSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZSBwcm90by5cclxuICogRE8gTk9UIFVTRSBUSElTIEZPUiBBTllUSElORyBFTFNFLlxyXG4gKiBUaGlzIG1ldGhvZCBjaGVhdHMuIEl0J3MgdHlwZWQgYXMgcmV0dXJuaW5nIFwibnVtYmVyXCIgYmVjYXVzZSB0aGF0J3Mgd2hhdFxyXG4gKiBvdXIgZ2VuZXJhdGVkIHByb3RvIGludGVyZmFjZXMgc2F5IEludDMyVmFsdWUgbXVzdCBiZS4gQnV0IEdSUEMgYWN0dWFsbHlcclxuICogZXhwZWN0cyBhIHsgdmFsdWU6IDxudW1iZXI+IH0gc3RydWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gdG9JbnQzMlByb3RvKHNlcmlhbGl6ZXIsIHZhbCkge1xyXG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbiB8fCBpc051bGxPclVuZGVmaW5lZCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWwgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG51bWJlciAob3IgbnVsbCkgZnJvbSBhIGdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlIHByb3RvLlxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUludDMyUHJvdG8odmFsKSB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gdmFsLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0ID0gdmFsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzTnVsbE9yVW5kZWZpbmVkKHJlc3VsdCkgPyBudWxsIDogcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdmFsdWUgZm9yIGEgRGF0ZSB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGludG8gYSBwcm90by5cclxuICovXHJcbmZ1bmN0aW9uIHRvVGltZXN0YW1wKHNlcmlhbGl6ZXIsIHRpbWVzdGFtcCkge1xyXG4gICAgaWYgKHNlcmlhbGl6ZXIudXNlUHJvdG8zSnNvbikge1xyXG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0byBJU08tODYwMSBkYXRlIGZvcm1hdCwgYnV0IHdpdGggZnVsbCBuYW5vIHJlc29sdXRpb24uXHJcbiAgICAgICAgLy8gU2luY2UgSlMgRGF0ZSBoYXMgb25seSBtaWxsaXMsIGxldCdzIG9ubHkgdXNlIGl0IGZvciB0aGUgc2Vjb25kcyBhbmRcclxuICAgICAgICAvLyB0aGVuIG1hbnVhbGx5IGFkZCB0aGUgZnJhY3Rpb25zIHRvIHRoZSBlbmQuXHJcbiAgICAgICAgY29uc3QganNEYXRlU3RyID0gbmV3IERhdGUodGltZXN0YW1wLnNlY29uZHMgKiAxMDAwKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgIC8vIFJlbW92ZSAueHh4IGZyYWMgcGFydCBhbmQgWiBpbiB0aGUgZW5kLlxyXG4gICAgICAgIGNvbnN0IHN0clVudGlsU2Vjb25kcyA9IGpzRGF0ZVN0ci5yZXBsYWNlKC9cXC5cXGQqLywgJycpLnJlcGxhY2UoJ1onLCAnJyk7XHJcbiAgICAgICAgLy8gUGFkIHRoZSBmcmFjdGlvbiBvdXQgdG8gOSBkaWdpdHMgKG5hbm9zKS5cclxuICAgICAgICBjb25zdCBuYW5vU3RyID0gKCcwMDAwMDAwMDAnICsgdGltZXN0YW1wLm5hbm9zZWNvbmRzKS5zbGljZSgtOSk7XHJcbiAgICAgICAgcmV0dXJuIGAke3N0clVudGlsU2Vjb25kc30uJHtuYW5vU3RyfVpgO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2Vjb25kczogJycgKyB0aW1lc3RhbXAuc2Vjb25kcyxcclxuICAgICAgICAgICAgbmFub3M6IHRpbWVzdGFtcC5uYW5vc2Vjb25kc1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZnJvbVRpbWVzdGFtcChkYXRlKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBub3JtYWxpemVUaW1lc3RhbXAoZGF0ZSk7XHJcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh0aW1lc3RhbXAuc2Vjb25kcywgdGltZXN0YW1wLm5hbm9zKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHZhbHVlIGZvciBieXRlcyB0aGF0J3MgYXBwcm9wcmlhdGUgdG8gcHV0IGluIGEgcHJvdG8uXHJcbiAqXHJcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0J5dGVzKHNlcmlhbGl6ZXIsIGJ5dGVzKSB7XHJcbiAgICBpZiAoc2VyaWFsaXplci51c2VQcm90bzNKc29uKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvQmFzZTY0KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYnl0ZXMudG9VaW50OEFycmF5KCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBCeXRlU3RyaW5nIGJhc2VkIG9uIHRoZSBwcm90byBzdHJpbmcgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tQnl0ZXMoc2VyaWFsaXplciwgdmFsdWUpIHtcclxuICAgIGlmIChzZXJpYWxpemVyLnVzZVByb3RvM0pzb24pIHtcclxuICAgICAgICBoYXJkQXNzZXJ0KHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVTdHJpbmcuZnJvbUJhc2U2NFN0cmluZyh2YWx1ZSA/IHZhbHVlIDogJycpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaGFyZEFzc2VydCh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XHJcbiAgICAgICAgcmV0dXJuIEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkodmFsdWUgPyB2YWx1ZSA6IG5ldyBVaW50OEFycmF5KCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvVmVyc2lvbihzZXJpYWxpemVyLCB2ZXJzaW9uKSB7XHJcbiAgICByZXR1cm4gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdmVyc2lvbi50b1RpbWVzdGFtcCgpKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tVmVyc2lvbih2ZXJzaW9uKSB7XHJcbiAgICBoYXJkQXNzZXJ0KCEhdmVyc2lvbik7XHJcbiAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLmZyb21UaW1lc3RhbXAoZnJvbVRpbWVzdGFtcCh2ZXJzaW9uKSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SZXNvdXJjZU5hbWUoZGF0YWJhc2VJZCwgcGF0aCkge1xyXG4gICAgcmV0dXJuIGZ1bGx5UXVhbGlmaWVkUHJlZml4UGF0aChkYXRhYmFzZUlkKVxyXG4gICAgICAgIC5jaGlsZCgnZG9jdW1lbnRzJylcclxuICAgICAgICAuY2hpbGQocGF0aClcclxuICAgICAgICAuY2Fub25pY2FsU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVJlc291cmNlTmFtZShuYW1lKSB7XHJcbiAgICBjb25zdCByZXNvdXJjZSA9IFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKG5hbWUpO1xyXG4gICAgaGFyZEFzc2VydChpc1ZhbGlkUmVzb3VyY2VOYW1lKHJlc291cmNlKSk7XHJcbiAgICByZXR1cm4gcmVzb3VyY2U7XHJcbn1cclxuZnVuY3Rpb24gdG9OYW1lKHNlcmlhbGl6ZXIsIGtleSkge1xyXG4gICAgcmV0dXJuIHRvUmVzb3VyY2VOYW1lKHNlcmlhbGl6ZXIuZGF0YWJhc2VJZCwga2V5LnBhdGgpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21OYW1lKHNlcmlhbGl6ZXIsIG5hbWUpIHtcclxuICAgIGNvbnN0IHJlc291cmNlID0gZnJvbVJlc291cmNlTmFtZShuYW1lKTtcclxuICAgIGlmIChyZXNvdXJjZS5nZXQoMSkgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5wcm9qZWN0SWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnVHJpZWQgdG8gZGVzZXJpYWxpemUga2V5IGZyb20gZGlmZmVyZW50IHByb2plY3Q6ICcgK1xyXG4gICAgICAgICAgICByZXNvdXJjZS5nZXQoMSkgK1xyXG4gICAgICAgICAgICAnIHZzICcgK1xyXG4gICAgICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQucHJvamVjdElkKTtcclxuICAgIH1cclxuICAgIGlmIChyZXNvdXJjZS5nZXQoMykgIT09IHNlcmlhbGl6ZXIuZGF0YWJhc2VJZC5kYXRhYmFzZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUcmllZCB0byBkZXNlcmlhbGl6ZSBrZXkgZnJvbSBkaWZmZXJlbnQgZGF0YWJhc2U6ICcgK1xyXG4gICAgICAgICAgICByZXNvdXJjZS5nZXQoMykgK1xyXG4gICAgICAgICAgICAnIHZzICcgK1xyXG4gICAgICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQuZGF0YWJhc2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudEtleShleHRyYWN0TG9jYWxQYXRoRnJvbVJlc291cmNlTmFtZShyZXNvdXJjZSkpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUXVlcnlQYXRoKHNlcmlhbGl6ZXIsIHBhdGgpIHtcclxuICAgIHJldHVybiB0b1Jlc291cmNlTmFtZShzZXJpYWxpemVyLmRhdGFiYXNlSWQsIHBhdGgpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21RdWVyeVBhdGgobmFtZSkge1xyXG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gZnJvbVJlc291cmNlTmFtZShuYW1lKTtcclxuICAgIC8vIEluIHYxYmV0YTEgcXVlcmllcyBmb3IgY29sbGVjdGlvbnMgYXQgdGhlIHJvb3QgZGlkIG5vdCBoYXZlIGEgdHJhaWxpbmdcclxuICAgIC8vIFwiL2RvY3VtZW50c1wiLiBJbiB2MSBhbGwgcmVzb3VyY2UgcGF0aHMgY29udGFpbiBcIi9kb2N1bWVudHNcIi4gUHJlc2VydmUgdGhlXHJcbiAgICAvLyBhYmlsaXR5IHRvIHJlYWQgdGhlIHYxYmV0YTEgZm9ybSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHF1ZXJpZXMgcGVyc2lzdGVkXHJcbiAgICAvLyBpbiB0aGUgbG9jYWwgdGFyZ2V0IGNhY2hlLlxyXG4gICAgaWYgKHJlc291cmNlTmFtZS5sZW5ndGggPT09IDQpIHtcclxuICAgICAgICByZXR1cm4gUmVzb3VyY2VQYXRoLmVtcHR5UGF0aCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV4dHJhY3RMb2NhbFBhdGhGcm9tUmVzb3VyY2VOYW1lKHJlc291cmNlTmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RW5jb2RlZERhdGFiYXNlSWQoc2VyaWFsaXplcikge1xyXG4gICAgY29uc3QgcGF0aCA9IG5ldyBSZXNvdXJjZVBhdGgoW1xyXG4gICAgICAgICdwcm9qZWN0cycsXHJcbiAgICAgICAgc2VyaWFsaXplci5kYXRhYmFzZUlkLnByb2plY3RJZCxcclxuICAgICAgICAnZGF0YWJhc2VzJyxcclxuICAgICAgICBzZXJpYWxpemVyLmRhdGFiYXNlSWQuZGF0YWJhc2VcclxuICAgIF0pO1xyXG4gICAgcmV0dXJuIHBhdGguY2Fub25pY2FsU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gZnVsbHlRdWFsaWZpZWRQcmVmaXhQYXRoKGRhdGFiYXNlSWQpIHtcclxuICAgIHJldHVybiBuZXcgUmVzb3VyY2VQYXRoKFtcclxuICAgICAgICAncHJvamVjdHMnLFxyXG4gICAgICAgIGRhdGFiYXNlSWQucHJvamVjdElkLFxyXG4gICAgICAgICdkYXRhYmFzZXMnLFxyXG4gICAgICAgIGRhdGFiYXNlSWQuZGF0YWJhc2VcclxuICAgIF0pO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RMb2NhbFBhdGhGcm9tUmVzb3VyY2VOYW1lKHJlc291cmNlTmFtZSkge1xyXG4gICAgaGFyZEFzc2VydChyZXNvdXJjZU5hbWUubGVuZ3RoID4gNCAmJiByZXNvdXJjZU5hbWUuZ2V0KDQpID09PSAnZG9jdW1lbnRzJyk7XHJcbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lLnBvcEZpcnN0KDUpO1xyXG59XHJcbi8qKiBDcmVhdGVzIGEgRG9jdW1lbnQgcHJvdG8gZnJvbSBrZXkgYW5kIGZpZWxkcyAoYnV0IG5vIGNyZWF0ZS91cGRhdGUgdGltZSkgKi9cclxuZnVuY3Rpb24gdG9NdXRhdGlvbkRvY3VtZW50KHNlcmlhbGl6ZXIsIGtleSwgZmllbGRzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IHRvTmFtZShzZXJpYWxpemVyLCBrZXkpLFxyXG4gICAgICAgIGZpZWxkczogZmllbGRzLnZhbHVlLm1hcFZhbHVlLmZpZWxkc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b0RvY3VtZW50KHNlcmlhbGl6ZXIsIGRvY3VtZW50KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IHRvTmFtZShzZXJpYWxpemVyLCBkb2N1bWVudC5rZXkpLFxyXG4gICAgICAgIGZpZWxkczogZG9jdW1lbnQuZGF0YS52YWx1ZS5tYXBWYWx1ZS5maWVsZHMsXHJcbiAgICAgICAgdXBkYXRlVGltZTogdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgZG9jdW1lbnQudmVyc2lvbi50b1RpbWVzdGFtcCgpKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRG9jdW1lbnQoc2VyaWFsaXplciwgZG9jdW1lbnQsIGhhc0NvbW1pdHRlZE11dGF0aW9ucykge1xyXG4gICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jdW1lbnQubmFtZSk7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24oZG9jdW1lbnQudXBkYXRlVGltZSk7XHJcbiAgICBjb25zdCBkYXRhID0gbmV3IE9iamVjdFZhbHVlKHsgbWFwVmFsdWU6IHsgZmllbGRzOiBkb2N1bWVudC5maWVsZHMgfSB9KTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IE11dGFibGVEb2N1bWVudC5uZXdGb3VuZERvY3VtZW50KGtleSwgdmVyc2lvbiwgZGF0YSk7XHJcbiAgICBpZiAoaGFzQ29tbWl0dGVkTXV0YXRpb25zKSB7XHJcbiAgICAgICAgcmVzdWx0LnNldEhhc0NvbW1pdHRlZE11dGF0aW9ucygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhhc0NvbW1pdHRlZE11dGF0aW9ucyA/IHJlc3VsdC5zZXRIYXNDb21taXR0ZWRNdXRhdGlvbnMoKSA6IHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBmcm9tRm91bmQoc2VyaWFsaXplciwgZG9jKSB7XHJcbiAgICBoYXJkQXNzZXJ0KCEhZG9jLmZvdW5kKTtcclxuICAgIGFzc2VydFByZXNlbnQoZG9jLmZvdW5kLm5hbWUpO1xyXG4gICAgYXNzZXJ0UHJlc2VudChkb2MuZm91bmQudXBkYXRlVGltZSk7XHJcbiAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBkb2MuZm91bmQubmFtZSk7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24oZG9jLmZvdW5kLnVwZGF0ZVRpbWUpO1xyXG4gICAgY29uc3QgZGF0YSA9IG5ldyBPYmplY3RWYWx1ZSh7IG1hcFZhbHVlOiB7IGZpZWxkczogZG9jLmZvdW5kLmZpZWxkcyB9IH0pO1xyXG4gICAgcmV0dXJuIE11dGFibGVEb2N1bWVudC5uZXdGb3VuZERvY3VtZW50KGtleSwgdmVyc2lvbiwgZGF0YSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbU1pc3Npbmcoc2VyaWFsaXplciwgcmVzdWx0KSB7XHJcbiAgICBoYXJkQXNzZXJ0KCEhcmVzdWx0Lm1pc3NpbmcpO1xyXG4gICAgaGFyZEFzc2VydCghIXJlc3VsdC5yZWFkVGltZSk7XHJcbiAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCByZXN1bHQubWlzc2luZyk7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24ocmVzdWx0LnJlYWRUaW1lKTtcclxuICAgIHJldHVybiBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIHZlcnNpb24pO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21CYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlKHNlcmlhbGl6ZXIsIHJlc3VsdCkge1xyXG4gICAgaWYgKCdmb3VuZCcgaW4gcmVzdWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21Gb3VuZChzZXJpYWxpemVyLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ21pc3NpbmcnIGluIHJlc3VsdCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tTWlzc2luZyhzZXJpYWxpemVyLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhaWwoKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tV2F0Y2hDaGFuZ2Uoc2VyaWFsaXplciwgY2hhbmdlKSB7XHJcbiAgICBsZXQgd2F0Y2hDaGFuZ2U7XHJcbiAgICBpZiAoJ3RhcmdldENoYW5nZScgaW4gY2hhbmdlKSB7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UudGFyZ2V0Q2hhbmdlKTtcclxuICAgICAgICAvLyBwcm90bzMgZGVmYXVsdCB2YWx1ZSBpcyB1bnNldCBpbiBKU09OICh1bmRlZmluZWQpLCBzbyB1c2UgJ05PX0NIQU5HRSdcclxuICAgICAgICAvLyBpZiB1bnNldFxyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gZnJvbVdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUoY2hhbmdlLnRhcmdldENoYW5nZS50YXJnZXRDaGFuZ2VUeXBlIHx8ICdOT19DSEFOR0UnKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRJZHMgPSBjaGFuZ2UudGFyZ2V0Q2hhbmdlLnRhcmdldElkcyB8fCBbXTtcclxuICAgICAgICBjb25zdCByZXN1bWVUb2tlbiA9IGZyb21CeXRlcyhzZXJpYWxpemVyLCBjaGFuZ2UudGFyZ2V0Q2hhbmdlLnJlc3VtZVRva2VuKTtcclxuICAgICAgICBjb25zdCBjYXVzZVByb3RvID0gY2hhbmdlLnRhcmdldENoYW5nZS5jYXVzZTtcclxuICAgICAgICBjb25zdCBjYXVzZSA9IGNhdXNlUHJvdG8gJiYgZnJvbVJwY1N0YXR1cyhjYXVzZVByb3RvKTtcclxuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBXYXRjaFRhcmdldENoYW5nZShzdGF0ZSwgdGFyZ2V0SWRzLCByZXN1bWVUb2tlbiwgY2F1c2UgfHwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnZG9jdW1lbnRDaGFuZ2UnIGluIGNoYW5nZSkge1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoY2hhbmdlLmRvY3VtZW50Q2hhbmdlKTtcclxuICAgICAgICBjb25zdCBlbnRpdHlDaGFuZ2UgPSBjaGFuZ2UuZG9jdW1lbnRDaGFuZ2U7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChlbnRpdHlDaGFuZ2UuZG9jdW1lbnQpO1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50Lm5hbWUpO1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoZW50aXR5Q2hhbmdlLmRvY3VtZW50LnVwZGF0ZVRpbWUpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGZyb21OYW1lKHNlcmlhbGl6ZXIsIGVudGl0eUNoYW5nZS5kb2N1bWVudC5uYW1lKTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZnJvbVZlcnNpb24oZW50aXR5Q2hhbmdlLmRvY3VtZW50LnVwZGF0ZVRpbWUpO1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgT2JqZWN0VmFsdWUoe1xyXG4gICAgICAgICAgICBtYXBWYWx1ZTogeyBmaWVsZHM6IGVudGl0eUNoYW5nZS5kb2N1bWVudC5maWVsZHMgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGRvYyA9IE11dGFibGVEb2N1bWVudC5uZXdGb3VuZERvY3VtZW50KGtleSwgdmVyc2lvbiwgZGF0YSk7XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZFRhcmdldElkcyA9IGVudGl0eUNoYW5nZS50YXJnZXRJZHMgfHwgW107XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZFRhcmdldElkcyA9IGVudGl0eUNoYW5nZS5yZW1vdmVkVGFyZ2V0SWRzIHx8IFtdO1xyXG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IERvY3VtZW50V2F0Y2hDaGFuZ2UodXBkYXRlZFRhcmdldElkcywgcmVtb3ZlZFRhcmdldElkcywgZG9jLmtleSwgZG9jKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCdkb2N1bWVudERlbGV0ZScgaW4gY2hhbmdlKSB7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZG9jdW1lbnREZWxldGUpO1xyXG4gICAgICAgIGNvbnN0IGRvY0RlbGV0ZSA9IGNoYW5nZS5kb2N1bWVudERlbGV0ZTtcclxuICAgICAgICBhc3NlcnRQcmVzZW50KGRvY0RlbGV0ZS5kb2N1bWVudCk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgZG9jRGVsZXRlLmRvY3VtZW50KTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gZG9jRGVsZXRlLnJlYWRUaW1lXHJcbiAgICAgICAgICAgID8gZnJvbVZlcnNpb24oZG9jRGVsZXRlLnJlYWRUaW1lKVxyXG4gICAgICAgICAgICA6IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICBjb25zdCBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3Tm9Eb2N1bWVudChrZXksIHZlcnNpb24pO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBkb2NEZWxldGUucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcclxuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBEb2N1bWVudFdhdGNoQ2hhbmdlKFtdLCByZW1vdmVkVGFyZ2V0SWRzLCBkb2Mua2V5LCBkb2MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2RvY3VtZW50UmVtb3ZlJyBpbiBjaGFuZ2UpIHtcclxuICAgICAgICBhc3NlcnRQcmVzZW50KGNoYW5nZS5kb2N1bWVudFJlbW92ZSk7XHJcbiAgICAgICAgY29uc3QgZG9jUmVtb3ZlID0gY2hhbmdlLmRvY3VtZW50UmVtb3ZlO1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoZG9jUmVtb3ZlLmRvY3VtZW50KTtcclxuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBkb2NSZW1vdmUuZG9jdW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRUYXJnZXRJZHMgPSBkb2NSZW1vdmUucmVtb3ZlZFRhcmdldElkcyB8fCBbXTtcclxuICAgICAgICB3YXRjaENoYW5nZSA9IG5ldyBEb2N1bWVudFdhdGNoQ2hhbmdlKFtdLCByZW1vdmVkVGFyZ2V0SWRzLCBrZXksIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2ZpbHRlcicgaW4gY2hhbmdlKSB7XHJcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBpbXBsZW1lbnQgZXhpc3RlbmNlIGZpbHRlciBwYXJzaW5nIHdpdGggc3RyYXRlZ3kuXHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChjaGFuZ2UuZmlsdGVyKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBjaGFuZ2UuZmlsdGVyO1xyXG4gICAgICAgIGFzc2VydFByZXNlbnQoZmlsdGVyLnRhcmdldElkKTtcclxuICAgICAgICBjb25zdCBjb3VudCA9IGZpbHRlci5jb3VudCB8fCAwO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0ZW5jZUZpbHRlciA9IG5ldyBFeGlzdGVuY2VGaWx0ZXIoY291bnQpO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gZmlsdGVyLnRhcmdldElkO1xyXG4gICAgICAgIHdhdGNoQ2hhbmdlID0gbmV3IEV4aXN0ZW5jZUZpbHRlckNoYW5nZSh0YXJnZXRJZCwgZXhpc3RlbmNlRmlsdGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gd2F0Y2hDaGFuZ2U7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVdhdGNoVGFyZ2V0Q2hhbmdlU3RhdGUoc3RhdGUpIHtcclxuICAgIGlmIChzdGF0ZSA9PT0gJ05PX0NIQU5HRScpIHtcclxuICAgICAgICByZXR1cm4gMCAvKiBOb0NoYW5nZSAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnQUREJykge1xyXG4gICAgICAgIHJldHVybiAxIC8qIEFkZGVkICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdSRU1PVkUnKSB7XHJcbiAgICAgICAgcmV0dXJuIDIgLyogUmVtb3ZlZCAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN0YXRlID09PSAnQ1VSUkVOVCcpIHtcclxuICAgICAgICByZXR1cm4gMyAvKiBDdXJyZW50ICovO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3RhdGUgPT09ICdSRVNFVCcpIHtcclxuICAgICAgICByZXR1cm4gNCAvKiBSZXNldCAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmVyc2lvbkZyb21MaXN0ZW5SZXNwb25zZShjaGFuZ2UpIHtcclxuICAgIC8vIFdlIGhhdmUgb25seSByZWFjaGVkIGEgY29uc2lzdGVudCBzbmFwc2hvdCBmb3IgdGhlIGVudGlyZSBzdHJlYW0gaWYgdGhlcmVcclxuICAgIC8vIGlzIGEgcmVhZF90aW1lIHNldCBhbmQgaXQgYXBwbGllcyB0byBhbGwgdGFyZ2V0cyAoaS5lLiB0aGUgbGlzdCBvZlxyXG4gICAgLy8gdGFyZ2V0cyBpcyBlbXB0eSkuIFRoZSBiYWNrZW5kIGlzIGd1YXJhbnRlZWQgdG8gc2VuZCBzdWNoIHJlc3BvbnNlcy5cclxuICAgIGlmICghKCd0YXJnZXRDaGFuZ2UnIGluIGNoYW5nZSkpIHtcclxuICAgICAgICByZXR1cm4gU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFyZ2V0Q2hhbmdlID0gY2hhbmdlLnRhcmdldENoYW5nZTtcclxuICAgIGlmICh0YXJnZXRDaGFuZ2UudGFyZ2V0SWRzICYmIHRhcmdldENoYW5nZS50YXJnZXRJZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgIH1cclxuICAgIGlmICghdGFyZ2V0Q2hhbmdlLnJlYWRUaW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmcm9tVmVyc2lvbih0YXJnZXRDaGFuZ2UucmVhZFRpbWUpO1xyXG59XHJcbmZ1bmN0aW9uIHRvTXV0YXRpb24oc2VyaWFsaXplciwgbXV0YXRpb24pIHtcclxuICAgIGxldCByZXN1bHQ7XHJcbiAgICBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBTZXRNdXRhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdXBkYXRlOiB0b011dGF0aW9uRG9jdW1lbnQoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5LCBtdXRhdGlvbi52YWx1ZSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBEZWxldGVNdXRhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHsgZGVsZXRlOiB0b05hbWUoc2VyaWFsaXplciwgbXV0YXRpb24ua2V5KSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobXV0YXRpb24gaW5zdGFuY2VvZiBQYXRjaE11dGF0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB1cGRhdGU6IHRvTXV0YXRpb25Eb2N1bWVudChzZXJpYWxpemVyLCBtdXRhdGlvbi5rZXksIG11dGF0aW9uLmRhdGEpLFxyXG4gICAgICAgICAgICB1cGRhdGVNYXNrOiB0b0RvY3VtZW50TWFzayhtdXRhdGlvbi5maWVsZE1hc2spXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG11dGF0aW9uIGluc3RhbmNlb2YgVmVyaWZ5TXV0YXRpb24pIHtcclxuICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHZlcmlmeTogdG9OYW1lKHNlcmlhbGl6ZXIsIG11dGF0aW9uLmtleSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxuICAgIGlmIChtdXRhdGlvbi5maWVsZFRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJlc3VsdC51cGRhdGVUcmFuc2Zvcm1zID0gbXV0YXRpb24uZmllbGRUcmFuc2Zvcm1zLm1hcCh0cmFuc2Zvcm0gPT4gdG9GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCB0cmFuc2Zvcm0pKTtcclxuICAgIH1cclxuICAgIGlmICghbXV0YXRpb24ucHJlY29uZGl0aW9uLmlzTm9uZSkge1xyXG4gICAgICAgIHJlc3VsdC5jdXJyZW50RG9jdW1lbnQgPSB0b1ByZWNvbmRpdGlvbihzZXJpYWxpemVyLCBtdXRhdGlvbi5wcmVjb25kaXRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBmcm9tTXV0YXRpb24oc2VyaWFsaXplciwgcHJvdG8pIHtcclxuICAgIGNvbnN0IHByZWNvbmRpdGlvbiA9IHByb3RvLmN1cnJlbnREb2N1bWVudFxyXG4gICAgICAgID8gZnJvbVByZWNvbmRpdGlvbihwcm90by5jdXJyZW50RG9jdW1lbnQpXHJcbiAgICAgICAgOiBQcmVjb25kaXRpb24ubm9uZSgpO1xyXG4gICAgY29uc3QgZmllbGRUcmFuc2Zvcm1zID0gcHJvdG8udXBkYXRlVHJhbnNmb3Jtc1xyXG4gICAgICAgID8gcHJvdG8udXBkYXRlVHJhbnNmb3Jtcy5tYXAodHJhbnNmb3JtID0+IGZyb21GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCB0cmFuc2Zvcm0pKVxyXG4gICAgICAgIDogW107XHJcbiAgICBpZiAocHJvdG8udXBkYXRlKSB7XHJcbiAgICAgICAgYXNzZXJ0UHJlc2VudChwcm90by51cGRhdGUubmFtZSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgcHJvdG8udXBkYXRlLm5hbWUpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IE9iamVjdFZhbHVlKHtcclxuICAgICAgICAgICAgbWFwVmFsdWU6IHsgZmllbGRzOiBwcm90by51cGRhdGUuZmllbGRzIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAocHJvdG8udXBkYXRlTWFzaykge1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZE1hc2sgPSBmcm9tRG9jdW1lbnRNYXNrKHByb3RvLnVwZGF0ZU1hc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oa2V5LCB2YWx1ZSwgZmllbGRNYXNrLCBwcmVjb25kaXRpb24sIGZpZWxkVHJhbnNmb3Jtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldE11dGF0aW9uKGtleSwgdmFsdWUsIHByZWNvbmRpdGlvbiwgZmllbGRUcmFuc2Zvcm1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm90by5kZWxldGUpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBmcm9tTmFtZShzZXJpYWxpemVyLCBwcm90by5kZWxldGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVsZXRlTXV0YXRpb24oa2V5LCBwcmVjb25kaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvdG8udmVyaWZ5KSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZnJvbU5hbWUoc2VyaWFsaXplciwgcHJvdG8udmVyaWZ5KTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlcmlmeU11dGF0aW9uKGtleSwgcHJlY29uZGl0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9QcmVjb25kaXRpb24oc2VyaWFsaXplciwgcHJlY29uZGl0aW9uKSB7XHJcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVwZGF0ZVRpbWU6IHRvVmVyc2lvbihzZXJpYWxpemVyLCBwcmVjb25kaXRpb24udXBkYXRlVGltZSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJlY29uZGl0aW9uLmV4aXN0cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgZXhpc3RzOiBwcmVjb25kaXRpb24uZXhpc3RzIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZyb21QcmVjb25kaXRpb24ocHJlY29uZGl0aW9uKSB7XHJcbiAgICBpZiAocHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBQcmVjb25kaXRpb24udXBkYXRlVGltZShmcm9tVmVyc2lvbihwcmVjb25kaXRpb24udXBkYXRlVGltZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJlY29uZGl0aW9uLmV4aXN0cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHMocHJlY29uZGl0aW9uLmV4aXN0cyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLm5vbmUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tV3JpdGVSZXN1bHQocHJvdG8sIGNvbW1pdFRpbWUpIHtcclxuICAgIC8vIE5PVEU6IERlbGV0ZXMgZG9uJ3QgaGF2ZSBhbiB1cGRhdGVUaW1lLlxyXG4gICAgbGV0IHZlcnNpb24gPSBwcm90by51cGRhdGVUaW1lXHJcbiAgICAgICAgPyBmcm9tVmVyc2lvbihwcm90by51cGRhdGVUaW1lKVxyXG4gICAgICAgIDogZnJvbVZlcnNpb24oY29tbWl0VGltZSk7XHJcbiAgICBpZiAodmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcclxuICAgICAgICAvLyBUaGUgRmlyZXN0b3JlIEVtdWxhdG9yIGN1cnJlbnRseSByZXR1cm5zIGFuIHVwZGF0ZSB0aW1lIG9mIDAgZm9yXHJcbiAgICAgICAgLy8gZGVsZXRlcyBvZiBub24tZXhpc3RpbmcgZG9jdW1lbnRzIChyYXRoZXIgdGhhbiBudWxsKS4gVGhpcyBicmVha3MgdGhlXHJcbiAgICAgICAgLy8gdGVzdCBcImdldCBkZWxldGVkIGRvYyB3aGlsZSBvZmZsaW5lIHdpdGggc291cmNlPWNhY2hlXCIgYXMgTm9Eb2N1bWVudHNcclxuICAgICAgICAvLyB3aXRoIHZlcnNpb24gMCBhcmUgZmlsdGVyZWQgYnkgSW5kZXhlZERiJ3MgUmVtb3RlRG9jdW1lbnRDYWNoZS5cclxuICAgICAgICAvLyBUT0RPKCMyMTQ5KTogUmVtb3ZlIHRoaXMgd2hlbiBFbXVsYXRvciBpcyBmaXhlZFxyXG4gICAgICAgIHZlcnNpb24gPSBmcm9tVmVyc2lvbihjb21taXRUaW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTXV0YXRpb25SZXN1bHQodmVyc2lvbiwgcHJvdG8udHJhbnNmb3JtUmVzdWx0cyB8fCBbXSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVdyaXRlUmVzdWx0cyhwcm90b3MsIGNvbW1pdFRpbWUpIHtcclxuICAgIGlmIChwcm90b3MgJiYgcHJvdG9zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBoYXJkQXNzZXJ0KGNvbW1pdFRpbWUgIT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgcmV0dXJuIHByb3Rvcy5tYXAocHJvdG8gPT4gZnJvbVdyaXRlUmVzdWx0KHByb3RvLCBjb21taXRUaW1lKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCBmaWVsZFRyYW5zZm9ybSkge1xyXG4gICAgY29uc3QgdHJhbnNmb3JtID0gZmllbGRUcmFuc2Zvcm0udHJhbnNmb3JtO1xyXG4gICAgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHNldFRvU2VydmVyVmFsdWU6ICdSRVFVRVNUX1RJTUUnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybSBpbnN0YW5jZW9mIEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxyXG4gICAgICAgICAgICBhcHBlbmRNaXNzaW5nRWxlbWVudHM6IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlczogdHJhbnNmb3JtLmVsZW1lbnRzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmaWVsZFBhdGg6IGZpZWxkVHJhbnNmb3JtLmZpZWxkLmNhbm9uaWNhbFN0cmluZygpLFxyXG4gICAgICAgICAgICByZW1vdmVBbGxGcm9tQXJyYXk6IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlczogdHJhbnNmb3JtLmVsZW1lbnRzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJhbnNmb3JtIGluc3RhbmNlb2YgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpZWxkUGF0aDogZmllbGRUcmFuc2Zvcm0uZmllbGQuY2Fub25pY2FsU3RyaW5nKCksXHJcbiAgICAgICAgICAgIGluY3JlbWVudDogdHJhbnNmb3JtLm9wZXJhbmRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZyb21GaWVsZFRyYW5zZm9ybShzZXJpYWxpemVyLCBwcm90bykge1xyXG4gICAgbGV0IHRyYW5zZm9ybSA9IG51bGw7XHJcbiAgICBpZiAoJ3NldFRvU2VydmVyVmFsdWUnIGluIHByb3RvKSB7XHJcbiAgICAgICAgaGFyZEFzc2VydChwcm90by5zZXRUb1NlcnZlclZhbHVlID09PSAnUkVRVUVTVF9USU1FJyk7XHJcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IFNlcnZlclRpbWVzdGFtcFRyYW5zZm9ybSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJ2FwcGVuZE1pc3NpbmdFbGVtZW50cycgaW4gcHJvdG8pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBwcm90by5hcHBlbmRNaXNzaW5nRWxlbWVudHMudmFsdWVzIHx8IFtdO1xyXG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBBcnJheVVuaW9uVHJhbnNmb3JtT3BlcmF0aW9uKHZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgncmVtb3ZlQWxsRnJvbUFycmF5JyBpbiBwcm90bykge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByb3RvLnJlbW92ZUFsbEZyb21BcnJheS52YWx1ZXMgfHwgW107XHJcbiAgICAgICAgdHJhbnNmb3JtID0gbmV3IEFycmF5UmVtb3ZlVHJhbnNmb3JtT3BlcmF0aW9uKHZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgnaW5jcmVtZW50JyBpbiBwcm90bykge1xyXG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBOdW1lcmljSW5jcmVtZW50VHJhbnNmb3JtT3BlcmF0aW9uKHNlcmlhbGl6ZXIsIHByb3RvLmluY3JlbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWlsKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWVsZFBhdGggPSBGaWVsZFBhdGgkMS5mcm9tU2VydmVyRm9ybWF0KHByb3RvLmZpZWxkUGF0aCk7XHJcbiAgICByZXR1cm4gbmV3IEZpZWxkVHJhbnNmb3JtKGZpZWxkUGF0aCwgdHJhbnNmb3JtKTtcclxufVxyXG5mdW5jdGlvbiB0b0RvY3VtZW50c1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXQpIHtcclxuICAgIHJldHVybiB7IGRvY3VtZW50czogW3RvUXVlcnlQYXRoKHNlcmlhbGl6ZXIsIHRhcmdldC5wYXRoKV0gfTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRG9jdW1lbnRzVGFyZ2V0KGRvY3VtZW50c1RhcmdldCkge1xyXG4gICAgY29uc3QgY291bnQgPSBkb2N1bWVudHNUYXJnZXQuZG9jdW1lbnRzLmxlbmd0aDtcclxuICAgIGhhcmRBc3NlcnQoY291bnQgPT09IDEpO1xyXG4gICAgY29uc3QgbmFtZSA9IGRvY3VtZW50c1RhcmdldC5kb2N1bWVudHNbMF07XHJcbiAgICByZXR1cm4gcXVlcnlUb1RhcmdldChuZXdRdWVyeUZvclBhdGgoZnJvbVF1ZXJ5UGF0aChuYW1lKSkpO1xyXG59XHJcbmZ1bmN0aW9uIHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KSB7XHJcbiAgICAvLyBEaXNzZWN0IHRoZSBwYXRoIGludG8gcGFyZW50LCBjb2xsZWN0aW9uSWQsIGFuZCBvcHRpb25hbCBrZXkgZmlsdGVyLlxyXG4gICAgY29uc3QgcmVzdWx0ID0geyBzdHJ1Y3R1cmVkUXVlcnk6IHt9IH07XHJcbiAgICBjb25zdCBwYXRoID0gdGFyZ2V0LnBhdGg7XHJcbiAgICBpZiAodGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc3VsdC5wYXJlbnQgPSB0b1F1ZXJ5UGF0aChzZXJpYWxpemVyLCBwYXRoKTtcclxuICAgICAgICByZXN1bHQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZDogdGFyZ2V0LmNvbGxlY3Rpb25Hcm91cCxcclxuICAgICAgICAgICAgICAgIGFsbERlc2NlbmRhbnRzOiB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzdWx0LnBhcmVudCA9IHRvUXVlcnlQYXRoKHNlcmlhbGl6ZXIsIHBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICByZXN1bHQuc3RydWN0dXJlZFF1ZXJ5LmZyb20gPSBbeyBjb2xsZWN0aW9uSWQ6IHBhdGgubGFzdFNlZ21lbnQoKSB9XTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdoZXJlID0gdG9GaWx0ZXIodGFyZ2V0LmZpbHRlcnMpO1xyXG4gICAgaWYgKHdoZXJlKSB7XHJcbiAgICAgICAgcmVzdWx0LnN0cnVjdHVyZWRRdWVyeS53aGVyZSA9IHdoZXJlO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3JkZXJCeSA9IHRvT3JkZXIodGFyZ2V0Lm9yZGVyQnkpO1xyXG4gICAgaWYgKG9yZGVyQnkpIHtcclxuICAgICAgICByZXN1bHQuc3RydWN0dXJlZFF1ZXJ5Lm9yZGVyQnkgPSBvcmRlckJ5O1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGltaXQgPSB0b0ludDMyUHJvdG8oc2VyaWFsaXplciwgdGFyZ2V0LmxpbWl0KTtcclxuICAgIGlmIChsaW1pdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc3VsdC5zdHJ1Y3R1cmVkUXVlcnkubGltaXQgPSBsaW1pdDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuc3RhcnRBdCkge1xyXG4gICAgICAgIHJlc3VsdC5zdHJ1Y3R1cmVkUXVlcnkuc3RhcnRBdCA9IHRvU3RhcnRBdEN1cnNvcih0YXJnZXQuc3RhcnRBdCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGFyZ2V0LmVuZEF0KSB7XHJcbiAgICAgICAgcmVzdWx0LnN0cnVjdHVyZWRRdWVyeS5lbmRBdCA9IHRvRW5kQXRDdXJzb3IodGFyZ2V0LmVuZEF0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY29udmVydFF1ZXJ5VGFyZ2V0VG9RdWVyeSh0YXJnZXQpIHtcclxuICAgIGxldCBwYXRoID0gZnJvbVF1ZXJ5UGF0aCh0YXJnZXQucGFyZW50KTtcclxuICAgIGNvbnN0IHF1ZXJ5ID0gdGFyZ2V0LnN0cnVjdHVyZWRRdWVyeTtcclxuICAgIGNvbnN0IGZyb21Db3VudCA9IHF1ZXJ5LmZyb20gPyBxdWVyeS5mcm9tLmxlbmd0aCA6IDA7XHJcbiAgICBsZXQgY29sbGVjdGlvbkdyb3VwID0gbnVsbDtcclxuICAgIGlmIChmcm9tQ291bnQgPiAwKSB7XHJcbiAgICAgICAgaGFyZEFzc2VydChmcm9tQ291bnQgPT09IDEpO1xyXG4gICAgICAgIGNvbnN0IGZyb20gPSBxdWVyeS5mcm9tWzBdO1xyXG4gICAgICAgIGlmIChmcm9tLmFsbERlc2NlbmRhbnRzKSB7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25Hcm91cCA9IGZyb20uY29sbGVjdGlvbklkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGguY2hpbGQoZnJvbS5jb2xsZWN0aW9uSWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBmaWx0ZXJCeSA9IFtdO1xyXG4gICAgaWYgKHF1ZXJ5LndoZXJlKSB7XHJcbiAgICAgICAgZmlsdGVyQnkgPSBmcm9tRmlsdGVyKHF1ZXJ5LndoZXJlKTtcclxuICAgIH1cclxuICAgIGxldCBvcmRlckJ5ID0gW107XHJcbiAgICBpZiAocXVlcnkub3JkZXJCeSkge1xyXG4gICAgICAgIG9yZGVyQnkgPSBmcm9tT3JkZXIocXVlcnkub3JkZXJCeSk7XHJcbiAgICB9XHJcbiAgICBsZXQgbGltaXQgPSBudWxsO1xyXG4gICAgaWYgKHF1ZXJ5LmxpbWl0KSB7XHJcbiAgICAgICAgbGltaXQgPSBmcm9tSW50MzJQcm90byhxdWVyeS5saW1pdCk7XHJcbiAgICB9XHJcbiAgICBsZXQgc3RhcnRBdCA9IG51bGw7XHJcbiAgICBpZiAocXVlcnkuc3RhcnRBdCkge1xyXG4gICAgICAgIHN0YXJ0QXQgPSBmcm9tU3RhcnRBdEN1cnNvcihxdWVyeS5zdGFydEF0KTtcclxuICAgIH1cclxuICAgIGxldCBlbmRBdCA9IG51bGw7XHJcbiAgICBpZiAocXVlcnkuZW5kQXQpIHtcclxuICAgICAgICBlbmRBdCA9IGZyb21FbmRBdEN1cnNvcihxdWVyeS5lbmRBdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3UXVlcnkocGF0aCwgY29sbGVjdGlvbkdyb3VwLCBvcmRlckJ5LCBmaWx0ZXJCeSwgbGltaXQsIFwiRlwiIC8qIEZpcnN0ICovLCBzdGFydEF0LCBlbmRBdCk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVF1ZXJ5VGFyZ2V0KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIHF1ZXJ5VG9UYXJnZXQoY29udmVydFF1ZXJ5VGFyZ2V0VG9RdWVyeSh0YXJnZXQpKTtcclxufVxyXG5mdW5jdGlvbiB0b0xpc3RlblJlcXVlc3RMYWJlbHMoc2VyaWFsaXplciwgdGFyZ2V0RGF0YSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSB0b0xhYmVsKHNlcmlhbGl6ZXIsIHRhcmdldERhdGEucHVycG9zZSk7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgJ2dvb2ctbGlzdGVuLXRhZ3MnOiB2YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9MYWJlbChzZXJpYWxpemVyLCBwdXJwb3NlKSB7XHJcbiAgICBzd2l0Y2ggKHB1cnBvc2UpIHtcclxuICAgICAgICBjYXNlIDAgLyogTGlzdGVuICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBjYXNlIDEgLyogRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2ggKi86XHJcbiAgICAgICAgICAgIHJldHVybiAnZXhpc3RlbmNlLWZpbHRlci1taXNtYXRjaCc7XHJcbiAgICAgICAgY2FzZSAyIC8qIExpbWJvUmVzb2x1dGlvbiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuICdsaW1iby1kb2N1bWVudCc7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1RhcmdldChzZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XHJcbiAgICBsZXQgcmVzdWx0O1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0RGF0YS50YXJnZXQ7XHJcbiAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0geyBkb2N1bWVudHM6IHRvRG9jdW1lbnRzVGFyZ2V0KHNlcmlhbGl6ZXIsIHRhcmdldCkgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IHsgcXVlcnk6IHRvUXVlcnlUYXJnZXQoc2VyaWFsaXplciwgdGFyZ2V0KSB9O1xyXG4gICAgfVxyXG4gICAgcmVzdWx0LnRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcclxuICAgIGlmICh0YXJnZXREYXRhLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcclxuICAgICAgICByZXN1bHQucmVzdW1lVG9rZW4gPSB0b0J5dGVzKHNlcmlhbGl6ZXIsIHRhcmdldERhdGEucmVzdW1lVG9rZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKFNuYXBzaG90VmVyc2lvbi5taW4oKSkgPiAwKSB7XHJcbiAgICAgICAgLy8gVE9ETyh3dWFuZHkpOiBDb25zaWRlciByZW1vdmluZyBhYm92ZSBjaGVjayBiZWNhdXNlIGl0IGlzIG1vc3QgbGlrZWx5IHRydWUuXHJcbiAgICAgICAgLy8gUmlnaHQgbm93LCBtYW55IHRlc3RzIGRlcGVuZCBvbiB0aGlzIGJlaGF2aW91ciB0aG91Z2ggKGxlYXZpbmcgbWluKCkgb3V0XHJcbiAgICAgICAgLy8gb2Ygc2VyaWFsaXphdGlvbikuXHJcbiAgICAgICAgcmVzdWx0LnJlYWRUaW1lID0gdG9UaW1lc3RhbXAoc2VyaWFsaXplciwgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHRvRmlsdGVyKGZpbHRlcnMpIHtcclxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHByb3RvcyA9IGZpbHRlcnMubWFwKGZpbHRlciA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHRvVW5hcnlPckZpZWxkRmlsdGVyKGZpbHRlcik7XHJcbiAgICB9KTtcclxuICAgIGlmIChwcm90b3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3Rvc1swXTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IGNvbXBvc2l0ZUZpbHRlcjogeyBvcDogJ0FORCcsIGZpbHRlcnM6IHByb3RvcyB9IH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbUZpbHRlcihmaWx0ZXIpIHtcclxuICAgIGlmICghZmlsdGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmlsdGVyLnVuYXJ5RmlsdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gW2Zyb21VbmFyeUZpbHRlcihmaWx0ZXIpXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZpbHRlci5maWVsZEZpbHRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIFtmcm9tRmllbGRGaWx0ZXIoZmlsdGVyKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmaWx0ZXIuY29tcG9zaXRlRmlsdGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gZmlsdGVyLmNvbXBvc2l0ZUZpbHRlclxyXG4gICAgICAgICAgICAuZmlsdGVycy5tYXAoZiA9PiBmcm9tRmlsdGVyKGYpKVxyXG4gICAgICAgICAgICAucmVkdWNlKChhY2N1bSwgY3VycmVudCkgPT4gYWNjdW0uY29uY2F0KGN1cnJlbnQpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9PcmRlcihvcmRlckJ5cykge1xyXG4gICAgaWYgKG9yZGVyQnlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJldHVybiBvcmRlckJ5cy5tYXAob3JkZXIgPT4gdG9Qcm9wZXJ0eU9yZGVyKG9yZGVyKSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbU9yZGVyKG9yZGVyQnlzKSB7XHJcbiAgICByZXR1cm4gb3JkZXJCeXMubWFwKG9yZGVyID0+IGZyb21Qcm9wZXJ0eU9yZGVyKG9yZGVyKSk7XHJcbn1cclxuZnVuY3Rpb24gdG9TdGFydEF0Q3Vyc29yKGN1cnNvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBiZWZvcmU6IGN1cnNvci5pbmNsdXNpdmUsXHJcbiAgICAgICAgdmFsdWVzOiBjdXJzb3IucG9zaXRpb25cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdG9FbmRBdEN1cnNvcihjdXJzb3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYmVmb3JlOiAhY3Vyc29yLmluY2x1c2l2ZSxcclxuICAgICAgICB2YWx1ZXM6IGN1cnNvci5wb3NpdGlvblxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBmcm9tU3RhcnRBdEN1cnNvcihjdXJzb3IpIHtcclxuICAgIGNvbnN0IGluY2x1c2l2ZSA9ICEhY3Vyc29yLmJlZm9yZTtcclxuICAgIGNvbnN0IHBvc2l0aW9uID0gY3Vyc29yLnZhbHVlcyB8fCBbXTtcclxuICAgIHJldHVybiBuZXcgQm91bmQocG9zaXRpb24sIGluY2x1c2l2ZSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbUVuZEF0Q3Vyc29yKGN1cnNvcikge1xyXG4gICAgY29uc3QgaW5jbHVzaXZlID0gIWN1cnNvci5iZWZvcmU7XHJcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnNvci52YWx1ZXMgfHwgW107XHJcbiAgICByZXR1cm4gbmV3IEJvdW5kKHBvc2l0aW9uLCBpbmNsdXNpdmUpO1xyXG59XHJcbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcclxuZnVuY3Rpb24gdG9EaXJlY3Rpb24oZGlyKSB7XHJcbiAgICByZXR1cm4gRElSRUNUSU9OU1tkaXJdO1xyXG59XHJcbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcclxuZnVuY3Rpb24gZnJvbURpcmVjdGlvbihkaXIpIHtcclxuICAgIHN3aXRjaCAoZGlyKSB7XHJcbiAgICAgICAgY2FzZSAnQVNDRU5ESU5HJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiYXNjXCIgLyogQVNDRU5ESU5HICovO1xyXG4gICAgICAgIGNhc2UgJ0RFU0NFTkRJTkcnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJkZXNjXCIgLyogREVTQ0VORElORyAqLztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcclxuZnVuY3Rpb24gdG9PcGVyYXRvck5hbWUob3ApIHtcclxuICAgIHJldHVybiBPUEVSQVRPUlNbb3BdO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21PcGVyYXRvck5hbWUob3ApIHtcclxuICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICBjYXNlICdFUVVBTCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIj09XCIgLyogRVFVQUwgKi87XHJcbiAgICAgICAgY2FzZSAnTk9UX0VRVUFMJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiIT1cIiAvKiBOT1RfRVFVQUwgKi87XHJcbiAgICAgICAgY2FzZSAnR1JFQVRFUl9USEFOJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiPlwiIC8qIEdSRUFURVJfVEhBTiAqLztcclxuICAgICAgICBjYXNlICdHUkVBVEVSX1RIQU5fT1JfRVFVQUwnOlxyXG4gICAgICAgICAgICByZXR1cm4gXCI+PVwiIC8qIEdSRUFURVJfVEhBTl9PUl9FUVVBTCAqLztcclxuICAgICAgICBjYXNlICdMRVNTX1RIQU4nOlxyXG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgLyogTEVTU19USEFOICovO1xyXG4gICAgICAgIGNhc2UgJ0xFU1NfVEhBTl9PUl9FUVVBTCc6XHJcbiAgICAgICAgICAgIHJldHVybiBcIjw9XCIgLyogTEVTU19USEFOX09SX0VRVUFMICovO1xyXG4gICAgICAgIGNhc2UgJ0FSUkFZX0NPTlRBSU5TJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXktY29udGFpbnNcIiAvKiBBUlJBWV9DT05UQUlOUyAqLztcclxuICAgICAgICBjYXNlICdJTic6XHJcbiAgICAgICAgICAgIHJldHVybiBcImluXCIgLyogSU4gKi87XHJcbiAgICAgICAgY2FzZSAnTk9UX0lOJzpcclxuICAgICAgICAgICAgcmV0dXJuIFwibm90LWluXCIgLyogTk9UX0lOICovO1xyXG4gICAgICAgIGNhc2UgJ0FSUkFZX0NPTlRBSU5TX0FOWSc6XHJcbiAgICAgICAgICAgIHJldHVybiBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIEFSUkFZX0NPTlRBSU5TX0FOWSAqLztcclxuICAgICAgICBjYXNlICdPUEVSQVRPUl9VTlNQRUNJRklFRCc6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShwYXRoKSB7XHJcbiAgICByZXR1cm4geyBmaWVsZFBhdGg6IHBhdGguY2Fub25pY2FsU3RyaW5nKCkgfTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpZWxkUmVmZXJlbmNlKSB7XHJcbiAgICByZXR1cm4gRmllbGRQYXRoJDEuZnJvbVNlcnZlckZvcm1hdChmaWVsZFJlZmVyZW5jZS5maWVsZFBhdGgpO1xyXG59XHJcbi8vIHZpc2libGUgZm9yIHRlc3RpbmdcclxuZnVuY3Rpb24gdG9Qcm9wZXJ0eU9yZGVyKG9yZGVyQnkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKG9yZGVyQnkuZmllbGQpLFxyXG4gICAgICAgIGRpcmVjdGlvbjogdG9EaXJlY3Rpb24ob3JkZXJCeS5kaXIpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21Qcm9wZXJ0eU9yZGVyKG9yZGVyQnkpIHtcclxuICAgIHJldHVybiBuZXcgT3JkZXJCeShmcm9tRmllbGRQYXRoUmVmZXJlbmNlKG9yZGVyQnkuZmllbGQpLCBmcm9tRGlyZWN0aW9uKG9yZGVyQnkuZGlyZWN0aW9uKSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbUZpZWxkRmlsdGVyKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZEZpbHRlci5maWVsZCksIGZyb21PcGVyYXRvck5hbWUoZmlsdGVyLmZpZWxkRmlsdGVyLm9wKSwgZmlsdGVyLmZpZWxkRmlsdGVyLnZhbHVlKTtcclxufVxyXG4vLyB2aXNpYmxlIGZvciB0ZXN0aW5nXHJcbmZ1bmN0aW9uIHRvVW5hcnlPckZpZWxkRmlsdGVyKGZpbHRlcikge1xyXG4gICAgaWYgKGZpbHRlci5vcCA9PT0gXCI9PVwiIC8qIEVRVUFMICovKSB7XHJcbiAgICAgICAgaWYgKGlzTmFuVmFsdWUoZmlsdGVyLnZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkKSxcclxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05BTidcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNOdWxsVmFsdWUoZmlsdGVyLnZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkKSxcclxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05VTEwnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmlsdGVyLm9wID09PSBcIiE9XCIgLyogTk9UX0VRVUFMICovKSB7XHJcbiAgICAgICAgaWYgKGlzTmFuVmFsdWUoZmlsdGVyLnZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdW5hcnlGaWx0ZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogdG9GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLmZpZWxkKSxcclxuICAgICAgICAgICAgICAgICAgICBvcDogJ0lTX05PVF9OQU4nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbFZhbHVlKGZpbHRlci52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVuYXJ5RmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRvRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci5maWVsZCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdJU19OT1RfTlVMTCdcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZpZWxkRmlsdGVyOiB7XHJcbiAgICAgICAgICAgIGZpZWxkOiB0b0ZpZWxkUGF0aFJlZmVyZW5jZShmaWx0ZXIuZmllbGQpLFxyXG4gICAgICAgICAgICBvcDogdG9PcGVyYXRvck5hbWUoZmlsdGVyLm9wKSxcclxuICAgICAgICAgICAgdmFsdWU6IGZpbHRlci52YWx1ZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbVVuYXJ5RmlsdGVyKGZpbHRlcikge1xyXG4gICAgc3dpdGNoIChmaWx0ZXIudW5hcnlGaWx0ZXIub3ApIHtcclxuICAgICAgICBjYXNlICdJU19OQU4nOlxyXG4gICAgICAgICAgICBjb25zdCBuYW5GaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcclxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShuYW5GaWVsZCwgXCI9PVwiIC8qIEVRVUFMICovLCB7XHJcbiAgICAgICAgICAgICAgICBkb3VibGVWYWx1ZTogTmFOXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2UgJ0lTX05VTEwnOlxyXG4gICAgICAgICAgICBjb25zdCBudWxsRmllbGQgPSBmcm9tRmllbGRQYXRoUmVmZXJlbmNlKGZpbHRlci51bmFyeUZpbHRlci5maWVsZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBGaWVsZEZpbHRlci5jcmVhdGUobnVsbEZpZWxkLCBcIj09XCIgLyogRVFVQUwgKi8sIHtcclxuICAgICAgICAgICAgICAgIG51bGxWYWx1ZTogJ05VTExfVkFMVUUnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2UgJ0lTX05PVF9OQU4nOlxyXG4gICAgICAgICAgICBjb25zdCBub3ROYW5GaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcclxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShub3ROYW5GaWVsZCwgXCIhPVwiIC8qIE5PVF9FUVVBTCAqLywge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlVmFsdWU6IE5hTlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlICdJU19OT1RfTlVMTCc6XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdE51bGxGaWVsZCA9IGZyb21GaWVsZFBhdGhSZWZlcmVuY2UoZmlsdGVyLnVuYXJ5RmlsdGVyLmZpZWxkKTtcclxuICAgICAgICAgICAgcmV0dXJuIEZpZWxkRmlsdGVyLmNyZWF0ZShub3ROdWxsRmllbGQsIFwiIT1cIiAvKiBOT1RfRVFVQUwgKi8sIHtcclxuICAgICAgICAgICAgICAgIG51bGxWYWx1ZTogJ05VTExfVkFMVUUnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNhc2UgJ09QRVJBVE9SX1VOU1BFQ0lGSUVEJzpcclxuICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvRG9jdW1lbnRNYXNrKGZpZWxkTWFzaykge1xyXG4gICAgY29uc3QgY2Fub25pY2FsRmllbGRzID0gW107XHJcbiAgICBmaWVsZE1hc2suZmllbGRzLmZvckVhY2goZmllbGQgPT4gY2Fub25pY2FsRmllbGRzLnB1c2goZmllbGQuY2Fub25pY2FsU3RyaW5nKCkpKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmllbGRQYXRoczogY2Fub25pY2FsRmllbGRzXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21Eb2N1bWVudE1hc2socHJvdG8pIHtcclxuICAgIGNvbnN0IHBhdGhzID0gcHJvdG8uZmllbGRQYXRocyB8fCBbXTtcclxuICAgIHJldHVybiBuZXcgRmllbGRNYXNrKHBhdGhzLm1hcChwYXRoID0+IEZpZWxkUGF0aCQxLmZyb21TZXJ2ZXJGb3JtYXQocGF0aCkpKTtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkUmVzb3VyY2VOYW1lKHBhdGgpIHtcclxuICAgIC8vIFJlc291cmNlIG5hbWVzIGhhdmUgYXQgbGVhc3QgNCBjb21wb25lbnRzIChwcm9qZWN0IElELCBkYXRhYmFzZSBJRClcclxuICAgIHJldHVybiAocGF0aC5sZW5ndGggPj0gNCAmJlxyXG4gICAgICAgIHBhdGguZ2V0KDApID09PSAncHJvamVjdHMnICYmXHJcbiAgICAgICAgcGF0aC5nZXQoMikgPT09ICdkYXRhYmFzZXMnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIHNldCBvZiBtZXRhZGF0YSB0aGF0IHRoZSBsb2NhbCBzdG9yZSB0cmFja3MgZm9yIGVhY2ggdGFyZ2V0LlxyXG4gKi9cclxuY2xhc3MgVGFyZ2V0RGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgdGFyZ2V0IGJlaW5nIGxpc3RlbmVkIHRvLiAqL1xyXG4gICAgdGFyZ2V0LCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRhcmdldCBJRCB0byB3aGljaCB0aGUgdGFyZ2V0IGNvcnJlc3BvbmRzOyBBc3NpZ25lZCBieSB0aGVcclxuICAgICAqIExvY2FsU3RvcmUgZm9yIHVzZXIgbGlzdGVucyBhbmQgYnkgdGhlIFN5bmNFbmdpbmUgZm9yIGxpbWJvIHdhdGNoZXMuXHJcbiAgICAgKi9cclxuICAgIHRhcmdldElkLCBcclxuICAgIC8qKiBUaGUgcHVycG9zZSBvZiB0aGUgdGFyZ2V0LiAqL1xyXG4gICAgcHVycG9zZSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIGxhc3QgdHJhbnNhY3Rpb24gZHVyaW5nIHdoaWNoIHRoaXMgdGFyZ2V0IGRhdGFcclxuICAgICAqIHdhcyBtb2RpZmllZC5cclxuICAgICAqL1xyXG4gICAgc2VxdWVuY2VOdW1iZXIsIFxyXG4gICAgLyoqIFRoZSBsYXRlc3Qgc25hcHNob3QgdmVyc2lvbiBzZWVuIGZvciB0aGlzIHRhcmdldC4gKi9cclxuICAgIHNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIHNuYXBzaG90IHZlcnNpb24gYXQgd2hpY2ggdGhlIGFzc29jaWF0ZWQgdmlld1xyXG4gICAgICogY29udGFpbmVkIG5vIGxpbWJvIGRvY3VtZW50cy5cclxuICAgICAqL1xyXG4gICAgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKSwgXHJcbiAgICAvKipcclxuICAgICAqIEFuIG9wYXF1ZSwgc2VydmVyLWFzc2lnbmVkIHRva2VuIHRoYXQgYWxsb3dzIHdhdGNoaW5nIGEgdGFyZ2V0IHRvIGJlXHJcbiAgICAgKiByZXN1bWVkIGFmdGVyIGRpc2Nvbm5lY3Rpbmcgd2l0aG91dCByZXRyYW5zbWl0dGluZyBhbGwgdGhlIGRhdGEgdGhhdFxyXG4gICAgICogbWF0Y2hlcyB0aGUgdGFyZ2V0LiBUaGUgcmVzdW1lIHRva2VuIGVzc2VudGlhbGx5IGlkZW50aWZpZXMgYSBwb2ludCBpblxyXG4gICAgICogdGltZSBmcm9tIHdoaWNoIHRoZSBzZXJ2ZXIgc2hvdWxkIHJlc3VtZSBzZW5kaW5nIHJlc3VsdHMuXHJcbiAgICAgKi9cclxuICAgIHJlc3VtZVRva2VuID0gQnl0ZVN0cmluZy5FTVBUWV9CWVRFX1NUUklORykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLnB1cnBvc2UgPSBwdXJwb3NlO1xyXG4gICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcclxuICAgICAgICB0aGlzLnNuYXBzaG90VmVyc2lvbiA9IHNuYXBzaG90VmVyc2lvbjtcclxuICAgICAgICB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgIHRoaXMucmVzdW1lVG9rZW4gPSByZXN1bWVUb2tlbjtcclxuICAgIH1cclxuICAgIC8qKiBDcmVhdGVzIGEgbmV3IHRhcmdldCBkYXRhIGluc3RhbmNlIHdpdGggYW4gdXBkYXRlZCBzZXF1ZW5jZSBudW1iZXIuICovXHJcbiAgICB3aXRoU2VxdWVuY2VOdW1iZXIoc2VxdWVuY2VOdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldERhdGEodGhpcy50YXJnZXQsIHRoaXMudGFyZ2V0SWQsIHRoaXMucHVycG9zZSwgc2VxdWVuY2VOdW1iZXIsIHRoaXMuc25hcHNob3RWZXJzaW9uLCB0aGlzLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIHRoaXMucmVzdW1lVG9rZW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRhcmdldCBkYXRhIGluc3RhbmNlIHdpdGggYW4gdXBkYXRlZCByZXN1bWUgdG9rZW4gYW5kXHJcbiAgICAgKiBzbmFwc2hvdCB2ZXJzaW9uLlxyXG4gICAgICovXHJcbiAgICB3aXRoUmVzdW1lVG9rZW4ocmVzdW1lVG9rZW4sIHNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0RGF0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXRJZCwgdGhpcy5wdXJwb3NlLCB0aGlzLnNlcXVlbmNlTnVtYmVyLCBzbmFwc2hvdFZlcnNpb24sIHRoaXMubGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiwgcmVzdW1lVG9rZW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRhcmdldCBkYXRhIGluc3RhbmNlIHdpdGggYW4gdXBkYXRlZCBsYXN0IGxpbWJvIGZyZWVcclxuICAgICAqIHNuYXBzaG90IHZlcnNpb24gbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICB3aXRoTGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbihsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXREYXRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldElkLCB0aGlzLnB1cnBvc2UsIHRoaXMuc2VxdWVuY2VOdW1iZXIsIHRoaXMuc25hcHNob3RWZXJzaW9uLCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCB0aGlzLnJlc3VtZVRva2VuKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogU2VyaWFsaXplciBmb3IgdmFsdWVzIHN0b3JlZCBpbiB0aGUgTG9jYWxTdG9yZS4gKi9cclxuY2xhc3MgTG9jYWxTZXJpYWxpemVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbW90ZVNlcmlhbGl6ZXIpIHtcclxuICAgICAgICB0aGlzLnJlbW90ZVNlcmlhbGl6ZXIgPSByZW1vdGVTZXJpYWxpemVyO1xyXG4gICAgfVxyXG59XHJcbi8qKiBEZWNvZGVzIGEgcmVtb3RlIGRvY3VtZW50IGZyb20gc3RvcmFnZSBsb2NhbGx5IHRvIGEgRG9jdW1lbnQuICovXHJcbmZ1bmN0aW9uIGZyb21EYlJlbW90ZURvY3VtZW50KGxvY2FsU2VyaWFsaXplciwgcmVtb3RlRG9jKSB7XHJcbiAgICBsZXQgZG9jO1xyXG4gICAgaWYgKHJlbW90ZURvYy5kb2N1bWVudCkge1xyXG4gICAgICAgIGRvYyA9IGZyb21Eb2N1bWVudChsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgcmVtb3RlRG9jLmRvY3VtZW50LCAhIXJlbW90ZURvYy5oYXNDb21taXR0ZWRNdXRhdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVtb3RlRG9jLm5vRG9jdW1lbnQpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tU2VnbWVudHMocmVtb3RlRG9jLm5vRG9jdW1lbnQucGF0aCk7XHJcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGZyb21EYlRpbWVzdGFtcChyZW1vdGVEb2Mubm9Eb2N1bWVudC5yZWFkVGltZSk7XHJcbiAgICAgICAgZG9jID0gTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQoa2V5LCB2ZXJzaW9uKTtcclxuICAgICAgICBpZiAocmVtb3RlRG9jLmhhc0NvbW1pdHRlZE11dGF0aW9ucykge1xyXG4gICAgICAgICAgICBkb2Muc2V0SGFzQ29tbWl0dGVkTXV0YXRpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhyZW1vdGVEb2MudW5rbm93bkRvY3VtZW50LnBhdGgpO1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBmcm9tRGJUaW1lc3RhbXAocmVtb3RlRG9jLnVua25vd25Eb2N1bWVudC52ZXJzaW9uKTtcclxuICAgICAgICBkb2MgPSBNdXRhYmxlRG9jdW1lbnQubmV3VW5rbm93bkRvY3VtZW50KGtleSwgdmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFpbCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlbW90ZURvYy5yZWFkVGltZSkge1xyXG4gICAgICAgIGRvYy5zZXRSZWFkVGltZShmcm9tRGJUaW1lc3RhbXBLZXkocmVtb3RlRG9jLnJlYWRUaW1lKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9jO1xyXG59XHJcbi8qKiBFbmNvZGVzIGEgZG9jdW1lbnQgZm9yIHN0b3JhZ2UgbG9jYWxseS4gKi9cclxuZnVuY3Rpb24gdG9EYlJlbW90ZURvY3VtZW50KGxvY2FsU2VyaWFsaXplciwgZG9jdW1lbnQpIHtcclxuICAgIGNvbnN0IGRiUmVhZFRpbWUgPSB0b0RiVGltZXN0YW1wS2V5KGRvY3VtZW50LnJlYWRUaW1lKTtcclxuICAgIGNvbnN0IHBhcmVudFBhdGggPSBkb2N1bWVudC5rZXkucGF0aC5wb3BMYXN0KCkudG9BcnJheSgpO1xyXG4gICAgaWYgKGRvY3VtZW50LmlzRm91bmREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgY29uc3QgZG9jID0gdG9Eb2N1bWVudChsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgZG9jdW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IGhhc0NvbW1pdHRlZE11dGF0aW9ucyA9IGRvY3VtZW50Lmhhc0NvbW1pdHRlZE11dGF0aW9ucztcclxuICAgICAgICByZXR1cm4gbmV3IERiUmVtb3RlRG9jdW1lbnQoXHJcbiAgICAgICAgLyogdW5rbm93bkRvY3VtZW50PSAqLyBudWxsLCBcclxuICAgICAgICAvKiBub0RvY3VtZW50PSAqLyBudWxsLCBkb2MsIGhhc0NvbW1pdHRlZE11dGF0aW9ucywgZGJSZWFkVGltZSwgcGFyZW50UGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkb2N1bWVudC5pc05vRG9jdW1lbnQoKSkge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBkb2N1bWVudC5rZXkucGF0aC50b0FycmF5KCk7XHJcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRvRGJUaW1lc3RhbXAoZG9jdW1lbnQudmVyc2lvbik7XHJcbiAgICAgICAgY29uc3QgaGFzQ29tbWl0dGVkTXV0YXRpb25zID0gZG9jdW1lbnQuaGFzQ29tbWl0dGVkTXV0YXRpb25zO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGJSZW1vdGVEb2N1bWVudChcclxuICAgICAgICAvKiB1bmtub3duRG9jdW1lbnQ9ICovIG51bGwsIG5ldyBEYk5vRG9jdW1lbnQocGF0aCwgdmVyc2lvbiksIFxyXG4gICAgICAgIC8qIGRvY3VtZW50PSAqLyBudWxsLCBoYXNDb21taXR0ZWRNdXRhdGlvbnMsIGRiUmVhZFRpbWUsIHBhcmVudFBhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZG9jdW1lbnQuaXNVbmtub3duRG9jdW1lbnQoKSkge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBkb2N1bWVudC5rZXkucGF0aC50b0FycmF5KCk7XHJcbiAgICAgICAgY29uc3QgcmVhZFRpbWUgPSB0b0RiVGltZXN0YW1wKGRvY3VtZW50LnZlcnNpb24pO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGJSZW1vdGVEb2N1bWVudChuZXcgRGJVbmtub3duRG9jdW1lbnQocGF0aCwgcmVhZFRpbWUpLCBcclxuICAgICAgICAvKiBub0RvY3VtZW50PSAqLyBudWxsLCBcclxuICAgICAgICAvKiBkb2N1bWVudD0gKi8gbnVsbCwgXHJcbiAgICAgICAgLyogaGFzQ29tbWl0dGVkTXV0YXRpb25zPSAqLyB0cnVlLCBkYlJlYWRUaW1lLCBwYXJlbnRQYXRoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9EYlRpbWVzdGFtcEtleShzbmFwc2hvdFZlcnNpb24pIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHNuYXBzaG90VmVyc2lvbi50b1RpbWVzdGFtcCgpO1xyXG4gICAgcmV0dXJuIFt0aW1lc3RhbXAuc2Vjb25kcywgdGltZXN0YW1wLm5hbm9zZWNvbmRzXTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRGJUaW1lc3RhbXBLZXkoZGJUaW1lc3RhbXBLZXkpIHtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBUaW1lc3RhbXAoZGJUaW1lc3RhbXBLZXlbMF0sIGRiVGltZXN0YW1wS2V5WzFdKTtcclxuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXApO1xyXG59XHJcbmZ1bmN0aW9uIHRvRGJUaW1lc3RhbXAoc25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBzbmFwc2hvdFZlcnNpb24udG9UaW1lc3RhbXAoKTtcclxuICAgIHJldHVybiBuZXcgRGJUaW1lc3RhbXAodGltZXN0YW1wLnNlY29uZHMsIHRpbWVzdGFtcC5uYW5vc2Vjb25kcyk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbURiVGltZXN0YW1wKGRiVGltZXN0YW1wKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgVGltZXN0YW1wKGRiVGltZXN0YW1wLnNlY29uZHMsIGRiVGltZXN0YW1wLm5hbm9zZWNvbmRzKTtcclxuICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXApO1xyXG59XHJcbi8qKiBFbmNvZGVzIGEgYmF0Y2ggb2YgbXV0YXRpb25zIGludG8gYSBEYk11dGF0aW9uQmF0Y2ggZm9yIGxvY2FsIHN0b3JhZ2UuICovXHJcbmZ1bmN0aW9uIHRvRGJNdXRhdGlvbkJhdGNoKGxvY2FsU2VyaWFsaXplciwgdXNlcklkLCBiYXRjaCkge1xyXG4gICAgY29uc3Qgc2VyaWFsaXplZEJhc2VNdXRhdGlvbnMgPSBiYXRjaC5iYXNlTXV0YXRpb25zLm1hcChtID0+IHRvTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcclxuICAgIGNvbnN0IHNlcmlhbGl6ZWRNdXRhdGlvbnMgPSBiYXRjaC5tdXRhdGlvbnMubWFwKG0gPT4gdG9NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgbSkpO1xyXG4gICAgcmV0dXJuIG5ldyBEYk11dGF0aW9uQmF0Y2godXNlcklkLCBiYXRjaC5iYXRjaElkLCBiYXRjaC5sb2NhbFdyaXRlVGltZS50b01pbGxpcygpLCBzZXJpYWxpemVkQmFzZU11dGF0aW9ucywgc2VyaWFsaXplZE11dGF0aW9ucyk7XHJcbn1cclxuLyoqIERlY29kZXMgYSBEYk11dGF0aW9uQmF0Y2ggaW50byBhIE11dGF0aW9uQmF0Y2ggKi9cclxuZnVuY3Rpb24gZnJvbURiTXV0YXRpb25CYXRjaChsb2NhbFNlcmlhbGl6ZXIsIGRiQmF0Y2gpIHtcclxuICAgIGNvbnN0IGJhc2VNdXRhdGlvbnMgPSAoZGJCYXRjaC5iYXNlTXV0YXRpb25zIHx8IFtdKS5tYXAobSA9PiBmcm9tTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcclxuICAgIC8vIFNxdWFzaCBvbGQgdHJhbnNmb3JtIG11dGF0aW9ucyBpbnRvIGV4aXN0aW5nIHBhdGNoIG9yIHNldCBtdXRhdGlvbnMuXHJcbiAgICAvLyBUaGUgcmVwbGFjZW1lbnQgb2YgcmVwcmVzZW50aW5nIGB0cmFuc2Zvcm1zYCB3aXRoIGB1cGRhdGVfdHJhbnNmb3Jtc2BcclxuICAgIC8vIG9uIHRoZSBTREsgbWVhbnMgdGhhdCBvbGQgYHRyYW5zZm9ybWAgbXV0YXRpb25zIHN0b3JlZCBpbiBJbmRleGVkREIgbmVlZFxyXG4gICAgLy8gdG8gYmUgdXBkYXRlZCB0byBgdXBkYXRlX3RyYW5zZm9ybXNgLlxyXG4gICAgLy8gVE9ETyhiLzE3NDYwODM3NCk6IFJlbW92ZSB0aGlzIGNvZGUgb25jZSB3ZSBwZXJmb3JtIGEgc2NoZW1hIG1pZ3JhdGlvbi5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGJCYXRjaC5tdXRhdGlvbnMubGVuZ3RoIC0gMTsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE11dGF0aW9uID0gZGJCYXRjaC5tdXRhdGlvbnNbaV07XHJcbiAgICAgICAgY29uc3QgaGFzVHJhbnNmb3JtID0gaSArIDEgPCBkYkJhdGNoLm11dGF0aW9ucy5sZW5ndGggJiZcclxuICAgICAgICAgICAgZGJCYXRjaC5tdXRhdGlvbnNbaSArIDFdLnRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChoYXNUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtTXV0YXRpb24gPSBkYkJhdGNoLm11dGF0aW9uc1tpICsgMV07XHJcbiAgICAgICAgICAgIGN1cnJlbnRNdXRhdGlvbi51cGRhdGVUcmFuc2Zvcm1zID1cclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU11dGF0aW9uLnRyYW5zZm9ybS5maWVsZFRyYW5zZm9ybXM7XHJcbiAgICAgICAgICAgIGRiQmF0Y2gubXV0YXRpb25zLnNwbGljZShpICsgMSwgMSk7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBtdXRhdGlvbnMgPSBkYkJhdGNoLm11dGF0aW9ucy5tYXAobSA9PiBmcm9tTXV0YXRpb24obG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIG0pKTtcclxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5mcm9tTWlsbGlzKGRiQmF0Y2gubG9jYWxXcml0ZVRpbWVNcyk7XHJcbiAgICByZXR1cm4gbmV3IE11dGF0aW9uQmF0Y2goZGJCYXRjaC5iYXRjaElkLCB0aW1lc3RhbXAsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XHJcbn1cclxuLyoqIERlY29kZXMgYSBEYlRhcmdldCBpbnRvIFRhcmdldERhdGEgKi9cclxuZnVuY3Rpb24gZnJvbURiVGFyZ2V0KGRiVGFyZ2V0KSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uID0gZnJvbURiVGltZXN0YW1wKGRiVGFyZ2V0LnJlYWRUaW1lKTtcclxuICAgIGNvbnN0IGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBkYlRhcmdldC5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uICE9PSB1bmRlZmluZWRcclxuICAgICAgICA/IGZyb21EYlRpbWVzdGFtcChkYlRhcmdldC5sYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKVxyXG4gICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpO1xyXG4gICAgbGV0IHRhcmdldDtcclxuICAgIGlmIChpc0RvY3VtZW50UXVlcnkoZGJUYXJnZXQucXVlcnkpKSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gZnJvbURvY3VtZW50c1RhcmdldChkYlRhcmdldC5xdWVyeSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0YXJnZXQgPSBmcm9tUXVlcnlUYXJnZXQoZGJUYXJnZXQucXVlcnkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBUYXJnZXREYXRhKHRhcmdldCwgZGJUYXJnZXQudGFyZ2V0SWQsIDAgLyogTGlzdGVuICovLCBkYlRhcmdldC5sYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIHZlcnNpb24sIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24sIEJ5dGVTdHJpbmcuZnJvbUJhc2U2NFN0cmluZyhkYlRhcmdldC5yZXN1bWVUb2tlbikpO1xyXG59XHJcbi8qKiBFbmNvZGVzIFRhcmdldERhdGEgaW50byBhIERiVGFyZ2V0IGZvciBzdG9yYWdlIGxvY2FsbHkuICovXHJcbmZ1bmN0aW9uIHRvRGJUYXJnZXQobG9jYWxTZXJpYWxpemVyLCB0YXJnZXREYXRhKSB7XHJcbiAgICBjb25zdCBkYlRpbWVzdGFtcCA9IHRvRGJUaW1lc3RhbXAodGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24pO1xyXG4gICAgY29uc3QgZGJMYXN0TGltYm9GcmVlVGltZXN0YW1wID0gdG9EYlRpbWVzdGFtcCh0YXJnZXREYXRhLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pO1xyXG4gICAgbGV0IHF1ZXJ5UHJvdG87XHJcbiAgICBpZiAodGFyZ2V0SXNEb2N1bWVudFRhcmdldCh0YXJnZXREYXRhLnRhcmdldCkpIHtcclxuICAgICAgICBxdWVyeVByb3RvID0gdG9Eb2N1bWVudHNUYXJnZXQobG9jYWxTZXJpYWxpemVyLnJlbW90ZVNlcmlhbGl6ZXIsIHRhcmdldERhdGEudGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHF1ZXJ5UHJvdG8gPSB0b1F1ZXJ5VGFyZ2V0KGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCB0YXJnZXREYXRhLnRhcmdldCk7XHJcbiAgICB9XHJcbiAgICAvLyBXZSBjYW4ndCBzdG9yZSB0aGUgcmVzdW1lVG9rZW4gYXMgYSBCeXRlU3RyaW5nIGluIEluZGV4ZWREYiwgc28gd2VcclxuICAgIC8vIGNvbnZlcnQgaXQgdG8gYSBiYXNlNjQgc3RyaW5nIGZvciBzdG9yYWdlLlxyXG4gICAgY29uc3QgcmVzdW1lVG9rZW4gPSB0YXJnZXREYXRhLnJlc3VtZVRva2VuLnRvQmFzZTY0KCk7XHJcbiAgICAvLyBsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgaXMgYWx3YXlzIDAgdW50aWwgd2UgZG8gcmVhbCBHQy5cclxuICAgIHJldHVybiBuZXcgRGJUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXRJZCwgY2Fub25pZnlUYXJnZXQodGFyZ2V0RGF0YS50YXJnZXQpLCBkYlRpbWVzdGFtcCwgcmVzdW1lVG9rZW4sIHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIsIGRiTGFzdExpbWJvRnJlZVRpbWVzdGFtcCwgcXVlcnlQcm90byk7XHJcbn1cclxuLyoqXHJcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBmaWd1cmluZyBvdXQgd2hhdCBraW5kIG9mIHF1ZXJ5IGhhcyBiZWVuIHN0b3JlZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzRG9jdW1lbnRRdWVyeShkYlF1ZXJ5KSB7XHJcbiAgICByZXR1cm4gZGJRdWVyeS5kb2N1bWVudHMgIT09IHVuZGVmaW5lZDtcclxufVxyXG4vKiogRW5jb2RlcyBhIERiQnVuZGxlIHRvIGEgQnVuZGxlTWV0YWRhdGEgb2JqZWN0LiAqL1xyXG5mdW5jdGlvbiBmcm9tRGJCdW5kbGUoZGJCdW5kbGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGRiQnVuZGxlLmJ1bmRsZUlkLFxyXG4gICAgICAgIGNyZWF0ZVRpbWU6IGZyb21EYlRpbWVzdGFtcChkYkJ1bmRsZS5jcmVhdGVUaW1lKSxcclxuICAgICAgICB2ZXJzaW9uOiBkYkJ1bmRsZS52ZXJzaW9uXHJcbiAgICB9O1xyXG59XHJcbi8qKiBFbmNvZGVzIGEgQnVuZGxlTWV0YWRhdGEgdG8gYSBEYkJ1bmRsZS4gKi9cclxuZnVuY3Rpb24gdG9EYkJ1bmRsZShtZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBidW5kbGVJZDogbWV0YWRhdGEuaWQsXHJcbiAgICAgICAgY3JlYXRlVGltZTogdG9EYlRpbWVzdGFtcChmcm9tVmVyc2lvbihtZXRhZGF0YS5jcmVhdGVUaW1lKSksXHJcbiAgICAgICAgdmVyc2lvbjogbWV0YWRhdGEudmVyc2lvblxyXG4gICAgfTtcclxufVxyXG4vKiogRW5jb2RlcyBhIERiTmFtZWRRdWVyeSB0byBhIE5hbWVkUXVlcnkuICovXHJcbmZ1bmN0aW9uIGZyb21EYk5hbWVkUXVlcnkoZGJOYW1lZFF1ZXJ5KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IGRiTmFtZWRRdWVyeS5uYW1lLFxyXG4gICAgICAgIHF1ZXJ5OiBmcm9tQnVuZGxlZFF1ZXJ5KGRiTmFtZWRRdWVyeS5idW5kbGVkUXVlcnkpLFxyXG4gICAgICAgIHJlYWRUaW1lOiBmcm9tRGJUaW1lc3RhbXAoZGJOYW1lZFF1ZXJ5LnJlYWRUaW1lKVxyXG4gICAgfTtcclxufVxyXG4vKiogRW5jb2RlcyBhIE5hbWVkUXVlcnkgZnJvbSBhIGJ1bmRsZSBwcm90byB0byBhIERiTmFtZWRRdWVyeS4gKi9cclxuZnVuY3Rpb24gdG9EYk5hbWVkUXVlcnkocXVlcnkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogcXVlcnkubmFtZSxcclxuICAgICAgICByZWFkVGltZTogdG9EYlRpbWVzdGFtcChmcm9tVmVyc2lvbihxdWVyeS5yZWFkVGltZSkpLFxyXG4gICAgICAgIGJ1bmRsZWRRdWVyeTogcXVlcnkuYnVuZGxlZFF1ZXJ5XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYEJ1bmRsZWRRdWVyeWAgZnJvbSBidW5kbGUgcHJvdG8gdG8gYSBRdWVyeSBvYmplY3QuXHJcbiAqXHJcbiAqIFRoaXMgcmVjb25zdHJ1Y3RzIHRoZSBvcmlnaW5hbCBxdWVyeSB1c2VkIHRvIGJ1aWxkIHRoZSBidW5kbGUgYmVpbmcgbG9hZGVkLFxyXG4gKiBpbmNsdWRpbmcgZmVhdHVyZXMgZXhpc3RzIG9ubHkgaW4gU0RLcyAoZm9yIGV4YW1wbGU6IGxpbWl0LXRvLWxhc3QpLlxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJ1bmRsZWRRdWVyeShidW5kbGVkUXVlcnkpIHtcclxuICAgIGNvbnN0IHF1ZXJ5ID0gY29udmVydFF1ZXJ5VGFyZ2V0VG9RdWVyeSh7XHJcbiAgICAgICAgcGFyZW50OiBidW5kbGVkUXVlcnkucGFyZW50LFxyXG4gICAgICAgIHN0cnVjdHVyZWRRdWVyeTogYnVuZGxlZFF1ZXJ5LnN0cnVjdHVyZWRRdWVyeVxyXG4gICAgfSk7XHJcbiAgICBpZiAoYnVuZGxlZFF1ZXJ5LmxpbWl0VHlwZSA9PT0gJ0xBU1QnKSB7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5LCBxdWVyeS5saW1pdCwgXCJMXCIgLyogTGFzdCAqLyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnk7XHJcbn1cclxuLyoqIEVuY29kZXMgYSBOYW1lZFF1ZXJ5IHByb3RvIG9iamVjdCB0byBhIE5hbWVkUXVlcnkgbW9kZWwgb2JqZWN0LiAqL1xyXG5mdW5jdGlvbiBmcm9tUHJvdG9OYW1lZFF1ZXJ5KG5hbWVkUXVlcnkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmFtZTogbmFtZWRRdWVyeS5uYW1lLFxyXG4gICAgICAgIHF1ZXJ5OiBmcm9tQnVuZGxlZFF1ZXJ5KG5hbWVkUXVlcnkuYnVuZGxlZFF1ZXJ5KSxcclxuICAgICAgICByZWFkVGltZTogZnJvbVZlcnNpb24obmFtZWRRdWVyeS5yZWFkVGltZSlcclxuICAgIH07XHJcbn1cclxuLyoqIERlY29kZXMgYSBCdW5kbGVNZXRhZGF0YSBwcm90byBpbnRvIGEgQnVuZGxlTWV0YWRhdGEgb2JqZWN0LiAqL1xyXG5mdW5jdGlvbiBmcm9tQnVuZGxlTWV0YWRhdGEobWV0YWRhdGEpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IG1ldGFkYXRhLmlkLFxyXG4gICAgICAgIHZlcnNpb246IG1ldGFkYXRhLnZlcnNpb24sXHJcbiAgICAgICAgY3JlYXRlVGltZTogZnJvbVZlcnNpb24obWV0YWRhdGEuY3JlYXRlVGltZSlcclxuICAgIH07XHJcbn1cclxuLyoqIEVuY29kZXMgYSBEYkRvY3VtZW50T3ZlcmxheSBvYmplY3QgdG8gYW4gT3ZlcmxheSBtb2RlbCBvYmplY3QuICovXHJcbmZ1bmN0aW9uIGZyb21EYkRvY3VtZW50T3ZlcmxheShsb2NhbFNlcmlhbGl6ZXIsIGRiRG9jdW1lbnRPdmVybGF5KSB7XHJcbiAgICByZXR1cm4gbmV3IE92ZXJsYXkoZGJEb2N1bWVudE92ZXJsYXkubGFyZ2VzdEJhdGNoSWQsIGZyb21NdXRhdGlvbihsb2NhbFNlcmlhbGl6ZXIucmVtb3RlU2VyaWFsaXplciwgZGJEb2N1bWVudE92ZXJsYXkub3ZlcmxheU11dGF0aW9uKSk7XHJcbn1cclxuLyoqIERlY29kZXMgYW4gT3ZlcmxheSBtb2RlbCBvYmplY3QgaW50byBhIERiRG9jdW1lbnRPdmVybGF5IG9iamVjdC4gKi9cclxuZnVuY3Rpb24gdG9EYkRvY3VtZW50T3ZlcmxheShsb2NhbFNlcmlhbGl6ZXIsIHVzZXJJZCwgb3ZlcmxheSkge1xyXG4gICAgY29uc3QgW18sIGNvbGxlY3Rpb25QYXRoLCBkb2N1bWVudElkXSA9IHRvRGJEb2N1bWVudE92ZXJsYXlLZXkodXNlcklkLCBvdmVybGF5Lm11dGF0aW9uLmtleSk7XHJcbiAgICByZXR1cm4gbmV3IERiRG9jdW1lbnRPdmVybGF5KHVzZXJJZCwgY29sbGVjdGlvblBhdGgsIGRvY3VtZW50SWQsIG92ZXJsYXkubXV0YXRpb24ua2V5LmdldENvbGxlY3Rpb25Hcm91cCgpLCBvdmVybGF5Lmxhcmdlc3RCYXRjaElkLCB0b011dGF0aW9uKGxvY2FsU2VyaWFsaXplci5yZW1vdGVTZXJpYWxpemVyLCBvdmVybGF5Lm11dGF0aW9uKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIERiRG9jdW1lbnRPdmVybGF5S2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHVzZXIgYW5kXHJcbiAqIGRvY3VtZW50IGtleS5cclxuICovXHJcbmZ1bmN0aW9uIHRvRGJEb2N1bWVudE92ZXJsYXlLZXkodXNlcklkLCBkb2NLZXkpIHtcclxuICAgIGNvbnN0IGRvY0lkID0gZG9jS2V5LnBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgIGNvbnN0IGNvbGxlY3Rpb25QYXRoID0gZW5jb2RlUmVzb3VyY2VQYXRoKGRvY0tleS5wYXRoLnBvcExhc3QoKSk7XHJcbiAgICByZXR1cm4gW3VzZXJJZCwgY29sbGVjdGlvblBhdGgsIGRvY0lkXTtcclxufVxyXG5mdW5jdGlvbiB0b0RiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4KSB7XHJcbiAgICByZXR1cm4gbmV3IERiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4LmluZGV4SWQsIGluZGV4LmNvbGxlY3Rpb25Hcm91cCwgaW5kZXguZmllbGRzLm1hcChzID0+IFtzLmZpZWxkUGF0aC5jYW5vbmljYWxTdHJpbmcoKSwgcy5raW5kXSkpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21EYkluZGV4Q29uZmlndXJhdGlvbihpbmRleCwgc3RhdGUpIHtcclxuICAgIGNvbnN0IGRlY29kZWRTdGF0ZSA9IHN0YXRlXHJcbiAgICAgICAgPyBuZXcgSW5kZXhTdGF0ZShzdGF0ZS5zZXF1ZW5jZU51bWJlciwgbmV3IEluZGV4T2Zmc2V0KGZyb21EYlRpbWVzdGFtcChzdGF0ZS5yZWFkVGltZSksIG5ldyBEb2N1bWVudEtleShkZWNvZGVSZXNvdXJjZVBhdGgoc3RhdGUuZG9jdW1lbnRLZXkpKSwgc3RhdGUubGFyZ2VzdEJhdGNoSWQpKVxyXG4gICAgICAgIDogSW5kZXhTdGF0ZS5lbXB0eSgpO1xyXG4gICAgY29uc3QgZGVjb2RlZFNlZ21lbnRzID0gaW5kZXguZmllbGRzLm1hcCgoW2ZpZWxkUGF0aCwga2luZF0pID0+IG5ldyBJbmRleFNlZ21lbnQoRmllbGRQYXRoJDEuZnJvbVNlcnZlckZvcm1hdChmaWVsZFBhdGgpLCBraW5kKSk7XHJcbiAgICByZXR1cm4gbmV3IEZpZWxkSW5kZXgoaW5kZXguaW5kZXhJZCwgaW5kZXguY29sbGVjdGlvbkdyb3VwLCBkZWNvZGVkU2VnbWVudHMsIGRlY29kZWRTdGF0ZSk7XHJcbn1cclxuZnVuY3Rpb24gdG9EYkluZGV4U3RhdGUoaW5kZXhJZCwgdXNlciwgc2VxdWVuY2VOdW1iZXIsIG9mZnNldCkge1xyXG4gICAgcmV0dXJuIG5ldyBEYkluZGV4U3RhdGUoaW5kZXhJZCwgdXNlci51aWQgfHwgJycsIHNlcXVlbmNlTnVtYmVyLCB0b0RiVGltZXN0YW1wKG9mZnNldC5yZWFkVGltZSksIGVuY29kZVJlc291cmNlUGF0aChvZmZzZXQuZG9jdW1lbnRLZXkucGF0aCksIG9mZnNldC5sYXJnZXN0QmF0Y2hJZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiQnVuZGxlQ2FjaGUge1xyXG4gICAgZ2V0QnVuZGxlTWV0YWRhdGEodHJhbnNhY3Rpb24sIGJ1bmRsZUlkKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ1bmRsZXNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmdldChidW5kbGVJZClcclxuICAgICAgICAgICAgLm5leHQoYnVuZGxlID0+IHtcclxuICAgICAgICAgICAgaWYgKGJ1bmRsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYkJ1bmRsZShidW5kbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzYXZlQnVuZGxlTWV0YWRhdGEodHJhbnNhY3Rpb24sIGJ1bmRsZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ1bmRsZXNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJCdW5kbGUoYnVuZGxlTWV0YWRhdGEpKTtcclxuICAgIH1cclxuICAgIGdldE5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuYW1lZFF1ZXJpZXNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmdldChxdWVyeU5hbWUpXHJcbiAgICAgICAgICAgIC5uZXh0KHF1ZXJ5ID0+IHtcclxuICAgICAgICAgICAgaWYgKHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbURiTmFtZWRRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNhdmVOYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBuYW1lZFF1ZXJpZXNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJOYW1lZFF1ZXJ5KHF1ZXJ5KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgYnVuZGxlcyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBidW5kbGVzU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkJ1bmRsZS5zdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgbmFtZWRRdWVyaWVzIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIG5hbWVkUXVlcmllc1N0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJOYW1lZFF1ZXJ5LnN0b3JlKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgRG9jdW1lbnRPdmVybGF5Q2FjaGUgdXNpbmcgSW5kZXhlZERiLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiRG9jdW1lbnRPdmVybGF5Q2FjaGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gc2VyaWFsaXplciAtIFRoZSBkb2N1bWVudCBzZXJpYWxpemVyLlxyXG4gICAgICogQHBhcmFtIHVzZXJJZCAtIFRoZSB1c2VySWQgZm9yIHdoaWNoIHdlIGFyZSBhY2Nlc3Npbmcgb3ZlcmxheXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIsIHVzZXJJZCkge1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgdGhpcy51c2VySWQgPSB1c2VySWQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZm9yVXNlcihzZXJpYWxpemVyLCB1c2VyKSB7XHJcbiAgICAgICAgY29uc3QgdXNlcklkID0gdXNlci51aWQgfHwgJyc7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRGJEb2N1bWVudE92ZXJsYXlDYWNoZShzZXJpYWxpemVyLCB1c2VySWQpO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxheSh0cmFuc2FjdGlvbiwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50T3ZlcmxheVN0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuZ2V0KHRvRGJEb2N1bWVudE92ZXJsYXlLZXkodGhpcy51c2VySWQsIGtleSkpXHJcbiAgICAgICAgICAgIC5uZXh0KGRiT3ZlcmxheSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkYk92ZXJsYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCBkYk92ZXJsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2F2ZU92ZXJsYXlzKHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgb3ZlcmxheXMpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIG92ZXJsYXlzLmZvckVhY2gobXV0YXRpb24gPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gbmV3IE92ZXJsYXkobGFyZ2VzdEJhdGNoSWQsIG11dGF0aW9uKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBvdmVybGF5KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgIH1cclxuICAgIHJlbW92ZU92ZXJsYXlzRm9yQmF0Y2hJZCh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzLCBiYXRjaElkKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvblBhdGhzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8vIEdldCB0aGUgc2V0IG9mIHVuaXF1ZSBjb2xsZWN0aW9uIHBhdGhzLlxyXG4gICAgICAgIGRvY3VtZW50S2V5cy5mb3JFYWNoKGtleSA9PiBjb2xsZWN0aW9uUGF0aHMuYWRkKGVuY29kZVJlc291cmNlUGF0aChrZXkuZ2V0Q29sbGVjdGlvblBhdGgoKSkpKTtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIGNvbGxlY3Rpb25QYXRocy5mb3JFYWNoKGNvbGxlY3Rpb25QYXRoID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBiYXRjaElkXSwgW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uUGF0aCwgYmF0Y2hJZCArIDFdLCBcclxuICAgICAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxyXG4gICAgICAgICAgICAvKnVwcGVyT3Blbj0qLyB0cnVlKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkb2N1bWVudE92ZXJsYXlTdG9yZSh0cmFuc2FjdGlvbikuZGVsZXRlQWxsKERiRG9jdW1lbnRPdmVybGF5LmNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4LCByYW5nZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5c0ZvckNvbGxlY3Rpb24odHJhbnNhY3Rpb24sIGNvbGxlY3Rpb24sIHNpbmNlQmF0Y2hJZCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uUGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChjb2xsZWN0aW9uKTtcclxuICAgICAgICAvLyBXZSB3YW50IGJhdGNoIElEcyBsYXJnZXIgdGhhbiBgc2luY2VCYXRjaElkYCwgYW5kIHNvIHRoZSBsb3dlciBib3VuZFxyXG4gICAgICAgIC8vIGlzIG5vdCBpbmNsdXNpdmUuXHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBzaW5jZUJhdGNoSWRdLCBbdGhpcy51c2VySWQsIGNvbGxlY3Rpb25QYXRoLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyB0cnVlKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5sb2FkQWxsKERiRG9jdW1lbnRPdmVybGF5LmNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4LCByYW5nZSlcclxuICAgICAgICAgICAgLm5leHQoZGJPdmVybGF5cyA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGJPdmVybGF5IG9mIGRiT3ZlcmxheXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBmcm9tRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCBkYk92ZXJsYXkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uR3JvdXAodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCwgc2luY2VCYXRjaElkLCBjb3VudCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcclxuICAgICAgICBsZXQgY3VycmVudEJhdGNoSWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gV2Ugd2FudCBiYXRjaCBJRHMgbGFyZ2VyIHRoYW4gYHNpbmNlQmF0Y2hJZGAsIGFuZCBzbyB0aGUgbG93ZXIgYm91bmRcclxuICAgICAgICAvLyBpcyBub3QgaW5jbHVzaXZlLlxyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZF0sIFt0aGlzLnVzZXJJZCwgY29sbGVjdGlvbkdyb3VwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyB0cnVlKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRPdmVybGF5U3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcclxuICAgICAgICAgICAgaW5kZXg6IERiRG9jdW1lbnRPdmVybGF5LmNvbGxlY3Rpb25Hcm91cE92ZXJsYXlJbmRleCxcclxuICAgICAgICAgICAgcmFuZ2VcclxuICAgICAgICB9LCAoXywgZGJPdmVybGF5LCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIHJldHVybiBwYXJ0aWFsIGJhdGNoIG92ZXJsYXlzLCBldmVuIGlmIHRoZSBzaXplXHJcbiAgICAgICAgICAgIC8vIG9mIHRoZSByZXN1bHQgc2V0IGV4Y2VlZHMgdGhlIGdpdmVuIGBjb3VudGAgYXJndW1lbnQuIFRoZXJlZm9yZSwgd2VcclxuICAgICAgICAgICAgLy8gY29udGludWUgdG8gYWdncmVnYXRlIHJlc3VsdHMgZXZlbiBhZnRlciB0aGUgcmVzdWx0IHNpemUgZXhjZWVkc1xyXG4gICAgICAgICAgICAvLyBgY291bnRgIGlmIHRoZXJlIGFyZSBtb3JlIG92ZXJsYXlzIGZyb20gdGhlIGBjdXJyZW50QmF0Y2hJZGAuXHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBmcm9tRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCBkYk92ZXJsYXkpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LnNpemUgPCBjb3VudCB8fFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA9PT0gY3VycmVudEJhdGNoSWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQob3ZlcmxheS5nZXRLZXkoKSwgb3ZlcmxheSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QmF0Y2hJZCA9IG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBzYXZlT3ZlcmxheSh0cmFuc2FjdGlvbiwgb3ZlcmxheSkge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudE92ZXJsYXlTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJEb2N1bWVudE92ZXJsYXkodGhpcy5zZXJpYWxpemVyLCB0aGlzLnVzZXJJZCwgb3ZlcmxheSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIGRvY3VtZW50IG92ZXJsYXkgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gZG9jdW1lbnRPdmVybGF5U3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkRvY3VtZW50T3ZlcmxheS5zdG9yZSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gTm90ZTogVGhpcyBjb2RlIGlzIGNvcGllZCBmcm9tIHRoZSBiYWNrZW5kLiBDb2RlIHRoYXQgaXMgbm90IHVzZWQgYnlcclxuLy8gRmlyZXN0b3JlIHdhcyByZW1vdmVkLlxyXG5jb25zdCBJTkRFWF9UWVBFX05VTEwgPSA1O1xyXG5jb25zdCBJTkRFWF9UWVBFX0JPT0xFQU4gPSAxMDtcclxuY29uc3QgSU5ERVhfVFlQRV9OQU4gPSAxMztcclxuY29uc3QgSU5ERVhfVFlQRV9OVU1CRVIgPSAxNTtcclxuY29uc3QgSU5ERVhfVFlQRV9USU1FU1RBTVAgPSAyMDtcclxuY29uc3QgSU5ERVhfVFlQRV9TVFJJTkcgPSAyNTtcclxuY29uc3QgSU5ERVhfVFlQRV9CTE9CID0gMzA7XHJcbmNvbnN0IElOREVYX1RZUEVfUkVGRVJFTkNFID0gMzc7XHJcbmNvbnN0IElOREVYX1RZUEVfR0VPUE9JTlQgPSA0NTtcclxuY29uc3QgSU5ERVhfVFlQRV9BUlJBWSA9IDUwO1xyXG5jb25zdCBJTkRFWF9UWVBFX01BUCA9IDU1O1xyXG5jb25zdCBJTkRFWF9UWVBFX1JFRkVSRU5DRV9TRUdNRU5UID0gNjA7XHJcbi8vIEEgdGVybWluYXRvciB0aGF0IGluZGljYXRlcyB0aGF0IGEgdHJ1bmNhdGFibGUgdmFsdWUgd2FzIG5vdCB0cnVuY2F0ZWQuXHJcbi8vIFRoaXMgbXVzdCBiZSBzbWFsbGVyIHRoYW4gYWxsIG90aGVyIHR5cGUgbGFiZWxzLlxyXG5jb25zdCBOT1RfVFJVTkNBVEVEID0gMjtcclxuLyoqIEZpcmVzdG9yZSBpbmRleCB2YWx1ZSB3cml0ZXIuICAqL1xyXG5jbGFzcyBGaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XHJcbiAgICAvLyBUaGUgd3JpdGUgbWV0aG9kcyBiZWxvdyBzaG9ydC1jaXJjdWl0IHdyaXRpbmcgdGVybWluYXRvcnMgZm9yIHZhbHVlc1xyXG4gICAgLy8gY29udGFpbmluZyBhICh0ZXJtaW5hdGluZykgdHJ1bmNhdGVkIHZhbHVlLlxyXG4gICAgLy9cclxuICAgIC8vIEFzIGFuIGV4YW1wbGUsIGNvbnNpZGVyIHRoZSByZXN1bHRpbmcgZW5jb2RpbmcgZm9yOlxyXG4gICAgLy9cclxuICAgIC8vIFtcImJhclwiLCBbMiwgXCJmb29cIl1dIC0+IChTVFJJTkcsIFwiYmFyXCIsIFRFUk0sIEFSUkFZLCBOVU1CRVIsIDIsIFNUUklORywgXCJmb29cIiwgVEVSTSwgVEVSTSwgVEVSTSlcclxuICAgIC8vIFtcImJhclwiLCBbMiwgdHJ1bmNhdGVkKFwiZm9vXCIpXV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVksIE5VTUJFUiwgMiwgU1RSSU5HLCBcImZvb1wiLCBUUlVOQylcclxuICAgIC8vIFtcImJhclwiLCB0cnVuY2F0ZWQoW1wiZm9vXCJdKV0gLT4gKFNUUklORywgXCJiYXJcIiwgVEVSTSwgQVJSQVkuIFNUUklORywgXCJmb29cIiwgVEVSTSwgVFJVTkMpXHJcbiAgICAvKiogV3JpdGVzIGFuIGluZGV4IHZhbHVlLiAgKi9cclxuICAgIHdyaXRlSW5kZXhWYWx1ZSh2YWx1ZSwgZW5jb2Rlcikge1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRleFZhbHVlQXV4KHZhbHVlLCBlbmNvZGVyKTtcclxuICAgICAgICAvLyBXcml0ZSBzZXBhcmF0b3IgdG8gc3BsaXQgaW5kZXggdmFsdWVzXHJcbiAgICAgICAgLy8gKHNlZSBnby9maXJlc3RvcmUtc3RvcmFnZS1mb3JtYXQjZW5jb2RpbmdzKS5cclxuICAgICAgICBlbmNvZGVyLndyaXRlSW5maW5pdHkoKTtcclxuICAgIH1cclxuICAgIHdyaXRlSW5kZXhWYWx1ZUF1eChpbmRleFZhbHVlLCBlbmNvZGVyKSB7XHJcbiAgICAgICAgaWYgKCdudWxsVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVMTCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdib29sZWFuVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfQk9PTEVBTik7XHJcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoaW5kZXhWYWx1ZS5ib29sZWFuVmFsdWUgPyAxIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdpbnRlZ2VyVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTlVNQkVSKTtcclxuICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihub3JtYWxpemVOdW1iZXIoaW5kZXhWYWx1ZS5pbnRlZ2VyVmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2RvdWJsZVZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG4gPSBub3JtYWxpemVOdW1iZXIoaW5kZXhWYWx1ZS5kb3VibGVWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihuKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfTkFOKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX05VTUJFUik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZVplcm8obikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAtMC4wLCAwIGFuZCAwLjAgYXJlIGFsbCBjb25zaWRlcmVkIHRoZSBzYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcigwLjApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgndGltZXN0YW1wVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gaW5kZXhWYWx1ZS50aW1lc3RhbXBWYWx1ZTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfVElNRVNUQU1QKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKGAke3RpbWVzdGFtcC5zZWNvbmRzIHx8ICcnfWApO1xyXG4gICAgICAgICAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcih0aW1lc3RhbXAubmFub3MgfHwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3N0cmluZ1ZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFN0cmluZyhpbmRleFZhbHVlLnN0cmluZ1ZhbHVlLCBlbmNvZGVyKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdieXRlc1ZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBJTkRFWF9UWVBFX0JMT0IpO1xyXG4gICAgICAgICAgICBlbmNvZGVyLndyaXRlQnl0ZXMobm9ybWFsaXplQnl0ZVN0cmluZyhpbmRleFZhbHVlLmJ5dGVzVmFsdWUpKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZVRydW5jYXRpb25NYXJrZXIoZW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdyZWZlcmVuY2VWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhFbnRpdHlSZWYoaW5kZXhWYWx1ZS5yZWZlcmVuY2VWYWx1ZSwgZW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdnZW9Qb2ludFZhbHVlJyBpbiBpbmRleFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdlb1BvaW50ID0gaW5kZXhWYWx1ZS5nZW9Qb2ludFZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9HRU9QT0lOVCk7XHJcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoZ2VvUG9pbnQubGF0aXR1ZGUgfHwgMCk7XHJcbiAgICAgICAgICAgIGVuY29kZXIud3JpdGVOdW1iZXIoZ2VvUG9pbnQubG9uZ2l0dWRlIHx8IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnbWFwVmFsdWUnIGluIGluZGV4VmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGlzTWF4VmFsdWUoaW5kZXhWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZVR5cGVMYWJlbChlbmNvZGVyLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhNYXAoaW5kZXhWYWx1ZS5tYXBWYWx1ZSwgZW5jb2Rlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnYXJyYXlWYWx1ZScgaW4gaW5kZXhWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhBcnJheShpbmRleFZhbHVlLmFycmF5VmFsdWUsIGVuY29kZXIpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlVHJ1bmNhdGlvbk1hcmtlcihlbmNvZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3cml0ZUluZGV4U3RyaW5nKHN0cmluZ0luZGV4VmFsdWUsIGVuY29kZXIpIHtcclxuICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9TVFJJTkcpO1xyXG4gICAgICAgIHRoaXMud3JpdGVVbmxhYmVsZWRJbmRleFN0cmluZyhzdHJpbmdJbmRleFZhbHVlLCBlbmNvZGVyKTtcclxuICAgIH1cclxuICAgIHdyaXRlVW5sYWJlbGVkSW5kZXhTdHJpbmcoc3RyaW5nSW5kZXhWYWx1ZSwgZW5jb2Rlcikge1xyXG4gICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcoc3RyaW5nSW5kZXhWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZUluZGV4TWFwKG1hcEluZGV4VmFsdWUsIGVuY29kZXIpIHtcclxuICAgICAgICBjb25zdCBtYXAgPSBtYXBJbmRleFZhbHVlLmZpZWxkcyB8fCB7fTtcclxuICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9NQVApO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUluZGV4U3RyaW5nKGtleSwgZW5jb2Rlcik7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbmRleFZhbHVlQXV4KG1hcFtrZXldLCBlbmNvZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3cml0ZUluZGV4QXJyYXkoYXJyYXlJbmRleFZhbHVlLCBlbmNvZGVyKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gYXJyYXlJbmRleFZhbHVlLnZhbHVlcyB8fCBbXTtcclxuICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9BUlJBWSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlSW5kZXhWYWx1ZUF1eChlbGVtZW50LCBlbmNvZGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3cml0ZUluZGV4RW50aXR5UmVmKHJlZmVyZW5jZVZhbHVlLCBlbmNvZGVyKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVZhbHVlVHlwZUxhYmVsKGVuY29kZXIsIElOREVYX1RZUEVfUkVGRVJFTkNFKTtcclxuICAgICAgICBjb25zdCBwYXRoID0gRG9jdW1lbnRLZXkuZnJvbU5hbWUocmVmZXJlbmNlVmFsdWUpLnBhdGg7XHJcbiAgICAgICAgcGF0aC5mb3JFYWNoKHNlZ21lbnQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgSU5ERVhfVFlQRV9SRUZFUkVOQ0VfU0VHTUVOVCk7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVVbmxhYmVsZWRJbmRleFN0cmluZyhzZWdtZW50LCBlbmNvZGVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHdyaXRlVmFsdWVUeXBlTGFiZWwoZW5jb2RlciwgdHlwZU9yZGVyKSB7XHJcbiAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcih0eXBlT3JkZXIpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVUcnVuY2F0aW9uTWFya2VyKGVuY29kZXIpIHtcclxuICAgICAgICAvLyBXaGlsZSB0aGUgU0RLIGRvZXMgbm90IGltcGxlbWVudCB0cnVuY2F0aW9uLCB0aGUgdHJ1bmNhdGlvbiBtYXJrZXIgaXNcclxuICAgICAgICAvLyB1c2VkIHRvIHRlcm1pbmF0ZSBhbGwgdmFyaWFibGUgbGVuZ3RoIHZhbHVlcyAod2hpY2ggYXJlIHN0cmluZ3MsIGJ5dGVzLFxyXG4gICAgICAgIC8vIHJlZmVyZW5jZXMsIGFycmF5cyBhbmQgbWFwcykuXHJcbiAgICAgICAgZW5jb2Rlci53cml0ZU51bWJlcihOT1RfVFJVTkNBVEVEKTtcclxuICAgIH1cclxufVxyXG5GaXJlc3RvcmVJbmRleFZhbHVlV3JpdGVyLklOU1RBTkNFID0gbmV3IEZpcmVzdG9yZUluZGV4VmFsdWVXcml0ZXIoKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IHwgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIHwgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3MgfCBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFRoZXNlIGNvbnN0YW50cyBhcmUgdGFrZW4gZnJvbSB0aGUgYmFja2VuZC4gKi9cclxuY29uc3QgTUlOX1NVUlJPR0FURSA9ICdcXHVEODAwJztcclxuY29uc3QgTUFYX1NVUlJPR0FURSA9ICdcXHVEQkZGJztcclxuY29uc3QgRVNDQVBFMSA9IDB4MDA7XHJcbmNvbnN0IE5VTExfQllURSA9IDB4ZmY7IC8vIENvbWJpbmVkIHdpdGggRVNDQVBFMVxyXG5jb25zdCBTRVBBUkFUT1IgPSAweDAxOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTFcclxuY29uc3QgRVNDQVBFMiA9IDB4ZmY7XHJcbmNvbnN0IElORklOSVRZID0gMHhmZjsgLy8gQ29tYmluZWQgd2l0aCBFU0NBUEUyXHJcbmNvbnN0IEZGX0JZVEUgPSAweDAwOyAvLyBDb21iaW5lZCB3aXRoIEVTQ0FQRTJcclxuY29uc3QgTE9OR19TSVpFID0gNjQ7XHJcbmNvbnN0IEJZVEVfU0laRSA9IDg7XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBzaXplIG9mIHRoZSBidWZmZXIuIFRoaXMgaXMgYXJiaXRyYXJ5LCBidXQgbGlrZWx5IGxhcmdlciB0aGFuXHJcbiAqIG1vc3QgaW5kZXggdmFsdWVzIHNvIHRoYXQgbGVzcyBjb3BpZXMgb2YgdGhlIHVuZGVybHlpbmcgYnVmZmVyIHdpbGwgYmUgbWFkZS5cclxuICogRm9yIGxhcmdlIHZhbHVlcywgYSBzaW5nbGUgY29weSB3aWxsIG1hZGUgdG8gZG91YmxlIHRoZSBidWZmZXIgbGVuZ3RoLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9CVUZGRVJfU0laRSA9IDEwMjQ7XHJcbi8qKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgbnVtYmVyIHRvIGEgYnl0ZSBhcnJheSAodXNpbmcgYmlnIGVuZGlhbiBlbmNvZGluZykuICovXHJcbmZ1bmN0aW9uIGRvdWJsZVRvTG9uZ0JpdHModmFsdWUpIHtcclxuICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSk7XHJcbiAgICBkdi5zZXRGbG9hdDY0KDAsIHZhbHVlLCAvKiBsaXR0bGVFbmRpYW49ICovIGZhbHNlKTtcclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkdi5idWZmZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBDb3VudHMgdGhlIG51bWJlciBvZiB6ZXJvcyBpbiBhIGJ5dGUuXHJcbiAqXHJcbiAqIFZpc2libGUgZm9yIHRlc3RpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBudW1iZXJPZkxlYWRpbmdaZXJvc0luQnl0ZSh4KSB7XHJcbiAgICBpZiAoeCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiA4O1xyXG4gICAgfVxyXG4gICAgbGV0IHplcm9zID0gMDtcclxuICAgIGlmICh4ID4+IDQgPT09IDApIHtcclxuICAgICAgICAvLyBUZXN0IGlmIHRoZSBmaXJzdCBmb3VyIGJpdHMgYXJlIHplcm8uXHJcbiAgICAgICAgemVyb3MgKz0gNDtcclxuICAgICAgICB4ID0geCA8PCA0O1xyXG4gICAgfVxyXG4gICAgaWYgKHggPj4gNiA9PT0gMCkge1xyXG4gICAgICAgIC8vIFRlc3QgaWYgdGhlIGZpcnN0IHR3byAob3IgbmV4dCB0d28pIGJpdHMgYXJlIHplcm8uXHJcbiAgICAgICAgemVyb3MgKz0gMjtcclxuICAgICAgICB4ID0geCA8PCAyO1xyXG4gICAgfVxyXG4gICAgaWYgKHggPj4gNyA9PT0gMCkge1xyXG4gICAgICAgIC8vIFRlc3QgaWYgdGhlIHJlbWFpbmluZyBiaXQgaXMgemVyby5cclxuICAgICAgICB6ZXJvcyArPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHplcm9zO1xyXG59XHJcbi8qKiBDb3VudHMgdGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIGluIHRoZSBnaXZlbiBieXRlIGFycmF5LiAqL1xyXG5mdW5jdGlvbiBudW1iZXJPZkxlYWRpbmdaZXJvcyhieXRlcykge1xyXG4gICAgbGV0IGxlYWRpbmdaZXJvcyA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHplcm9zID0gbnVtYmVyT2ZMZWFkaW5nWmVyb3NJbkJ5dGUoYnl0ZXNbaV0gJiAweGZmKTtcclxuICAgICAgICBsZWFkaW5nWmVyb3MgKz0gemVyb3M7XHJcbiAgICAgICAgaWYgKHplcm9zICE9PSA4KSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWFkaW5nWmVyb3M7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBcInZhbHVlXCIuIExlYWRpbmcgemVybyBieXRlc1xyXG4gKiBhcmUgc2tpcHBlZC5cclxuICovXHJcbmZ1bmN0aW9uIHVuc2lnbmVkTnVtTGVuZ3RoKHZhbHVlKSB7XHJcbiAgICAvLyBUaGlzIGlzIGp1c3QgdGhlIG51bWJlciBvZiBieXRlcyBmb3IgdGhlIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXHJcbiAgICBjb25zdCBudW1CaXRzID0gTE9OR19TSVpFIC0gbnVtYmVyT2ZMZWFkaW5nWmVyb3ModmFsdWUpO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChudW1CaXRzIC8gQllURV9TSVpFKTtcclxufVxyXG4vKipcclxuICogT3JkZXJlZENvZGVXcml0ZXIgaXMgYSBtaW5pbWFsLWFsbG9jYXRpb24gaW1wbGVtZW50YXRpb24gb2YgdGhlIHdyaXRpbmdcclxuICogYmVoYXZpb3IgZGVmaW5lZCBieSB0aGUgYmFja2VuZC5cclxuICpcclxuICogVGhlIGNvZGUgaXMgcG9ydGVkIGZyb20gaXRzIEphdmEgY291bnRlcnBhcnQuXHJcbiAqL1xyXG5jbGFzcyBPcmRlcmVkQ29kZVdyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KERFRkFVTFRfQlVGRkVSX1NJWkUpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG4gICAgfVxyXG4gICAgd3JpdGVCeXRlc0FzY2VuZGluZyh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGl0ID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgICAgIGxldCBieXRlID0gaXQubmV4dCgpO1xyXG4gICAgICAgIHdoaWxlICghYnl0ZS5kb25lKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKGJ5dGUudmFsdWUpO1xyXG4gICAgICAgICAgICBieXRlID0gaXQubmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndyaXRlU2VwYXJhdG9yQXNjZW5kaW5nKCk7XHJcbiAgICB9XHJcbiAgICB3cml0ZUJ5dGVzRGVzY2VuZGluZyh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGl0ID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgICAgIGxldCBieXRlID0gaXQubmV4dCgpO1xyXG4gICAgICAgIHdoaWxlICghYnl0ZS5kb25lKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZyhieXRlLnZhbHVlKTtcclxuICAgICAgICAgICAgYnl0ZSA9IGl0Lm5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0ZVNlcGFyYXRvckRlc2NlbmRpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKiBXcml0ZXMgdXRmOCBieXRlcyBpbnRvIHRoaXMgYnl0ZSBzZXF1ZW5jZSwgYXNjZW5kaW5nLiAqL1xyXG4gICAgd3JpdGVVdGY4QXNjZW5kaW5nKHNlcXVlbmNlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHNlcXVlbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlID0gYy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAweDgwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZyhjaGFyQ29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhckNvZGUgPCAweDgwMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoKDB4MGYgPDwgNikgfCAoY2hhckNvZGUgPj4+IDYpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIGNoYXJDb2RlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYyA8IE1JTl9TVVJST0dBVEUgfHwgTUFYX1NVUlJPR0FURSA8IGMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKCgweDBmIDw8IDUpIHwgKGNoYXJDb2RlID4+PiAxMikpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNoYXJDb2RlID4+PiA2KSkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVBc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGMuY29kZVBvaW50QXQoMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygoMHgwZiA8PCA0KSB8IChjb2RlUG9pbnQgPj4+IDE4KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiAoY29kZVBvaW50ID4+PiAxMikpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlQXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjb2RlUG9pbnQgPj4+IDYpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZUFzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjb2RlUG9pbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndyaXRlU2VwYXJhdG9yQXNjZW5kaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKiogV3JpdGVzIHV0ZjggYnl0ZXMgaW50byB0aGlzIGJ5dGUgc2VxdWVuY2UsIGRlc2NlbmRpbmcgKi9cclxuICAgIHdyaXRlVXRmOERlc2NlbmRpbmcoc2VxdWVuY2UpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc2VxdWVuY2UpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDB4ODApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZyhjaGFyQ29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhckNvZGUgPCAweDgwMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKCgweDBmIDw8IDYpIHwgKGNoYXJDb2RlID4+PiA2KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgY2hhckNvZGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjIDwgTUlOX1NVUlJPR0FURSB8fCBNQVhfU1VSUk9HQVRFIDwgYykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKCgweDBmIDw8IDUpIHwgKGNoYXJDb2RlID4+PiAxMikpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUJ5dGVEZXNjZW5kaW5nKDB4ODAgfCAoMHgzZiAmIChjaGFyQ29kZSA+Pj4gNikpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjaGFyQ29kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gYy5jb2RlUG9pbnRBdCgwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygoMHgwZiA8PCA0KSB8IChjb2RlUG9pbnQgPj4+IDE4KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNvZGVQb2ludCA+Pj4gMTIpKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnl0ZURlc2NlbmRpbmcoMHg4MCB8ICgweDNmICYgKGNvZGVQb2ludCA+Pj4gNikpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCeXRlRGVzY2VuZGluZygweDgwIHwgKDB4M2YgJiBjb2RlUG9pbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndyaXRlU2VwYXJhdG9yRGVzY2VuZGluZygpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVOdW1iZXJBc2NlbmRpbmcodmFsKSB7XHJcbiAgICAgICAgLy8gVmFsdWVzIGFyZSBlbmNvZGVkIHdpdGggYSBzaW5nbGUgYnl0ZSBsZW5ndGggcHJlZml4LCBmb2xsb3dlZCBieSB0aGVcclxuICAgICAgICAvLyBhY3R1YWwgdmFsdWUgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2l0aCBsZWFkaW5nIDAgYnl0ZXMgZHJvcHBlZC5cclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudG9PcmRlcmVkQml0cyh2YWwpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHVuc2lnbmVkTnVtTGVuZ3RoKHZhbHVlKTtcclxuICAgICAgICB0aGlzLmVuc3VyZUF2YWlsYWJsZSgxICsgbGVuKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gbGVuICYgMHhmZjsgLy8gV3JpdGUgdGhlIGxlbmd0aFxyXG4gICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZS5sZW5ndGggLSBsZW47IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gdmFsdWVbaV0gJiAweGZmO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHdyaXRlTnVtYmVyRGVzY2VuZGluZyh2YWwpIHtcclxuICAgICAgICAvLyBWYWx1ZXMgYXJlIGVuY29kZWQgd2l0aCBhIHNpbmdsZSBieXRlIGxlbmd0aCBwcmVmaXgsIGZvbGxvd2VkIGJ5IHRoZVxyXG4gICAgICAgIC8vIGludmVydGVkIHZhbHVlIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdpdGggbGVhZGluZyAwIGJ5dGVzIGRyb3BwZWQuXHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRvT3JkZXJlZEJpdHModmFsKTtcclxuICAgICAgICBjb25zdCBsZW4gPSB1bnNpZ25lZE51bUxlbmd0aCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSArIGxlbik7XHJcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IH4obGVuICYgMHhmZik7IC8vIFdyaXRlIHRoZSBsZW5ndGhcclxuICAgICAgICBmb3IgKGxldCBpID0gdmFsdWUubGVuZ3RoIC0gbGVuOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IH4odmFsdWVbaV0gJiAweGZmKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyB0aGUgXCJpbmZpbml0eVwiIGJ5dGUgc2VxdWVuY2UgdGhhdCBzb3J0cyBhZnRlciBhbGwgb3RoZXIgYnl0ZVxyXG4gICAgICogc2VxdWVuY2VzIHdyaXR0ZW4gaW4gYXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZmluaXR5QXNjZW5kaW5nKCkge1xyXG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhFU0NBUEUyKTtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoSU5GSU5JVFkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgdGhlIFwiaW5maW5pdHlcIiBieXRlIHNlcXVlbmNlIHRoYXQgc29ydHMgYmVmb3JlIGFsbCBvdGhlciBieXRlXHJcbiAgICAgKiBzZXF1ZW5jZXMgd3JpdHRlbiBpbiBkZXNjZW5kaW5nIG9yZGVyLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZmluaXR5RGVzY2VuZGluZygpIHtcclxuICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVEZXNjZW5kaW5nKEVTQ0FQRTIpO1xyXG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoSU5GSU5JVFkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGJ1ZmZlciBzdWNoIHRoYXQgaXQgaXMgdGhlIHNhbWUgYXMgd2hlbiBpdCB3YXMgbmV3bHlcclxuICAgICAqIGNvbnN0cnVjdGVkLlxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxuICAgIH1cclxuICAgIHNlZWQoZW5jb2RlZEJ5dGVzKSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoZW5jb2RlZEJ5dGVzLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5idWZmZXIuc2V0KGVuY29kZWRCeXRlcywgdGhpcy5wb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBlbmNvZGVkQnl0ZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqIE1ha2VzIGEgY29weSBvZiB0aGUgZW5jb2RlZCBieXRlcyBpbiB0aGlzIGJ1ZmZlci4gICovXHJcbiAgICBlbmNvZGVkQnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIGB2YWxgIGludG8gYW4gZW5jb2Rpbmcgc28gdGhhdCB0aGUgb3JkZXIgbWF0Y2hlcyB0aGUgSUVFRSA3NTRcclxuICAgICAqIGZsb2F0aW5nLXBvaW50IGNvbXBhcmlzb24gcmVzdWx0cyB3aXRoIHRoZSBmb2xsb3dpbmcgZXhjZXB0aW9uczpcclxuICAgICAqICAgLTAuMCA8IDAuMFxyXG4gICAgICogICBhbGwgbm9uLU5hTiA8IE5hTlxyXG4gICAgICogICBOYU4gPSBOYU5cclxuICAgICAqL1xyXG4gICAgdG9PcmRlcmVkQml0cyh2YWwpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRvdWJsZVRvTG9uZ0JpdHModmFsKTtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlyc3QgYml0IGlzIHNldC4gV2UgdXNlIGEgYml0IG1hc2sgc2luY2UgdmFsdWVbMF0gaXNcclxuICAgICAgICAvLyBlbmNvZGVkIGFzIGEgbnVtYmVyIGZyb20gMCB0byAyNTUuXHJcbiAgICAgICAgY29uc3QgaXNOZWdhdGl2ZSA9ICh2YWx1ZVswXSAmIDB4ODApICE9PSAwO1xyXG4gICAgICAgIC8vIFJldmVydCB0aGUgdHdvIGNvbXBsZW1lbnQgdG8gZ2V0IG5hdHVyYWwgb3JkZXJpbmdcclxuICAgICAgICB2YWx1ZVswXSBePSBpc05lZ2F0aXZlID8gMHhmZiA6IDB4ODA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YWx1ZVtpXSBePSBpc05lZ2F0aXZlID8gMHhmZiA6IDB4MDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKiBXcml0ZXMgYSBzaW5nbGUgYnl0ZSBhc2NlbmRpbmcgdG8gdGhlIGJ1ZmZlci4gKi9cclxuICAgIHdyaXRlQnl0ZUFzY2VuZGluZyhiKSB7XHJcbiAgICAgICAgY29uc3QgbWFza2VkID0gYiAmIDB4ZmY7XHJcbiAgICAgICAgaWYgKG1hc2tlZCA9PT0gRVNDQVBFMSkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRVNDQVBFMSk7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhOVUxMX0JZVEUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXNrZWQgPT09IEVTQ0FQRTIpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTIpO1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcoRkZfQllURSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlRXNjYXBlZEJ5dGVBc2NlbmRpbmcobWFza2VkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogV3JpdGVzIGEgc2luZ2xlIGJ5dGUgZGVzY2VuZGluZyB0byB0aGUgYnVmZmVyLiAgKi9cclxuICAgIHdyaXRlQnl0ZURlc2NlbmRpbmcoYikge1xyXG4gICAgICAgIGNvbnN0IG1hc2tlZCA9IGIgJiAweGZmO1xyXG4gICAgICAgIGlmIChtYXNrZWQgPT09IEVTQ0FQRTEpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUxKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhOVUxMX0JZVEUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXNrZWQgPT09IEVTQ0FQRTIpIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhFU0NBUEUyKTtcclxuICAgICAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhGRl9CWVRFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGVTZXBhcmF0b3JBc2NlbmRpbmcoKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlQXNjZW5kaW5nKEVTQ0FQRTEpO1xyXG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhTRVBBUkFUT1IpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVTZXBhcmF0b3JEZXNjZW5kaW5nKCkge1xyXG4gICAgICAgIHRoaXMud3JpdGVFc2NhcGVkQnl0ZURlc2NlbmRpbmcoRVNDQVBFMSk7XHJcbiAgICAgICAgdGhpcy53cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhTRVBBUkFUT1IpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVFc2NhcGVkQnl0ZUFzY2VuZGluZyhiKSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSk7XHJcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IGI7XHJcbiAgICB9XHJcbiAgICB3cml0ZUVzY2FwZWRCeXRlRGVzY2VuZGluZyhiKSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVBdmFpbGFibGUoMSk7XHJcbiAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IH5iO1xyXG4gICAgfVxyXG4gICAgZW5zdXJlQXZhaWxhYmxlKGJ5dGVzKSB7XHJcbiAgICAgICAgY29uc3QgbWluQ2FwYWNpdHkgPSBieXRlcyArIHRoaXMucG9zaXRpb247XHJcbiAgICAgICAgaWYgKG1pbkNhcGFjaXR5IDw9IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRyeSBkb3VibGluZy5cclxuICAgICAgICBsZXQgbmV3TGVuZ3RoID0gdGhpcy5idWZmZXIubGVuZ3RoICogMjtcclxuICAgICAgICAvLyBTdGlsbCBub3QgYmlnIGVub3VnaD8gSnVzdCBhbGxvY2F0ZSB0aGUgcmlnaHQgc2l6ZS5cclxuICAgICAgICBpZiAobmV3TGVuZ3RoIDwgbWluQ2FwYWNpdHkpIHtcclxuICAgICAgICAgICAgbmV3TGVuZ3RoID0gbWluQ2FwYWNpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IGJ1ZmZlci5cclxuICAgICAgICBjb25zdCBuZXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShuZXdMZW5ndGgpO1xyXG4gICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIpOyAvLyBjb3B5IG9sZCBkYXRhXHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQXNjZW5kaW5nSW5kZXhCeXRlRW5jb2RlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcmRlcmVkQ29kZSkge1xyXG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUgPSBvcmRlcmVkQ29kZTtcclxuICAgIH1cclxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlQnl0ZXNBc2NlbmRpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVTdHJpbmcodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlVXRmOEFzY2VuZGluZyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZU51bWJlcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUud3JpdGVOdW1iZXJBc2NlbmRpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbmZpbml0eSgpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlSW5maW5pdHlBc2NlbmRpbmcoKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBEZXNjZW5kaW5nSW5kZXhCeXRlRW5jb2RlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcmRlcmVkQ29kZSkge1xyXG4gICAgICAgIHRoaXMub3JkZXJlZENvZGUgPSBvcmRlcmVkQ29kZTtcclxuICAgIH1cclxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlQnl0ZXNEZXNjZW5kaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZVV0ZjhEZXNjZW5kaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlTnVtYmVyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS53cml0ZU51bWJlckRlc2NlbmRpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbmZpbml0eSgpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLndyaXRlSW5maW5pdHlEZXNjZW5kaW5nKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYERpcmVjdGlvbmFsSW5kZXhCeXRlRW5jb2RlcmAgdXNpbmcgYE9yZGVyZWRDb2RlV3JpdGVyYCBmb3IgdGhlXHJcbiAqIGFjdHVhbCBlbmNvZGluZy5cclxuICovXHJcbmNsYXNzIEluZGV4Qnl0ZUVuY29kZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZSA9IG5ldyBPcmRlcmVkQ29kZVdyaXRlcigpO1xyXG4gICAgICAgIHRoaXMuYXNjZW5kaW5nID0gbmV3IEFzY2VuZGluZ0luZGV4Qnl0ZUVuY29kZXIodGhpcy5vcmRlcmVkQ29kZSk7XHJcbiAgICAgICAgdGhpcy5kZXNjZW5kaW5nID0gbmV3IERlc2NlbmRpbmdJbmRleEJ5dGVFbmNvZGVyKHRoaXMub3JkZXJlZENvZGUpO1xyXG4gICAgfVxyXG4gICAgc2VlZChlbmNvZGVkQnl0ZXMpIHtcclxuICAgICAgICB0aGlzLm9yZGVyZWRDb2RlLnNlZWQoZW5jb2RlZEJ5dGVzKTtcclxuICAgIH1cclxuICAgIGZvcktpbmQoa2luZCkge1xyXG4gICAgICAgIHJldHVybiBraW5kID09PSAwIC8qIEFTQ0VORElORyAqLyA/IHRoaXMuYXNjZW5kaW5nIDogdGhpcy5kZXNjZW5kaW5nO1xyXG4gICAgfVxyXG4gICAgZW5jb2RlZEJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9yZGVyZWRDb2RlLmVuY29kZWRCeXRlcygpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5vcmRlcmVkQ29kZS5yZXNldCgpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBSZXByZXNlbnRzIGFuIGluZGV4IGVudHJ5IHNhdmVkIGJ5IHRoZSBTREsgaW4gcGVyc2lzdGVkIHN0b3JhZ2UuICovXHJcbmNsYXNzIEluZGV4RW50cnkge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXhJZCwgZG9jdW1lbnRLZXksIGFycmF5VmFsdWUsIGRpcmVjdGlvbmFsVmFsdWUpIHtcclxuICAgICAgICB0aGlzLmluZGV4SWQgPSBpbmRleElkO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRLZXkgPSBkb2N1bWVudEtleTtcclxuICAgICAgICB0aGlzLmFycmF5VmFsdWUgPSBhcnJheVZhbHVlO1xyXG4gICAgICAgIHRoaXMuZGlyZWN0aW9uYWxWYWx1ZSA9IGRpcmVjdGlvbmFsVmFsdWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5kZXhFbnRyeUNvbXBhcmF0b3IobGVmdCwgcmlnaHQpIHtcclxuICAgIGxldCBjbXAgPSBsZWZ0LmluZGV4SWQgLSByaWdodC5pbmRleElkO1xyXG4gICAgaWYgKGNtcCAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICB9XHJcbiAgICBjbXAgPSBEb2N1bWVudEtleS5jb21wYXJhdG9yKGxlZnQuZG9jdW1lbnRLZXksIHJpZ2h0LmRvY3VtZW50S2V5KTtcclxuICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgY21wID0gY29tcGFyZUJ5dGVBcnJheXMobGVmdC5hcnJheVZhbHVlLCByaWdodC5hcnJheVZhbHVlKTtcclxuICAgIGlmIChjbXAgIT09IDApIHtcclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBhcmVCeXRlQXJyYXlzKGxlZnQuZGlyZWN0aW9uYWxWYWx1ZSwgcmlnaHQuZGlyZWN0aW9uYWxWYWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZUJ5dGVBcnJheXMobGVmdCwgcmlnaHQpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdC5sZW5ndGggJiYgaSA8IHJpZ2h0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGFyZSA9IGxlZnRbaV0gLSByaWdodFtpXTtcclxuICAgICAgICBpZiAoY29tcGFyZSAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVmdC5sZW5ndGggLSByaWdodC5sZW5ndGg7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlJbmRleE1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50SW5kZXggPSBuZXcgTWVtb3J5Q29sbGVjdGlvblBhcmVudEluZGV4KCk7XHJcbiAgICB9XHJcbiAgICBhZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvblBhdGgpIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25QYXJlbnRJbmRleC5hZGQoY29sbGVjdGlvblBhdGgpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmNvbGxlY3Rpb25QYXJlbnRJbmRleC5nZXRFbnRyaWVzKGNvbGxlY3Rpb25JZCkpO1xyXG4gICAgfVxyXG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAvLyBGaWVsZCBpbmRpY2VzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbWVtb3J5IHBlcnNpc3RlbmNlLlxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdUYXJnZXQodHJhbnNhY3Rpb24sIGZpZWxkSW5kZXgsIHRhcmdldCkge1xyXG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGRvY3VtZW50S2V5U2V0KCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gRmllbGQgaW5kaWNlcyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICB9XHJcbiAgICBnZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25Hcm91cCkge1xyXG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKFtdKTtcclxuICAgIH1cclxuICAgIGdldE5leHRDb2xsZWN0aW9uR3JvdXBUb1VwZGF0ZSh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIG9mZnNldCkge1xyXG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50cykge1xyXG4gICAgICAgIC8vIEZpZWxkIGluZGljZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBtZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBjb2xsZWN0aW9uLXBhcmVudCBpbmRleCBleHBvc2VkIGJ5IE1lbW9yeUluZGV4TWFuYWdlci5cclxuICogQWxzbyB1c2VkIGZvciBpbi1tZW1vcnkgY2FjaGluZyBieSBJbmRleGVkRGJJbmRleE1hbmFnZXIgYW5kIGluaXRpYWwgaW5kZXggcG9wdWxhdGlvblxyXG4gKiBpbiBpbmRleGVkZGJfc2NoZW1hLnRzXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlDb2xsZWN0aW9uUGFyZW50SW5kZXgge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IHt9O1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgZW50cnkgYWxyZWFkeSBleGlzdGVkLlxyXG4gICAgYWRkKGNvbGxlY3Rpb25QYXRoKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY29sbGVjdGlvblBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyZW50cyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSB8fFxyXG4gICAgICAgICAgICBuZXcgU29ydGVkU2V0KFJlc291cmNlUGF0aC5jb21wYXJhdG9yKTtcclxuICAgICAgICBjb25zdCBhZGRlZCA9ICFleGlzdGluZ1BhcmVudHMuaGFzKHBhcmVudFBhdGgpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXSA9IGV4aXN0aW5nUGFyZW50cy5hZGQocGFyZW50UGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIGFkZGVkO1xyXG4gICAgfVxyXG4gICAgaGFzKGNvbGxlY3Rpb25QYXRoKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY29sbGVjdGlvblBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyZW50cyA9IHRoaXMuaW5kZXhbY29sbGVjdGlvbklkXTtcclxuICAgICAgICByZXR1cm4gZXhpc3RpbmdQYXJlbnRzICYmIGV4aXN0aW5nUGFyZW50cy5oYXMocGFyZW50UGF0aCk7XHJcbiAgICB9XHJcbiAgICBnZXRFbnRyaWVzKGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGhzID0gdGhpcy5pbmRleFtjb2xsZWN0aW9uSWRdIHx8XHJcbiAgICAgICAgICAgIG5ldyBTb3J0ZWRTZXQoUmVzb3VyY2VQYXRoLmNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHJldHVybiBwYXJlbnRQYXRocy50b0FycmF5KCk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyRmID0gJ0luZGV4ZWREYkluZGV4TWFuYWdlcic7XHJcbi8qKlxyXG4gKiBBIHBlcnNpc3RlZCBpbXBsZW1lbnRhdGlvbiBvZiBJbmRleE1hbmFnZXIuXHJcbiAqXHJcbiAqIFBPUlRJTkcgTk9URTogVW5saWtlIGlPUyBhbmQgQW5kcm9pZCwgdGhlIFdlYiBTREsgZG9lcyBub3QgbWVtb2l6ZSBpbmRleFxyXG4gKiBkYXRhIGFzIGl0IHN1cHBvcnRzIG11bHRpLXRhYiBhY2Nlc3MuXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRGJJbmRleE1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IodXNlcikge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gaW4tbWVtb3J5IGNvcHkgb2YgdGhlIGluZGV4IGVudHJpZXMgd2UndmUgYWxyZWFkeSB3cml0dGVuIHNpbmNlIHRoZSBTREtcclxuICAgICAgICAgKiBsYXVuY2hlZC4gVXNlZCB0byBhdm9pZCByZS13cml0aW5nIHRoZSBzYW1lIGVudHJ5IHJlcGVhdGVkbHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzICpOT1QqIGEgY29tcGxldGUgY2FjaGUgb2Ygd2hhdCdzIGluIHBlcnNpc3RlbmNlIGFuZCBzbyBjYW4gbmV2ZXIgYmVcclxuICAgICAgICAgKiB1c2VkIHRvIHNhdGlzZnkgcmVhZHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uUGFyZW50c0NhY2hlID0gbmV3IE1lbW9yeUNvbGxlY3Rpb25QYXJlbnRJbmRleCgpO1xyXG4gICAgICAgIHRoaXMudWlkID0gdXNlci51aWQgfHwgJyc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgZW50cnkgdG8gdGhlIGNvbGxlY3Rpb24gcGFyZW50IGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIFJlcGVhdGVkIGNhbGxzIGZvciB0aGUgc2FtZSBjb2xsZWN0aW9uUGF0aCBzaG91bGQgYmUgYXZvaWRlZCB3aXRoaW4gYVxyXG4gICAgICogdHJhbnNhY3Rpb24gYXMgSW5kZXhlZERiSW5kZXhNYW5hZ2VyIG9ubHkgY2FjaGVzIHdyaXRlcyBvbmNlIGEgdHJhbnNhY3Rpb25cclxuICAgICAqIGhhcyBiZWVuIGNvbW1pdHRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25QYXRoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbGxlY3Rpb25QYXJlbnRzQ2FjaGUuaGFzKGNvbGxlY3Rpb25QYXRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBjb2xsZWN0aW9uUGF0aC5sYXN0U2VnbWVudCgpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gY29sbGVjdGlvblBhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5hZGRPbkNvbW1pdHRlZExpc3RlbmVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29sbGVjdGlvbiB0byB0aGUgaW4gbWVtb3J5IGNhY2hlIG9ubHkgaWYgdGhlIHRyYW5zYWN0aW9uIHdhc1xyXG4gICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bGx5IGNvbW1pdHRlZC5cclxuICAgICAgICAgICAgICAgIHRoaXMuY29sbGVjdGlvblBhcmVudHNDYWNoZS5hZGQoY29sbGVjdGlvblBhdGgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblBhcmVudCA9IHtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZCxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogZW5jb2RlUmVzb3VyY2VQYXRoKHBhcmVudFBhdGgpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uUGFyZW50c1N0b3JlKHRyYW5zYWN0aW9uKS5wdXQoY29sbGVjdGlvblBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29sbGVjdGlvblBhcmVudHModHJhbnNhY3Rpb24sIGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGhzID0gW107XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY29sbGVjdGlvbklkLCAnJ10sIFtpbW1lZGlhdGVTdWNjZXNzb3IoY29sbGVjdGlvbklkKSwgJyddLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5sb2FkQWxsKHJhbmdlKVxyXG4gICAgICAgICAgICAubmV4dChlbnRyaWVzID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvbGxlY3Rpb25JZCBndWFyZCBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IChhbmQgaXNuJ3QgYXMgbG9uZ1xyXG4gICAgICAgICAgICAgICAgLy8gYXMgd2UncmUgcnVubmluZyBpbiBhIHJlYWwgYnJvd3NlciksIGJ1dCB0aGVyZSdzIGEgYnVnIGluXHJcbiAgICAgICAgICAgICAgICAvLyBpbmRleGVkZGJzaGltIHRoYXQgYnJlYWtzIG91ciByYW5nZSBpbiBvdXIgdGVzdHMgcnVubmluZyBpbiBub2RlOlxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F4ZW1jbGlvbi9JbmRleGVkREJTaGltL2lzc3Vlcy8zMzRcclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5jb2xsZWN0aW9uSWQgIT09IGNvbGxlY3Rpb25JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50UGF0aHMucHVzaChkZWNvZGVSZXNvdXJjZVBhdGgoZW50cnkucGFyZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFBhdGhzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkRmllbGRJbmRleCh0cmFuc2FjdGlvbiwgaW5kZXgpIHtcclxuICAgICAgICAvLyBUT0RPKGluZGV4aW5nKTogVmVyaWZ5IHRoYXQgdGhlIGF1dG8taW5jcmVtZW50aW5nIGluZGV4IElEIHdvcmtzIGluXHJcbiAgICAgICAgLy8gU2FmYXJpICYgRmlyZWZveC5cclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGRiSW5kZXggPSB0b0RiSW5kZXhDb25maWd1cmF0aW9uKGluZGV4KTtcclxuICAgICAgICBkZWxldGUgZGJJbmRleC5pbmRleElkOyAvLyBgaW5kZXhJZGAgaXMgYXV0by1wb3B1bGF0ZWQgYnkgSW5kZXhlZERiXHJcbiAgICAgICAgcmV0dXJuIGluZGV4ZXMuYWRkKGRiSW5kZXgpLm5leHQoKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZUZpZWxkSW5kZXgodHJhbnNhY3Rpb24sIGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhlcyA9IGluZGV4Q29uZmlndXJhdGlvblN0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBpbmRleEVudHJpZXNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ZXNcclxuICAgICAgICAgICAgLmRlbGV0ZShpbmRleC5pbmRleElkKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBzdGF0ZXMuZGVsZXRlKElEQktleVJhbmdlLmJvdW5kKFtpbmRleC5pbmRleElkXSwgW2luZGV4LmluZGV4SWQgKyAxXSwgXHJcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxyXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZW50cmllcy5kZWxldGUoSURCS2V5UmFuZ2UuYm91bmQoW2luZGV4LmluZGV4SWRdLCBbaW5kZXguaW5kZXhJZCArIDFdLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSkpKTtcclxuICAgIH1cclxuICAgIGdldERvY3VtZW50c01hdGNoaW5nVGFyZ2V0KHRyYW5zYWN0aW9uLCBmaWVsZEluZGV4LCB0YXJnZXQpIHtcclxuICAgICAgICAvLyBUT0RPKGluZGV4aW5nKTogSW1wbGVtZW50XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGRvY3VtZW50S2V5U2V0KCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0RmllbGRJbmRleCh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gVE9ETyhpbmRleGluZyk6IEltcGxlbWVudFxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYnl0ZSBlbmNvZGVkIGZvcm0gb2YgdGhlIGRpcmVjdGlvbmFsIHZhbHVlcyBpbiB0aGUgZmllbGQgaW5kZXguXHJcbiAgICAgKiBSZXR1cm5zIGBudWxsYCBpZiB0aGUgZG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBhbGwgZmllbGRzIHNwZWNpZmllZCBpbiB0aGVcclxuICAgICAqIGluZGV4LlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVEaXJlY3Rpb25hbEVsZW1lbnRzKGZpZWxkSW5kZXgsIGRvY3VtZW50KSB7XHJcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBzZWdtZW50IG9mIGZpZWxkSW5kZXhHZXREaXJlY3Rpb25hbFNlZ21lbnRzKGZpZWxkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZG9jdW1lbnQuZGF0YS5maWVsZChzZWdtZW50LmZpZWxkUGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25hbEVuY29kZXIgPSBlbmNvZGVyLmZvcktpbmQoc2VnbWVudC5raW5kKTtcclxuICAgICAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUoZmllbGQsIGRpcmVjdGlvbmFsRW5jb2Rlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbmNvZGVyLmVuY29kZWRCeXRlcygpO1xyXG4gICAgfVxyXG4gICAgLyoqIEVuY29kZXMgYSBzaW5nbGUgdmFsdWUgdG8gdGhlIGFzY2VuZGluZyBpbmRleCBmb3JtYXQuICovXHJcbiAgICBlbmNvZGVTaW5nbGVFbGVtZW50KHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBJbmRleEJ5dGVFbmNvZGVyKCk7XHJcbiAgICAgICAgRmlyZXN0b3JlSW5kZXhWYWx1ZVdyaXRlci5JTlNUQU5DRS53cml0ZUluZGV4VmFsdWUodmFsdWUsIGVuY29kZXIuZm9yS2luZCgwIC8qIEFTQ0VORElORyAqLykpO1xyXG4gICAgICAgIHJldHVybiBlbmNvZGVyLmVuY29kZWRCeXRlcygpO1xyXG4gICAgfVxyXG4gICAgZ2V0RmllbGRJbmRleGVzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIChjb2xsZWN0aW9uR3JvdXBcclxuICAgICAgICAgICAgPyBpbmRleGVzLmxvYWRBbGwoRGJJbmRleENvbmZpZ3VyYXRpb24uY29sbGVjdGlvbkdyb3VwSW5kZXgsIElEQktleVJhbmdlLmJvdW5kKGNvbGxlY3Rpb25Hcm91cCwgY29sbGVjdGlvbkdyb3VwKSlcclxuICAgICAgICAgICAgOiBpbmRleGVzLmxvYWRBbGwoKSkubmV4dChpbmRleENvbmZpZ3MgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGluZGV4Q29uZmlncywgKGluZGV4Q29uZmlnKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldChbaW5kZXhDb25maWcuaW5kZXhJZCwgdGhpcy51aWRdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGluZGV4U3RhdGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyb21EYkluZGV4Q29uZmlndXJhdGlvbihpbmRleENvbmZpZywgaW5kZXhTdGF0ZSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldE5leHRDb2xsZWN0aW9uR3JvdXBUb1VwZGF0ZSh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkSW5kZXhlcyh0cmFuc2FjdGlvbikubmV4dChpbmRleGVzID0+IHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmRleGVzLnNvcnQoKGwsIHIpID0+IGwuaW5kZXhTdGF0ZS5zZXF1ZW5jZU51bWJlciAtIHIuaW5kZXhTdGF0ZS5zZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleGVzWzBdLmNvbGxlY3Rpb25Hcm91cDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUNvbGxlY3Rpb25Hcm91cCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBvZmZzZXQpIHtcclxuICAgICAgICBjb25zdCBpbmRleGVzID0gaW5kZXhDb25maWd1cmF0aW9uU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGluZGV4U3RhdGVTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV4dFNlcXVlbmNlTnVtYmVyKHRyYW5zYWN0aW9uKS5uZXh0KG5leHRTZXF1ZW5jZU51bWJlciA9PiBpbmRleGVzXHJcbiAgICAgICAgICAgIC5sb2FkQWxsKERiSW5kZXhDb25maWd1cmF0aW9uLmNvbGxlY3Rpb25Hcm91cEluZGV4LCBJREJLZXlSYW5nZS5ib3VuZChjb2xsZWN0aW9uR3JvdXAsIGNvbGxlY3Rpb25Hcm91cCkpXHJcbiAgICAgICAgICAgIC5uZXh0KGNvbmZpZ3MgPT4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goY29uZmlncywgKGNvbmZpZykgPT4gc3RhdGVzLnB1dCh0b0RiSW5kZXhTdGF0ZShjb25maWcuaW5kZXhJZCwgdGhpcy51c2VyLCBuZXh0U2VxdWVuY2VOdW1iZXIsIG9mZnNldCkpKSkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudHMpIHtcclxuICAgICAgICAvLyBQb3J0aW5nIE5vdGU6IGBnZXRGaWVsZEluZGV4ZXMoKWAgb24gV2ViIGRvZXMgbm90IGNhY2hlIGluZGV4IGxvb2t1cHMgYXNcclxuICAgICAgICAvLyBpdCBjb3VsZCBiZSB1c2VkIGFjcm9zcyBkaWZmZXJlbnQgSW5kZXhlZERCIHRyYW5zYWN0aW9ucy4gQXMgYW55IGNhY2hlZFxyXG4gICAgICAgIC8vIGRhdGEgbWlnaHQgYmUgaW52YWxpZGF0ZWQgYnkgb3RoZXIgbXVsdGktdGFiIGNsaWVudHMsIHdlIGNhbiBvbmx5IHRydXN0XHJcbiAgICAgICAgLy8gZGF0YSB3aXRoaW4gYSBzaW5nbGUgSW5kZXhlZERCIHRyYW5zYWN0aW9uLiBXZSB0aGVyZWZvcmUgYWRkIGEgY2FjaGVcclxuICAgICAgICAvLyBoZXJlLlxyXG4gICAgICAgIGNvbnN0IG1lbW9pemVkSW5kZXhlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goZG9jdW1lbnRzLCAoa2V5LCBkb2MpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWVtb2l6ZWRDb2xsZWN0aW9uSW5kZXhlcyA9IG1lbW9pemVkSW5kZXhlcy5nZXQoa2V5LmNvbGxlY3Rpb25Hcm91cCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5kZXhlcyA9IG1lbW9pemVkQ29sbGVjdGlvbkluZGV4ZXNcclxuICAgICAgICAgICAgICAgID8gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobWVtb2l6ZWRDb2xsZWN0aW9uSW5kZXhlcylcclxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXRGaWVsZEluZGV4ZXModHJhbnNhY3Rpb24sIGtleS5jb2xsZWN0aW9uR3JvdXApO1xyXG4gICAgICAgICAgICByZXR1cm4gZmllbGRJbmRleGVzLm5leHQoZmllbGRJbmRleGVzID0+IHtcclxuICAgICAgICAgICAgICAgIG1lbW9pemVkSW5kZXhlcy5zZXQoa2V5LmNvbGxlY3Rpb25Hcm91cCwgZmllbGRJbmRleGVzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChmaWVsZEluZGV4ZXMsIChmaWVsZEluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhpc3RpbmdJbmRleEVudHJpZXModHJhbnNhY3Rpb24sIGtleSwgZmllbGRJbmRleCkubmV4dChleGlzdGluZ0VudHJpZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdFbnRyaWVzID0gdGhpcy5jb21wdXRlSW5kZXhFbnRyaWVzKGRvYywgZmllbGRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdFbnRyaWVzLmlzRXF1YWwobmV3RW50cmllcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUVudHJpZXModHJhbnNhY3Rpb24sIGRvYywgZXhpc3RpbmdFbnRyaWVzLCBuZXdFbnRyaWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFkZEluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBpbmRleEVudHJ5KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhFbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiBpbmRleEVudHJpZXMucHV0KG5ldyBEYkluZGV4RW50cnkoaW5kZXhFbnRyeS5pbmRleElkLCB0aGlzLnVpZCwgaW5kZXhFbnRyeS5hcnJheVZhbHVlLCBpbmRleEVudHJ5LmRpcmVjdGlvbmFsVmFsdWUsIGVuY29kZVJlc291cmNlUGF0aChkb2N1bWVudC5rZXkucGF0aCkpKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZUluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBpbmRleEVudHJ5KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhFbnRyaWVzID0gaW5kZXhFbnRyaWVzU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiBpbmRleEVudHJpZXMuZGVsZXRlKFtcclxuICAgICAgICAgICAgaW5kZXhFbnRyeS5pbmRleElkLFxyXG4gICAgICAgICAgICB0aGlzLnVpZCxcclxuICAgICAgICAgICAgaW5kZXhFbnRyeS5hcnJheVZhbHVlLFxyXG4gICAgICAgICAgICBpbmRleEVudHJ5LmRpcmVjdGlvbmFsVmFsdWUsXHJcbiAgICAgICAgICAgIGVuY29kZVJlc291cmNlUGF0aChkb2N1bWVudC5rZXkucGF0aClcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGdldEV4aXN0aW5nSW5kZXhFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSwgZmllbGRJbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4RW50cmllcyA9IGluZGV4RW50cmllc1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQoaW5kZXhFbnRyeUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHJldHVybiBpbmRleEVudHJpZXNcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJJbmRleEVudHJ5LmRvY3VtZW50S2V5SW5kZXgsXHJcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS5vbmx5KFtcclxuICAgICAgICAgICAgICAgIGZpZWxkSW5kZXguaW5kZXhJZCxcclxuICAgICAgICAgICAgICAgIHRoaXMudWlkLFxyXG4gICAgICAgICAgICAgICAgZW5jb2RlUmVzb3VyY2VQYXRoKGRvY3VtZW50S2V5LnBhdGgpXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgfSwgKF8sIGVudHJ5KSA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmFkZChuZXcgSW5kZXhFbnRyeShmaWVsZEluZGV4LmluZGV4SWQsIGRvY3VtZW50S2V5LCBlbnRyeS5hcnJheVZhbHVlLCBlbnRyeS5kaXJlY3Rpb25hbFZhbHVlKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlcyB0aGUgaW5kZXggZW50cmllcyBmb3IgdGhlIGdpdmVuIGRvY3VtZW50LiAqL1xyXG4gICAgY29tcHV0ZUluZGV4RW50cmllcyhkb2N1bWVudCwgZmllbGRJbmRleCkge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gbmV3IFNvcnRlZFNldChpbmRleEVudHJ5Q29tcGFyYXRvcik7XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uYWxWYWx1ZSA9IHRoaXMuZW5jb2RlRGlyZWN0aW9uYWxFbGVtZW50cyhmaWVsZEluZGV4LCBkb2N1bWVudCk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbmFsVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXJyYXlTZWdtZW50ID0gZmllbGRJbmRleEdldEFycmF5U2VnbWVudChmaWVsZEluZGV4KTtcclxuICAgICAgICBpZiAoYXJyYXlTZWdtZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb2N1bWVudC5kYXRhLmZpZWxkKGFycmF5U2VnbWVudC5maWVsZFBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXJyYXlWYWx1ZSBvZiB2YWx1ZS5hcnJheVZhbHVlLnZhbHVlcyB8fCBbXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmFkZChuZXcgSW5kZXhFbnRyeShmaWVsZEluZGV4LmluZGV4SWQsIGRvY3VtZW50LmtleSwgdGhpcy5lbmNvZGVTaW5nbGVFbGVtZW50KGFycmF5VmFsdWUpLCBkaXJlY3Rpb25hbFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmFkZChuZXcgSW5kZXhFbnRyeShmaWVsZEluZGV4LmluZGV4SWQsIGRvY3VtZW50LmtleSwgbmV3IFVpbnQ4QXJyYXkoKSwgZGlyZWN0aW9uYWxWYWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgaW5kZXggZW50cmllcyBmb3IgdGhlIHByb3ZpZGVkIGRvY3VtZW50IGJ5IGRlbGV0aW5nIGVudHJpZXNcclxuICAgICAqIHRoYXQgYXJlIG5vIGxvbmdlciByZWZlcmVuY2VkIGluIGBuZXdFbnRyaWVzYCBhbmQgYWRkaW5nIGFsbCBuZXdseSBhZGRlZFxyXG4gICAgICogZW50cmllcy5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGV4aXN0aW5nRW50cmllcywgbmV3RW50cmllcykge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckZiwgXCJVcGRhdGluZyBpbmRleCBlbnRyaWVzIGZvciBkb2N1bWVudCAnJXMnXCIsIGRvY3VtZW50LmtleSk7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBkaWZmU29ydGVkU2V0cyhleGlzdGluZ0VudHJpZXMsIG5ld0VudHJpZXMsIGluZGV4RW50cnlDb21wYXJhdG9yLCBcclxuICAgICAgICAvKiBvbkFkZD0gKi8gZW50cnkgPT4ge1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuYWRkSW5kZXhFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnQsIGVudHJ5KSk7XHJcbiAgICAgICAgfSwgXHJcbiAgICAgICAgLyogb25SZW1vdmU9ICovIGVudHJ5ID0+IHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRlbGV0ZUluZGV4RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50LCBlbnRyeSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XHJcbiAgICB9XHJcbiAgICBnZXROZXh0U2VxdWVuY2VOdW1iZXIodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBsZXQgbmV4dFNlcXVlbmNlTnVtYmVyID0gMTtcclxuICAgICAgICBjb25zdCBzdGF0ZXMgPSBpbmRleFN0YXRlU3RvcmUodHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiBzdGF0ZXNcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJJbmRleFN0YXRlLnNlcXVlbmNlTnVtYmVySW5kZXgsXHJcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWUsXHJcbiAgICAgICAgICAgIHJhbmdlOiBJREJLZXlSYW5nZS51cHBlckJvdW5kKFt0aGlzLnVpZCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJdKVxyXG4gICAgICAgIH0sIChfLCBzdGF0ZSwgY29udHJvbGxlcikgPT4ge1xyXG4gICAgICAgICAgICBjb250cm9sbGVyLmRvbmUoKTtcclxuICAgICAgICAgICAgbmV4dFNlcXVlbmNlTnVtYmVyID0gc3RhdGUuc2VxdWVuY2VOdW1iZXIgKyAxO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IG5leHRTZXF1ZW5jZU51bWJlcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgY29sbGVjdGlvblBhcmVudHNcclxuICogZG9jdW1lbnQgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb2xsZWN0aW9uUGFyZW50c1N0b3JlKHR4bikge1xyXG4gICAgcmV0dXJuIGdldFN0b3JlKHR4biwgRGJDb2xsZWN0aW9uUGFyZW50LnN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBpbmRleCBlbnRyeSBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmRleEVudHJpZXNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiSW5kZXhFbnRyeS5zdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgaW5kZXggY29uZmlndXJhdGlvbiBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmRleENvbmZpZ3VyYXRpb25TdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiSW5kZXhDb25maWd1cmF0aW9uLnN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBpbmRleCBzdGF0ZSBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmRleFN0YXRlU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkluZGV4U3RhdGUuc3RvcmUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEZWxldGUgYSBtdXRhdGlvbiBiYXRjaCBhbmQgdGhlIGFzc29jaWF0ZWQgZG9jdW1lbnQgbXV0YXRpb25zLlxyXG4gKiBAcmV0dXJucyBBIFBlcnNpc3RlbmNlUHJvbWlzZSBvZiB0aGUgZG9jdW1lbnQgbXV0YXRpb25zIHRoYXQgd2VyZSByZW1vdmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlTXV0YXRpb25CYXRjaCh0eG4sIHVzZXJJZCwgYmF0Y2gpIHtcclxuICAgIGNvbnN0IG11dGF0aW9uU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoLnN0b3JlKTtcclxuICAgIGNvbnN0IGluZGV4VHhuID0gdHhuLnN0b3JlKERiRG9jdW1lbnRNdXRhdGlvbi5zdG9yZSk7XHJcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5vbmx5KGJhdGNoLmJhdGNoSWQpO1xyXG4gICAgbGV0IG51bURlbGV0ZWQgPSAwO1xyXG4gICAgY29uc3QgcmVtb3ZlUHJvbWlzZSA9IG11dGF0aW9uU3RvcmUuaXRlcmF0ZSh7IHJhbmdlIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgbnVtRGVsZXRlZCsrO1xyXG4gICAgICAgIHJldHVybiBjb250cm9sLmRlbGV0ZSgpO1xyXG4gICAgfSk7XHJcbiAgICBwcm9taXNlcy5wdXNoKHJlbW92ZVByb21pc2UubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgaGFyZEFzc2VydChudW1EZWxldGVkID09PSAxKTtcclxuICAgIH0pKTtcclxuICAgIGNvbnN0IHJlbW92ZWREb2N1bWVudHMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXhLZXkgPSBEYkRvY3VtZW50TXV0YXRpb24ua2V5KHVzZXJJZCwgbXV0YXRpb24ua2V5LnBhdGgsIGJhdGNoLmJhdGNoSWQpO1xyXG4gICAgICAgIHByb21pc2VzLnB1c2goaW5kZXhUeG4uZGVsZXRlKGluZGV4S2V5KSk7XHJcbiAgICAgICAgcmVtb3ZlZERvY3VtZW50cy5wdXNoKG11dGF0aW9uLmtleSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gcmVtb3ZlZERvY3VtZW50cyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYXBwcm94aW1hdGUgc2l6ZSBmb3IgdGhlIGdpdmVuIGRvY3VtZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZGJEb2N1bWVudFNpemUoZG9jKSB7XHJcbiAgICBpZiAoIWRvYykge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgbGV0IHZhbHVlO1xyXG4gICAgaWYgKGRvYy5kb2N1bWVudCkge1xyXG4gICAgICAgIHZhbHVlID0gZG9jLmRvY3VtZW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZG9jLnVua25vd25Eb2N1bWVudCkge1xyXG4gICAgICAgIHZhbHVlID0gZG9jLnVua25vd25Eb2N1bWVudDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGRvYy5ub0RvY3VtZW50KSB7XHJcbiAgICAgICAgdmFsdWUgPSBkb2Mubm9Eb2N1bWVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkubGVuZ3RoO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBBIG11dGF0aW9uIHF1ZXVlIGZvciBhIHNwZWNpZmljIHVzZXIsIGJhY2tlZCBieSBJbmRleGVkREIuICovXHJcbmNsYXNzIEluZGV4ZWREYk11dGF0aW9uUXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBub3JtYWxpemVkIHVzZXJJZCAoZS5nLiBudWxsIFVJRCA9PiBcIlwiIHVzZXJJZCkgdXNlZCB0byBzdG9yZSAvXHJcbiAgICAgKiByZXRyaWV2ZSBtdXRhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHVzZXJJZCwgc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSkge1xyXG4gICAgICAgIHRoaXMudXNlcklkID0gdXNlcklkO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBpbmRleE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IHJlZmVyZW5jZURlbGVnYXRlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhY2hlcyB0aGUgZG9jdW1lbnQga2V5cyBmb3IgcGVuZGluZyBtdXRhdGlvbiBiYXRjaGVzLiBJZiB0aGUgbXV0YXRpb25cclxuICAgICAgICAgKiBoYXMgYmVlbiByZW1vdmVkIGZyb20gSW5kZXhlZERiLCB0aGUgY2FjaGVkIHZhbHVlIG1heSBjb250aW51ZSB0b1xyXG4gICAgICAgICAqIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIGJhdGNoJ3MgZG9jdW1lbnQga2V5cy4gVG8gcmVtb3ZlIGEgY2FjaGVkIHZhbHVlXHJcbiAgICAgICAgICogbG9jYWxseSwgYHJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cygpYCBzaG91bGQgYmUgaW52b2tlZCBlaXRoZXIgZGlyZWN0bHlcclxuICAgICAgICAgKiBvciB0aHJvdWdoIGByZW1vdmVNdXRhdGlvbkJhdGNoZXMoKWAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaXRoIG11bHRpLXRhYiwgd2hlbiB0aGUgcHJpbWFyeSBjbGllbnQgYWNrbm93bGVkZ2VzIG9yIHJlamVjdHMgYSBtdXRhdGlvbixcclxuICAgICAgICAgKiB0aGlzIGNhY2hlIGlzIHVzZWQgYnkgc2Vjb25kYXJ5IGNsaWVudHMgdG8gaW52YWxpZGF0ZSB0aGUgbG9jYWxcclxuICAgICAgICAgKiB2aWV3IG9mIHRoZSBkb2N1bWVudHMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgYWZmZWN0ZWQgYnkgdGhlIG11dGF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWQgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBtdXRhdGlvbiBxdWV1ZSBmb3IgdGhlIGdpdmVuIHVzZXIuXHJcbiAgICAgKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyIGZvciB3aGljaCB0byBjcmVhdGUgYSBtdXRhdGlvbiBxdWV1ZS5cclxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIHNlcmlhbGl6ZXIgdG8gdXNlIHdoZW4gcGVyc2lzdGluZyB0byBJbmRleGVkRGIuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JVc2VyKHVzZXIsIHNlcmlhbGl6ZXIsIGluZGV4TWFuYWdlciwgcmVmZXJlbmNlRGVsZWdhdGUpIHtcclxuICAgICAgICAvLyBUT0RPKG1jZyk6IEZpZ3VyZSBvdXQgd2hhdCBjb25zdHJhaW50cyB0aGVyZSBhcmUgb24gdXNlcklEc1xyXG4gICAgICAgIC8vIEluIHBhcnRpY3VsYXIsIGFyZSB0aGVyZSBhbnkgcmVzZXJ2ZWQgY2hhcmFjdGVycz8gYXJlIGVtcHR5IGlkcyBhbGxvd2VkP1xyXG4gICAgICAgIC8vIEZvciB0aGUgbW9tZW50IHN0b3JlIHRoZXNlIHRvZ2V0aGVyIGluIHRoZSBzYW1lIG11dGF0aW9ucyB0YWJsZSBhc3N1bWluZ1xyXG4gICAgICAgIC8vIHRoYXQgZW1wdHkgdXNlcklEcyBhcmVuJ3QgYWxsb3dlZC5cclxuICAgICAgICBoYXJkQXNzZXJ0KHVzZXIudWlkICE9PSAnJyk7XHJcbiAgICAgICAgY29uc3QgdXNlcklkID0gdXNlci5pc0F1dGhlbnRpY2F0ZWQoKSA/IHVzZXIudWlkIDogJyc7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRGJNdXRhdGlvblF1ZXVlKHVzZXJJZCwgc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0VtcHR5KHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgbGV0IGVtcHR5ID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0aGlzLnVzZXJJZCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXSwgW3RoaXMudXNlcklkLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldKTtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiTXV0YXRpb25CYXRjaC51c2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlIH0sIChrZXksIHZhbHVlLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGVtcHR5KTtcclxuICAgIH1cclxuICAgIGFkZE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudFN0b3JlID0gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25TdG9yZSA9IG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAvLyBUaGUgSW5kZXhlZERiIGltcGxlbWVudGF0aW9uIGluIENocm9tZSAoYW5kIEZpcmVmb3gpIGRvZXMgbm90IGhhbmRsZVxyXG4gICAgICAgIC8vIGNvbXBvdW5kIGluZGljZXMgdGhhdCBpbmNsdWRlIGF1dG8tZ2VuZXJhdGVkIGtleXMgY29ycmVjdGx5LiBUbyBlbnN1cmVcclxuICAgICAgICAvLyB0aGF0IHRoZSBpbmRleCBlbnRyeSBpcyBhZGRlZCBjb3JyZWN0bHkgaW4gYWxsIGJyb3dzZXJzLCB3ZSBwZXJmb3JtIHR3b1xyXG4gICAgICAgIC8vIHdyaXRlczogVGhlIGZpcnN0IHdyaXRlIGlzIHVzZWQgdG8gcmV0cmlldmUgdGhlIG5leHQgYXV0by1nZW5lcmF0ZWQgQmF0Y2hcclxuICAgICAgICAvLyBJRCwgYW5kIHRoZSBzZWNvbmQgd3JpdGUgcG9wdWxhdGVzIHRoZSBpbmRleCBhbmQgc3RvcmVzIHRoZSBhY3R1YWxcclxuICAgICAgICAvLyBtdXRhdGlvbiBiYXRjaC5cclxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTcwMTk3MlxyXG4gICAgICAgIC8vIFdlIHdyaXRlIGFuIGVtcHR5IG9iamVjdCB0byBvYnRhaW4ga2V5XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25TdG9yZS5hZGQoe30pLm5leHQoYmF0Y2hJZCA9PiB7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIGJhdGNoSWQgPT09ICdudW1iZXInKTtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBuZXcgTXV0YXRpb25CYXRjaChiYXRjaElkLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKTtcclxuICAgICAgICAgICAgY29uc3QgZGJCYXRjaCA9IHRvRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgdGhpcy51c2VySWQsIGJhdGNoKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb25QYXJlbnRzID0gbmV3IFNvcnRlZFNldCgobCwgcikgPT4gcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNhbm9uaWNhbFN0cmluZygpLCByLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEtleSA9IERiRG9jdW1lbnRNdXRhdGlvbi5rZXkodGhpcy51c2VySWQsIG11dGF0aW9uLmtleS5wYXRoLCBiYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzID0gY29sbGVjdGlvblBhcmVudHMuYWRkKG11dGF0aW9uLmtleS5wYXRoLnBvcExhc3QoKSk7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG11dGF0aW9uU3RvcmUucHV0KGRiQmF0Y2gpKTtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZG9jdW1lbnRTdG9yZS5wdXQoaW5kZXhLZXksIERiRG9jdW1lbnRNdXRhdGlvbi5QTEFDRUhPTERFUikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb25QYXJlbnRzLmZvckVhY2gocGFyZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5pbmRleE1hbmFnZXIuYWRkVG9Db2xsZWN0aW9uUGFyZW50SW5kZXgodHJhbnNhY3Rpb24sIHBhcmVudCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWRkT25Db21taXR0ZWRMaXN0ZW5lcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSA9IGJhdGNoLmtleXMoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykubmV4dCgoKSA9PiBiYXRjaCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBsb29rdXBNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaElkKSB7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuZ2V0KGJhdGNoSWQpXHJcbiAgICAgICAgICAgIC5uZXh0KGRiQmF0Y2ggPT4ge1xyXG4gICAgICAgICAgICBpZiAoZGJCYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChkYkJhdGNoLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb21EYk11dGF0aW9uQmF0Y2godGhpcy5zZXJpYWxpemVyLCBkYkJhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZG9jdW1lbnQga2V5cyBmb3IgdGhlIG11dGF0aW9uIGJhdGNoIHdpdGggdGhlIGdpdmVuIGJhdGNoSWQuXHJcbiAgICAgKiBGb3IgcHJpbWFyeSBjbGllbnRzLCB0aGlzIG1ldGhvZCByZXR1cm5zIGBudWxsYCBhZnRlclxyXG4gICAgICogYHJlbW92ZU11dGF0aW9uQmF0Y2hlcygpYCBoYXMgYmVlbiBjYWxsZWQuIFNlY29uZGFyeSBjbGllbnRzIHJldHVybiBhXHJcbiAgICAgKiBjYWNoZWQgcmVzdWx0IHVudGlsIGByZW1vdmVDYWNoZWRNdXRhdGlvbktleXMoKWAgaXMgaW52b2tlZC5cclxuICAgICAqL1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cclxuICAgIGxvb2t1cE11dGF0aW9uS2V5cyh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50S2V5c0J5QmF0Y2hJZFtiYXRjaElkXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwTXV0YXRpb25CYXRjaCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkubmV4dChiYXRjaCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gYmF0Y2gua2V5cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRLZXlzQnlCYXRjaElkW2JhdGNoSWRdID0ga2V5cztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXROZXh0TXV0YXRpb25CYXRjaEFmdGVyQmF0Y2hJZCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xyXG4gICAgICAgIGNvbnN0IG5leHRCYXRjaElkID0gYmF0Y2hJZCArIDE7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKFt0aGlzLnVzZXJJZCwgbmV4dEJhdGNoSWRdKTtcclxuICAgICAgICBsZXQgZm91bmRCYXRjaCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IGluZGV4OiBEYk11dGF0aW9uQmF0Y2gudXNlck11dGF0aW9uc0luZGV4LCByYW5nZSB9LCAoa2V5LCBkYkJhdGNoLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkYkJhdGNoLnVzZXJJZCA9PT0gdGhpcy51c2VySWQpIHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGJCYXRjaC5iYXRjaElkID49IG5leHRCYXRjaElkKTtcclxuICAgICAgICAgICAgICAgIGZvdW5kQmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gZm91bmRCYXRjaCk7XHJcbiAgICB9XHJcbiAgICBnZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS51cHBlckJvdW5kKFtcclxuICAgICAgICAgICAgdGhpcy51c2VySWQsXHJcbiAgICAgICAgICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGxldCBiYXRjaElkID0gQkFUQ0hJRF9VTktOT1dOO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyBpbmRleDogRGJNdXRhdGlvbkJhdGNoLnVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UsIHJldmVyc2U6IHRydWUgfSwgKGtleSwgZGJCYXRjaCwgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICBiYXRjaElkID0gZGJCYXRjaC5iYXRjaElkO1xyXG4gICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBiYXRjaElkKTtcclxuICAgIH1cclxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3RoaXMudXNlcklkLCBCQVRDSElEX1VOS05PV05dLCBbdGhpcy51c2VySWQsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0pO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmxvYWRBbGwoRGJNdXRhdGlvbkJhdGNoLnVzZXJNdXRhdGlvbnNJbmRleCwgcmFuZ2UpXHJcbiAgICAgICAgICAgIC5uZXh0KGRiQmF0Y2hlcyA9PiBkYkJhdGNoZXMubWFwKGRiQmF0Y2ggPT4gZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIGRiQmF0Y2gpKSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICAvLyBTY2FuIHRoZSBkb2N1bWVudC1tdXRhdGlvbiBpbmRleCBzdGFydGluZyB3aXRoIGEgcHJlZml4IHN0YXJ0aW5nIHdpdGhcclxuICAgICAgICAvLyB0aGUgZ2l2ZW4gZG9jdW1lbnRLZXkuXHJcbiAgICAgICAgY29uc3QgaW5kZXhQcmVmaXggPSBEYkRvY3VtZW50TXV0YXRpb24ucHJlZml4Rm9yUGF0aCh0aGlzLnVzZXJJZCwgZG9jdW1lbnRLZXkucGF0aCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhTdGFydCA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoaW5kZXhQcmVmaXgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRNdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZTogaW5kZXhTdGFydCB9LCAoaW5kZXhLZXksIF8sIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW3VzZXJJRCwgZW5jb2RlZFBhdGgsIGJhdGNoSWRdID0gaW5kZXhLZXk7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgY29uc2lkZXIgcm93cyBtYXRjaGluZyBleGFjdGx5IHRoZSBzcGVjaWZpYyBrZXkgb2ZcclxuICAgICAgICAgICAgLy8gaW50ZXJlc3QuIE5vdGUgdGhhdCBiZWNhdXNlIHdlIG9yZGVyIGJ5IHBhdGggZmlyc3QsIGFuZCB3ZVxyXG4gICAgICAgICAgICAvLyBvcmRlciB0ZXJtaW5hdG9ycyBiZWZvcmUgcGF0aCBzZXBhcmF0b3JzLCB3ZSdsbCBlbmNvdW50ZXIgYWxsXHJcbiAgICAgICAgICAgIC8vIHRoZSBpbmRleCByb3dzIGZvciBkb2N1bWVudEtleSBjb250aWd1b3VzbHkuIEluIHBhcnRpY3VsYXIsIGFsbFxyXG4gICAgICAgICAgICAvLyB0aGUgcm93cyBmb3IgZG9jdW1lbnRLZXkgd2lsbCBvY2N1ciBiZWZvcmUgYW55IHJvd3MgZm9yXHJcbiAgICAgICAgICAgIC8vIGRvY3VtZW50cyBuZXN0ZWQgaW4gYSBzdWJjb2xsZWN0aW9uIGJlbmVhdGggZG9jdW1lbnRLZXkgc28gd2VcclxuICAgICAgICAgICAgLy8gY2FuIHN0b3AgYXMgc29vbiBhcyB3ZSBoaXQgYW55IHN1Y2ggcm93LlxyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGVuY29kZWRQYXRoKTtcclxuICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQgfHwgIWRvY3VtZW50S2V5LnBhdGguaXNFcXVhbChwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTG9vayB1cCB0aGUgbXV0YXRpb24gYmF0Y2ggaW4gdGhlIHN0b3JlLlxyXG4gICAgICAgICAgICByZXR1cm4gbXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAuZ2V0KGJhdGNoSWQpXHJcbiAgICAgICAgICAgICAgICAubmV4dChtdXRhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFyZEFzc2VydChtdXRhdGlvbi51c2VySWQgPT09IHRoaXMudXNlcklkKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgbXV0YXRpb24pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChkb2N1bWVudEtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4U3RhcnQgPSBEYkRvY3VtZW50TXV0YXRpb24ucHJlZml4Rm9yUGF0aCh0aGlzLnVzZXJJZCwgZG9jdW1lbnRLZXkucGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleFN0YXJ0KTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHJhbnNhY3Rpb24pLml0ZXJhdGUoeyByYW5nZSB9LCAoaW5kZXhLZXksIF8sIGNvbnRyb2wpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFt1c2VySUQsIGVuY29kZWRQYXRoLCBiYXRjaElEXSA9IGluZGV4S2V5O1xyXG4gICAgICAgICAgICAgICAgLy8gT25seSBjb25zaWRlciByb3dzIG1hdGNoaW5nIGV4YWN0bHkgdGhlIHNwZWNpZmljIGtleSBvZlxyXG4gICAgICAgICAgICAgICAgLy8gaW50ZXJlc3QuIE5vdGUgdGhhdCBiZWNhdXNlIHdlIG9yZGVyIGJ5IHBhdGggZmlyc3QsIGFuZCB3ZVxyXG4gICAgICAgICAgICAgICAgLy8gb3JkZXIgdGVybWluYXRvcnMgYmVmb3JlIHBhdGggc2VwYXJhdG9ycywgd2UnbGwgZW5jb3VudGVyIGFsbFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGluZGV4IHJvd3MgZm9yIGRvY3VtZW50S2V5IGNvbnRpZ3VvdXNseS4gSW4gcGFydGljdWxhciwgYWxsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcm93cyBmb3IgZG9jdW1lbnRLZXkgd2lsbCBvY2N1ciBiZWZvcmUgYW55IHJvd3MgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBkb2N1bWVudHMgbmVzdGVkIGluIGEgc3ViY29sbGVjdGlvbiBiZW5lYXRoIGRvY3VtZW50S2V5IHNvIHdlXHJcbiAgICAgICAgICAgICAgICAvLyBjYW4gc3RvcCBhcyBzb29uIGFzIHdlIGhpdCBhbnkgc3VjaCByb3cuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGVuY29kZWRQYXRoKTtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VySUQgIT09IHRoaXMudXNlcklkIHx8ICFkb2N1bWVudEtleS5wYXRoLmlzRXF1YWwocGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1bmlxdWVCYXRjaElEcyA9IHVuaXF1ZUJhdGNoSURzLmFkZChiYXRjaElEKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKS5uZXh0KCgpID0+IHRoaXMubG9va3VwTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uLCB1bmlxdWVCYXRjaElEcykpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gcXVlcnkucGF0aDtcclxuICAgICAgICBjb25zdCBpbW1lZGlhdGVDaGlsZHJlbkxlbmd0aCA9IHF1ZXJ5UGF0aC5sZW5ndGggKyAxO1xyXG4gICAgICAgIC8vIFRPRE8obWNnKTogQWN0dWFsbHkgaW1wbGVtZW50IGEgc2luZ2xlLWNvbGxlY3Rpb24gcXVlcnlcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYWN0dWFsbHkgZXhlY3V0aW5nIGFuIGFuY2VzdG9yIHF1ZXJ5LCB0cmF2ZXJzaW5nIHRoZSB3aG9sZVxyXG4gICAgICAgIC8vIHN1YnRyZWUgYmVsb3cgdGhlIGNvbGxlY3Rpb24gd2hpY2ggY2FuIGJlIGhvcnJpZmljYWxseSBpbmVmZmljaWVudCBmb3JcclxuICAgICAgICAvLyBzb21lIHN0cnVjdHVyZXMuIFRoZSByaWdodCB3YXkgdG8gc29sdmUgdGhpcyBpcyB0byBpbXBsZW1lbnQgdGhlIGZ1bGxcclxuICAgICAgICAvLyB2YWx1ZSBpbmRleCwgYnV0IHRoYXQncyBub3QgaW4gdGhlIGNhcmRzIGluIHRoZSBuZWFyIGZ1dHVyZSBzbyB0aGlzIGlzXHJcbiAgICAgICAgLy8gdGhlIGJlc3Qgd2UgY2FuIGRvIGZvciB0aGUgbW9tZW50LlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3QgeWV0IGluZGV4IHRoZSBhY3R1YWwgcHJvcGVydGllcyBpbiB0aGUgbXV0YXRpb25zLCBvdXJcclxuICAgICAgICAvLyBjdXJyZW50IGFwcHJvYWNoIGlzIHRvIGp1c3QgcmV0dXJuIGFsbCBtdXRhdGlvbiBiYXRjaGVzIHRoYXQgYWZmZWN0XHJcbiAgICAgICAgLy8gZG9jdW1lbnRzIGluIHRoZSBjb2xsZWN0aW9uIGJlaW5nIHF1ZXJpZWQuXHJcbiAgICAgICAgY29uc3QgaW5kZXhQcmVmaXggPSBEYkRvY3VtZW50TXV0YXRpb24ucHJlZml4Rm9yUGF0aCh0aGlzLnVzZXJJZCwgcXVlcnlQYXRoKTtcclxuICAgICAgICBjb25zdCBpbmRleFN0YXJ0ID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleFByZWZpeCk7XHJcbiAgICAgICAgLy8gQ29sbGVjdCB1cCB1bmlxdWUgYmF0Y2hJRHMgZW5jb3VudGVyZWQgZHVyaW5nIGEgc2NhbiBvZiB0aGUgaW5kZXguIFVzZSBhXHJcbiAgICAgICAgLy8gU29ydGVkU2V0IHRvIGFjY3VtdWxhdGUgYmF0Y2ggSURzIHNvIHRoZXkgY2FuIGJlIHRyYXZlcnNlZCBpbiBvcmRlciBpbiBhXHJcbiAgICAgICAgLy8gc2NhbiBvZiB0aGUgbWFpbiB0YWJsZS5cclxuICAgICAgICBsZXQgdW5pcXVlQmF0Y2hJRHMgPSBuZXcgU29ydGVkU2V0KHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlOiBpbmRleFN0YXJ0IH0sIChpbmRleEtleSwgXywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBbdXNlcklELCBlbmNvZGVkUGF0aCwgYmF0Y2hJRF0gPSBpbmRleEtleTtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRlY29kZVJlc291cmNlUGF0aChlbmNvZGVkUGF0aCk7XHJcbiAgICAgICAgICAgIGlmICh1c2VySUQgIT09IHRoaXMudXNlcklkIHx8ICFxdWVyeVBhdGguaXNQcmVmaXhPZihwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUm93cyB3aXRoIGRvY3VtZW50IGtleXMgbW9yZSB0aGFuIG9uZSBzZWdtZW50IGxvbmdlciB0aGFuIHRoZVxyXG4gICAgICAgICAgICAvLyBxdWVyeSBwYXRoIGNhbid0IGJlIG1hdGNoZXMuIEZvciBleGFtcGxlLCBhIHF1ZXJ5IG9uICdyb29tcydcclxuICAgICAgICAgICAgLy8gY2FuJ3QgbWF0Y2ggdGhlIGRvY3VtZW50IC9yb29tcy9hYmMvbWVzc2FnZXMveHl4LlxyXG4gICAgICAgICAgICAvLyBUT0RPKG1jZyk6IHdlJ2xsIG5lZWQgYSBkaWZmZXJlbnQgc2Nhbm5lciB3aGVuIHdlIGltcGxlbWVudFxyXG4gICAgICAgICAgICAvLyBhbmNlc3RvciBxdWVyaWVzLlxyXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IGltbWVkaWF0ZUNoaWxkcmVuTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQoYmF0Y2hJRCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gdGhpcy5sb29rdXBNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24sIHVuaXF1ZUJhdGNoSURzKSk7XHJcbiAgICB9XHJcbiAgICBsb29rdXBNdXRhdGlvbkJhdGNoZXModHJhbnNhY3Rpb24sIGJhdGNoSURzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgLy8gVE9ETyhyb2Nrd29vZCk6IEltcGxlbWVudCB0aGlzIHVzaW5nIGl0ZXJhdGUuXHJcbiAgICAgICAgYmF0Y2hJRHMuZm9yRWFjaChiYXRjaElkID0+IHtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChtdXRhdGlvbnNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgICAgIC5nZXQoYmF0Y2hJZClcclxuICAgICAgICAgICAgICAgIC5uZXh0KG11dGF0aW9uID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQobXV0YXRpb24udXNlcklkID09PSB0aGlzLnVzZXJJZCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZnJvbURiTXV0YXRpb25CYXRjaCh0aGlzLnNlcmlhbGl6ZXIsIG11dGF0aW9uKSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaCkge1xyXG4gICAgICAgIHJldHVybiByZW1vdmVNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLnNpbXBsZURiVHJhbnNhY3Rpb24sIHRoaXMudXNlcklkLCBiYXRjaCkubmV4dChyZW1vdmVkRG9jdW1lbnRzID0+IHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWRkT25Db21taXR0ZWRMaXN0ZW5lcigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cyhiYXRjaC5iYXRjaElkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChyZW1vdmVkRG9jdW1lbnRzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5tYXJrUG90ZW50aWFsbHlPcnBoYW5lZCh0cmFuc2FjdGlvbiwga2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgY2FjaGVkIGtleXMgZm9yIGEgbXV0YXRpb24gYmF0Y2guIFRoaXMgbWV0aG9kIHNob3VsZCBiZVxyXG4gICAgICogY2FsbGVkIGJ5IHNlY29uZGFyeSBjbGllbnRzIGFmdGVyIHRoZXkgcHJvY2VzcyBtdXRhdGlvbiB1cGRhdGVzLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBoYXZlIHRvIGJlIGNhbGxlZCBmcm9tIHByaW1hcnkgY2xpZW50cyBhc1xyXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgY2FjaGUgZW50cmllcyBhcmUgY2xlYXJlZCB3aGVuIGFuIGFja25vd2xlZGdlZCBvclxyXG4gICAgICogcmVqZWN0ZWQgYmF0Y2ggaXMgcmVtb3ZlZCBmcm9tIHRoZSBtdXRhdGlvbiBxdWV1ZS5cclxuICAgICAqL1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seVxyXG4gICAgcmVtb3ZlQ2FjaGVkTXV0YXRpb25LZXlzKGJhdGNoSWQpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudEtleXNCeUJhdGNoSWRbYmF0Y2hJZF07XHJcbiAgICB9XHJcbiAgICBwZXJmb3JtQ29uc2lzdGVuY3lDaGVjayh0eG4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0VtcHR5KHR4bikubmV4dChlbXB0eSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZW1wdHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGFyZSBubyBlbnRyaWVzIGluIHRoZSBkb2N1bWVudE11dGF0aW9ucyBpbmRleCBpZlxyXG4gICAgICAgICAgICAvLyB0aGUgcXVldWUgaXMgZW1wdHkuXHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UmFuZ2UgPSBJREJLZXlSYW5nZS5sb3dlckJvdW5kKERiRG9jdW1lbnRNdXRhdGlvbi5wcmVmaXhGb3JVc2VyKHRoaXMudXNlcklkKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhbmdsaW5nTXV0YXRpb25SZWZlcmVuY2VzID0gW107XHJcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHR4bilcclxuICAgICAgICAgICAgICAgIC5pdGVyYXRlKHsgcmFuZ2U6IHN0YXJ0UmFuZ2UgfSwgKGtleSwgXywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlcklEID0ga2V5WzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJJRCAhPT0gdGhpcy51c2VySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gZGVjb2RlUmVzb3VyY2VQYXRoKGtleVsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGFuZ2xpbmdNdXRhdGlvblJlZmVyZW5jZXMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQoZGFuZ2xpbmdNdXRhdGlvblJlZmVyZW5jZXMubGVuZ3RoID09PSAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb250YWluc0tleSh0eG4sIGtleSkge1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB0aGlzLnVzZXJJZCwga2V5KTtcclxuICAgIH1cclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkgKHN0YXRlIGlzIGhlbGQgaW4gbWVtb3J5IGluIG90aGVyIGNsaWVudHMpLlxyXG4gICAgLyoqIFJldHVybnMgdGhlIG11dGF0aW9uIHF1ZXVlJ3MgbWV0YWRhdGEgZnJvbSBJbmRleGVkRGIuICovXHJcbiAgICBnZXRNdXRhdGlvblF1ZXVlTWV0YWRhdGEodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmdldCh0aGlzLnVzZXJJZClcclxuICAgICAgICAgICAgLm5leHQoKG1ldGFkYXRhKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiAobWV0YWRhdGEgfHxcclxuICAgICAgICAgICAgICAgIG5ldyBEYk11dGF0aW9uUXVldWUodGhpcy51c2VySWQsIEJBVENISURfVU5LTk9XTiwgXHJcbiAgICAgICAgICAgICAgICAvKmxhc3RTdHJlYW1Ub2tlbj0qLyAnJykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBtdXRhdGlvbiBxdWV1ZSBmb3IgdGhlIGdpdmVuIHVzZXIgY29udGFpbnMgYSBwZW5kaW5nXHJcbiAqICAgICAgICAgbXV0YXRpb24gZm9yIHRoZSBnaXZlbiBrZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvblF1ZXVlQ29udGFpbnNLZXkodHhuLCB1c2VySWQsIGtleSkge1xyXG4gICAgY29uc3QgaW5kZXhLZXkgPSBEYkRvY3VtZW50TXV0YXRpb24ucHJlZml4Rm9yUGF0aCh1c2VySWQsIGtleS5wYXRoKTtcclxuICAgIGNvbnN0IGVuY29kZWRQYXRoID0gaW5kZXhLZXlbMV07XHJcbiAgICBjb25zdCBzdGFydFJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChpbmRleEtleSk7XHJcbiAgICBsZXQgY29udGFpbnNLZXkgPSBmYWxzZTtcclxuICAgIHJldHVybiBkb2N1bWVudE11dGF0aW9uc1N0b3JlKHR4bilcclxuICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlOiBzdGFydFJhbmdlLCBrZXlzT25seTogdHJ1ZSB9LCAoa2V5LCB2YWx1ZSwgY29udHJvbCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IFt1c2VySUQsIGtleVBhdGgsIC8qYmF0Y2hJRCovIF9dID0ga2V5O1xyXG4gICAgICAgIGlmICh1c2VySUQgPT09IHVzZXJJZCAmJiBrZXlQYXRoID09PSBlbmNvZGVkUGF0aCkge1xyXG4gICAgICAgICAgICBjb250YWluc0tleSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgfSlcclxuICAgICAgICAubmV4dCgoKSA9PiBjb250YWluc0tleSk7XHJcbn1cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiBhbnkgbXV0YXRpb24gcXVldWUgY29udGFpbnMgdGhlIGdpdmVuIGRvY3VtZW50LiAqL1xyXG5mdW5jdGlvbiBtdXRhdGlvblF1ZXVlc0NvbnRhaW5LZXkodHhuLCBkb2NLZXkpIHtcclxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIG11dGF0aW9uUXVldWVzU3RvcmUodHhuKVxyXG4gICAgICAgIC5pdGVyYXRlU2VyaWFsKHVzZXJJZCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVDb250YWluc0tleSh0eG4sIHVzZXJJZCwgZG9jS2V5KS5uZXh0KGNvbnRhaW5zS2V5ID0+IHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zS2V5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCFjb250YWluc0tleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KVxyXG4gICAgICAgIC5uZXh0KCgpID0+IGZvdW5kKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBtdXRhdGlvbnMgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gbXV0YXRpb25zU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYk11dGF0aW9uQmF0Y2guc3RvcmUpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9uUXVldWVzIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIGRvY3VtZW50TXV0YXRpb25zU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkRvY3VtZW50TXV0YXRpb24uc3RvcmUpO1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIG11dGF0aW9uUXVldWVzIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIG11dGF0aW9uUXVldWVzU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYk11dGF0aW9uUXVldWUuc3RvcmUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBPZmZzZXQgdG8gZW5zdXJlIG5vbi1vdmVybGFwcGluZyB0YXJnZXQgaWRzLiAqL1xyXG5jb25zdCBPRkZTRVQgPSAyO1xyXG4vKipcclxuICogR2VuZXJhdGVzIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyB0YXJnZXQgSURzIGZvciBzZW5kaW5nIHRhcmdldHMgdG8gdGhlXHJcbiAqIHdhdGNoIHN0cmVhbS5cclxuICpcclxuICogVGhlIGNsaWVudCBjb25zdHJ1Y3RzIHR3byBnZW5lcmF0b3JzLCBvbmUgZm9yIHRoZSB0YXJnZXQgY2FjaGUsIGFuZCBvbmUgZm9yXHJcbiAqIGZvciB0aGUgc3luYyBlbmdpbmUgKHRvIGdlbmVyYXRlIGxpbWJvIGRvY3VtZW50cyB0YXJnZXRzKS4gVGhlc2VcclxuICogZ2VuZXJhdG9ycyBwcm9kdWNlIG5vbi1vdmVybGFwcGluZyBJRHMgKGJ5IHVzaW5nIGV2ZW4gYW5kIG9kZCBJRHNcclxuICogcmVzcGVjdGl2ZWx5KS5cclxuICpcclxuICogQnkgc2VwYXJhdGluZyB0aGUgdGFyZ2V0IElEIHNwYWNlLCB0aGUgcXVlcnkgY2FjaGUgY2FuIGdlbmVyYXRlIHRhcmdldCBJRHNcclxuICogdGhhdCBwZXJzaXN0IGFjcm9zcyBjbGllbnQgcmVzdGFydHMsIHdoaWxlIHN5bmMgZW5naW5lIGNhbiBpbmRlcGVuZGVudGx5XHJcbiAqIGdlbmVyYXRlIGluLW1lbW9yeSB0YXJnZXQgSURzIHRoYXQgYXJlIHRyYW5zaWVudCBhbmQgY2FuIGJlIHJldXNlZCBhZnRlciBhXHJcbiAqIHJlc3RhcnQuXHJcbiAqL1xyXG5jbGFzcyBUYXJnZXRJZEdlbmVyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihsYXN0SWQpIHtcclxuICAgICAgICB0aGlzLmxhc3RJZCA9IGxhc3RJZDtcclxuICAgIH1cclxuICAgIG5leHQoKSB7XHJcbiAgICAgICAgdGhpcy5sYXN0SWQgKz0gT0ZGU0VUO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RJZDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmb3JUYXJnZXRDYWNoZSgpIHtcclxuICAgICAgICAvLyBUaGUgdGFyZ2V0IGNhY2hlIGdlbmVyYXRvciBtdXN0IHJldHVybiAnMicgaW4gaXRzIGZpcnN0IGNhbGwgdG8gYG5leHQoKWBcclxuICAgICAgICAvLyBhcyB0aGVyZSBpcyBubyBkaWZmZXJlbnRpYXRpb24gaW4gdGhlIHByb3RvY29sIGxheWVyIGJldHdlZW4gYW4gdW5zZXRcclxuICAgICAgICAvLyBudW1iZXIgYW5kIHRoZSBudW1iZXIgJzAnLiBJZiB3ZSB3ZXJlIHRvIHNlbnQgYSB0YXJnZXQgd2l0aCB0YXJnZXQgSURcclxuICAgICAgICAvLyAnMCcsIHRoZSBiYWNrZW5kIHdvdWxkIGNvbnNpZGVyIGl0IHVuc2V0IGFuZCByZXBsYWNlIGl0IHdpdGggaXRzIG93biBJRC5cclxuICAgICAgICByZXR1cm4gbmV3IFRhcmdldElkR2VuZXJhdG9yKDIgLSBPRkZTRVQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZvclN5bmNFbmdpbmUoKSB7XHJcbiAgICAgICAgLy8gU3luYyBlbmdpbmUgYXNzaWducyB0YXJnZXQgSURzIGZvciBsaW1ibyBkb2N1bWVudCBkZXRlY3Rpb24uXHJcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXRJZEdlbmVyYXRvcigxIC0gT0ZGU0VUKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRGJUYXJnZXRDYWNoZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZWZlcmVuY2VEZWxlZ2F0ZSwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgfVxyXG4gICAgLy8gUE9SVElORyBOT1RFOiBXZSBkb24ndCBjYWNoZSBnbG9iYWwgbWV0YWRhdGEgZm9yIHRoZSB0YXJnZXQgY2FjaGUsIHNpbmNlXHJcbiAgICAvLyBzb21lIG9mIGl0IChpbiBwYXJ0aWN1bGFyIGBoaWdoZXN0VGFyZ2V0SWRgKSBjYW4gYmUgbW9kaWZpZWQgYnkgc2Vjb25kYXJ5XHJcbiAgICAvLyB0YWJzLiBXZSBjb3VsZCBwZXJoYXBzIGJlIG1vcmUgZ3JhbnVsYXIgKGFuZCBlLmcuIHN0aWxsIGNhY2hlXHJcbiAgICAvLyBgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbmAgaW4gbWVtb3J5KSBidXQgZm9yIHNpbXBsaWNpdHkgd2UgY3VycmVudGx5IGdvXHJcbiAgICAvLyB0byBJbmRleGVkRGIgd2hlbmV2ZXIgd2UgbmVlZCB0byByZWFkIG1ldGFkYXRhLiBXZSBjYW4gcmV2aXNpdCBpZiBpdCB0dXJuc1xyXG4gICAgLy8gb3V0IHRvIGhhdmUgYSBtZWFuaW5nZnVsIHBlcmZvcm1hbmNlIGltcGFjdC5cclxuICAgIGFsbG9jYXRlVGFyZ2V0SWQodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXRyaWV2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0SWRHZW5lcmF0b3IgPSBuZXcgVGFyZ2V0SWRHZW5lcmF0b3IobWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKTtcclxuICAgICAgICAgICAgbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkID0gdGFyZ2V0SWRHZW5lcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlTWV0YWRhdGEodHJhbnNhY3Rpb24sIG1ldGFkYXRhKS5uZXh0KCgpID0+IG1ldGFkYXRhLmhpZ2hlc3RUYXJnZXRJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBTbmFwc2hvdFZlcnNpb24uZnJvbVRpbWVzdGFtcChuZXcgVGltZXN0YW1wKG1ldGFkYXRhLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24uc2Vjb25kcywgbWV0YWRhdGEubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbi5uYW5vc2Vjb25kcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0SGlnaGVzdFNlcXVlbmNlTnVtYmVyKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dCh0YXJnZXRHbG9iYWwgPT4gdGFyZ2V0R2xvYmFsLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcik7XHJcbiAgICB9XHJcbiAgICBzZXRUYXJnZXRzTWV0YWRhdGEodHJhbnNhY3Rpb24sIGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciwgbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4ge1xyXG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSBoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI7XHJcbiAgICAgICAgICAgIGlmIChsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS5sYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uID1cclxuICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uLnRvVGltZXN0YW1wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA+IG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEuaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID0gaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKS5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikubmV4dChtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtZXRhZGF0YS50YXJnZXRDb3VudCArPSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNZXRhZGF0YUZyb21UYXJnZXREYXRhKHRhcmdldERhdGEsIG1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zYXZlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHJhbnNhY3Rpb24sIHRhcmdldERhdGEudGFyZ2V0SWQpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbikuZGVsZXRlKHRhcmdldERhdGEudGFyZ2V0SWQpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pKVxyXG4gICAgICAgICAgICAubmV4dChtZXRhZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQobWV0YWRhdGEudGFyZ2V0Q291bnQgPiAwKTtcclxuICAgICAgICAgICAgbWV0YWRhdGEudGFyZ2V0Q291bnQgLT0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyb3BzIGFueSB0YXJnZXRzIHdpdGggc2VxdWVuY2UgbnVtYmVyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdXBwZXIgYm91bmQsIGV4Y2VwdGluZyB0aG9zZVxyXG4gICAgICogcHJlc2VudCBpbiBgYWN0aXZlVGFyZ2V0SWRzYC4gRG9jdW1lbnQgYXNzb2NpYXRpb25zIGZvciB0aGUgcmVtb3ZlZCB0YXJnZXRzIGFyZSBhbHNvIHJlbW92ZWQuXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGFyZ2V0cyByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHhuKVxyXG4gICAgICAgICAgICAuaXRlcmF0ZSgoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gZnJvbURiVGFyZ2V0KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPD0gdXBwZXJCb3VuZCAmJlxyXG4gICAgICAgICAgICAgICAgYWN0aXZlVGFyZ2V0SWRzLmdldCh0YXJnZXREYXRhLnRhcmdldElkKSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5yZW1vdmVUYXJnZXREYXRhKHR4biwgdGFyZ2V0RGF0YSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjb3VudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGwgcHJvdmlkZWQgZnVuY3Rpb24gd2l0aCBlYWNoIGBUYXJnZXREYXRhYCB0aGF0IHdlIGhhdmUgY2FjaGVkLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoVGFyZ2V0KHR4biwgZikge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXRzU3RvcmUodHhuKS5pdGVyYXRlKChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBmcm9tRGJUYXJnZXQodmFsdWUpO1xyXG4gICAgICAgICAgICBmKHRhcmdldERhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0cmlldmVNZXRhZGF0YSh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWxUYXJnZXRTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmdldChEYlRhcmdldEdsb2JhbC5rZXkpXHJcbiAgICAgICAgICAgIC5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgaGFyZEFzc2VydChtZXRhZGF0YSAhPT0gbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNhdmVNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsVGFyZ2V0U3RvcmUodHJhbnNhY3Rpb24pLnB1dChEYlRhcmdldEdsb2JhbC5rZXksIG1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIHNhdmVUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbikucHV0KHRvRGJUYXJnZXQodGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluLXBsYWNlIHVwZGF0ZXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIHRvIGFjY291bnQgZm9yIHZhbHVlcyBpbiB0aGUgZ2l2ZW5cclxuICAgICAqIFRhcmdldERhdGEuIFNhdmluZyBpcyBkb25lIHNlcGFyYXRlbHkuIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSB3ZXJlIGFueVxyXG4gICAgICogY2hhbmdlcyB0byB0aGUgbWV0YWRhdGEuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZU1ldGFkYXRhRnJvbVRhcmdldERhdGEodGFyZ2V0RGF0YSwgbWV0YWRhdGEpIHtcclxuICAgICAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0YXJnZXREYXRhLnRhcmdldElkID4gbWV0YWRhdGEuaGlnaGVzdFRhcmdldElkKSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhLmhpZ2hlc3RUYXJnZXRJZCA9IHRhcmdldERhdGEudGFyZ2V0SWQ7XHJcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0RGF0YS5zZXF1ZW5jZU51bWJlciA+IG1ldGFkYXRhLmhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgICAgICBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIgPSB0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICB9XHJcbiAgICBnZXRUYXJnZXRDb3VudCh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJldHJpZXZlTWV0YWRhdGEodHJhbnNhY3Rpb24pLm5leHQobWV0YWRhdGEgPT4gbWV0YWRhdGEudGFyZ2V0Q291bnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gSXRlcmF0aW5nIGJ5IHRoZSBjYW5vbmljYWxJZCBtYXkgeWllbGQgbW9yZSB0aGFuIG9uZSByZXN1bHQgYmVjYXVzZVxyXG4gICAgICAgIC8vIGNhbm9uaWNhbElkIHZhbHVlcyBhcmUgbm90IHJlcXVpcmVkIHRvIGJlIHVuaXF1ZSBwZXIgdGFyZ2V0LiBUaGlzIHF1ZXJ5XHJcbiAgICAgICAgLy8gZGVwZW5kcyBvbiB0aGUgcXVlcnlUYXJnZXRzIGluZGV4IHRvIGJlIGVmZmljaWVudC5cclxuICAgICAgICBjb25zdCBjYW5vbmljYWxJZCA9IGNhbm9uaWZ5VGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbY2Fub25pY2FsSWQsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sIFtjYW5vbmljYWxJZCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyByYW5nZSwgaW5kZXg6IERiVGFyZ2V0LnF1ZXJ5VGFyZ2V0c0luZGV4TmFtZSB9LCAoa2V5LCB2YWx1ZSwgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGZyb21EYlRhcmdldCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIC8vIEFmdGVyIGZpbmRpbmcgYSBwb3RlbnRpYWwgbWF0Y2gsIGNoZWNrIHRoYXQgdGhlIHRhcmdldCBpc1xyXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBlcXVhbCB0byB0aGUgcmVxdWVzdGVkIHRhcmdldC5cclxuICAgICAgICAgICAgaWYgKHRhcmdldEVxdWFscyh0YXJnZXQsIGZvdW5kLnRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZvdW5kO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgYWRkTWF0Y2hpbmdLZXlzKHR4biwga2V5cywgdGFyZ2V0SWQpIHtcclxuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IFRoZSByZXZlcnNlIGluZGV4IChkb2N1bWVudHNUYXJnZXRzKSBpcyBtYWludGFpbmVkIGJ5XHJcbiAgICAgICAgLy8gSW5kZXhlZERiLlxyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBkb2N1bWVudFRhcmdldFN0b3JlKHR4bik7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoa2V5LnBhdGgpO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHN0b3JlLnB1dChuZXcgRGJUYXJnZXREb2N1bWVudCh0YXJnZXRJZCwgcGF0aCkpKTtcclxuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlZmVyZW5jZURlbGVnYXRlLmFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTWF0Y2hpbmdLZXlzKHR4biwga2V5cywgdGFyZ2V0SWQpIHtcclxuICAgICAgICAvLyBQT1JUSU5HIE5PVEU6IFRoZSByZXZlcnNlIGluZGV4IChkb2N1bWVudHNUYXJnZXRzKSBpcyBtYWludGFpbmVkIGJ5XHJcbiAgICAgICAgLy8gSW5kZXhlZERiLlxyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaChrZXlzLCAoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlbmNvZGVSZXNvdXJjZVBhdGgoa2V5LnBhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IoW1xyXG4gICAgICAgICAgICAgICAgc3RvcmUuZGVsZXRlKFt0YXJnZXRJZCwgcGF0aF0pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKTtcclxuICAgICAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmJvdW5kKFt0YXJnZXRJZF0sIFt0YXJnZXRJZCArIDFdLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShyYW5nZSk7XHJcbiAgICB9XHJcbiAgICBnZXRNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldElkKSB7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbdGFyZ2V0SWRdLCBbdGFyZ2V0SWQgKyAxXSwgXHJcbiAgICAgICAgLypsb3dlck9wZW49Ki8gZmFsc2UsIFxyXG4gICAgICAgIC8qdXBwZXJPcGVuPSovIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgIHJldHVybiBzdG9yZVxyXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlLCBrZXlzT25seTogdHJ1ZSB9LCAoa2V5LCBfLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoa2V5WzFdKTtcclxuICAgICAgICAgICAgY29uc3QgZG9jS2V5ID0gbmV3IERvY3VtZW50S2V5KHBhdGgpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGRvY0tleSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGNvbnRhaW5zS2V5KHR4biwga2V5KSB7XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCk7XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChbcGF0aF0sIFtpbW1lZGlhdGVTdWNjZXNzb3IocGF0aCldLCBcclxuICAgICAgICAvKmxvd2VyT3Blbj0qLyBmYWxzZSwgXHJcbiAgICAgICAgLyp1cHBlck9wZW49Ki8gdHJ1ZSk7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pXHJcbiAgICAgICAgICAgIC5pdGVyYXRlKHtcclxuICAgICAgICAgICAgaW5kZXg6IERiVGFyZ2V0RG9jdW1lbnQuZG9jdW1lbnRUYXJnZXRzSW5kZXgsXHJcbiAgICAgICAgICAgIGtleXNPbmx5OiB0cnVlLFxyXG4gICAgICAgICAgICByYW5nZVxyXG4gICAgICAgIH0sIChbdGFyZ2V0SWQsIHBhdGhdLCBfLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEhhdmluZyBhIHNlbnRpbmVsIHJvdyBmb3IgYSBkb2N1bWVudCBkb2VzIG5vdCBjb3VudCBhcyBjb250YWluaW5nIHRoYXQgZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIC8vIEZvciB0aGUgdGFyZ2V0IGNhY2hlLCBjb250YWluaW5nIHRoZSBkb2N1bWVudCBtZWFucyB0aGUgZG9jdW1lbnQgaXMgcGFydCBvZiBzb21lXHJcbiAgICAgICAgICAgIC8vIHRhcmdldC5cclxuICAgICAgICAgICAgaWYgKHRhcmdldElkICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBjb3VudCA+IDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb29rcyB1cCBhIFRhcmdldERhdGEgZW50cnkgYnkgdGFyZ2V0IElELlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXJnZXRJZCAtIFRoZSB0YXJnZXQgSUQgb2YgdGhlIFRhcmdldERhdGEgZW50cnkgdG8gbG9vayB1cC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBjYWNoZWQgVGFyZ2V0RGF0YSBlbnRyeSwgb3IgbnVsbCBpZiB0aGUgY2FjaGUgaGFzIG5vIGVudHJ5IGZvclxyXG4gICAgICogdGhlIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cclxuICAgIGdldFRhcmdldERhdGFGb3JUYXJnZXQodHJhbnNhY3Rpb24sIHRhcmdldElkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldHNTdG9yZSh0cmFuc2FjdGlvbilcclxuICAgICAgICAgICAgLmdldCh0YXJnZXRJZClcclxuICAgICAgICAgICAgLm5leHQoZm91bmQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRGJUYXJnZXQoZm91bmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBxdWVyaWVzIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIHRhcmdldHNTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiVGFyZ2V0LnN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSB0YXJnZXQgZ2xvYmFscyBvYmplY3Qgc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnbG9iYWxUYXJnZXRTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiVGFyZ2V0R2xvYmFsLnN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSBkb2N1bWVudCB0YXJnZXQgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiVGFyZ2V0RG9jdW1lbnQuc3RvcmUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBWZXJpZmllcyB0aGUgZXJyb3IgdGhyb3duIGJ5IGEgTG9jYWxTdG9yZSBvcGVyYXRpb24uIElmIGEgTG9jYWxTdG9yZVxyXG4gKiBvcGVyYXRpb24gZmFpbHMgYmVjYXVzZSB0aGUgcHJpbWFyeSBsZWFzZSBoYXMgYmVlbiB0YWtlbiBieSBhbm90aGVyIGNsaWVudCxcclxuICogd2UgaWdub3JlIHRoZSBlcnJvciAodGhlIHBlcnNpc3RlbmNlIGxheWVyIHdpbGwgaW1tZWRpYXRlbHkgY2FsbFxyXG4gKiBgYXBwbHlQcmltYXJ5TGVhc2VgIHRvIHByb3BhZ2F0ZSB0aGUgcHJpbWFyeSBzdGF0ZSBjaGFuZ2UpLiBBbGwgb3RoZXIgZXJyb3JzXHJcbiAqIGFyZSByZS10aHJvd24uXHJcbiAqXHJcbiAqIEBwYXJhbSBlcnIgLSBBbiBlcnJvciByZXR1cm5lZCBieSBhIExvY2FsU3RvcmUgb3BlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB3ZSByZWNvdmVyZWQsIG9yIHRoZSBvcmlnaW5hbCBlcnJvci5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnIpIHtcclxuICAgIGlmIChlcnIuY29kZSA9PT0gQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OICYmXHJcbiAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFBSSU1BUllfTEVBU0VfTE9TVF9FUlJPUl9NU0cpIHtcclxuICAgICAgICBsb2dEZWJ1ZygnTG9jYWxTdG9yZScsICdVbmV4cGVjdGVkbHkgbG9zdCBwcmltYXJ5IGxlYXNlJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgR0NfRElEX05PVF9SVU4gPSB7XHJcbiAgICBkaWRSdW46IGZhbHNlLFxyXG4gICAgc2VxdWVuY2VOdW1iZXJzQ29sbGVjdGVkOiAwLFxyXG4gICAgdGFyZ2V0c1JlbW92ZWQ6IDAsXHJcbiAgICBkb2N1bWVudHNSZW1vdmVkOiAwXHJcbn07XHJcbmNvbnN0IExSVV9DT0xMRUNUSU9OX0RJU0FCTEVEID0gLTE7XHJcbmNvbnN0IExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMgPSA0MCAqIDEwMjQgKiAxMDI0O1xyXG5jbGFzcyBMcnVQYXJhbXMge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvLyBXaGVuIHdlIGF0dGVtcHQgdG8gY29sbGVjdCwgd2Ugd2lsbCBvbmx5IGRvIHNvIGlmIHRoZSBjYWNoZSBzaXplIGlzIGdyZWF0ZXIgdGhhbiB0aGlzXHJcbiAgICAvLyB0aHJlc2hvbGQuIFBhc3NpbmcgYENPTExFQ1RJT05fRElTQUJMRURgIGhlcmUgd2lsbCBjYXVzZSBjb2xsZWN0aW9uIHRvIGFsd2F5cyBiZSBza2lwcGVkLlxyXG4gICAgY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCwgXHJcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiBzZXF1ZW5jZSBudW1iZXJzIHRoYXQgd2Ugd2lsbCBhdHRlbXB0IHRvIGNvbGxlY3RcclxuICAgIHBlcmNlbnRpbGVUb0NvbGxlY3QsIFxyXG4gICAgLy8gQSBjYXAgb24gdGhlIHRvdGFsIG51bWJlciBvZiBzZXF1ZW5jZSBudW1iZXJzIHRoYXQgd2lsbCBiZSBjb2xsZWN0ZWQuIFRoaXMgcHJldmVudHNcclxuICAgIC8vIHVzIGZyb20gY29sbGVjdGluZyBhIGh1Z2UgbnVtYmVyIG9mIHNlcXVlbmNlIG51bWJlcnMgaWYgdGhlIGNhY2hlIGhhcyBncm93biB2ZXJ5IGxhcmdlLlxyXG4gICAgbWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCkge1xyXG4gICAgICAgIHRoaXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCA9IGNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGQ7XHJcbiAgICAgICAgdGhpcy5wZXJjZW50aWxlVG9Db2xsZWN0ID0gcGVyY2VudGlsZVRvQ29sbGVjdDtcclxuICAgICAgICB0aGlzLm1heGltdW1TZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QgPSBtYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHdpdGhDYWNoZVNpemUoY2FjaGVTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMcnVQYXJhbXMoY2FjaGVTaXplLCBMcnVQYXJhbXMuREVGQVVMVF9DT0xMRUNUSU9OX1BFUkNFTlRJTEUsIExydVBhcmFtcy5ERUZBVUxUX01BWF9TRVFVRU5DRV9OVU1CRVJTX1RPX0NPTExFQ1QpO1xyXG4gICAgfVxyXG59XHJcbkxydVBhcmFtcy5ERUZBVUxUX0NPTExFQ1RJT05fUEVSQ0VOVElMRSA9IDEwO1xyXG5McnVQYXJhbXMuREVGQVVMVF9NQVhfU0VRVUVOQ0VfTlVNQkVSU19UT19DT0xMRUNUID0gMTAwMDtcclxuTHJ1UGFyYW1zLkRFRkFVTFQgPSBuZXcgTHJ1UGFyYW1zKExSVV9ERUZBVUxUX0NBQ0hFX1NJWkVfQllURVMsIExydVBhcmFtcy5ERUZBVUxUX0NPTExFQ1RJT05fUEVSQ0VOVElMRSwgTHJ1UGFyYW1zLkRFRkFVTFRfTUFYX1NFUVVFTkNFX05VTUJFUlNfVE9fQ09MTEVDVCk7XHJcbkxydVBhcmFtcy5ESVNBQkxFRCA9IG5ldyBMcnVQYXJhbXMoTFJVX0NPTExFQ1RJT05fRElTQUJMRUQsIDAsIDApO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJGUgPSAnTHJ1R2FyYmFnZUNvbGxlY3Rvcic7XHJcbmNvbnN0IExSVV9NSU5JTVVNX0NBQ0hFX1NJWkVfQllURVMgPSAxICogMTAyNCAqIDEwMjQ7XHJcbi8qKiBIb3cgbG9uZyB3ZSB3YWl0IHRvIHRyeSBydW5uaW5nIExSVSBHQyBhZnRlciBTREsgaW5pdGlhbGl6YXRpb24uICovXHJcbmNvbnN0IElOSVRJQUxfR0NfREVMQVlfTVMgPSAxICogNjAgKiAxMDAwO1xyXG4vKiogTWluaW11bSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIEdDIGNoZWNrcywgYWZ0ZXIgdGhlIGZpcnN0IG9uZS4gKi9cclxuY29uc3QgUkVHVUxBUl9HQ19ERUxBWV9NUyA9IDUgKiA2MCAqIDEwMDA7XHJcbmZ1bmN0aW9uIGJ1ZmZlckVudHJ5Q29tcGFyYXRvcihbYVNlcXVlbmNlLCBhSW5kZXhdLCBbYlNlcXVlbmNlLCBiSW5kZXhdKSB7XHJcbiAgICBjb25zdCBzZXFDbXAgPSBwcmltaXRpdmVDb21wYXJhdG9yKGFTZXF1ZW5jZSwgYlNlcXVlbmNlKTtcclxuICAgIGlmIChzZXFDbXAgPT09IDApIHtcclxuICAgICAgICAvLyBUaGlzIG9yZGVyIGRvZXNuJ3QgbWF0dGVyLCBidXQgd2UgY2FuIGJpYXMgYWdhaW5zdCBjaHVybiBieSBzb3J0aW5nXHJcbiAgICAgICAgLy8gZW50cmllcyBjcmVhdGVkIGVhcmxpZXIgYXMgbGVzcyB0aGFuIG5ld2VyIGVudHJpZXMuXHJcbiAgICAgICAgcmV0dXJuIHByaW1pdGl2ZUNvbXBhcmF0b3IoYUluZGV4LCBiSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcUNtcDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVXNlZCB0byBjYWxjdWxhdGUgdGhlIG50aCBzZXF1ZW5jZSBudW1iZXIuIEtlZXBzIGEgcm9sbGluZyBidWZmZXIgb2YgdGhlXHJcbiAqIGxvd2VzdCBuIHZhbHVlcyBwYXNzZWQgdG8gYGFkZEVsZW1lbnRgLCBhbmQgZmluYWxseSByZXBvcnRzIHRoZSBsYXJnZXN0IG9mXHJcbiAqIHRoZW0gaW4gYG1heFZhbHVlYC5cclxuICovXHJcbmNsYXNzIFJvbGxpbmdTZXF1ZW5jZU51bWJlckJ1ZmZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXhFbGVtZW50cykge1xyXG4gICAgICAgIHRoaXMubWF4RWxlbWVudHMgPSBtYXhFbGVtZW50cztcclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBTb3J0ZWRTZXQoYnVmZmVyRW50cnlDb21wYXJhdG9yKTtcclxuICAgICAgICB0aGlzLnByZXZpb3VzSW5kZXggPSAwO1xyXG4gICAgfVxyXG4gICAgbmV4dEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiArK3RoaXMucHJldmlvdXNJbmRleDtcclxuICAgIH1cclxuICAgIGFkZEVsZW1lbnQoc2VxdWVuY2VOdW1iZXIpIHtcclxuICAgICAgICBjb25zdCBlbnRyeSA9IFtzZXF1ZW5jZU51bWJlciwgdGhpcy5uZXh0SW5kZXgoKV07XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLnNpemUgPCB0aGlzLm1heEVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuYWRkKGVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hlc3RWYWx1ZSA9IHRoaXMuYnVmZmVyLmxhc3QoKTtcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlckVudHJ5Q29tcGFyYXRvcihlbnRyeSwgaGlnaGVzdFZhbHVlKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuZGVsZXRlKGhpZ2hlc3RWYWx1ZSkuYWRkKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBtYXhWYWx1ZSgpIHtcclxuICAgICAgICAvLyBHdWFyYW50ZWVkIHRvIGJlIG5vbi1lbXB0eS4gSWYgd2UgZGVjaWRlIHdlIGFyZSBub3QgY29sbGVjdGluZyBhbnlcclxuICAgICAgICAvLyBzZXF1ZW5jZSBudW1iZXJzLCBudGhTZXF1ZW5jZU51bWJlciBiZWxvdyBzaG9ydC1jaXJjdWl0cy4gSWYgd2UgaGF2ZVxyXG4gICAgICAgIC8vIGRlY2lkZWQgdGhhdCB3ZSBhcmUgY29sbGVjdGluZyBuIHNlcXVlbmNlIG51bWJlcnMsIGl0J3MgYmVjYXVzZSBuIGlzIHNvbWVcclxuICAgICAgICAvLyBwZXJjZW50YWdlIG9mIHRoZSBleGlzdGluZyBzZXF1ZW5jZSBudW1iZXJzLiBUaGF0IG1lYW5zIHdlIHNob3VsZCBuZXZlclxyXG4gICAgICAgIC8vIGJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSBjb2xsZWN0aW5nIHNlcXVlbmNlIG51bWJlcnMgYnV0IGRvbid0XHJcbiAgICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhbnkuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxhc3QoKVswXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHNjaGVkdWxpbmcgb2YgTFJVIGdhcmJhZ2UgY29sbGVjdGlvbi4gSXQgaGFuZGxlcyBjaGVja2luZ1xyXG4gKiB3aGV0aGVyIG9yIG5vdCBHQyBpcyBlbmFibGVkLCBhcyB3ZWxsIGFzIHdoaWNoIGRlbGF5IHRvIHVzZSBiZWZvcmUgdGhlIG5leHQgcnVuLlxyXG4gKi9cclxuY2xhc3MgTHJ1U2NoZWR1bGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdhcmJhZ2VDb2xsZWN0b3IsIGFzeW5jUXVldWUpIHtcclxuICAgICAgICB0aGlzLmdhcmJhZ2VDb2xsZWN0b3IgPSBnYXJiYWdlQ29sbGVjdG9yO1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XHJcbiAgICAgICAgdGhpcy5oYXNSdW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmdjVGFzayA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGFydChsb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2FyYmFnZUNvbGxlY3Rvci5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCAhPT1cclxuICAgICAgICAgICAgTFJVX0NPTExFQ1RJT05fRElTQUJMRUQpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUdDKGxvY2FsU3RvcmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2NUYXNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2NUYXNrLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdjVGFzayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2NUYXNrICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2NoZWR1bGVHQyhsb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgY29uc3QgZGVsYXkgPSB0aGlzLmhhc1J1biA/IFJFR1VMQVJfR0NfREVMQVlfTVMgOiBJTklUSUFMX0dDX0RFTEFZX01TO1xyXG4gICAgICAgIGxvZ0RlYnVnKCdMcnVHYXJiYWdlQ29sbGVjdG9yJywgYEdhcmJhZ2UgY29sbGVjdGlvbiBzY2hlZHVsZWQgaW4gJHtkZWxheX1tc2ApO1xyXG4gICAgICAgIHRoaXMuZ2NUYXNrID0gdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwibHJ1X2dhcmJhZ2VfY29sbGVjdGlvblwiIC8qIExydUdhcmJhZ2VDb2xsZWN0aW9uICovLCBkZWxheSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmdjVGFzayA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzUnVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmUuY29sbGVjdEdhcmJhZ2UodGhpcy5nYXJiYWdlQ29sbGVjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZSwgJ0lnbm9yaW5nIEluZGV4ZWREQiBlcnJvciBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uOiAnLCBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNjaGVkdWxlR0MobG9jYWxTdG9yZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIEltcGxlbWVudHMgdGhlIHN0ZXBzIGZvciBMUlUgZ2FyYmFnZSBjb2xsZWN0aW9uLiAqL1xyXG5jbGFzcyBMcnVHYXJiYWdlQ29sbGVjdG9ySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlVGFyZ2V0Q291bnQodHhuLCBwZXJjZW50aWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuZ2V0U2VxdWVuY2VOdW1iZXJDb3VudCh0eG4pLm5leHQodGFyZ2V0Q291bnQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigocGVyY2VudGlsZSAvIDEwMC4wKSAqIHRhcmdldENvdW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG50aFNlcXVlbmNlTnVtYmVyKHR4biwgbikge1xyXG4gICAgICAgIGlmIChuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFJvbGxpbmdTZXF1ZW5jZU51bWJlckJ1ZmZlcihuKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZVxyXG4gICAgICAgICAgICAuZm9yRWFjaFRhcmdldCh0eG4sIHRhcmdldCA9PiBidWZmZXIuYWRkRWxlbWVudCh0YXJnZXQuc2VxdWVuY2VOdW1iZXIpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmZvckVhY2hPcnBoYW5lZERvY3VtZW50U2VxdWVuY2VOdW1iZXIodHhuLCBzZXF1ZW5jZU51bWJlciA9PiBidWZmZXIuYWRkRWxlbWVudChzZXF1ZW5jZU51bWJlcikpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGJ1ZmZlci5tYXhWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXRzKHR4biwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5yZW1vdmVPcnBoYW5lZERvY3VtZW50cyh0eG4sIHVwcGVyQm91bmQpO1xyXG4gICAgfVxyXG4gICAgY29sbGVjdCh0eG4sIGFjdGl2ZVRhcmdldElkcykge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5jYWNoZVNpemVDb2xsZWN0aW9uVGhyZXNob2xkID09PSBMUlVfQ09MTEVDVElPTl9ESVNBQkxFRCkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZygnTHJ1R2FyYmFnZUNvbGxlY3RvcicsICdHYXJiYWdlIGNvbGxlY3Rpb24gc2tpcHBlZDsgZGlzYWJsZWQnKTtcclxuICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKEdDX0RJRF9OT1RfUlVOKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVTaXplKHR4bikubmV4dChjYWNoZVNpemUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVTaXplIDwgdGhpcy5wYXJhbXMuY2FjaGVTaXplQ29sbGVjdGlvblRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0xydUdhcmJhZ2VDb2xsZWN0b3InLCBgR2FyYmFnZSBjb2xsZWN0aW9uIHNraXBwZWQ7IENhY2hlIHNpemUgJHtjYWNoZVNpemV9IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBpcyBsb3dlciB0aGFuIHRocmVzaG9sZCAke3RoaXMucGFyYW1zLmNhY2hlU2l6ZUNvbGxlY3Rpb25UaHJlc2hvbGR9YCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gR0NfRElEX05PVF9SVU47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5HYXJiYWdlQ29sbGVjdGlvbih0eG4sIGFjdGl2ZVRhcmdldElkcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldENhY2hlU2l6ZSh0eG4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5nZXRDYWNoZVNpemUodHhuKTtcclxuICAgIH1cclxuICAgIHJ1bkdhcmJhZ2VDb2xsZWN0aW9uKHR4biwgYWN0aXZlVGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgbGV0IHVwcGVyQm91bmRTZXF1ZW5jZU51bWJlcjtcclxuICAgICAgICBsZXQgc2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0LCB0YXJnZXRzUmVtb3ZlZDtcclxuICAgICAgICAvLyBUaW1lc3RhbXBzIGZvciB2YXJpb3VzIHBpZWNlcyBvZiB0aGUgcHJvY2Vzc1xyXG4gICAgICAgIGxldCBjb3VudGVkVGFyZ2V0c1RzLCBmb3VuZFVwcGVyQm91bmRUcywgcmVtb3ZlZFRhcmdldHNUcywgcmVtb3ZlZERvY3VtZW50c1RzO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVRhcmdldENvdW50KHR4biwgdGhpcy5wYXJhbXMucGVyY2VudGlsZVRvQ29sbGVjdClcclxuICAgICAgICAgICAgLm5leHQoc2VxdWVuY2VOdW1iZXJzID0+IHtcclxuICAgICAgICAgICAgLy8gQ2FwIGF0IHRoZSBjb25maWd1cmVkIG1heFxyXG4gICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXJzID4gdGhpcy5wYXJhbXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0xydUdhcmJhZ2VDb2xsZWN0b3InLCAnQ2FwcGluZyBzZXF1ZW5jZSBudW1iZXJzIHRvIGNvbGxlY3QgZG93biAnICtcclxuICAgICAgICAgICAgICAgICAgICBgdG8gdGhlIG1heGltdW0gb2YgJHt0aGlzLnBhcmFtcy5tYXhpbXVtU2VxdWVuY2VOdW1iZXJzVG9Db2xsZWN0fSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZnJvbSAke3NlcXVlbmNlTnVtYmVyc31gKTtcclxuICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMubWF4aW11bVNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdCA9IHNlcXVlbmNlTnVtYmVycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb3VudGVkVGFyZ2V0c1RzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnRoU2VxdWVuY2VOdW1iZXIodHhuLCBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KHVwcGVyQm91bmQgPT4ge1xyXG4gICAgICAgICAgICB1cHBlckJvdW5kU2VxdWVuY2VOdW1iZXIgPSB1cHBlckJvdW5kO1xyXG4gICAgICAgICAgICBmb3VuZFVwcGVyQm91bmRUcyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVRhcmdldHModHhuLCB1cHBlckJvdW5kU2VxdWVuY2VOdW1iZXIsIGFjdGl2ZVRhcmdldElkcyk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQobnVtVGFyZ2V0c1JlbW92ZWQgPT4ge1xyXG4gICAgICAgICAgICB0YXJnZXRzUmVtb3ZlZCA9IG51bVRhcmdldHNSZW1vdmVkO1xyXG4gICAgICAgICAgICByZW1vdmVkVGFyZ2V0c1RzID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlT3JwaGFuZWREb2N1bWVudHModHhuLCB1cHBlckJvdW5kU2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KGRvY3VtZW50c1JlbW92ZWQgPT4ge1xyXG4gICAgICAgICAgICByZW1vdmVkRG9jdW1lbnRzVHMgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA8PSBMb2dMZXZlbC5ERUJVRykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9ICdMUlUgR2FyYmFnZSBDb2xsZWN0aW9uXFxuJyArXHJcbiAgICAgICAgICAgICAgICAgICAgYFxcdENvdW50ZWQgdGFyZ2V0cyBpbiAke2NvdW50ZWRUYXJnZXRzVHMgLSBzdGFydFRzfW1zXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFxcdERldGVybWluZWQgbGVhc3QgcmVjZW50bHkgdXNlZCAke3NlcXVlbmNlTnVtYmVyc1RvQ29sbGVjdH0gaW4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYCR7Zm91bmRVcHBlckJvdW5kVHMgLSBjb3VudGVkVGFyZ2V0c1RzfW1zXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFxcdFJlbW92ZWQgJHt0YXJnZXRzUmVtb3ZlZH0gdGFyZ2V0cyBpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJHtyZW1vdmVkVGFyZ2V0c1RzIC0gZm91bmRVcHBlckJvdW5kVHN9bXNcXG5gICtcclxuICAgICAgICAgICAgICAgICAgICBgXFx0UmVtb3ZlZCAke2RvY3VtZW50c1JlbW92ZWR9IGRvY3VtZW50cyBpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJHtyZW1vdmVkRG9jdW1lbnRzVHMgLSByZW1vdmVkVGFyZ2V0c1RzfW1zXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYFRvdGFsIER1cmF0aW9uOiAke3JlbW92ZWREb2N1bWVudHNUcyAtIHN0YXJ0VHN9bXNgO1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0xydUdhcmJhZ2VDb2xsZWN0b3InLCBkZXNjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgZGlkUnVuOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgc2VxdWVuY2VOdW1iZXJzQ29sbGVjdGVkOiBzZXF1ZW5jZU51bWJlcnNUb0NvbGxlY3QsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRzUmVtb3ZlZCxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50c1JlbW92ZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3THJ1R2FyYmFnZUNvbGxlY3RvcihkZWxlZ2F0ZSwgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gbmV3IExydUdhcmJhZ2VDb2xsZWN0b3JJbXBsKGRlbGVnYXRlLCBwYXJhbXMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBQcm92aWRlcyBMUlUgZnVuY3Rpb25hbGl0eSBmb3IgSW5kZXhlZERCIHBlcnNpc3RlbmNlLiAqL1xyXG5jbGFzcyBJbmRleGVkRGJMcnVEZWxlZ2F0ZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZGIsIHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMuZGIgPSBkYjtcclxuICAgICAgICB0aGlzLmdhcmJhZ2VDb2xsZWN0b3IgPSBuZXdMcnVHYXJiYWdlQ29sbGVjdG9yKHRoaXMsIHBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBnZXRTZXF1ZW5jZU51bWJlckNvdW50KHR4bikge1xyXG4gICAgICAgIGNvbnN0IGRvY0NvdW50UHJvbWlzZSA9IHRoaXMub3JwaGFuZWREb2N1bWVudENvdW50KHR4bik7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Q291bnRQcm9taXNlID0gdGhpcy5kYi5nZXRUYXJnZXRDYWNoZSgpLmdldFRhcmdldENvdW50KHR4bik7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldENvdW50UHJvbWlzZS5uZXh0KHRhcmdldENvdW50ID0+IGRvY0NvdW50UHJvbWlzZS5uZXh0KGRvY0NvdW50ID0+IHRhcmdldENvdW50ICsgZG9jQ291bnQpKTtcclxuICAgIH1cclxuICAgIG9ycGhhbmVkRG9jdW1lbnRDb3VudCh0eG4pIHtcclxuICAgICAgICBsZXQgb3JwaGFuZWRDb3VudCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnRTZXF1ZW5jZU51bWJlcih0eG4sIF8gPT4ge1xyXG4gICAgICAgICAgICBvcnBoYW5lZENvdW50Kys7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiBvcnBoYW5lZENvdW50KTtcclxuICAgIH1cclxuICAgIGZvckVhY2hUYXJnZXQodHhuLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS5mb3JFYWNoVGFyZ2V0KHR4biwgZik7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoT3JwaGFuZWREb2N1bWVudFNlcXVlbmNlTnVtYmVyKHR4biwgZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgKGRvY0tleSwgc2VxdWVuY2VOdW1iZXIpID0+IGYoc2VxdWVuY2VOdW1iZXIpKTtcclxuICAgIH1cclxuICAgIGFkZFJlZmVyZW5jZSh0eG4sIHRhcmdldElkLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gd3JpdGVTZW50aW5lbEtleSh0eG4sIGtleSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVSZWZlcmVuY2UodHhuLCB0YXJnZXRJZCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRiLmdldFRhcmdldENhY2hlKCkucmVtb3ZlVGFyZ2V0cyh0eG4sIHVwcGVyQm91bmQsIGFjdGl2ZVRhcmdldElkcyk7XHJcbiAgICB9XHJcbiAgICBtYXJrUG90ZW50aWFsbHlPcnBoYW5lZCh0eG4sIGtleSkge1xyXG4gICAgICAgIHJldHVybiB3cml0ZVNlbnRpbmVsS2V5KHR4biwga2V5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFueXRoaW5nIHdvdWxkIHByZXZlbnQgdGhpcyBkb2N1bWVudCBmcm9tIGJlaW5nIGdhcmJhZ2VcclxuICAgICAqIGNvbGxlY3RlZCwgZ2l2ZW4gdGhhdCB0aGUgZG9jdW1lbnQgaW4gcXVlc3Rpb24gaXMgbm90IHByZXNlbnQgaW4gYW55XHJcbiAgICAgKiB0YXJnZXRzIGFuZCBoYXMgYSBzZXF1ZW5jZSBudW1iZXIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB1cHBlciBib3VuZCBmb3JcclxuICAgICAqIHRoZSBjb2xsZWN0aW9uIHJ1bi5cclxuICAgICAqL1xyXG4gICAgaXNQaW5uZWQodHhuLCBkb2NLZXkpIHtcclxuICAgICAgICByZXR1cm4gbXV0YXRpb25RdWV1ZXNDb250YWluS2V5KHR4biwgZG9jS2V5KTtcclxuICAgIH1cclxuICAgIHJlbW92ZU9ycGhhbmVkRG9jdW1lbnRzKHR4biwgdXBwZXJCb3VuZCkge1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50Q2FjaGUgPSB0aGlzLmRiLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcclxuICAgICAgICBjb25zdCBjaGFuZ2VCdWZmZXIgPSBkb2N1bWVudENhY2hlLm5ld0NoYW5nZUJ1ZmZlcigpO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgbGV0IGRvY3VtZW50Q291bnQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGl0ZXJhdGlvbiA9IHRoaXMuZm9yRWFjaE9ycGhhbmVkRG9jdW1lbnQodHhuLCAoZG9jS2V5LCBzZXF1ZW5jZU51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgPD0gdXBwZXJCb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuaXNQaW5uZWQodHhuLCBkb2NLZXkpLm5leHQoaXNQaW5uZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQaW5uZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXIgc2l6ZSBhY2NvdW50aW5nIHJlcXVpcmVzIHVzIHRvIHJlYWQgYWxsIGRvY3VtZW50cyBiZWZvcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZpbmcgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUJ1ZmZlci5nZXRFbnRyeSh0eG4sIGRvY0tleSkubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VCdWZmZXIucmVtb3ZlRW50cnkoZG9jS2V5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50VGFyZ2V0U3RvcmUodHhuKS5kZWxldGUoc2VudGluZWxLZXkkMShkb2NLZXkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNoYW5nZUJ1ZmZlci5hcHBseSh0eG4pKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudENvdW50KTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRhcmdldCh0eG4sIHRhcmdldERhdGEpIHtcclxuICAgICAgICBjb25zdCB1cGRhdGVkID0gdGFyZ2V0RGF0YS53aXRoU2VxdWVuY2VOdW1iZXIodHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZ2V0VGFyZ2V0Q2FjaGUoKS51cGRhdGVUYXJnZXREYXRhKHR4biwgdXBkYXRlZCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMaW1ib0RvY3VtZW50KHR4biwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIHByb3ZpZGVkIGZ1bmN0aW9uIGZvciBlYWNoIGRvY3VtZW50IGluIHRoZSBjYWNoZSB0aGF0IGlzICdvcnBoYW5lZCcuIE9ycGhhbmVkXHJcbiAgICAgKiBtZWFucyBub3QgYSBwYXJ0IG9mIGFueSB0YXJnZXQsIHNvIHRoZSBvbmx5IGVudHJ5IGluIHRoZSB0YXJnZXQtZG9jdW1lbnQgaW5kZXggZm9yXHJcbiAgICAgKiB0aGF0IGRvY3VtZW50IHdpbGwgYmUgdGhlIHNlbnRpbmVsIHJvdyAodGFyZ2V0SWQgMCksIHdoaWNoIHdpbGwgYWxzbyBoYXZlIHRoZSBzZXF1ZW5jZVxyXG4gICAgICogbnVtYmVyIGZvciB0aGUgbGFzdCB0aW1lIHRoZSBkb2N1bWVudCB3YXMgYWNjZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2hPcnBoYW5lZERvY3VtZW50KHR4biwgZikge1xyXG4gICAgICAgIGNvbnN0IHN0b3JlID0gZG9jdW1lbnRUYXJnZXRTdG9yZSh0eG4pO1xyXG4gICAgICAgIGxldCBuZXh0VG9SZXBvcnQgPSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEO1xyXG4gICAgICAgIGxldCBuZXh0UGF0aDtcclxuICAgICAgICByZXR1cm4gc3RvcmVcclxuICAgICAgICAgICAgLml0ZXJhdGUoe1xyXG4gICAgICAgICAgICBpbmRleDogRGJUYXJnZXREb2N1bWVudC5kb2N1bWVudFRhcmdldHNJbmRleFxyXG4gICAgICAgIH0sIChbdGFyZ2V0SWQsIGRvY0tleV0sIHsgcGF0aCwgc2VxdWVuY2VOdW1iZXIgfSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIG5leHRUb1JlcG9ydCBpcyB2YWxpZCwgcmVwb3J0IGl0LCB0aGlzIGlzIGEgbmV3IGtleSBzbyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGxhc3Qgb25lIG11c3Qgbm90IGJlIGEgbWVtYmVyIG9mIGFueSB0YXJnZXRzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRUb1JlcG9ydCAhPT0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYobmV3IERvY3VtZW50S2V5KGRlY29kZVJlc291cmNlUGF0aChuZXh0UGF0aCkpLCBuZXh0VG9SZXBvcnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IG5leHRUb1JlcG9ydCB0byBiZSB0aGlzIHNlcXVlbmNlIG51bWJlci4gSXQncyB0aGUgbmV4dCBvbmUgd2VcclxuICAgICAgICAgICAgICAgIC8vIG1pZ2h0IHJlcG9ydCwgaWYgd2UgZG9uJ3QgZmluZCBhbnkgdGFyZ2V0cyBmb3IgdGhpcyBkb2N1bWVudC5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgc2VxdWVuY2UgbnVtYmVyIG11c3QgYmUgZGVmaW5lZCB3aGVuIHRoZSB0YXJnZXRJZFxyXG4gICAgICAgICAgICAgICAgLy8gaXMgMC5cclxuICAgICAgICAgICAgICAgIG5leHRUb1JlcG9ydCA9IHNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgbmV4dFBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IG5leHRUb1JlcG9ydCB0byBiZSBpbnZhbGlkLCB3ZSBrbm93IHdlIGRvbid0IG5lZWQgdG8gcmVwb3J0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG9uZSBzaW5jZSB3ZSBmb3VuZCBhIHRhcmdldCBmb3IgaXQuXHJcbiAgICAgICAgICAgICAgICBuZXh0VG9SZXBvcnQgPSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSByZXBvcnQgc2VxdWVuY2UgbnVtYmVycyBhZnRlciBnZXR0aW5nIHRvIHRoZSBuZXh0IGtleSwgd2VcclxuICAgICAgICAgICAgLy8gbmVlZCB0byBjaGVjayBpZiB0aGUgbGFzdCBrZXkgd2UgaXRlcmF0ZWQgb3ZlciB3YXMgYW4gb3JwaGFuZWRcclxuICAgICAgICAgICAgLy8gZG9jdW1lbnQgYW5kIHJlcG9ydCBpdC5cclxuICAgICAgICAgICAgaWYgKG5leHRUb1JlcG9ydCAhPT0gTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkge1xyXG4gICAgICAgICAgICAgICAgZihuZXcgRG9jdW1lbnRLZXkoZGVjb2RlUmVzb3VyY2VQYXRoKG5leHRQYXRoKSksIG5leHRUb1JlcG9ydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldENhY2hlU2l6ZSh0eG4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYi5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCkuZ2V0U2l6ZSh0eG4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNlbnRpbmVsS2V5JDEoa2V5KSB7XHJcbiAgICByZXR1cm4gWzAsIGVuY29kZVJlc291cmNlUGF0aChrZXkucGF0aCldO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBBIHZhbHVlIHN1aXRhYmxlIGZvciB3cml0aW5nIGEgc2VudGluZWwgcm93IGluIHRoZSB0YXJnZXQtZG9jdW1lbnRcclxuICogc3RvcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZW50aW5lbFJvdyhrZXksIHNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICByZXR1cm4gbmV3IERiVGFyZ2V0RG9jdW1lbnQoMCwgZW5jb2RlUmVzb3VyY2VQYXRoKGtleS5wYXRoKSwgc2VxdWVuY2VOdW1iZXIpO1xyXG59XHJcbmZ1bmN0aW9uIHdyaXRlU2VudGluZWxLZXkodHhuLCBrZXkpIHtcclxuICAgIHJldHVybiBkb2N1bWVudFRhcmdldFN0b3JlKHR4bikucHV0KHNlbnRpbmVsUm93KGtleSwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcikpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIG1hcCBpbXBsZW1lbnRhdGlvbiB0aGF0IHVzZXMgb2JqZWN0cyBhcyBrZXlzLiBPYmplY3RzIG11c3QgaGF2ZSBhblxyXG4gKiBhc3NvY2lhdGVkIGVxdWFscyBmdW5jdGlvbiBhbmQgbXVzdCBiZSBpbW11dGFibGUuIEVudHJpZXMgaW4gdGhlIG1hcCBhcmVcclxuICogc3RvcmVkIHRvZ2V0aGVyIHdpdGggdGhlIGtleSBiZWluZyBwcm9kdWNlZCBmcm9tIHRoZSBtYXBLZXlGbi4gVGhpcyBtYXBcclxuICogYXV0b21hdGljYWxseSBoYW5kbGVzIGNvbGxpc2lvbnMgb2Yga2V5cy5cclxuICovXHJcbmNsYXNzIE9iamVjdE1hcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXBLZXlGbiwgZXF1YWxzRm4pIHtcclxuICAgICAgICB0aGlzLm1hcEtleUZuID0gbWFwS2V5Rm47XHJcbiAgICAgICAgdGhpcy5lcXVhbHNGbiA9IGVxdWFsc0ZuO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbm5lciBtYXAgZm9yIGEga2V5L3ZhbHVlIHBhaXIuIER1ZSB0byB0aGUgcG9zc2liaWxpdHkgb2YgY29sbGlzaW9ucyB3ZVxyXG4gICAgICAgICAqIGtlZXAgYSBsaXN0IG9mIGVudHJpZXMgdGhhdCB3ZSBkbyBhIGxpbmVhciBzZWFyY2ggdGhyb3VnaCB0byBmaW5kIGFuIGFjdHVhbFxyXG4gICAgICAgICAqIG1hdGNoLiBOb3RlIHRoYXQgY29sbGlzaW9ucyBzaG91bGQgYmUgcmFyZSwgc28gd2Ugc3RpbGwgZXhwZWN0IG5lYXJcclxuICAgICAgICAgKiBjb25zdGFudCB0aW1lIGxvb2t1cHMgaW4gcHJhY3RpY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbm5lciA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqIEdldCBhIHZhbHVlIGZvciB0aGlzIGtleSwgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LiAqL1xyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tYXBLZXlGbihrZXkpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcclxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgW290aGVyS2V5LCB2YWx1ZV0gb2YgbWF0Y2hlcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGbihvdGhlcktleSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKiBQdXQgdGhpcyBrZXkgYW5kIHZhbHVlIGluIHRoZSBtYXAuICovXHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5tYXBLZXlGbihrZXkpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmlubmVyW2lkXTtcclxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5uZXJbaWRdID0gW1trZXksIHZhbHVlXV07XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0ZuKG1hdGNoZXNbaV1bMF0sIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZXNbaV0gPSBba2V5LCB2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0Y2hlcy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSB0aGlzIGtleSBmcm9tIHRoZSBtYXAuIFJldHVybnMgYSBib29sZWFuIGlmIGFueXRoaW5nIHdhcyBkZWxldGVkLlxyXG4gICAgICovXHJcbiAgICBkZWxldGUoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLm1hcEtleUZuKGtleSk7XHJcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuaW5uZXJbaWRdO1xyXG4gICAgICAgIGlmIChtYXRjaGVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzRm4obWF0Y2hlc1tpXVswXSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5uZXJbaWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoKGZuKSB7XHJcbiAgICAgICAgZm9yRWFjaCh0aGlzLmlubmVyLCAoXywgZW50cmllcykgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmbihrLCB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmlubmVyKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW4tbWVtb3J5IGJ1ZmZlciBvZiBlbnRyaWVzIHRvIGJlIHdyaXR0ZW4gdG8gYSBSZW1vdGVEb2N1bWVudENhY2hlLlxyXG4gKiBJdCBjYW4gYmUgdXNlZCB0byBiYXRjaCB1cCBhIHNldCBvZiBjaGFuZ2VzIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIGNhY2hlLCBidXRcclxuICogYWRkaXRpb25hbGx5IHN1cHBvcnRzIHJlYWRpbmcgZW50cmllcyBiYWNrIHdpdGggdGhlIGBnZXRFbnRyeSgpYCBtZXRob2QsXHJcbiAqIGZhbGxpbmcgYmFjayB0byB0aGUgdW5kZXJseWluZyBSZW1vdGVEb2N1bWVudENhY2hlIGlmIG5vIGVudHJ5IGlzXHJcbiAqIGJ1ZmZlcmVkLlxyXG4gKlxyXG4gKiBFbnRyaWVzIGFkZGVkIHRvIHRoZSBjYWNoZSAqbXVzdCogYmUgcmVhZCBmaXJzdC4gVGhpcyBpcyB0byBmYWNpbGl0YXRlXHJcbiAqIGNhbGN1bGF0aW5nIHRoZSBzaXplIGRlbHRhIG9mIHRoZSBwZW5kaW5nIGNoYW5nZXMuXHJcbiAqXHJcbiAqIFBPUlRJTkcgTk9URTogVGhpcyBjbGFzcyB3YXMgaW1wbGVtZW50ZWQgdGhlbiByZW1vdmVkIGZyb20gb3RoZXIgcGxhdGZvcm1zLlxyXG4gKiBJZiBieXRlLWNvdW50aW5nIGVuZHMgdXAgYmVpbmcgbmVlZGVkIG9uIHRoZSBvdGhlciBwbGF0Zm9ybXMsIGNvbnNpZGVyXHJcbiAqIHBvcnRpbmcgdGhpcyBjbGFzcyBhcyBwYXJ0IG9mIHRoYXQgaW1wbGVtZW50YXRpb24gd29yay5cclxuICovXHJcbmNsYXNzIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vIEEgbWFwcGluZyBvZiBkb2N1bWVudCBrZXkgdG8gdGhlIG5ldyBjYWNoZSBlbnRyeSB0aGF0IHNob3VsZCBiZSB3cml0dGVuLlxyXG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IG5ldyBPYmplY3RNYXAoa2V5ID0+IGtleS50b1N0cmluZygpLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXNBcHBsaWVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJ1ZmZlcnMgYSBgUmVtb3RlRG9jdW1lbnRDYWNoZS5hZGRFbnRyeSgpYCBjYWxsLlxyXG4gICAgICpcclxuICAgICAqIFlvdSBjYW4gb25seSBtb2RpZnkgZG9jdW1lbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcmV0cmlldmVkIHZpYVxyXG4gICAgICogYGdldEVudHJ5KCkvZ2V0RW50cmllcygpYCAoZW5mb3JjZWQgdmlhIEluZGV4ZWREYnMgYGFwcGx5KClgKS5cclxuICAgICAqL1xyXG4gICAgYWRkRW50cnkoZG9jdW1lbnQpIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGRvY3VtZW50LmtleSwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWZmZXJzIGEgYFJlbW90ZURvY3VtZW50Q2FjaGUucmVtb3ZlRW50cnkoKWAgY2FsbC5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgY2FuIG9ubHkgcmVtb3ZlIGRvY3VtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCB2aWFcclxuICAgICAqIGBnZXRFbnRyeSgpL2dldEVudHJpZXMoKWAgKGVuZm9yY2VkIHZpYSBJbmRleGVkRGJzIGBhcHBseSgpYCkuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUVudHJ5KGtleSwgcmVhZFRpbWUpIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXMuc2V0KGtleSwgTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChrZXkpLnNldFJlYWRUaW1lKHJlYWRUaW1lKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvb2tzIHVwIGFuIGVudHJ5IGluIHRoZSBjYWNoZS4gVGhlIGJ1ZmZlcmVkIGNoYW5nZXMgd2lsbCBmaXJzdCBiZSBjaGVja2VkLFxyXG4gICAgICogYW5kIGlmIG5vIGJ1ZmZlcmVkIGNoYW5nZSBhcHBsaWVzLCB0aGlzIHdpbGwgZm9yd2FyZCB0b1xyXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm0gYW55IHBlcnNpc3RlbmNlXHJcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cclxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleSAtIFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIGRvY3VtZW50IG9yIGFuIGludmFsaWQgZG9jdW1lbnQgaWYgd2UgaGF2ZSBub3RoaW5nXHJcbiAgICAgKiBjYWNoZWQuXHJcbiAgICAgKi9cclxuICAgIGdldEVudHJ5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xyXG4gICAgICAgIHRoaXMuYXNzZXJ0Tm90QXBwbGllZCgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkRW50cnkgPSB0aGlzLmNoYW5nZXMuZ2V0KGRvY3VtZW50S2V5KTtcclxuICAgICAgICBpZiAoYnVmZmVyZWRFbnRyeSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZShidWZmZXJlZEVudHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZyb21DYWNoZSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9va3MgdXAgc2V2ZXJhbCBlbnRyaWVzIGluIHRoZSBjYWNoZSwgZm9yd2FyZGluZyB0b1xyXG4gICAgICogYFJlbW90ZURvY3VtZW50Q2FjaGUuZ2V0RW50cnkoKWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIGluIHdoaWNoIHRvIHBlcmZvcm0gYW55IHBlcnNpc3RlbmNlXHJcbiAgICAgKiAgICAgb3BlcmF0aW9ucy5cclxuICAgICAqIEBwYXJhbSBkb2N1bWVudEtleXMgLSBUaGUga2V5cyBvZiB0aGUgZW50cmllcyB0byBsb29rIHVwLlxyXG4gICAgICogQHJldHVybnMgQSBtYXAgb2YgY2FjaGVkIGRvY3VtZW50cywgaW5kZXhlZCBieSBrZXkuIElmIGFuIGVudHJ5IGNhbm5vdCBiZVxyXG4gICAgICogICAgIGZvdW5kLCB0aGUgY29ycmVzcG9uZGluZyBrZXkgd2lsbCBiZSBtYXBwZWQgdG8gYW4gaW52YWxpZCBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGJ1ZmZlcmVkIGNoYW5nZXMgdG8gdGhlIHVuZGVybHlpbmcgUmVtb3RlRG9jdW1lbnRDYWNoZSwgdXNpbmdcclxuICAgICAqIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbi5cclxuICAgICAqL1xyXG4gICAgYXBwbHkodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmFzc2VydE5vdEFwcGxpZWQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZXNBcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUNoYW5nZXModHJhbnNhY3Rpb24pO1xyXG4gICAgfVxyXG4gICAgLyoqIEhlbHBlciB0byBhc3NlcnQgdGhpcy5jaGFuZ2VzIGlzIG5vdCBudWxsICAqL1xyXG4gICAgYXNzZXJ0Tm90QXBwbGllZCgpIHtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIFJlbW90ZURvY3VtZW50Q2FjaGUgZm9yIEluZGV4ZWREYi4gVG8gY29uc3RydWN0LCBpbnZva2VcclxuICogYG5ld0luZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUoKWAuXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgIH1cclxuICAgIHNldEluZGV4TWFuYWdlcihpbmRleE1hbmFnZXIpIHtcclxuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgc3VwcGxpZWQgZW50cmllcyB0byB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQWxsIGNhbGxzIG9mIGBhZGRFbnRyeWAgYXJlIHJlcXVpcmVkIHRvIGdvIHRocm91Z2ggdGhlIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyXHJcbiAgICAgKiByZXR1cm5lZCBieSBgbmV3Q2hhbmdlQnVmZmVyKClgIHRvIGVuc3VyZSBwcm9wZXIgYWNjb3VudGluZyBvZiBtZXRhZGF0YS5cclxuICAgICAqL1xyXG4gICAgYWRkRW50cnkodHJhbnNhY3Rpb24sIGtleSwgZG9jKSB7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRTdG9yZSA9IHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRTdG9yZS5wdXQoZGJLZXkoa2V5KSwgZG9jKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGRvY3VtZW50IGZyb20gdGhlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEFsbCBjYWxscyBvZiBgcmVtb3ZlRW50cnlgICBhcmUgcmVxdWlyZWQgdG8gZ28gdGhyb3VnaCB0aGUgUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXJcclxuICAgICAqIHJldHVybmVkIGJ5IGBuZXdDaGFuZ2VCdWZmZXIoKWAgdG8gZW5zdXJlIHByb3BlciBhY2NvdW50aW5nIG9mIG1ldGFkYXRhLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICBjb25zdCBrZXkgPSBkYktleShkb2N1bWVudEtleSk7XHJcbiAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShrZXkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IGNhY2hlIHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQ2FsbGVycyB0byBgYWRkRW50cnkoKWAgYW5kIGByZW1vdmVFbnRyeSgpYCAqbXVzdCogY2FsbCB0aGlzIGFmdGVyd2FyZHMgdG8gdXBkYXRlIHRoZVxyXG4gICAgICogY2FjaGUncyBtZXRhZGF0YS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlTWV0YWRhdGEodHJhbnNhY3Rpb24sIHNpemVEZWx0YSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKHRyYW5zYWN0aW9uKS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgbWV0YWRhdGEuYnl0ZVNpemUgKz0gc2l6ZURlbHRhO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNZXRhZGF0YSh0cmFuc2FjdGlvbiwgbWV0YWRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuZ2V0KGRiS2V5KGRvY3VtZW50S2V5KSlcclxuICAgICAgICAgICAgLm5leHQoZGJSZW1vdGVEb2MgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXliZURlY29kZURvY3VtZW50KGRvY3VtZW50S2V5LCBkYlJlbW90ZURvYyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvb2tzIHVwIGFuIGVudHJ5IGluIHRoZSBjYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRLZXkgLSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBsb29rIHVwLlxyXG4gICAgICogQHJldHVybnMgVGhlIGNhY2hlZCBkb2N1bWVudCBlbnRyeSBhbmQgaXRzIHNpemUuXHJcbiAgICAgKi9cclxuICAgIGdldFNpemVkRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuZ2V0KGRiS2V5KGRvY3VtZW50S2V5KSlcclxuICAgICAgICAgICAgLm5leHQoZGJSZW1vdGVEb2MgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoZG9jdW1lbnRLZXksIGRiUmVtb3RlRG9jKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50OiBkb2MsXHJcbiAgICAgICAgICAgICAgICBzaXplOiBkYkRvY3VtZW50U2l6ZShkYlJlbW90ZURvYylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgKGtleSwgZGJSZW1vdGVEb2MpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZG9jID0gdGhpcy5tYXliZURlY29kZURvY3VtZW50KGtleSwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvb2tzIHVwIHNldmVyYWwgZW50cmllcyBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50S2V5cyAtIFRoZSBzZXQgb2Yga2V5cyBlbnRyaWVzIHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBBIG1hcCBvZiBkb2N1bWVudHMgaW5kZXhlZCBieSBrZXkgYW5kIGEgbWFwIG9mIHNpemVzIGluZGV4ZWQgYnlcclxuICAgICAqICAgICBrZXkgKHplcm8gaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGV4aXN0KS5cclxuICAgICAqL1xyXG4gICAgZ2V0U2l6ZWRFbnRyaWVzKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcclxuICAgICAgICBsZXQgcmVzdWx0cyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xyXG4gICAgICAgIGxldCBzaXplTWFwID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JFYWNoRGJFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzLCAoa2V5LCBkYlJlbW90ZURvYykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoa2V5LCBkYlJlbW90ZURvYyk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChrZXksIGRvYyk7XHJcbiAgICAgICAgICAgIHNpemVNYXAgPSBzaXplTWFwLmluc2VydChrZXksIGRiRG9jdW1lbnRTaXplKGRiUmVtb3RlRG9jKSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50czogcmVzdWx0cywgc2l6ZU1hcCB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaERiRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnRLZXlzLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBJREJLZXlSYW5nZS5ib3VuZChkb2N1bWVudEtleXMuZmlyc3QoKS5wYXRoLnRvQXJyYXkoKSwgZG9jdW1lbnRLZXlzLmxhc3QoKS5wYXRoLnRvQXJyYXkoKSk7XHJcbiAgICAgICAgY29uc3Qga2V5SXRlciA9IGRvY3VtZW50S2V5cy5nZXRJdGVyYXRvcigpO1xyXG4gICAgICAgIGxldCBuZXh0S2V5ID0ga2V5SXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuaXRlcmF0ZSh7IHJhbmdlIH0sIChwb3RlbnRpYWxLZXlSYXcsIGRiUmVtb3RlRG9jLCBjb250cm9sKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvdGVudGlhbEtleSA9IERvY3VtZW50S2V5LmZyb21TZWdtZW50cyhwb3RlbnRpYWxLZXlSYXcpO1xyXG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGtleXMgbm90IGZvdW5kIGluIGNhY2hlLlxyXG4gICAgICAgICAgICB3aGlsZSAobmV4dEtleSAmJiBEb2N1bWVudEtleS5jb21wYXJhdG9yKG5leHRLZXksIHBvdGVudGlhbEtleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXh0S2V5LCBudWxsKTtcclxuICAgICAgICAgICAgICAgIG5leHRLZXkgPSBrZXlJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV4dEtleSAmJiBuZXh0S2V5LmlzRXF1YWwocG90ZW50aWFsS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gS2V5IGZvdW5kIGluIGNhY2hlLlxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV4dEtleSwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgICAgICAgICAgbmV4dEtleSA9IGtleUl0ZXIuaGFzTmV4dCgpID8ga2V5SXRlci5nZXROZXh0KCkgOiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFNraXAgdG8gdGhlIG5leHQga2V5IChpZiB0aGVyZSBpcyBvbmUpLlxyXG4gICAgICAgICAgICBpZiAobmV4dEtleSkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5za2lwKG5leHRLZXkucGF0aC50b0FycmF5KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFRoZSByZXN0IG9mIHRoZSBrZXlzIGFyZSBub3QgaW4gdGhlIGNhY2hlLiBPbmUgY2FzZSB3aGVyZSBgaXRlcmF0ZWBcclxuICAgICAgICAgICAgLy8gYWJvdmUgd29uJ3QgZ28gdGhyb3VnaCB0aGVtIGlzIHdoZW4gdGhlIGNhY2hlIGlzIGVtcHR5LlxyXG4gICAgICAgICAgICB3aGlsZSAobmV4dEtleSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV4dEtleSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0S2V5ID0ga2V5SXRlci5oYXNOZXh0KCkgPyBrZXlJdGVyLmdldE5leHQoKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldEFsbCh0cmFuc2FjdGlvbiwgY29sbGVjdGlvbiwgc2luY2VSZWFkVGltZSkge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgY29uc3QgaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGggKyAxO1xyXG4gICAgICAgIGNvbnN0IGl0ZXJhdGlvbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICBpZiAoc2luY2VSZWFkVGltZS5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcclxuICAgICAgICAgICAgLy8gRG9jdW1lbnRzIGFyZSBvcmRlcmVkIGJ5IGtleSwgc28gd2UgY2FuIHVzZSBhIHByZWZpeCBzY2FuIHRvIG5hcnJvd1xyXG4gICAgICAgICAgICAvLyBkb3duIHRoZSBkb2N1bWVudHMgd2UgbmVlZCB0byBtYXRjaCB0aGUgcXVlcnkgYWdhaW5zdC5cclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRLZXkgPSBjb2xsZWN0aW9uLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgaXRlcmF0aW9uT3B0aW9ucy5yYW5nZSA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoc3RhcnRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBhbiBpbmRleC1mcmVlIHF1ZXJ5IGFuZCBmaWx0ZXIgYnkgcmVhZCB0aW1lLiBUaGlzIGlzIHNhZmVcclxuICAgICAgICAgICAgLy8gc2luY2UgYWxsIGRvY3VtZW50IGNoYW5nZXMgdG8gcXVlcmllcyB0aGF0IGhhdmUgYVxyXG4gICAgICAgICAgICAvLyBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uIChgc2luY2VSZWFkVGltZWApIGhhdmUgYSByZWFkIHRpbWUgc2V0LlxyXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aW9uS2V5ID0gY29sbGVjdGlvbi50b0FycmF5KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlYWRUaW1lS2V5ID0gdG9EYlRpbWVzdGFtcEtleShzaW5jZVJlYWRUaW1lKTtcclxuICAgICAgICAgICAgaXRlcmF0aW9uT3B0aW9ucy5yYW5nZSA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoW2NvbGxlY3Rpb25LZXksIHJlYWRUaW1lS2V5XSwgXHJcbiAgICAgICAgICAgIC8qIG9wZW49ICovIHRydWUpO1xyXG4gICAgICAgICAgICBpdGVyYXRpb25PcHRpb25zLmluZGV4ID0gRGJSZW1vdGVEb2N1bWVudC5jb2xsZWN0aW9uUmVhZFRpbWVJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZURvY3VtZW50c1N0b3JlKHRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAuaXRlcmF0ZShpdGVyYXRpb25PcHRpb25zLCAoa2V5LCBkYlJlbW90ZURvYywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBUaGUgcXVlcnkgaXMgYWN0dWFsbHkgcmV0dXJuaW5nIGFueSBwYXRoIHRoYXQgc3RhcnRzIHdpdGggdGhlIHF1ZXJ5XHJcbiAgICAgICAgICAgIC8vIHBhdGggcHJlZml4IHdoaWNoIG1heSBpbmNsdWRlIGRvY3VtZW50cyBpbiBzdWJjb2xsZWN0aW9ucy4gRm9yXHJcbiAgICAgICAgICAgIC8vIGV4YW1wbGUsIGEgcXVlcnkgb24gJ3Jvb21zJyB3aWxsIHJldHVybiByb29tcy9hYmMvbWVzc2FnZXMveHl4IGJ1dCB3ZVxyXG4gICAgICAgICAgICAvLyBzaG91bGRuJ3QgbWF0Y2ggaXQuIEZpeCB0aGlzIGJ5IGRpc2NhcmRpbmcgcm93cyB3aXRoIGRvY3VtZW50IGtleXNcclxuICAgICAgICAgICAgLy8gbW9yZSB0aGFuIG9uZSBzZWdtZW50IGxvbmdlciB0aGFuIHRoZSBxdWVyeSBwYXRoLlxyXG4gICAgICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLm1heWJlRGVjb2RlRG9jdW1lbnQoRG9jdW1lbnRLZXkuZnJvbVNlZ21lbnRzKGtleSksIGRiUmVtb3RlRG9jKTtcclxuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb24uaXNQcmVmaXhPZihkb2N1bWVudC5rZXkucGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChkb2N1bWVudC5rZXksIGRvY3VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICBuZXdDaGFuZ2VCdWZmZXIob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodGhpcywgISFvcHRpb25zICYmIG9wdGlvbnMudHJhY2tSZW1vdmFscyk7XHJcbiAgICB9XHJcbiAgICBnZXRTaXplKHR4bikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKHR4bikubmV4dChtZXRhZGF0YSA9PiBtZXRhZGF0YS5ieXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICBnZXRNZXRhZGF0YSh0eG4pIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRHbG9iYWxTdG9yZSh0eG4pXHJcbiAgICAgICAgICAgIC5nZXQoRGJSZW1vdGVEb2N1bWVudEdsb2JhbC5rZXkpXHJcbiAgICAgICAgICAgIC5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgaGFyZEFzc2VydCghIW1ldGFkYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0TWV0YWRhdGEodHhuLCBtZXRhZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudEdsb2JhbFN0b3JlKHR4bikucHV0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWwua2V5LCBtZXRhZGF0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYGRiUmVtb3RlRG9jYCBhbmQgcmV0dXJucyB0aGUgZG9jdW1lbnQgKG9yIGFuIGludmFsaWQgZG9jdW1lbnQgaWZcclxuICAgICAqIHRoZSBkb2N1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgZm9ybWF0IHVzZWQgZm9yIHNlbnRpbmVsIGRlbGV0ZXMpLlxyXG4gICAgICovXHJcbiAgICBtYXliZURlY29kZURvY3VtZW50KGRvY3VtZW50S2V5LCBkYlJlbW90ZURvYykge1xyXG4gICAgICAgIGlmIChkYlJlbW90ZURvYykge1xyXG4gICAgICAgICAgICBjb25zdCBkb2MgPSBmcm9tRGJSZW1vdGVEb2N1bWVudCh0aGlzLnNlcmlhbGl6ZXIsIGRiUmVtb3RlRG9jKTtcclxuICAgICAgICAgICAgLy8gV2hldGhlciB0aGUgZG9jdW1lbnQgaXMgYSBzZW50aW5lbCByZW1vdmFsIGFuZCBzaG91bGQgb25seSBiZSB1c2VkIGluIHRoZVxyXG4gICAgICAgICAgICAvLyBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgXHJcbiAgICAgICAgICAgIGNvbnN0IGlzU2VudGluZWxSZW1vdmFsID0gZG9jLmlzTm9Eb2N1bWVudCgpICYmIGRvYy52ZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKTtcclxuICAgICAgICAgICAgaWYgKCFpc1NlbnRpbmVsUmVtb3ZhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSk7XHJcbiAgICB9XHJcbn1cclxuLyoqIENyZWF0ZXMgYSBuZXcgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZS4gKi9cclxuZnVuY3Rpb24gbmV3SW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDYWNoZShzZXJpYWxpemVyKSB7XHJcbiAgICByZXR1cm4gbmV3IEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGVJbXBsKHNlcmlhbGl6ZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoYXQgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBzcGVjaWZpZWQgcmVhZFxyXG4gKiB0aW1lLlxyXG4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi5cclxuZnVuY3Rpb24gcmVtb3RlRG9jdW1lbnRDYWNoZUdldE5ld0RvY3VtZW50Q2hhbmdlcyhyZW1vdGVEb2N1bWVudENhY2hlLCB0cmFuc2FjdGlvbiwgc2luY2VSZWFkVGltZSkge1xyXG4gICAgY29uc3QgcmVtb3RlRG9jdW1lbnRDYWNoZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlRG9jdW1lbnRDYWNoZSk7XHJcbiAgICBsZXQgY2hhbmdlZERvY3MgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgIGxldCBsYXN0UmVhZFRpbWUgPSB0b0RiVGltZXN0YW1wS2V5KHNpbmNlUmVhZFRpbWUpO1xyXG4gICAgY29uc3QgZG9jdW1lbnRzU3RvcmUgPSByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICBjb25zdCByYW5nZSA9IElEQktleVJhbmdlLmxvd2VyQm91bmQobGFzdFJlYWRUaW1lLCB0cnVlKTtcclxuICAgIHJldHVybiBkb2N1bWVudHNTdG9yZVxyXG4gICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnQucmVhZFRpbWVJbmRleCwgcmFuZ2UgfSwgKF8sIGRiUmVtb3RlRG9jKSA9PiB7XHJcbiAgICAgICAgLy8gVW5saWtlIGBnZXRFbnRyeSgpYCBhbmQgb3RoZXJzLCBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgIHBhcnNlc1xyXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudHMgZGlyZWN0bHkgc2luY2Ugd2Ugd2FudCB0byBrZWVwIHNlbnRpbmVsIGRlbGV0ZXMuXHJcbiAgICAgICAgY29uc3QgZG9jID0gZnJvbURiUmVtb3RlRG9jdW1lbnQocmVtb3RlRG9jdW1lbnRDYWNoZUltcGwuc2VyaWFsaXplciwgZGJSZW1vdGVEb2MpO1xyXG4gICAgICAgIGNoYW5nZWREb2NzID0gY2hhbmdlZERvY3MuaW5zZXJ0KGRvYy5rZXksIGRvYyk7XHJcbiAgICAgICAgbGFzdFJlYWRUaW1lID0gZGJSZW1vdGVEb2MucmVhZFRpbWU7XHJcbiAgICB9KVxyXG4gICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjaGFuZ2VkRG9jcyxcclxuICAgICAgICAgICAgcmVhZFRpbWU6IGZyb21EYlRpbWVzdGFtcEtleShsYXN0UmVhZFRpbWUpXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByZWFkIHRpbWUgb2YgdGhlIG1vc3QgcmVjZW50bHkgcmVhZCBkb2N1bWVudCBpbiB0aGUgY2FjaGUsIG9yXHJcbiAqIFNuYXBzaG90VmVyc2lvbi5taW4oKSBpZiBub3QgYXZhaWxhYmxlLlxyXG4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi5cclxuZnVuY3Rpb24gcmVtb3RlRG9jdW1lbnRDYWNoZUdldExhc3RSZWFkVGltZSh0cmFuc2FjdGlvbikge1xyXG4gICAgY29uc3QgZG9jdW1lbnRzU3RvcmUgPSByZW1vdGVEb2N1bWVudHNTdG9yZSh0cmFuc2FjdGlvbik7XHJcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZXhpc3RpbmcgZW50cmllcywgd2UgcmV0dXJuIFNuYXBzaG90VmVyc2lvbi5taW4oKS5cclxuICAgIGxldCByZWFkVGltZSA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgIHJldHVybiBkb2N1bWVudHNTdG9yZVxyXG4gICAgICAgIC5pdGVyYXRlKHsgaW5kZXg6IERiUmVtb3RlRG9jdW1lbnQucmVhZFRpbWVJbmRleCwgcmV2ZXJzZTogdHJ1ZSB9LCAoa2V5LCBkYlJlbW90ZURvYywgY29udHJvbCkgPT4ge1xyXG4gICAgICAgIGlmIChkYlJlbW90ZURvYy5yZWFkVGltZSkge1xyXG4gICAgICAgICAgICByZWFkVGltZSA9IGZyb21EYlRpbWVzdGFtcEtleShkYlJlbW90ZURvYy5yZWFkVGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRyb2wuZG9uZSgpO1xyXG4gICAgfSlcclxuICAgICAgICAubmV4dCgoKSA9PiByZWFkVGltZSk7XHJcbn1cclxuLyoqXHJcbiAqIEhhbmRsZXMgdGhlIGRldGFpbHMgb2YgYWRkaW5nIGFuZCB1cGRhdGluZyBkb2N1bWVudHMgaW4gdGhlIEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUuXHJcbiAqXHJcbiAqIFVubGlrZSB0aGUgTWVtb3J5UmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIsIHRoZSBJbmRleGVkRGIgaW1wbGVtZW50YXRpb24gY29tcHV0ZXMgdGhlIHNpemVcclxuICogZGVsdGEgZm9yIGFsbCBzdWJtaXR0ZWQgY2hhbmdlcy4gVGhpcyBhdm9pZHMgaGF2aW5nIHRvIHJlLXJlYWQgYWxsIGRvY3VtZW50cyBmcm9tIEluZGV4ZWREYlxyXG4gKiB3aGVuIHdlIGFwcGx5IHRoZSBjaGFuZ2VzLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiUmVtb3RlRG9jdW1lbnRDaGFuZ2VCdWZmZXIgZXh0ZW5kcyBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudENhY2hlIC0gVGhlIEluZGV4ZWREYlJlbW90ZURvY3VtZW50Q2FjaGUgdG8gYXBwbHkgdGhlIGNoYW5nZXMgdG8uXHJcbiAgICAgKiBAcGFyYW0gdHJhY2tSZW1vdmFscyAtIFdoZXRoZXIgdG8gY3JlYXRlIHNlbnRpbmVsIGRlbGV0ZXMgdGhhdCBjYW4gYmUgdHJhY2tlZCBieVxyXG4gICAgICogYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnRDYWNoZSwgdHJhY2tSZW1vdmFscykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudENhY2hlID0gZG9jdW1lbnRDYWNoZTtcclxuICAgICAgICB0aGlzLnRyYWNrUmVtb3ZhbHMgPSB0cmFja1JlbW92YWxzO1xyXG4gICAgICAgIC8vIEEgbWFwIG9mIGRvY3VtZW50IHNpemVzIHByaW9yIHRvIGFwcGx5aW5nIHRoZSBjaGFuZ2VzIGluIHRoaXMgYnVmZmVyLlxyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTaXplcyA9IG5ldyBPYmplY3RNYXAoa2V5ID0+IGtleS50b1N0cmluZygpLCAobCwgcikgPT4gbC5pc0VxdWFsKHIpKTtcclxuICAgIH1cclxuICAgIGFwcGx5Q2hhbmdlcyh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgbGV0IHNpemVEZWx0YSA9IDA7XHJcbiAgICAgICAgbGV0IGNvbGxlY3Rpb25QYXJlbnRzID0gbmV3IFNvcnRlZFNldCgobCwgcikgPT4gcHJpbWl0aXZlQ29tcGFyYXRvcihsLmNhbm9uaWNhbFN0cmluZygpLCByLmNhbm9uaWNhbFN0cmluZygpKSk7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VzLmZvckVhY2goKGtleSwgZG9jdW1lbnRDaGFuZ2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTaXplID0gdGhpcy5kb2N1bWVudFNpemVzLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnRDaGFuZ2UuaXNWYWxpZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRvRGJSZW1vdGVEb2N1bWVudCh0aGlzLmRvY3VtZW50Q2FjaGUuc2VyaWFsaXplciwgZG9jdW1lbnRDaGFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblBhcmVudHMgPSBjb2xsZWN0aW9uUGFyZW50cy5hZGQoa2V5LnBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBkYkRvY3VtZW50U2l6ZShkb2MpO1xyXG4gICAgICAgICAgICAgICAgc2l6ZURlbHRhICs9IHNpemUgLSBwcmV2aW91c1NpemU7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5hZGRFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBkb2MpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNpemVEZWx0YSAtPSBwcmV2aW91c1NpemU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja1JlbW92YWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gdHJhY2sgcmVtb3ZhbHMsIHdlIHN0b3JlIGEgXCJzZW50aW5lbCBkZWxldGVcIiBpbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdGVEb2N1bWVudENhY2hlLiBUaGlzIGVudHJ5IGlzIHJlcHJlc2VudGVkIGJ5IGEgTm9Eb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggYSB2ZXJzaW9uIG9mIDAgYW5kIGlnbm9yZWQgYnkgYG1heWJlRGVjb2RlRG9jdW1lbnQoKWAgYnV0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJlc2VydmVkIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWAuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlZERvYyA9IHRvRGJSZW1vdGVEb2N1bWVudCh0aGlzLmRvY3VtZW50Q2FjaGUuc2VyaWFsaXplciwgZG9jdW1lbnRDaGFuZ2UuY29udmVydFRvTm9Eb2N1bWVudChTbmFwc2hvdFZlcnNpb24ubWluKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5hZGRFbnRyeSh0cmFuc2FjdGlvbiwga2V5LCBkZWxldGVkRG9jKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5yZW1vdmVFbnRyeSh0cmFuc2FjdGlvbiwga2V5KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb2xsZWN0aW9uUGFyZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kb2N1bWVudENhY2hlLmluZGV4TWFuYWdlci5hZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgcGFyZW50KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmRvY3VtZW50Q2FjaGUudXBkYXRlTWV0YWRhdGEodHJhbnNhY3Rpb24sIHNpemVEZWx0YSkpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XHJcbiAgICB9XHJcbiAgICBnZXRGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBzaXplIG9mIGV2ZXJ5dGhpbmcgd2UgbG9hZCBmcm9tIHRoZSBjYWNoZSBzbyB3ZSBjYW4gY29tcHV0ZSBhIGRlbHRhIGxhdGVyLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGVcclxuICAgICAgICAgICAgLmdldFNpemVkRW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KVxyXG4gICAgICAgICAgICAubmV4dChnZXRSZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50U2l6ZXMuc2V0KGRvY3VtZW50S2V5LCBnZXRSZXN1bHQuc2l6ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRSZXN1bHQuZG9jdW1lbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIC8vIFJlY29yZCB0aGUgc2l6ZSBvZiBldmVyeXRoaW5nIHdlIGxvYWQgZnJvbSB0aGUgY2FjaGUgc28gd2UgY2FuIGNvbXB1dGVcclxuICAgICAgICAvLyBhIGRlbHRhIGxhdGVyLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50Q2FjaGVcclxuICAgICAgICAgICAgLmdldFNpemVkRW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKVxyXG4gICAgICAgICAgICAubmV4dCgoeyBkb2N1bWVudHMsIHNpemVNYXAgfSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBgZ2V0QWxsRnJvbUNhY2hlYCByZXR1cm5zIHR3byBtYXBzIGluc3RlYWQgb2YgYSBzaW5nbGUgbWFwIGZyb21cclxuICAgICAgICAgICAgLy8ga2V5cyB0byBgRG9jdW1lbnRTaXplRW50cnlgcy4gVGhpcyBpcyB0byBhbGxvdyByZXR1cm5pbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIGBNdXRhYmxlRG9jdW1lbnRNYXBgIGRpcmVjdGx5LCB3aXRob3V0IGEgY29udmVyc2lvbi5cclxuICAgICAgICAgICAgc2l6ZU1hcC5mb3JFYWNoKChkb2N1bWVudEtleSwgc2l6ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb2N1bWVudFNpemVzLnNldChkb2N1bWVudEtleSwgc2l6ZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRvY3VtZW50R2xvYmFsU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlJlbW90ZURvY3VtZW50R2xvYmFsLnN0b3JlKTtcclxufVxyXG4vKipcclxuICogSGVscGVyIHRvIGdldCBhIHR5cGVkIFNpbXBsZURiU3RvcmUgZm9yIHRoZSByZW1vdGVEb2N1bWVudHMgb2JqZWN0IHN0b3JlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3RlRG9jdW1lbnRzU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYlJlbW90ZURvY3VtZW50LnN0b3JlKTtcclxufVxyXG5mdW5jdGlvbiBkYktleShkb2NLZXkpIHtcclxuICAgIHJldHVybiBkb2NLZXkucGF0aC50b0FycmF5KCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFBlcmZvcm1zIGRhdGFiYXNlIGNyZWF0aW9uIGFuZCBzY2hlbWEgdXBncmFkZXMuICovXHJcbmNsYXNzIFNjaGVtYUNvbnZlcnRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgZGF0YWJhc2UgY3JlYXRpb24gYW5kIHNjaGVtYSB1cGdyYWRlcy5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgaW4gcHJvZHVjdGlvbiwgdGhpcyBtZXRob2QgaXMgb25seSBldmVyIHVzZWQgdG8gdXBncmFkZSB0aGUgc2NoZW1hXHJcbiAgICAgKiB0byBTQ0hFTUFfVkVSU0lPTi4gRGlmZmVyZW50IHZhbHVlcyBvZiB0b1ZlcnNpb24gYXJlIG9ubHkgdXNlZCBmb3IgdGVzdGluZ1xyXG4gICAgICogYW5kIGxvY2FsIGZlYXR1cmUgZGV2ZWxvcG1lbnQuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZU9yVXBncmFkZShkYiwgdHhuLCBmcm9tVmVyc2lvbiwgdG9WZXJzaW9uKSB7XHJcbiAgICAgICAgY29uc3Qgc2ltcGxlRGJUcmFuc2FjdGlvbiA9IG5ldyBTaW1wbGVEYlRyYW5zYWN0aW9uKCdjcmVhdGVPclVwZ3JhZGUnLCB0eG4pO1xyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDEgJiYgdG9WZXJzaW9uID49IDEpIHtcclxuICAgICAgICAgICAgY3JlYXRlUHJpbWFyeUNsaWVudFN0b3JlKGRiKTtcclxuICAgICAgICAgICAgY3JlYXRlTXV0YXRpb25RdWV1ZShkYik7XHJcbiAgICAgICAgICAgIGNyZWF0ZVF1ZXJ5Q2FjaGUoZGIpO1xyXG4gICAgICAgICAgICBjcmVhdGVSZW1vdGVEb2N1bWVudENhY2hlKGRiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWlncmF0aW9uIDIgdG8gcG9wdWxhdGUgdGhlIHRhcmdldEdsb2JhbCBvYmplY3Qgbm8gbG9uZ2VyIG5lZWRlZCBzaW5jZVxyXG4gICAgICAgIC8vIG1pZ3JhdGlvbiAzIHVuY29uZGl0aW9uYWxseSBjbGVhcnMgaXQuXHJcbiAgICAgICAgbGV0IHAgPSBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDMgJiYgdG9WZXJzaW9uID49IDMpIHtcclxuICAgICAgICAgICAgLy8gQnJhbmQgbmV3IGNsaWVudHMgZG9uJ3QgbmVlZCB0byBkcm9wIGFuZCByZWNyZWF0ZS0tb25seSBjbGllbnRzIHRoYXRcclxuICAgICAgICAgICAgLy8gcG90ZW50aWFsbHkgaGF2ZSBjb3JydXB0IGRhdGEuXHJcbiAgICAgICAgICAgIGlmIChmcm9tVmVyc2lvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZHJvcFF1ZXJ5Q2FjaGUoZGIpO1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlUXVlcnlDYWNoZShkYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB3cml0ZUVtcHR5VGFyZ2V0R2xvYmFsRW50cnkoc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA0ICYmIHRvVmVyc2lvbiA+PSA0KSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tVmVyc2lvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NoZW1hIHZlcnNpb24gMyB1c2VzIGF1dG8tZ2VuZXJhdGVkIGtleXMgdG8gZ2VuZXJhdGUgZ2xvYmFsbHkgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICAvLyBtdXRhdGlvbiBiYXRjaCBJRHMgKHRoaXMgd2FzIHByZXZpb3VzbHkgZW5zdXJlZCBpbnRlcm5hbGx5IGJ5IHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50KS4gVG8gbWlncmF0ZSB0byB0aGUgbmV3IHNjaGVtYSwgd2UgaGF2ZSB0byByZWFkIGFsbCBtdXRhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB3cml0ZSB0aGVtIGJhY2sgb3V0LiBXZSBwcmVzZXJ2ZSB0aGUgZXhpc3RpbmcgYmF0Y2ggSURzIHRvIGd1YXJhbnRlZVxyXG4gICAgICAgICAgICAgICAgLy8gY29uc2lzdGVuY3kgd2l0aCBvdGhlciBvYmplY3Qgc3RvcmVzLiBBbnkgZnVydGhlciBtdXRhdGlvbiBiYXRjaCBJRHMgd2lsbFxyXG4gICAgICAgICAgICAgICAgLy8gYmUgYXV0by1nZW5lcmF0ZWQuXHJcbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHVwZ3JhZGVNdXRhdGlvbkJhdGNoU2NoZW1hQW5kTWlncmF0ZURhdGEoZGIsIHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUNsaWVudE1ldGFkYXRhU3RvcmUoZGIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNSAmJiB0b1ZlcnNpb24gPj0gNSkge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMucmVtb3ZlQWNrbm93bGVkZ2VkTXV0YXRpb25zKHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgNiAmJiB0b1ZlcnNpb24gPj0gNikge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZURvY3VtZW50R2xvYmFsU3RvcmUoZGIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRG9jdW1lbnRHbG9iYWwoc2ltcGxlRGJUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA3ICYmIHRvVmVyc2lvbiA+PSA3KSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5lbnN1cmVTZXF1ZW5jZU51bWJlcnMoc2ltcGxlRGJUcmFuc2FjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCA4ICYmIHRvVmVyc2lvbiA+PSA4KSB7XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQoKCkgPT4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uUGFyZW50SW5kZXgoZGIsIHNpbXBsZURiVHJhbnNhY3Rpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb21WZXJzaW9uIDwgOSAmJiB0b1ZlcnNpb24gPj0gOSkge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE11bHRpLVRhYiB1c2VkIHRvIG1hbmFnZSBpdHMgb3duIGNoYW5nZWxvZywgYnV0IHRoaXMgaGFzIGJlZW4gbW92ZWRcclxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBEYlJlbW90ZURvY3VtZW50IG9iamVjdCBzdG9yZSBpdHNlbGYuIFNpbmNlIHRoZSBwcmV2aW91cyBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIC8vIGxvZyBvbmx5IGNvbnRhaW5lZCB0cmFuc2llbnQgZGF0YSwgd2UgY2FuIGRyb3AgaXRzIG9iamVjdCBzdG9yZS5cclxuICAgICAgICAgICAgICAgIGRyb3BSZW1vdGVEb2N1bWVudENoYW5nZXNTdG9yZShkYik7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVSZW1vdGVEb2N1bWVudFJlYWRUaW1lSW5kZXgodHhuKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDEwICYmIHRvVmVyc2lvbiA+PSAxMCkge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHRoaXMucmV3cml0ZUNhbm9uaWNhbElkcyhzaW1wbGVEYlRyYW5zYWN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcm9tVmVyc2lvbiA8IDExICYmIHRvVmVyc2lvbiA+PSAxMSkge1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUJ1bmRsZXNTdG9yZShkYik7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVOYW1lZFF1ZXJpZXNTdG9yZShkYik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMiAmJiB0b1ZlcnNpb24gPj0gMTIpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVEb2N1bWVudE92ZXJsYXlTdG9yZShkYik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJvbVZlcnNpb24gPCAxMyAmJiB0b1ZlcnNpb24gPj0gMTMpIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGVGaWVsZEluZGV4KGRiKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgYWRkRG9jdW1lbnRHbG9iYWwodHhuKSB7XHJcbiAgICAgICAgbGV0IGJ5dGVDb3VudCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHR4blxyXG4gICAgICAgICAgICAuc3RvcmUoRGJSZW1vdGVEb2N1bWVudC5zdG9yZSlcclxuICAgICAgICAgICAgLml0ZXJhdGUoKF8sIGRvYykgPT4ge1xyXG4gICAgICAgICAgICBieXRlQ291bnQgKz0gZGJEb2N1bWVudFNpemUoZG9jKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IERiUmVtb3RlRG9jdW1lbnRHbG9iYWwoYnl0ZUNvdW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHR4blxyXG4gICAgICAgICAgICAgICAgLnN0b3JlKERiUmVtb3RlRG9jdW1lbnRHbG9iYWwuc3RvcmUpXHJcbiAgICAgICAgICAgICAgICAucHV0KERiUmVtb3RlRG9jdW1lbnRHbG9iYWwua2V5LCBtZXRhZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVBY2tub3dsZWRnZWRNdXRhdGlvbnModHhuKSB7XHJcbiAgICAgICAgY29uc3QgcXVldWVzU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvblF1ZXVlLnN0b3JlKTtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbnNTdG9yZSA9IHR4bi5zdG9yZShEYk11dGF0aW9uQmF0Y2guc3RvcmUpO1xyXG4gICAgICAgIHJldHVybiBxdWV1ZXNTdG9yZS5sb2FkQWxsKCkubmV4dChxdWV1ZXMgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocXVldWVzLCAocXVldWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gSURCS2V5UmFuZ2UuYm91bmQoW3F1ZXVlLnVzZXJJZCwgQkFUQ0hJRF9VTktOT1dOXSwgW3F1ZXVlLnVzZXJJZCwgcXVldWUubGFzdEFja25vd2xlZGdlZEJhdGNoSWRdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtdXRhdGlvbnNTdG9yZVxyXG4gICAgICAgICAgICAgICAgICAgIC5sb2FkQWxsKERiTXV0YXRpb25CYXRjaC51c2VyTXV0YXRpb25zSW5kZXgsIHJhbmdlKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGRiQmF0Y2hlcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGRiQmF0Y2hlcywgKGRiQmF0Y2gpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChkYkJhdGNoLnVzZXJJZCA9PT0gcXVldWUudXNlcklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBmcm9tRGJNdXRhdGlvbkJhdGNoKHRoaXMuc2VyaWFsaXplciwgZGJCYXRjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVNdXRhdGlvbkJhdGNoKHR4biwgcXVldWUudXNlcklkLCBiYXRjaCkubmV4dCgoKSA9PiB7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoYXQgZXZlcnkgZG9jdW1lbnQgaW4gdGhlIHJlbW90ZSBkb2N1bWVudCBjYWNoZSBoYXMgYSBjb3JyZXNwb25kaW5nIHNlbnRpbmVsIHJvd1xyXG4gICAgICogd2l0aCBhIHNlcXVlbmNlIG51bWJlci4gTWlzc2luZyByb3dzIGFyZSBnaXZlbiB0aGUgbW9zdCByZWNlbnRseSB1c2VkIHNlcXVlbmNlIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgZW5zdXJlU2VxdWVuY2VOdW1iZXJzKHR4bikge1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50VGFyZ2V0U3RvcmUgPSB0eG4uc3RvcmUoRGJUYXJnZXREb2N1bWVudC5zdG9yZSk7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRzU3RvcmUgPSB0eG4uc3RvcmUoRGJSZW1vdGVEb2N1bWVudC5zdG9yZSk7XHJcbiAgICAgICAgY29uc3QgZ2xvYmFsVGFyZ2V0U3RvcmUgPSB0eG4uc3RvcmUoRGJUYXJnZXRHbG9iYWwuc3RvcmUpO1xyXG4gICAgICAgIHJldHVybiBnbG9iYWxUYXJnZXRTdG9yZS5nZXQoRGJUYXJnZXRHbG9iYWwua2V5KS5uZXh0KG1ldGFkYXRhID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgd3JpdGVTZW50aW5lbEtleSA9IChwYXRoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRUYXJnZXRTdG9yZS5wdXQobmV3IERiVGFyZ2V0RG9jdW1lbnQoMCwgZW5jb2RlUmVzb3VyY2VQYXRoKHBhdGgpLCBtZXRhZGF0YS5oaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50c1N0b3JlXHJcbiAgICAgICAgICAgICAgICAuaXRlcmF0ZSgoa2V5LCBkb2MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKGtleSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NTZW50aW5lbEtleSA9IHNlbnRpbmVsS2V5KHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChkb2N1bWVudFRhcmdldFN0b3JlLmdldChkb2NTZW50aW5lbEtleSkubmV4dChtYXliZVNlbnRpbmVsID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heWJlU2VudGluZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlU2VudGluZWxLZXkocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQ29sbGVjdGlvblBhcmVudEluZGV4KGRiLCB0eG4pIHtcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGluZGV4LlxyXG4gICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiQ29sbGVjdGlvblBhcmVudC5zdG9yZSwge1xyXG4gICAgICAgICAgICBrZXlQYXRoOiBEYkNvbGxlY3Rpb25QYXJlbnQua2V5UGF0aFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25QYXJlbnRzU3RvcmUgPSB0eG4uc3RvcmUoRGJDb2xsZWN0aW9uUGFyZW50LnN0b3JlKTtcclxuICAgICAgICAvLyBIZWxwZXIgdG8gYWRkIGFuIGluZGV4IGVudHJ5IGlmZiB3ZSBoYXZlbid0IGFscmVhZHkgd3JpdHRlbiBpdC5cclxuICAgICAgICBjb25zdCBjYWNoZSA9IG5ldyBNZW1vcnlDb2xsZWN0aW9uUGFyZW50SW5kZXgoKTtcclxuICAgICAgICBjb25zdCBhZGRFbnRyeSA9IChjb2xsZWN0aW9uUGF0aCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2FjaGUuYWRkKGNvbGxlY3Rpb25QYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gY29sbGVjdGlvblBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBjb2xsZWN0aW9uUGF0aC5wb3BMYXN0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvblBhcmVudHNTdG9yZS5wdXQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZCxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGVuY29kZVJlc291cmNlUGF0aChwYXJlbnRQYXRoKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEluZGV4IGV4aXN0aW5nIHJlbW90ZSBkb2N1bWVudHMuXHJcbiAgICAgICAgcmV0dXJuIHR4blxyXG4gICAgICAgICAgICAuc3RvcmUoRGJSZW1vdGVEb2N1bWVudC5zdG9yZSlcclxuICAgICAgICAgICAgLml0ZXJhdGUoeyBrZXlzT25seTogdHJ1ZSB9LCAocGF0aFNlZ21lbnRzLCBfKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBuZXcgUmVzb3VyY2VQYXRoKHBhdGhTZWdtZW50cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBhZGRFbnRyeShwYXRoLnBvcExhc3QoKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJbmRleCBleGlzdGluZyBtdXRhdGlvbnMuXHJcbiAgICAgICAgICAgIHJldHVybiB0eG5cclxuICAgICAgICAgICAgICAgIC5zdG9yZShEYkRvY3VtZW50TXV0YXRpb24uc3RvcmUpXHJcbiAgICAgICAgICAgICAgICAuaXRlcmF0ZSh7IGtleXNPbmx5OiB0cnVlIH0sIChbdXNlcklELCBlbmNvZGVkUGF0aCwgYmF0Y2hJZF0sIF8pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZWNvZGVSZXNvdXJjZVBhdGgoZW5jb2RlZFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZEVudHJ5KHBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXdyaXRlQ2Fub25pY2FsSWRzKHR4bikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0b3JlID0gdHhuLnN0b3JlKERiVGFyZ2V0LnN0b3JlKTtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0U3RvcmUuaXRlcmF0ZSgoa2V5LCBvcmlnaW5hbERiVGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVGFyZ2V0RGF0YSA9IGZyb21EYlRhcmdldChvcmlnaW5hbERiVGFyZ2V0KTtcclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZERiVGFyZ2V0ID0gdG9EYlRhcmdldCh0aGlzLnNlcmlhbGl6ZXIsIG9yaWdpbmFsVGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRTdG9yZS5wdXQodXBkYXRlZERiVGFyZ2V0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZW50aW5lbEtleShwYXRoKSB7XHJcbiAgICByZXR1cm4gWzAsIGVuY29kZVJlc291cmNlUGF0aChwYXRoKV07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUHJpbWFyeUNsaWVudFN0b3JlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlByaW1hcnlDbGllbnQuc3RvcmUpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU11dGF0aW9uUXVldWUoZGIpIHtcclxuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiTXV0YXRpb25RdWV1ZS5zdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25RdWV1ZS5rZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IG11dGF0aW9uQmF0Y2hlc1N0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJNdXRhdGlvbkJhdGNoLnN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJNdXRhdGlvbkJhdGNoLmtleVBhdGgsXHJcbiAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBtdXRhdGlvbkJhdGNoZXNTdG9yZS5jcmVhdGVJbmRleChEYk11dGF0aW9uQmF0Y2gudXNlck11dGF0aW9uc0luZGV4LCBEYk11dGF0aW9uQmF0Y2gudXNlck11dGF0aW9uc0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJEb2N1bWVudE11dGF0aW9uLnN0b3JlKTtcclxufVxyXG4vKipcclxuICogVXBncmFkZSBmdW5jdGlvbiB0byBtaWdyYXRlIHRoZSAnbXV0YXRpb25zJyBzdG9yZSBmcm9tIFYxIHRvIFYzLiBMb2Fkc1xyXG4gKiBhbmQgcmV3cml0ZXMgYWxsIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGdyYWRlTXV0YXRpb25CYXRjaFNjaGVtYUFuZE1pZ3JhdGVEYXRhKGRiLCB0eG4pIHtcclxuICAgIGNvbnN0IHYxTXV0YXRpb25zU3RvcmUgPSB0eG4uc3RvcmUoRGJNdXRhdGlvbkJhdGNoLnN0b3JlKTtcclxuICAgIHJldHVybiB2MU11dGF0aW9uc1N0b3JlLmxvYWRBbGwoKS5uZXh0KGV4aXN0aW5nTXV0YXRpb25zID0+IHtcclxuICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZShEYk11dGF0aW9uQmF0Y2guc3RvcmUpO1xyXG4gICAgICAgIGNvbnN0IG11dGF0aW9uc1N0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJNdXRhdGlvbkJhdGNoLnN0b3JlLCB7XHJcbiAgICAgICAgICAgIGtleVBhdGg6IERiTXV0YXRpb25CYXRjaC5rZXlQYXRoLFxyXG4gICAgICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbXV0YXRpb25zU3RvcmUuY3JlYXRlSW5kZXgoRGJNdXRhdGlvbkJhdGNoLnVzZXJNdXRhdGlvbnNJbmRleCwgRGJNdXRhdGlvbkJhdGNoLnVzZXJNdXRhdGlvbnNLZXlQYXRoLCB7IHVuaXF1ZTogdHJ1ZSB9KTtcclxuICAgICAgICBjb25zdCB2M011dGF0aW9uc1N0b3JlID0gdHhuLnN0b3JlKERiTXV0YXRpb25CYXRjaC5zdG9yZSk7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVBbGwgPSBleGlzdGluZ011dGF0aW9ucy5tYXAobXV0YXRpb24gPT4gdjNNdXRhdGlvbnNTdG9yZS5wdXQobXV0YXRpb24pKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3Iod3JpdGVBbGwpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVtb3RlRG9jdW1lbnRDYWNoZShkYikge1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudC5zdG9yZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRHbG9iYWxTdG9yZShkYikge1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJSZW1vdGVEb2N1bWVudEdsb2JhbC5zdG9yZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUXVlcnlDYWNoZShkYikge1xyXG4gICAgY29uc3QgdGFyZ2V0RG9jdW1lbnRzU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYlRhcmdldERvY3VtZW50LnN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJUYXJnZXREb2N1bWVudC5rZXlQYXRoXHJcbiAgICB9KTtcclxuICAgIHRhcmdldERvY3VtZW50c1N0b3JlLmNyZWF0ZUluZGV4KERiVGFyZ2V0RG9jdW1lbnQuZG9jdW1lbnRUYXJnZXRzSW5kZXgsIERiVGFyZ2V0RG9jdW1lbnQuZG9jdW1lbnRUYXJnZXRzS2V5UGF0aCwgeyB1bmlxdWU6IHRydWUgfSk7XHJcbiAgICBjb25zdCB0YXJnZXRTdG9yZSA9IGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiVGFyZ2V0LnN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJUYXJnZXQua2V5UGF0aFxyXG4gICAgfSk7XHJcbiAgICAvLyBOT1RFOiBUaGlzIGlzIHVuaXF1ZSBvbmx5IGJlY2F1c2UgdGhlIFRhcmdldElkIGlzIHRoZSBzdWZmaXguXHJcbiAgICB0YXJnZXRTdG9yZS5jcmVhdGVJbmRleChEYlRhcmdldC5xdWVyeVRhcmdldHNJbmRleE5hbWUsIERiVGFyZ2V0LnF1ZXJ5VGFyZ2V0c0tleVBhdGgsIHsgdW5pcXVlOiB0cnVlIH0pO1xyXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJUYXJnZXRHbG9iYWwuc3RvcmUpO1xyXG59XHJcbmZ1bmN0aW9uIGRyb3BRdWVyeUNhY2hlKGRiKSB7XHJcbiAgICBkYi5kZWxldGVPYmplY3RTdG9yZShEYlRhcmdldERvY3VtZW50LnN0b3JlKTtcclxuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0LnN0b3JlKTtcclxuICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKERiVGFyZ2V0R2xvYmFsLnN0b3JlKTtcclxufVxyXG5mdW5jdGlvbiBkcm9wUmVtb3RlRG9jdW1lbnRDaGFuZ2VzU3RvcmUoZGIpIHtcclxuICAgIGlmIChkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdyZW1vdGVEb2N1bWVudENoYW5nZXMnKSkge1xyXG4gICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKCdyZW1vdGVEb2N1bWVudENoYW5nZXMnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyB0aGUgdGFyZ2V0IGdsb2JhbCBzaW5nbGV0b24gcm93LlxyXG4gKlxyXG4gKiBAcGFyYW0gdHhuIC0gVGhlIHZlcnNpb24gdXBncmFkZSB0cmFuc2FjdGlvbiBmb3IgaW5kZXhlZGRiXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZUVtcHR5VGFyZ2V0R2xvYmFsRW50cnkodHhuKSB7XHJcbiAgICBjb25zdCBnbG9iYWxTdG9yZSA9IHR4bi5zdG9yZShEYlRhcmdldEdsb2JhbC5zdG9yZSk7XHJcbiAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBEYlRhcmdldEdsb2JhbChcclxuICAgIC8qaGlnaGVzdFRhcmdldElkPSovIDAsIFxyXG4gICAgLypsYXN0TGlzdGVuU2VxdWVuY2VOdW1iZXI9Ki8gMCwgU25hcHNob3RWZXJzaW9uLm1pbigpLnRvVGltZXN0YW1wKCksIFxyXG4gICAgLyp0YXJnZXRDb3VudD0qLyAwKTtcclxuICAgIHJldHVybiBnbG9iYWxTdG9yZS5wdXQoRGJUYXJnZXRHbG9iYWwua2V5LCBtZXRhZGF0YSk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgaW5kaWNlcyBvbiB0aGUgUmVtb3RlRG9jdW1lbnRzIHN0b3JlIHVzZWQgZm9yIGJvdGggbXVsdGktdGFiXHJcbiAqIGFuZCBJbmRleC1GcmVlIHF1ZXJpZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVSZW1vdGVEb2N1bWVudFJlYWRUaW1lSW5kZXgodHhuKSB7XHJcbiAgICBjb25zdCByZW1vdGVEb2N1bWVudFN0b3JlID0gdHhuLm9iamVjdFN0b3JlKERiUmVtb3RlRG9jdW1lbnQuc3RvcmUpO1xyXG4gICAgcmVtb3RlRG9jdW1lbnRTdG9yZS5jcmVhdGVJbmRleChEYlJlbW90ZURvY3VtZW50LnJlYWRUaW1lSW5kZXgsIERiUmVtb3RlRG9jdW1lbnQucmVhZFRpbWVJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxuICAgIHJlbW90ZURvY3VtZW50U3RvcmUuY3JlYXRlSW5kZXgoRGJSZW1vdGVEb2N1bWVudC5jb2xsZWN0aW9uUmVhZFRpbWVJbmRleCwgRGJSZW1vdGVEb2N1bWVudC5jb2xsZWN0aW9uUmVhZFRpbWVJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVDbGllbnRNZXRhZGF0YVN0b3JlKGRiKSB7XHJcbiAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkNsaWVudE1ldGFkYXRhLnN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJDbGllbnRNZXRhZGF0YS5rZXlQYXRoXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVCdW5kbGVzU3RvcmUoZGIpIHtcclxuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiQnVuZGxlLnN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJCdW5kbGUua2V5UGF0aFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlTmFtZWRRdWVyaWVzU3RvcmUoZGIpIHtcclxuICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERiTmFtZWRRdWVyeS5zdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiTmFtZWRRdWVyeS5rZXlQYXRoXHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVGaWVsZEluZGV4KGRiKSB7XHJcbiAgICBjb25zdCBpbmRleENvbmZpZ3VyYXRpb1N0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleENvbmZpZ3VyYXRpb24uc3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkluZGV4Q29uZmlndXJhdGlvbi5rZXlQYXRoLFxyXG4gICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWVcclxuICAgIH0pO1xyXG4gICAgaW5kZXhDb25maWd1cmF0aW9TdG9yZS5jcmVhdGVJbmRleChEYkluZGV4Q29uZmlndXJhdGlvbi5jb2xsZWN0aW9uR3JvdXBJbmRleCwgRGJJbmRleENvbmZpZ3VyYXRpb24uY29sbGVjdGlvbkdyb3VwSW5kZXhQYXRoLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbiAgICBjb25zdCBpbmRleFN0YXRlU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkluZGV4U3RhdGUuc3RvcmUsIHtcclxuICAgICAgICBrZXlQYXRoOiBEYkluZGV4U3RhdGUua2V5UGF0aFxyXG4gICAgfSk7XHJcbiAgICBpbmRleFN0YXRlU3RvcmUuY3JlYXRlSW5kZXgoRGJJbmRleFN0YXRlLnNlcXVlbmNlTnVtYmVySW5kZXgsIERiSW5kZXhTdGF0ZS5zZXF1ZW5jZU51bWJlckluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgY29uc3QgaW5kZXhFbnRyeVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRGJJbmRleEVudHJ5LnN0b3JlLCB7XHJcbiAgICAgICAga2V5UGF0aDogRGJJbmRleEVudHJ5LmtleVBhdGhcclxuICAgIH0pO1xyXG4gICAgaW5kZXhFbnRyeVN0b3JlLmNyZWF0ZUluZGV4KERiSW5kZXhFbnRyeS5kb2N1bWVudEtleUluZGV4LCBEYkluZGV4RW50cnkuZG9jdW1lbnRLZXlJbmRleFBhdGgsIHsgdW5pcXVlOiBmYWxzZSB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudE92ZXJsYXlTdG9yZShkYikge1xyXG4gICAgY29uc3QgZG9jdW1lbnRPdmVybGF5U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShEYkRvY3VtZW50T3ZlcmxheS5zdG9yZSwge1xyXG4gICAgICAgIGtleVBhdGg6IERiRG9jdW1lbnRPdmVybGF5LmtleVBhdGhcclxuICAgIH0pO1xyXG4gICAgZG9jdW1lbnRPdmVybGF5U3RvcmUuY3JlYXRlSW5kZXgoRGJEb2N1bWVudE92ZXJsYXkuY29sbGVjdGlvblBhdGhPdmVybGF5SW5kZXgsIERiRG9jdW1lbnRPdmVybGF5LmNvbGxlY3Rpb25QYXRoT3ZlcmxheUluZGV4UGF0aCwgeyB1bmlxdWU6IGZhbHNlIH0pO1xyXG4gICAgZG9jdW1lbnRPdmVybGF5U3RvcmUuY3JlYXRlSW5kZXgoRGJEb2N1bWVudE92ZXJsYXkuY29sbGVjdGlvbkdyb3VwT3ZlcmxheUluZGV4LCBEYkRvY3VtZW50T3ZlcmxheS5jb2xsZWN0aW9uR3JvdXBPdmVybGF5SW5kZXhQYXRoLCB7IHVuaXF1ZTogZmFsc2UgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyRkID0gJ0luZGV4ZWREYlBlcnNpc3RlbmNlJztcclxuLyoqXHJcbiAqIE9sZGVzdCBhY2NlcHRhYmxlIGFnZSBpbiBtaWxsaXNlY29uZHMgZm9yIGNsaWVudCBtZXRhZGF0YSBiZWZvcmUgdGhlIGNsaWVudFxyXG4gKiBpcyBjb25zaWRlcmVkIGluYWN0aXZlIGFuZCBpdHMgYXNzb2NpYXRlZCBkYXRhIGlzIGdhcmJhZ2UgY29sbGVjdGVkLlxyXG4gKi9cclxuY29uc3QgTUFYX0NMSUVOVF9BR0VfTVMgPSAzMCAqIDYwICogMTAwMDsgLy8gMzAgbWludXRlc1xyXG4vKipcclxuICogT2xkZXN0IGFjY2VwdGFibGUgbWV0YWRhdGEgYWdlIGZvciBjbGllbnRzIHRoYXQgbWF5IHBhcnRpY2lwYXRlIGluIHRoZVxyXG4gKiBwcmltYXJ5IGxlYXNlIGVsZWN0aW9uLiBDbGllbnRzIHRoYXQgaGF2ZSBub3QgdXBkYXRlZCB0aGVpciBjbGllbnQgbWV0YWRhdGFcclxuICogd2l0aGluIDUgc2Vjb25kcyBhcmUgbm90IGVsaWdpYmxlIHRvIHJlY2VpdmUgYSBwcmltYXJ5IGxlYXNlLlxyXG4gKi9cclxuY29uc3QgTUFYX1BSSU1BUllfRUxJR0lCTEVfQUdFX01TID0gNTAwMDtcclxuLyoqXHJcbiAqIFRoZSBpbnRlcnZhbCBhdCB3aGljaCBjbGllbnRzIHdpbGwgdXBkYXRlIHRoZWlyIG1ldGFkYXRhLCBpbmNsdWRpbmdcclxuICogcmVmcmVzaGluZyB0aGVpciBwcmltYXJ5IGxlYXNlIGlmIGhlbGQgb3IgcG90ZW50aWFsbHkgdHJ5aW5nIHRvIGFjcXVpcmUgaXQgaWZcclxuICogbm90IGhlbGQuXHJcbiAqXHJcbiAqIFByaW1hcnkgY2xpZW50cyBtYXkgb3Bwb3J0dW5pc3RpY2FsbHkgcmVmcmVzaCB0aGVpciBtZXRhZGF0YSBlYXJsaWVyXHJcbiAqIGlmIHRoZXkncmUgYWxyZWFkeSBwZXJmb3JtaW5nIGFuIEluZGV4ZWREQiBvcGVyYXRpb24uXHJcbiAqL1xyXG5jb25zdCBDTElFTlRfTUVUQURBVEFfUkVGUkVTSF9JTlRFUlZBTF9NUyA9IDQwMDA7XHJcbi8qKiBVc2VyLWZhY2luZyBlcnJvciB3aGVuIHRoZSBwcmltYXJ5IGxlYXNlIGlzIHJlcXVpcmVkIGJ1dCBub3QgYXZhaWxhYmxlLiAqL1xyXG5jb25zdCBQUklNQVJZX0xFQVNFX0VYQ0xVU0lWRV9FUlJPUl9NU0cgPSAnRmFpbGVkIHRvIG9idGFpbiBleGNsdXNpdmUgYWNjZXNzIHRvIHRoZSBwZXJzaXN0ZW5jZSBsYXllci4gVG8gYWxsb3cgJyArXHJcbiAgICAnc2hhcmVkIGFjY2VzcywgbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbiBoYXMgdG8gYmUgZW5hYmxlZCBpbiBhbGwgdGFicy4gJyArXHJcbiAgICAnSWYgeW91IGFyZSB1c2luZyBgZXhwZXJpbWVudGFsRm9yY2VPd25pbmdUYWI6dHJ1ZWAsIG1ha2Ugc3VyZSB0aGF0IG9ubHkgJyArXHJcbiAgICAnb25lIHRhYiBoYXMgcGVyc2lzdGVuY2UgZW5hYmxlZCBhdCBhbnkgZ2l2ZW4gdGltZS4nO1xyXG5jb25zdCBVTlNVUFBPUlRFRF9QTEFURk9STV9FUlJPUl9NU0cgPSAnVGhpcyBwbGF0Zm9ybSBpcyBlaXRoZXIgbWlzc2luZyBJbmRleGVkREIgb3IgaXMga25vd24gdG8gaGF2ZSAnICtcclxuICAgICdhbiBpbmNvbXBsZXRlIGltcGxlbWVudGF0aW9uLiBPZmZsaW5lIHBlcnNpc3RlbmNlIGhhcyBiZWVuIGRpc2FibGVkLic7XHJcbi8vIFRoZSBmb3JtYXQgb2YgdGhlIExvY2FsU3RvcmFnZSBrZXkgdGhhdCBzdG9yZXMgem9tYmllZCBjbGllbnQgaXM6XHJcbi8vICAgICBmaXJlc3RvcmVfem9tYmllXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxpbnN0YW5jZV9rZXk+XHJcbmNvbnN0IFpPTUJJRURfQ0xJRU5UU19LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV96b21iaWUnO1xyXG4vKipcclxuICogVGhlIG5hbWUgb2YgdGhlIG1haW4gKGFuZCBjdXJyZW50bHkgb25seSkgSW5kZXhlZERCIGRhdGFiYXNlLiBUaGlzIG5hbWUgaXNcclxuICogYXBwZW5kZWQgdG8gdGhlIHByZWZpeCBwcm92aWRlZCB0byB0aGUgSW5kZXhlZERiUGVyc2lzdGVuY2UgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5jb25zdCBNQUlOX0RBVEFCQVNFID0gJ21haW4nO1xyXG4vKipcclxuICogQW4gSW5kZXhlZERCLWJhY2tlZCBpbnN0YW5jZSBvZiBQZXJzaXN0ZW5jZS4gRGF0YSBpcyBzdG9yZWQgcGVyc2lzdGVudGx5XHJcbiAqIGFjcm9zcyBzZXNzaW9ucy5cclxuICpcclxuICogT24gV2ViIG9ubHksIHRoZSBGaXJlc3RvcmUgU0RLcyBzdXBwb3J0IHNoYXJlZCBhY2Nlc3MgdG8gaXRzIHBlcnNpc3RlbmNlXHJcbiAqIGxheWVyLiBUaGlzIGFsbG93cyBtdWx0aXBsZSBicm93c2VyIHRhYnMgdG8gcmVhZCBhbmQgd3JpdGUgdG8gSW5kZXhlZERiIGFuZFxyXG4gKiB0byBzeW5jaHJvbml6ZSBzdGF0ZSBldmVuIHdpdGhvdXQgbmV0d29yayBjb25uZWN0aXZpdHkuIFNoYXJlZCBhY2Nlc3MgaXNcclxuICogY3VycmVudGx5IG9wdGlvbmFsIGFuZCBub3QgZW5hYmxlZCB1bmxlc3MgYWxsIGNsaWVudHMgaW52b2tlXHJcbiAqIGBlbmFibGVQZXJzaXN0ZW5jZSgpYCB3aXRoIGB7c3luY2hyb25pemVUYWJzOnRydWV9YC5cclxuICpcclxuICogSW4gbXVsdGktdGFiIG1vZGUsIGlmIG11bHRpcGxlIGNsaWVudHMgYXJlIGFjdGl2ZSBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgU0RLXHJcbiAqIHdpbGwgZGVzaWduYXRlIG9uZSBjbGllbnQgYXMgdGhlIOKAnHByaW1hcnkgY2xpZW504oCdLiBBbiBlZmZvcnQgaXMgbWFkZSB0byBwaWNrXHJcbiAqIGEgdmlzaWJsZSwgbmV0d29yay1jb25uZWN0ZWQgYW5kIGFjdGl2ZSBjbGllbnQsIGFuZCB0aGlzIGNsaWVudCBpc1xyXG4gKiByZXNwb25zaWJsZSBmb3IgbGV0dGluZyBvdGhlciBjbGllbnRzIGtub3cgYWJvdXQgaXRzIHByZXNlbmNlLiBUaGUgcHJpbWFyeVxyXG4gKiBjbGllbnQgd3JpdGVzIGEgdW5pcXVlIGNsaWVudC1nZW5lcmF0ZWQgaWRlbnRpZmllciAodGhlIGNsaWVudCBJRCkgdG9cclxuICogSW5kZXhlZERi4oCZcyDigJxvd25lcuKAnSBzdG9yZSBldmVyeSA0IHNlY29uZHMuIElmIHRoZSBwcmltYXJ5IGNsaWVudCBmYWlscyB0b1xyXG4gKiB1cGRhdGUgdGhpcyBlbnRyeSwgYW5vdGhlciBjbGllbnQgY2FuIGFjcXVpcmUgdGhlIGxlYXNlIGFuZCB0YWtlIG92ZXIgYXNcclxuICogcHJpbWFyeS5cclxuICpcclxuICogU29tZSBwZXJzaXN0ZW5jZSBvcGVyYXRpb25zIGluIHRoZSBTREsgYXJlIGRlc2lnbmF0ZWQgYXMgcHJpbWFyeS1jbGllbnQgb25seVxyXG4gKiBvcGVyYXRpb25zLiBUaGlzIGluY2x1ZGVzIHRoZSBhY2tub3dsZWRnbWVudCBvZiBtdXRhdGlvbnMgYW5kIGFsbCB1cGRhdGVzIG9mXHJcbiAqIHJlbW90ZSBkb2N1bWVudHMuIFRoZSBlZmZlY3RzIG9mIHRoZXNlIG9wZXJhdGlvbnMgYXJlIHdyaXR0ZW4gdG8gcGVyc2lzdGVuY2VcclxuICogYW5kIHRoZW4gYnJvYWRjYXN0IHRvIG90aGVyIHRhYnMgdmlhIExvY2FsU3RvcmFnZSAoc2VlXHJcbiAqIGBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGVgKSwgd2hpY2ggdGhlbiByZWZyZXNoIHRoZWlyIHN0YXRlIGZyb21cclxuICogcGVyc2lzdGVuY2UuXHJcbiAqXHJcbiAqIFNpbWlsYXJseSwgdGhlIHByaW1hcnkgY2xpZW50IGxpc3RlbnMgdG8gbm90aWZpY2F0aW9ucyBzZW50IGJ5IHNlY29uZGFyeVxyXG4gKiBjbGllbnRzIHRvIGRpc2NvdmVyIHBlcnNpc3RlbmNlIGNoYW5nZXMgd3JpdHRlbiBieSBzZWNvbmRhcnkgY2xpZW50cywgc3VjaCBhc1xyXG4gKiB0aGUgYWRkaXRpb24gb2YgbmV3IG11dGF0aW9ucyBhbmQgcXVlcnkgdGFyZ2V0cy5cclxuICpcclxuICogSWYgbXVsdGktdGFiIGlzIG5vdCBlbmFibGVkIGFuZCBhbm90aGVyIHRhYiBhbHJlYWR5IG9idGFpbmVkIHRoZSBwcmltYXJ5XHJcbiAqIGxlYXNlLCBJbmRleGVkRGJQZXJzaXN0ZW5jZSBlbnRlcnMgYSBmYWlsZWQgc3RhdGUgYW5kIGFsbCBzdWJzZXF1ZW50XHJcbiAqIG9wZXJhdGlvbnMgd2lsbCBhdXRvbWF0aWNhbGx5IGZhaWwuXHJcbiAqXHJcbiAqIEFkZGl0aW9uYWxseSwgdGhlcmUgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHRoYXQgd2hlbiBhIHRhYiBpcyBjbG9zZWQsIHRoZVxyXG4gKiBwcmltYXJ5IGxlYXNlIGlzIHJlbGVhc2VkIGltbWVkaWF0ZWx5ICh0aGlzIGlzIGVzcGVjaWFsbHkgaW1wb3J0YW50IHRvIG1ha2VcclxuICogc3VyZSB0aGF0IGEgcmVmcmVzaGVkIHRhYiBpcyBhYmxlIHRvIGltbWVkaWF0ZWx5IHJlLWFjcXVpcmUgdGhlIHByaW1hcnlcclxuICogbGVhc2UpLiBVbmZvcnR1bmF0ZWx5LCBJbmRleGVkREIgY2Fubm90IGJlIHJlbGlhYmx5IHVzZWQgaW4gd2luZG93LnVubG9hZFxyXG4gKiBzaW5jZSBpdCBpcyBhbiBhc3luY2hyb25vdXMgQVBJLiBTbyBpbiBhZGRpdGlvbiB0byBhdHRlbXB0aW5nIHRvIGdpdmUgdXAgdGhlXHJcbiAqIGxlYXNlLCB0aGUgbGVhc2Vob2xkZXIgd3JpdGVzIGl0cyBjbGllbnQgSUQgdG8gYSBcInpvbWJpZWRDbGllbnRcIiBlbnRyeSBpblxyXG4gKiBMb2NhbFN0b3JhZ2Ugd2hpY2ggYWN0cyBhcyBhbiBpbmRpY2F0b3IgdGhhdCBhbm90aGVyIHRhYiBzaG91bGQgZ28gYWhlYWQgYW5kXHJcbiAqIHRha2UgdGhlIHByaW1hcnkgbGVhc2UgaW1tZWRpYXRlbHkgcmVnYXJkbGVzcyBvZiB0aGUgY3VycmVudCBsZWFzZSB0aW1lc3RhbXAuXHJcbiAqXHJcbiAqIFRPRE8oYi8xMTQyMjYyMzQpOiBSZW1vdmUgYHN5bmNocm9uaXplVGFic2Agc2VjdGlvbiB3aGVuIG11bHRpLXRhYiBpcyBub1xyXG4gKiBsb25nZXIgb3B0aW9uYWwuXHJcbiAqL1xyXG5jbGFzcyBJbmRleGVkRGJQZXJzaXN0ZW5jZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBzeW5jaHJvbml6ZSB0aGUgaW4tbWVtb3J5IHN0YXRlIG9mIG11bHRpcGxlIHRhYnMgYW5kIHNoYXJlXHJcbiAgICAgKiBhY2Nlc3MgdG8gbG9jYWwgcGVyc2lzdGVuY2UuXHJcbiAgICAgKi9cclxuICAgIGFsbG93VGFiU3luY2hyb25pemF0aW9uLCBwZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQsIGxydVBhcmFtcywgcXVldWUsIHdpbmRvdywgZG9jdW1lbnQsIHNlcmlhbGl6ZXIsIHNlcXVlbmNlTnVtYmVyU3luY2VyLCBcclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIGZvcmNlZnVsbHkgb2J0YWlucyBkYXRhYmFzZSBhY2Nlc3MuIEV4aXN0aW5nIHRhYnMgd2lsbFxyXG4gICAgICogbm8gbG9uZ2VyIGJlIGFibGUgdG8gYWNjZXNzIEluZGV4ZWREQi5cclxuICAgICAqL1xyXG4gICAgZm9yY2VPd25pbmdUYWIsIHNjaGVtYVZlcnNpb24gPSBTQ0hFTUFfVkVSU0lPTikge1xyXG4gICAgICAgIHRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24gPSBhbGxvd1RhYlN5bmNocm9uaXphdGlvbjtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XHJcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xyXG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcclxuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcclxuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlclN5bmNlciA9IHNlcXVlbmNlTnVtYmVyU3luY2VyO1xyXG4gICAgICAgIHRoaXMuZm9yY2VPd25pbmdUYWIgPSBmb3JjZU93bmluZ1RhYjtcclxuICAgICAgICB0aGlzLnNjaGVtYVZlcnNpb24gPSBzY2hlbWFWZXJzaW9uO1xyXG4gICAgICAgIHRoaXMubGlzdGVuU2VxdWVuY2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubmV0d29ya0VuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIC8qKiBPdXIgd2luZG93LnVubG9hZCBoYW5kbGVyLCBpZiByZWdpc3RlcmVkLiAqL1xyXG4gICAgICAgIHRoaXMud2luZG93VW5sb2FkSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbkZvcmVncm91bmQgPSBmYWxzZTtcclxuICAgICAgICAvKiogT3VyICd2aXNpYmlsaXR5Y2hhbmdlJyBsaXN0ZW5lciBpZiByZWdpc3RlcmVkLiAqL1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgLyoqIFRoZSBjbGllbnQgbWV0YWRhdGEgcmVmcmVzaCB0YXNrLiAqL1xyXG4gICAgICAgIHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKiBUaGUgbGFzdCB0aW1lIHdlIGdhcmJhZ2UgY29sbGVjdGVkIHRoZSBjbGllbnQgbWV0YWRhdGEgb2JqZWN0IHN0b3JlLiAqL1xyXG4gICAgICAgIHRoaXMubGFzdEdhcmJhZ2VDb2xsZWN0aW9uVGltZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuICAgICAgICAvKiogQSBsaXN0ZW5lciB0byBub3RpZnkgb24gcHJpbWFyeSBzdGF0ZSBjaGFuZ2VzLiAqL1xyXG4gICAgICAgIHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIgPSBfID0+IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIGlmICghSW5kZXhlZERiUGVyc2lzdGVuY2UuaXNBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTklNUExFTUVOVEVELCBVTlNVUFBPUlRFRF9QTEFURk9STV9FUlJPUl9NU0cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZmVyZW5jZURlbGVnYXRlID0gbmV3IEluZGV4ZWREYkxydURlbGVnYXRlSW1wbCh0aGlzLCBscnVQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuZGJOYW1lID0gcGVyc2lzdGVuY2VLZXkgKyBNQUlOX0RBVEFCQVNFO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBMb2NhbFNlcmlhbGl6ZXIoc2VyaWFsaXplcik7XHJcbiAgICAgICAgdGhpcy5zaW1wbGVEYiA9IG5ldyBTaW1wbGVEYih0aGlzLmRiTmFtZSwgdGhpcy5zY2hlbWFWZXJzaW9uLCBuZXcgU2NoZW1hQ29udmVydGVyKHRoaXMuc2VyaWFsaXplcikpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0Q2FjaGUgPSBuZXcgSW5kZXhlZERiVGFyZ2V0Q2FjaGUodGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSwgdGhpcy5zZXJpYWxpemVyKTtcclxuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdJbmRleGVkRGJSZW1vdGVEb2N1bWVudENhY2hlKHRoaXMuc2VyaWFsaXplcik7XHJcbiAgICAgICAgdGhpcy5idW5kbGVDYWNoZSA9IG5ldyBJbmRleGVkRGJCdW5kbGVDYWNoZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLndpbmRvdyAmJiB0aGlzLndpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlID0gdGhpcy53aW5kb3cubG9jYWxTdG9yYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGZvcmNlT3duaW5nVGFiID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRkLCAnTG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlLiBBcyBhIHJlc3VsdCwgcGVyc2lzdGVuY2UgbWF5IG5vdCB3b3JrICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdyZWxpYWJseS4gSW4gcGFydGljdWxhciBlbmFibGVQZXJzaXN0ZW5jZSgpIGNvdWxkIGZhaWwgaW1tZWRpYXRlbHkgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2FmdGVyIHJlZnJlc2hpbmcgdGhlIHBhZ2UuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHQgdG8gc3RhcnQgSW5kZXhlZERiIHBlcnNpc3RlbmNlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgcGVyc2lzdGVuY2Ugd2FzIGVuYWJsZWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgZXhwZWN0ZWQgdG8gZmFpbCBzb21ldGltZXMgKGluIHRoZSBjYXNlIG9mIGFub3RoZXIgdGFiXHJcbiAgICAgICAgLy8gYWxyZWFkeSBoYXZpbmcgdGhlIHBlcnNpc3RlbmNlIGxvY2spLCBzbyBpdCdzIHRoZSBmaXJzdCB0aGluZyB3ZSBzaG91bGRcclxuICAgICAgICAvLyBkby5cclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDbGllbnRNZXRhZGF0YUFuZFRyeUJlY29tZVByaW1hcnkoKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1ByaW1hcnkgJiYgIXRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIEZhaWwgYHN0YXJ0KClgIGlmIGBzeW5jaHJvbml6ZVRhYnNgIGlzIGRpc2FibGVkIGFuZCB3ZSBjYW5ub3RcclxuICAgICAgICAgICAgICAgIC8vIG9idGFpbiB0aGUgcHJpbWFyeSBsZWFzZS5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hdHRhY2hWaXNpYmlsaXR5SGFuZGxlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmF0dGFjaFdpbmRvd1VubG9hZEhvb2soKTtcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNsaWVudE1ldGFkYXRhQW5kUHJpbWFyeUxlYXNlUmVmcmVzaGVzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1blRyYW5zYWN0aW9uKCdnZXRIaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXInLCAncmVhZG9ubHknLCB0eG4gPT4gdGhpcy50YXJnZXRDYWNoZS5nZXRIaWdoZXN0U2VxdWVuY2VOdW1iZXIodHhuKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnRoZW4oaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyID0+IHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5TZXF1ZW5jZSA9IG5ldyBMaXN0ZW5TZXF1ZW5jZShoaWdoZXN0TGlzdGVuU2VxdWVuY2VOdW1iZXIsIHRoaXMuc2VxdWVuY2VOdW1iZXJTeW5jZXIpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2ltcGxlRGIgJiYgdGhpcy5zaW1wbGVEYi5jbG9zZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBwcmltYXJ5IHN0YXRlIG9mIHRoZVxyXG4gICAgICogaW5zdGFuY2UgY2hhbmdlcy4gVXBvbiByZWdpc3RlcmluZywgdGhpcyBsaXN0ZW5lciBpcyBpbnZva2VkIGltbWVkaWF0ZWx5XHJcbiAgICAgKiB3aXRoIHRoZSBjdXJyZW50IHByaW1hcnkgc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cclxuICAgICAqL1xyXG4gICAgc2V0UHJpbWFyeVN0YXRlTGlzdGVuZXIocHJpbWFyeVN0YXRlTGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyID0gYXN5bmMgKHByaW1hcnlTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJpbWFyeVN0YXRlTGlzdGVuZXIocHJpbWFyeVN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHByaW1hcnlTdGF0ZUxpc3RlbmVyKHRoaXMuaXNQcmltYXJ5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBkYXRhYmFzZSByZWNlaXZlcyBhXHJcbiAgICAgKiB2ZXJzaW9uIGNoYW5nZSBldmVudCBpbmRpY2F0aW5nIHRoYXQgaXQgaGFzIGRlbGV0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cclxuICAgICAqL1xyXG4gICAgc2V0RGF0YWJhc2VEZWxldGVkTGlzdGVuZXIoZGF0YWJhc2VEZWxldGVkTGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLnNpbXBsZURiLnNldFZlcnNpb25DaGFuZ2VMaXN0ZW5lcihhc3luYyAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW4gYXR0ZW1wdCBpcyBtYWRlIHRvIGRlbGV0ZSBJbmRleGVkREIuXHJcbiAgICAgICAgICAgIGlmIChldmVudC5uZXdWZXJzaW9uID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYXRhYmFzZURlbGV0ZWRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkanVzdHMgdGhlIGN1cnJlbnQgbmV0d29yayBzdGF0ZSBpbiB0aGUgY2xpZW50J3MgbWV0YWRhdGEsIHBvdGVudGlhbGx5XHJcbiAgICAgKiBhZmZlY3RpbmcgdGhlIHByaW1hcnkgbGVhc2UuXHJcbiAgICAgKlxyXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cclxuICAgICAqL1xyXG4gICAgc2V0TmV0d29ya0VuYWJsZWQobmV0d29ya0VuYWJsZWQpIHtcclxuICAgICAgICBpZiAodGhpcy5uZXR3b3JrRW5hYmxlZCAhPT0gbmV0d29ya0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXR3b3JrRW5hYmxlZCA9IG5ldHdvcmtFbmFibGVkO1xyXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIHByaW1hcnkgbGVhc2UgcmVmcmVzaCBmb3IgaW1tZWRpYXRlIGV4ZWN1dGlvbi4gVGhlIGV2ZW50dWFsXHJcbiAgICAgICAgICAgIC8vIGxlYXNlIHVwZGF0ZSB3aWxsIGJlIHByb3BhZ2F0ZWQgdmlhIGBwcmltYXJ5U3RhdGVMaXN0ZW5lcmAuXHJcbiAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVDbGllbnRNZXRhZGF0YUFuZFRyeUJlY29tZVByaW1hcnkoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBjbGllbnQgbWV0YWRhdGEgaW4gSW5kZXhlZERiIGFuZCBhdHRlbXB0cyB0byBlaXRoZXIgb2J0YWluIG9yXHJcbiAgICAgKiBleHRlbmQgdGhlIHByaW1hcnkgbGVhc2UgZm9yIHRoZSBsb2NhbCBjbGllbnQuIEFzeW5jaHJvbm91c2x5IG5vdGlmaWVzIHRoZVxyXG4gICAgICogcHJpbWFyeSBzdGF0ZSBsaXN0ZW5lciBpZiB0aGUgY2xpZW50IGVpdGhlciBuZXdseSBvYnRhaW5lZCBvciByZWxlYXNlZCBpdHNcclxuICAgICAqIHByaW1hcnkgbGVhc2UuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmFuc2FjdGlvbigndXBkYXRlQ2xpZW50TWV0YWRhdGFBbmRUcnlCZWNvbWVQcmltYXJ5JywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhU3RvcmUgPSBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bik7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVN0b3JlXHJcbiAgICAgICAgICAgICAgICAucHV0KG5ldyBEYkNsaWVudE1ldGFkYXRhKHRoaXMuY2xpZW50SWQsIERhdGUubm93KCksIHRoaXMubmV0d29ya0VuYWJsZWQsIHRoaXMuaW5Gb3JlZ3JvdW5kKSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVByaW1hcnlMZWFzZSh0eG4pLm5leHQoc3VjY2VzcyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZVJldHJ5YWJsZSgoKSA9PiB0aGlzLnByaW1hcnlTdGF0ZUxpc3RlbmVyKGZhbHNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5uZXh0KCgpID0+IHRoaXMuY2FuQWN0QXNQcmltYXJ5KHR4bikpXHJcbiAgICAgICAgICAgICAgICAubmV4dChjYW5BY3RBc1ByaW1hcnkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5ICYmICFjYW5BY3RBc1ByaW1hcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxlYXNlUHJpbWFyeUxlYXNlSWZIZWxkKHR4bikubmV4dCgoKSA9PiBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjYW5BY3RBc1ByaW1hcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UodHhuKS5uZXh0KCgpID0+IHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qIGNhbkFjdEFzUHJpbWFyeT0gKi8gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRkLCAnRmFpbGVkIHRvIGV4dGVuZCBvd25lciBsZWFzZTogJywgZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBQcm9jZWVkIHdpdGggdGhlIGV4aXN0aW5nIHN0YXRlLiBBbnkgc3Vic2VxdWVudCBhY2Nlc3MgdG9cclxuICAgICAgICAgICAgICAgIC8vIEluZGV4ZWREQiB3aWxsIHZlcmlmeSB0aGUgbGVhc2UuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ByaW1hcnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZCwgJ1JlbGVhc2luZyBvd25lciBsZWFzZSBhZnRlciBlcnJvciBkdXJpbmcgbGVhc2UgcmVmcmVzaCcsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gLyogaXNQcmltYXJ5PSAqLyBmYWxzZTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudGhlbihpc1ByaW1hcnkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnkgIT09IGlzUHJpbWFyeSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIoaXNQcmltYXJ5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBpc1ByaW1hcnk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB2ZXJpZnlQcmltYXJ5TGVhc2UodHhuKSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcclxuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0KERiUHJpbWFyeUNsaWVudC5rZXkpLm5leHQocHJpbWFyeUNsaWVudCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmlzTG9jYWxDbGllbnQocHJpbWFyeUNsaWVudCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ2xpZW50TWV0YWRhdGEodHhuKSB7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGFTdG9yZSA9IGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKTtcclxuICAgICAgICByZXR1cm4gbWV0YWRhdGFTdG9yZS5kZWxldGUodGhpcy5jbGllbnRJZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBnYXJiYWdlIGNvbGxlY3Rpb24gdGhyZXNob2xkIGhhcyBwYXNzZWQsIHBydW5lcyB0aGVcclxuICAgICAqIFJlbW90ZURvY3VtZW50Q2hhbmdlcyBhbmQgdGhlIENsaWVudE1ldGFkYXRhIHN0b3JlIGJhc2VkIG9uIHRoZSBsYXN0IHVwZGF0ZVxyXG4gICAgICogdGltZSBvZiBhbGwgY2xpZW50cy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgbWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5ICYmXHJcbiAgICAgICAgICAgICF0aGlzLmlzV2l0aGluQWdlKHRoaXMubGFzdEdhcmJhZ2VDb2xsZWN0aW9uVGltZSwgTUFYX0NMSUVOVF9BR0VfTVMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEdhcmJhZ2VDb2xsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluYWN0aXZlQ2xpZW50cyA9IGF3YWl0IHRoaXMucnVuVHJhbnNhY3Rpb24oJ21heWJlR2FyYmFnZUNvbGxlY3RNdWx0aUNsaWVudFN0YXRlJywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhU3RvcmUgPSBnZXRTdG9yZSh0eG4sIERiQ2xpZW50TWV0YWRhdGEuc3RvcmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhU3RvcmUubG9hZEFsbCgpLm5leHQoZXhpc3RpbmdDbGllbnRzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmZpbHRlckFjdGl2ZUNsaWVudHMoZXhpc3RpbmdDbGllbnRzLCBNQVhfQ0xJRU5UX0FHRV9NUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5hY3RpdmUgPSBleGlzdGluZ0NsaWVudHMuZmlsdGVyKGNsaWVudCA9PiBhY3RpdmUuaW5kZXhPZihjbGllbnQpID09PSAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIG1ldGFkYXRhIGZvciBjbGllbnRzIHRoYXQgYXJlIG5vIGxvbmdlciBjb25zaWRlcmVkIGFjdGl2ZS5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2goaW5hY3RpdmUsIChpbmFjdGl2ZUNsaWVudCkgPT4gbWV0YWRhdGFTdG9yZS5kZWxldGUoaW5hY3RpdmVDbGllbnQuY2xpZW50SWQpKS5uZXh0KCgpID0+IGluYWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcHJpbWFyeSBsZWFzZSB2aW9sYXRpb25zIG9yIGFueSBvdGhlciB0eXBlIG9mIGVycm9yLiBUaGUgbmV4dFxyXG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeSB3aWxsIHJ1biBgbWF5YmVHYXJiYWdlQ29sbGVjdE11bHRpQ2xpZW50U3RhdGUoKWAgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgYGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcygpYCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGRlcGVuZFxyXG4gICAgICAgICAgICAgICAgLy8gb24gTG9jYWxTdG9yZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIERlbGV0ZSBwb3RlbnRpYWwgbGVmdG92ZXIgZW50cmllcyB0aGF0IG1heSBjb250aW51ZSB0byBtYXJrIHRoZVxyXG4gICAgICAgICAgICAvLyBpbmFjdGl2ZSBjbGllbnRzIGFzIHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlLlxyXG4gICAgICAgICAgICAvLyBJZGVhbGx5IHdlJ2QgZGVsZXRlIHRoZSBJbmRleGVkRGIgYW5kIExvY2FsU3RvcmFnZSB6b21iaWUgZW50cmllcyBmb3JcclxuICAgICAgICAgICAgLy8gdGhlIGNsaWVudCBhdG9taWNhbGx5LCBidXQgd2UgY2FuJ3QuIFNvIHdlIG9wdCB0byBkZWxldGUgdGhlIEluZGV4ZWREYlxyXG4gICAgICAgICAgICAvLyBlbnRyaWVzIGZpcnN0IHRvIGF2b2lkIHBvdGVudGlhbGx5IHJldml2aW5nIGEgem9tYmllZCBjbGllbnQuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLndlYlN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5hY3RpdmVDbGllbnQgb2YgaW5hY3RpdmVDbGllbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWJTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy56b21iaWVkQ2xpZW50TG9jYWxTdG9yYWdlS2V5KGluYWN0aXZlQ2xpZW50LmNsaWVudElkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjaGVkdWxlcyBhIHJlY3VycmluZyB0aW1lciB0byB1cGRhdGUgdGhlIGNsaWVudCBtZXRhZGF0YSBhbmQgdG8gZWl0aGVyXHJcbiAgICAgKiBleHRlbmQgb3IgYWNxdWlyZSB0aGUgcHJpbWFyeSBsZWFzZSBpZiB0aGUgY2xpZW50IGlzIGVsaWdpYmxlLlxyXG4gICAgICovXHJcbiAgICBzY2hlZHVsZUNsaWVudE1ldGFkYXRhQW5kUHJpbWFyeUxlYXNlUmVmcmVzaGVzKCkge1xyXG4gICAgICAgIHRoaXMuY2xpZW50TWV0YWRhdGFSZWZyZXNoZXIgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KFwiY2xpZW50X21ldGFkYXRhX3JlZnJlc2hcIiAvKiBDbGllbnRNZXRhZGF0YVJlZnJlc2ggKi8sIENMSUVOVF9NRVRBREFUQV9SRUZSRVNIX0lOVEVSVkFMX01TLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLm1heWJlR2FyYmFnZUNvbGxlY3RNdWx0aUNsaWVudFN0YXRlKCkpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNjaGVkdWxlQ2xpZW50TWV0YWRhdGFBbmRQcmltYXJ5TGVhc2VSZWZyZXNoZXMoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgYGNsaWVudGAgaXMgdGhlIGxvY2FsIGNsaWVudC4gKi9cclxuICAgIGlzTG9jYWxDbGllbnQoY2xpZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGNsaWVudCA/IGNsaWVudC5vd25lcklkID09PSB0aGlzLmNsaWVudElkIDogZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlIHRoZSBzdGF0ZSBvZiBhbGwgYWN0aXZlIGNsaWVudHMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZSBsb2NhbFxyXG4gICAgICogY2xpZW50IGlzIG9yIGNhbiBhY3QgYXMgdGhlIGhvbGRlciBvZiB0aGUgcHJpbWFyeSBsZWFzZS4gUmV0dXJucyB3aGV0aGVyXHJcbiAgICAgKiB0aGUgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGUgbGVhc2UsIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSBhY3F1aXJlIGl0LlxyXG4gICAgICogTWF5IHJldHVybiAnZmFsc2UnIGV2ZW4gaWYgdGhlcmUgaXMgbm8gYWN0aXZlIGxlYXNlaG9sZGVyIGFuZCBhbm90aGVyXHJcbiAgICAgKiAoZm9yZWdyb3VuZCkgY2xpZW50IHNob3VsZCBiZWNvbWUgbGVhc2Vob2xkZXIgaW5zdGVhZC5cclxuICAgICAqL1xyXG4gICAgY2FuQWN0QXNQcmltYXJ5KHR4bikge1xyXG4gICAgICAgIGlmICh0aGlzLmZvcmNlT3duaW5nVGFiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcclxuICAgICAgICByZXR1cm4gc3RvcmVcclxuICAgICAgICAgICAgLmdldChEYlByaW1hcnlDbGllbnQua2V5KVxyXG4gICAgICAgICAgICAubmV4dChjdXJyZW50UHJpbWFyeSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZWFzZUlzVmFsaWQgPSBjdXJyZW50UHJpbWFyeSAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1dpdGhpbkFnZShjdXJyZW50UHJpbWFyeS5sZWFzZVRpbWVzdGFtcE1zLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5pc0NsaWVudFpvbWJpZWQoY3VycmVudFByaW1hcnkub3duZXJJZCk7XHJcbiAgICAgICAgICAgIC8vIEEgY2xpZW50IGlzIGVsaWdpYmxlIGZvciB0aGUgcHJpbWFyeSBsZWFzZSBpZjpcclxuICAgICAgICAgICAgLy8gLSBpdHMgbmV0d29yayBpcyBlbmFibGVkIGFuZCB0aGUgY2xpZW50J3MgdGFiIGlzIGluIHRoZSBmb3JlZ3JvdW5kLlxyXG4gICAgICAgICAgICAvLyAtIGl0cyBuZXR3b3JrIGlzIGVuYWJsZWQgYW5kIG5vIG90aGVyIGNsaWVudCdzIHRhYiBpcyBpbiB0aGVcclxuICAgICAgICAgICAgLy8gICBmb3JlZ3JvdW5kLlxyXG4gICAgICAgICAgICAvLyAtIGV2ZXJ5IGNsaWVudHMgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgdGhlIGNsaWVudCdzIHRhYiBpcyBpbiB0aGVcclxuICAgICAgICAgICAgLy8gICBmb3JlZ3JvdW5kLlxyXG4gICAgICAgICAgICAvLyAtIGV2ZXJ5IGNsaWVudHMgbmV0d29yayBpcyBkaXNhYmxlZCBhbmQgbm8gb3RoZXIgY2xpZW50J3MgdGFiIGlzIGluXHJcbiAgICAgICAgICAgIC8vICAgdGhlIGZvcmVncm91bmQuXHJcbiAgICAgICAgICAgIC8vIC0gdGhlIGBmb3JjZU93bmluZ1RhYmAgc2V0dGluZyB3YXMgcGFzc2VkIGluLlxyXG4gICAgICAgICAgICBpZiAoY3VycmVudExlYXNlSXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2NhbENsaWVudChjdXJyZW50UHJpbWFyeSkgJiYgdGhpcy5uZXR3b3JrRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWxDbGllbnQoY3VycmVudFByaW1hcnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJpbWFyeS5hbGxvd1RhYlN5bmNocm9uaXphdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWlsIHRoZSBgY2FuQWN0QXNQcmltYXJ5YCBjaGVjayBpZiB0aGUgY3VycmVudCBsZWFzZWhvbGRlciBoYXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IG9wdGVkIGludG8gbXVsdGktdGFiIHN5bmNocm9uaXphdGlvbi4gSWYgdGhpcyBoYXBwZW5zIGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudCBzdGFydHVwLCB3ZSByZWplY3QgdGhlIFByb21pc2UgcmV0dXJuZWQgYnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGVuYWJsZVBlcnNpc3RlbmNlKClgIGFuZCB0aGUgdXNlciBjYW4gY29udGludWUgdG8gdXNlIEZpcmVzdG9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGluLW1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmYWlscyBkdXJpbmcgYSBsZWFzZSByZWZyZXNoLCB3ZSB3aWxsIGluc3RlYWQgYmxvY2sgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzeW5jUXVldWUgZnJvbSBleGVjdXRpbmcgZnVydGhlciBvcGVyYXRpb25zLiBOb3RlIHRoYXQgdGhpcyBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2NlcHRhYmxlIHNpbmNlIG1peGluZyAmIG1hdGNoaW5nIGRpZmZlcmVudCBgc3luY2hyb25pemVUYWJzYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5ncyBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGIvMTE0MjI2MjM0KTogUmVtb3ZlIHRoaXMgY2hlY2sgd2hlbiBgc3luY2hyb25pemVUYWJzYCBjYW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIGJlIHR1cm5lZCBvZmYuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrRW5hYmxlZCAmJiB0aGlzLmluRm9yZWdyb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKVxyXG4gICAgICAgICAgICAgICAgLmxvYWRBbGwoKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoZXhpc3RpbmdDbGllbnRzID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgYWxsIGV4aXN0aW5nIGNsaWVudHMgYW5kIGRldGVybWluZSB3aGV0aGVyIGF0IGxlYXN0IG9uZSBvZlxyXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBpcyBiZXR0ZXIgc3VpdGVkIHRvIG9idGFpbiB0aGUgcHJpbWFyeSBsZWFzZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZlcnJlZENhbmRpZGF0ZSA9IHRoaXMuZmlsdGVyQWN0aXZlQ2xpZW50cyhleGlzdGluZ0NsaWVudHMsIE1BWF9QUklNQVJZX0VMSUdJQkxFX0FHRV9NUykuZmluZChvdGhlckNsaWVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50SWQgIT09IG90aGVyQ2xpZW50LmNsaWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2xpZW50SGFzQmV0dGVyTmV0d29ya1N0YXRlID0gIXRoaXMubmV0d29ya0VuYWJsZWQgJiYgb3RoZXJDbGllbnQubmV0d29ya0VuYWJsZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2xpZW50SGFzQmV0dGVyVmlzaWJpbGl0eSA9ICF0aGlzLmluRm9yZWdyb3VuZCAmJiBvdGhlckNsaWVudC5pbkZvcmVncm91bmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyQ2xpZW50SGFzU2FtZU5ldHdvcmtTdGF0ZSA9IHRoaXMubmV0d29ya0VuYWJsZWQgPT09IG90aGVyQ2xpZW50Lm5ldHdvcmtFbmFibGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJDbGllbnRIYXNCZXR0ZXJOZXR3b3JrU3RhdGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvdGhlckNsaWVudEhhc0JldHRlclZpc2liaWxpdHkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlckNsaWVudEhhc1NhbWVOZXR3b3JrU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmZXJyZWRDYW5kaWRhdGUgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoY2FuQWN0QXNQcmltYXJ5ID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5ICE9PSBjYW5BY3RBc1ByaW1hcnkpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZCwgYENsaWVudCAke2NhbkFjdEFzUHJpbWFyeSA/ICdpcycgOiAnaXMgbm90J30gZWxpZ2libGUgZm9yIGEgcHJpbWFyeSBsZWFzZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2FuQWN0QXNQcmltYXJ5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgc2h1dGRvd24oKSB7XHJcbiAgICAgICAgLy8gVGhlIHNodXRkb3duKCkgb3BlcmF0aW9ucyBhcmUgaWRlbXBvdGVudCBhbmQgY2FuIGJlIGNhbGxlZCBldmVuIHdoZW5cclxuICAgICAgICAvLyBzdGFydCgpIGFib3J0ZWQgKGUuZy4gYmVjYXVzZSBpdCBjb3VsZG4ndCBhY3F1aXJlIHRoZSBwZXJzaXN0ZW5jZSBsZWFzZSkuXHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWFya0NsaWVudFpvbWJpZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5jbGllbnRNZXRhZGF0YVJlZnJlc2hlcikge1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsaWVudE1ldGFkYXRhUmVmcmVzaGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kZXRhY2hWaXNpYmlsaXR5SGFuZGxlcigpO1xyXG4gICAgICAgIHRoaXMuZGV0YWNoV2luZG93VW5sb2FkSG9vaygpO1xyXG4gICAgICAgIC8vIFVzZSBgU2ltcGxlRGIucnVuVHJhbnNhY3Rpb25gIGRpcmVjdGx5IHRvIGF2b2lkIGZhaWxpbmcgaWYgYW5vdGhlciB0YWJcclxuICAgICAgICAvLyBoYXMgb2J0YWluZWQgdGhlIHByaW1hcnkgbGVhc2UuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5zaW1wbGVEYi5ydW5UcmFuc2FjdGlvbignc2h1dGRvd24nLCAncmVhZHdyaXRlJywgW0RiUHJpbWFyeUNsaWVudC5zdG9yZSwgRGJDbGllbnRNZXRhZGF0YS5zdG9yZV0sIHNpbXBsZURiVHhuID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbiA9IG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbihzaW1wbGVEYlR4biwgTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGVhc2VQcmltYXJ5TGVhc2VJZkhlbGQocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikubmV4dCgoKSA9PiB0aGlzLnJlbW92ZUNsaWVudE1ldGFkYXRhKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNpbXBsZURiLmNsb3NlKCk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBlbnRyeSBtYXJraW5nIHRoZSBjbGllbnQgYXMgem9tYmllZCBmcm9tIExvY2FsU3RvcmFnZSBzaW5jZVxyXG4gICAgICAgIC8vIHdlIHN1Y2Nlc3NmdWxseSBkZWxldGVkIGl0cyBtZXRhZGF0YSBmcm9tIEluZGV4ZWREYi5cclxuICAgICAgICB0aGlzLnJlbW92ZUNsaWVudFpvbWJpZWRFbnRyeSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGNsaWVudHMgdGhhdCBhcmUgbm90IHpvbWJpZWQgYW5kIGhhdmUgYW4gdXBkYXRlVGltZSB3aXRoaW4gdGhlXHJcbiAgICAgKiBwcm92aWRlZCB0aHJlc2hvbGQuXHJcbiAgICAgKi9cclxuICAgIGZpbHRlckFjdGl2ZUNsaWVudHMoY2xpZW50cywgYWN0aXZpdHlUaHJlc2hvbGRNcykge1xyXG4gICAgICAgIHJldHVybiBjbGllbnRzLmZpbHRlcihjbGllbnQgPT4gdGhpcy5pc1dpdGhpbkFnZShjbGllbnQudXBkYXRlVGltZU1zLCBhY3Rpdml0eVRocmVzaG9sZE1zKSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5pc0NsaWVudFpvbWJpZWQoY2xpZW50LmNsaWVudElkKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIElEcyBvZiB0aGUgY2xpZW50cyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLiBJZiBtdWx0aS10YWJcclxuICAgICAqIGlzIG5vdCBzdXBwb3J0ZWQsIHJldHVybnMgYW4gYXJyYXkgdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBsb2NhbCBjbGllbnQnc1xyXG4gICAgICogSUQuXHJcbiAgICAgKlxyXG4gICAgICogUE9SVElORyBOT1RFOiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgV2ViIG11bHRpLXRhYi5cclxuICAgICAqL1xyXG4gICAgZ2V0QWN0aXZlQ2xpZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ydW5UcmFuc2FjdGlvbignZ2V0QWN0aXZlQ2xpZW50cycsICdyZWFkb25seScsIHR4biA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRNZXRhZGF0YVN0b3JlKHR4bilcclxuICAgICAgICAgICAgICAgIC5sb2FkQWxsKClcclxuICAgICAgICAgICAgICAgIC5uZXh0KGNsaWVudHMgPT4gdGhpcy5maWx0ZXJBY3RpdmVDbGllbnRzKGNsaWVudHMsIE1BWF9DTElFTlRfQUdFX01TKS5tYXAoY2xpZW50TWV0YWRhdGEgPT4gY2xpZW50TWV0YWRhdGEuY2xpZW50SWQpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCBzdGFydGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydGVkO1xyXG4gICAgfVxyXG4gICAgZ2V0TXV0YXRpb25RdWV1ZSh1c2VyLCBpbmRleE1hbmFnZXIpIHtcclxuICAgICAgICByZXR1cm4gSW5kZXhlZERiTXV0YXRpb25RdWV1ZS5mb3JVc2VyKHVzZXIsIHRoaXMuc2VyaWFsaXplciwgaW5kZXhNYW5hZ2VyLCB0aGlzLnJlZmVyZW5jZURlbGVnYXRlKTtcclxuICAgIH1cclxuICAgIGdldFRhcmdldENhY2hlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldENhY2hlO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhNYW5hZ2VyKHVzZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4ZWREYkluZGV4TWFuYWdlcih1c2VyKTtcclxuICAgIH1cclxuICAgIGdldERvY3VtZW50T3ZlcmxheUNhY2hlKHVzZXIpIHtcclxuICAgICAgICByZXR1cm4gSW5kZXhlZERiRG9jdW1lbnRPdmVybGF5Q2FjaGUuZm9yVXNlcih0aGlzLnNlcmlhbGl6ZXIsIHVzZXIpO1xyXG4gICAgfVxyXG4gICAgZ2V0QnVuZGxlQ2FjaGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVuZGxlQ2FjaGU7XHJcbiAgICB9XHJcbiAgICBydW5UcmFuc2FjdGlvbihhY3Rpb24sIG1vZGUsIHRyYW5zYWN0aW9uT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRkLCAnU3RhcnRpbmcgdHJhbnNhY3Rpb246JywgYWN0aW9uKTtcclxuICAgICAgICBjb25zdCBzaW1wbGVEYk1vZGUgPSBtb2RlID09PSAncmVhZG9ubHknID8gJ3JlYWRvbmx5JyA6ICdyZWFkd3JpdGUnO1xyXG4gICAgICAgIGNvbnN0IG9iamVjdFN0b3JlcyA9IGdldE9iamVjdFN0b3Jlcyh0aGlzLnNjaGVtYVZlcnNpb24pO1xyXG4gICAgICAgIGxldCBwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uO1xyXG4gICAgICAgIC8vIERvIGFsbCB0cmFuc2FjdGlvbnMgYXMgcmVhZHdyaXRlIGFnYWluc3QgYWxsIG9iamVjdCBzdG9yZXMsIHNpbmNlIHdlXHJcbiAgICAgICAgLy8gYXJlIHRoZSBvbmx5IHJlYWRlci93cml0ZXIuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2ltcGxlRGJcclxuICAgICAgICAgICAgLnJ1blRyYW5zYWN0aW9uKGFjdGlvbiwgc2ltcGxlRGJNb2RlLCBvYmplY3RTdG9yZXMsIHNpbXBsZURiVHhuID0+IHtcclxuICAgICAgICAgICAgcGVyc2lzdGVuY2VUcmFuc2FjdGlvbiA9IG5ldyBJbmRleGVkRGJUcmFuc2FjdGlvbihzaW1wbGVEYlR4biwgdGhpcy5saXN0ZW5TZXF1ZW5jZVxyXG4gICAgICAgICAgICAgICAgPyB0aGlzLmxpc3RlblNlcXVlbmNlLm5leHQoKVxyXG4gICAgICAgICAgICAgICAgOiBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKTtcclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdyZWFkd3JpdGUtcHJpbWFyeScpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdoaWxlIHdlIG1lcmVseSB2ZXJpZnkgdGhhdCB3ZSBoYXZlIChvciBjYW4gYWNxdWlyZSkgdGhlIGxlYXNlXHJcbiAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2Ugd2FpdCB0byBleHRlbmQgdGhlIHByaW1hcnkgbGVhc2UgdW50aWwgYWZ0ZXJcclxuICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGluZyB0cmFuc2FjdGlvbk9wZXJhdGlvbigpLiBUaGlzIGVuc3VyZXMgdGhhdCBldmVuIGlmIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25PcGVyYXRpb24gdGFrZXMgYSBsb25nIHRpbWUsIHdlJ2xsIHVzZSBhIHJlY2VudFxyXG4gICAgICAgICAgICAgICAgLy8gbGVhc2VUaW1lc3RhbXBNcyBpbiB0aGUgZXh0ZW5kZWQgKG9yIG5ld2x5IGFjcXVpcmVkKSBsZWFzZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVByaW1hcnlMZWFzZShwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGhvbGRzUHJpbWFyeUxlYXNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZHNQcmltYXJ5TGVhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC8qIGhvbGRzUHJpbWFyeUxlYXNlPSAqLyB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5BY3RBc1ByaW1hcnkocGVyc2lzdGVuY2VUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KGhvbGRzUHJpbWFyeUxlYXNlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhvbGRzUHJpbWFyeUxlYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKGBGYWlsZWQgdG8gb2J0YWluIHByaW1hcnkgbGVhc2UgZm9yIGFjdGlvbiAnJHthY3Rpb259Jy5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnF1ZXVlUmV0cnlhYmxlKCgpID0+IHRoaXMucHJpbWFyeVN0YXRlTGlzdGVuZXIoZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgUFJJTUFSWV9MRUFTRV9MT1NUX0VSUk9SX01TRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbk9wZXJhdGlvbihwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlT3JFeHRlbmRQcmltYXJ5TGVhc2UocGVyc2lzdGVuY2VUcmFuc2FjdGlvbikubmV4dCgoKSA9PiByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlBbGxvd1RhYlN5bmNocm9uaXphdGlvbihwZXJzaXN0ZW5jZVRyYW5zYWN0aW9uKS5uZXh0KCgpID0+IHRyYW5zYWN0aW9uT3BlcmF0aW9uKHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHBlcnNpc3RlbmNlVHJhbnNhY3Rpb24ucmFpc2VPbkNvbW1pdHRlZEV2ZW50KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIGN1cnJlbnQgdGFiIGlzIHRoZSBwcmltYXJ5IGxlYXNlaG9sZGVyIG9yIGFsdGVybmF0aXZlbHlcclxuICAgICAqIHRoYXQgdGhlIGxlYXNlaG9sZGVyIGhhcyBvcHRlZCBpbnRvIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE8oYi8xMTQyMjYyMzQpOiBSZW1vdmUgdGhpcyBjaGVjayB3aGVuIGBzeW5jaHJvbml6ZVRhYnNgIGNhbiBubyBsb25nZXJcclxuICAgIC8vIGJlIHR1cm5lZCBvZmYuXHJcbiAgICB2ZXJpZnlBbGxvd1RhYlN5bmNocm9uaXphdGlvbih0eG4pIHtcclxuICAgICAgICBjb25zdCBzdG9yZSA9IHByaW1hcnlDbGllbnRTdG9yZSh0eG4pO1xyXG4gICAgICAgIHJldHVybiBzdG9yZS5nZXQoRGJQcmltYXJ5Q2xpZW50LmtleSkubmV4dChjdXJyZW50UHJpbWFyeSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZWFzZUlzVmFsaWQgPSBjdXJyZW50UHJpbWFyeSAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1dpdGhpbkFnZShjdXJyZW50UHJpbWFyeS5sZWFzZVRpbWVzdGFtcE1zLCBNQVhfUFJJTUFSWV9FTElHSUJMRV9BR0VfTVMpICYmXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5pc0NsaWVudFpvbWJpZWQoY3VycmVudFByaW1hcnkub3duZXJJZCk7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGVhc2VJc1ZhbGlkICYmICF0aGlzLmlzTG9jYWxDbGllbnQoY3VycmVudFByaW1hcnkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZm9yY2VPd25pbmdUYWIgJiZcclxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMuYWxsb3dUYWJTeW5jaHJvbml6YXRpb24gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIWN1cnJlbnRQcmltYXJ5LmFsbG93VGFiU3luY2hyb25pemF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFBSSU1BUllfTEVBU0VfRVhDTFVTSVZFX0VSUk9SX01TRyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT2J0YWlucyBvciBleHRlbmRzIHRoZSBuZXcgcHJpbWFyeSBsZWFzZSBmb3IgdGhlIGxvY2FsIGNsaWVudC4gVGhpc1xyXG4gICAgICogbWV0aG9kIGRvZXMgbm90IHZlcmlmeSB0aGF0IHRoZSBjbGllbnQgaXMgZWxpZ2libGUgZm9yIHRoaXMgbGVhc2UuXHJcbiAgICAgKi9cclxuICAgIGFjcXVpcmVPckV4dGVuZFByaW1hcnlMZWFzZSh0eG4pIHtcclxuICAgICAgICBjb25zdCBuZXdQcmltYXJ5ID0gbmV3IERiUHJpbWFyeUNsaWVudCh0aGlzLmNsaWVudElkLCB0aGlzLmFsbG93VGFiU3luY2hyb25pemF0aW9uLCBEYXRlLm5vdygpKTtcclxuICAgICAgICByZXR1cm4gcHJpbWFyeUNsaWVudFN0b3JlKHR4bikucHV0KERiUHJpbWFyeUNsaWVudC5rZXksIG5ld1ByaW1hcnkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzQXZhaWxhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiBTaW1wbGVEYi5pc0F2YWlsYWJsZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqIENoZWNrcyB0aGUgcHJpbWFyeSBsZWFzZSBhbmQgcmVtb3ZlcyBpdCBpZiB3ZSBhcmUgdGhlIGN1cnJlbnQgcHJpbWFyeS4gKi9cclxuICAgIHJlbGVhc2VQcmltYXJ5TGVhc2VJZkhlbGQodHhuKSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBwcmltYXJ5Q2xpZW50U3RvcmUodHhuKTtcclxuICAgICAgICByZXR1cm4gc3RvcmUuZ2V0KERiUHJpbWFyeUNsaWVudC5rZXkpLm5leHQocHJpbWFyeUNsaWVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9jYWxDbGllbnQocHJpbWFyeUNsaWVudCkpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckZCwgJ1JlbGVhc2luZyBwcmltYXJ5IGxlYXNlLicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmRlbGV0ZShEYlByaW1hcnlDbGllbnQua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogVmVyaWZpZXMgdGhhdCBgdXBkYXRlVGltZU1zYCBpcyB3aXRoaW4gYG1heEFnZU1zYC4gKi9cclxuICAgIGlzV2l0aGluQWdlKHVwZGF0ZVRpbWVNcywgbWF4QWdlTXMpIHtcclxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IG1pbkFjY2VwdGFibGUgPSBub3cgLSBtYXhBZ2VNcztcclxuICAgICAgICBjb25zdCBtYXhBY2NlcHRhYmxlID0gbm93O1xyXG4gICAgICAgIGlmICh1cGRhdGVUaW1lTXMgPCBtaW5BY2NlcHRhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodXBkYXRlVGltZU1zID4gbWF4QWNjZXB0YWJsZSkge1xyXG4gICAgICAgICAgICBsb2dFcnJvcihgRGV0ZWN0ZWQgYW4gdXBkYXRlIHRpbWUgdGhhdCBpcyBpbiB0aGUgZnV0dXJlOiAke3VwZGF0ZVRpbWVNc30gPiAke21heEFjY2VwdGFibGV9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBhdHRhY2hWaXNpYmlsaXR5SGFuZGxlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5kb2N1bWVudCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbkZvcmVncm91bmQgPSB0aGlzLmRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUNsaWVudE1ldGFkYXRhQW5kVHJ5QmVjb21lUHJpbWFyeSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuaW5Gb3JlZ3JvdW5kID0gdGhpcy5kb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXRhY2hWaXNpYmlsaXR5SGFuZGxlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5kb2N1bWVudFZpc2liaWxpdHlIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRWaXNpYmlsaXR5SGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyBhIHdpbmRvdy51bmxvYWQgaGFuZGxlciB0aGF0IHdpbGwgc3luY2hyb25vdXNseSB3cml0ZSBvdXJcclxuICAgICAqIGNsaWVudElkIHRvIGEgXCJ6b21iaWUgY2xpZW50IGlkXCIgbG9jYXRpb24gaW4gTG9jYWxTdG9yYWdlLiBUaGlzIGNhbiBiZSB1c2VkXHJcbiAgICAgKiBieSB0YWJzIHRyeWluZyB0byBhY3F1aXJlIHRoZSBwcmltYXJ5IGxlYXNlIHRvIGRldGVybWluZSB0aGF0IHRoZSBsZWFzZVxyXG4gICAgICogaXMgbm8gbG9uZ2VyIHZhbGlkIGV2ZW4gaWYgdGhlIHRpbWVzdGFtcCBpcyByZWNlbnQuIFRoaXMgaXMgcGFydGljdWxhcmx5XHJcbiAgICAgKiBpbXBvcnRhbnQgZm9yIHRoZSByZWZyZXNoIGNhc2UgKHNvIHRoZSB0YWIgY29ycmVjdGx5IHJlLWFjcXVpcmVzIHRoZVxyXG4gICAgICogcHJpbWFyeSBsZWFzZSkuIExvY2FsU3RvcmFnZSBpcyB1c2VkIGZvciB0aGlzIHJhdGhlciB0aGFuIEluZGV4ZWREYiBiZWNhdXNlXHJcbiAgICAgKiBpdCBpcyBhIHN5bmNocm9ub3VzIEFQSSBhbmQgc28gY2FuIGJlIHVzZWQgcmVsaWFibHkgZnJvbSAgYW4gdW5sb2FkXHJcbiAgICAgKiBoYW5kbGVyLlxyXG4gICAgICovXHJcbiAgICBhdHRhY2hXaW5kb3dVbmxvYWRIb29rKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodHlwZW9mICgoX2EgPSB0aGlzLndpbmRvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93VW5sb2FkSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IEluIHRoZW9yeSwgdGhpcyBzaG91bGQgYmUgc2NoZWR1bGVkIG9uIHRoZSBBc3luY1F1ZXVlIHNpbmNlIGl0XHJcbiAgICAgICAgICAgICAgICAvLyBhY2Nlc3NlcyBpbnRlcm5hbCBzdGF0ZS4gV2UgZXhlY3V0ZSB0aGlzIGNvZGUgZGlyZWN0bHkgZHVyaW5nIHNodXRkb3duXHJcbiAgICAgICAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBhIGNoYW5jZSB0byBydW4uXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtDbGllbnRab21iaWVkKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTYWZhcmkoKSAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvVmVyc2lvblxcLzFbNDVdLykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPbiBTYWZhcmkgMTQgYW5kIDE1LCB3ZSBkbyBub3QgcnVuIGFueSBjbGVhbnVwIGFjdGlvbnMgYXMgaXQgbWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGEgYnVnIHRoYXQgcHJldmVudHMgU2FmYXJpIGZyb20gcmUtb3BlbmluZyBJbmRleGVkREIgZHVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5leHQgcGFnZSBsb2FkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjI2NTQ3XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5lbnRlclJlc3RyaWN0ZWRNb2RlKC8qIHB1cmdlRXhpc3RpbmdUYXNrcz0gKi8gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgZ3JhY2VmdWwgc2h1dGRvd24gKGluY2x1ZGluZyByZWxlYXNpbmcgb3VyIHByaW1hcnkgbGVhc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGVyZSdzIG5vIGd1YXJhbnRlZSBpdCB3aWxsIGNvbXBsZXRlLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLndpbmRvd1VubG9hZEhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRldGFjaFdpbmRvd1VubG9hZEhvb2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2luZG93VW5sb2FkSGFuZGxlcikge1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMud2luZG93VW5sb2FkSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMud2luZG93VW5sb2FkSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBjbGllbnQgaXMgXCJ6b21iaWVkXCIgYmFzZWQgb24gaXRzIExvY2FsU3RvcmFnZSBlbnRyeS5cclxuICAgICAqIENsaWVudHMgYmVjb21lIHpvbWJpZWQgd2hlbiB0aGVpciB0YWIgY2xvc2VzIHdpdGhvdXQgcnVubmluZyBhbGwgb2YgdGhlXHJcbiAgICAgKiBjbGVhbnVwIGxvZ2ljIGluIGBzaHV0ZG93bigpYC5cclxuICAgICAqL1xyXG4gICAgaXNDbGllbnRab21iaWVkKGNsaWVudElkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzWm9tYmllZCA9ICgoX2EgPSB0aGlzLndlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleShjbGllbnRJZCkpKSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRkLCBgQ2xpZW50ICcke2NsaWVudElkfScgJHtpc1pvbWJpZWQgPyAnaXMnIDogJ2lzIG5vdCd9IHpvbWJpZWQgaW4gTG9jYWxTdG9yYWdlYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1pvbWJpZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGlmIExvY2FsU3RvcmFnZSBpc24ndCB3b3JraW5nLlxyXG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGQsICdGYWlsZWQgdG8gZ2V0IHpvbWJpZWQgY2xpZW50IGlkLicsIGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNvcmQgY2xpZW50IGFzIHpvbWJpZWQgKGEgY2xpZW50IHRoYXQgaGFkIGl0cyB0YWIgY2xvc2VkKS4gWm9tYmllZFxyXG4gICAgICogY2xpZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgcHJpbWFyeSB0YWIgc2VsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBtYXJrQ2xpZW50Wm9tYmllZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMud2ViU3RvcmFnZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5zZXRJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSwgU3RyaW5nKERhdGUubm93KCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgaWYgTG9jYWxTdG9yYWdlIGlzbid0IGF2YWlsYWJsZSAvIHdvcmtpbmcuXHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsZWQgdG8gc2V0IHpvbWJpZSBjbGllbnQgaWQuJywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIFJlbW92ZXMgdGhlIHpvbWJpZWQgY2xpZW50IGVudHJ5IGlmIGl0IGV4aXN0cy4gKi9cclxuICAgIHJlbW92ZUNsaWVudFpvbWJpZWRFbnRyeSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMud2ViU3RvcmFnZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuem9tYmllZENsaWVudExvY2FsU3RvcmFnZUtleSh0aGlzLmNsaWVudElkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIElnbm9yZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHpvbWJpZWRDbGllbnRMb2NhbFN0b3JhZ2VLZXkoY2xpZW50SWQpIHtcclxuICAgICAgICByZXR1cm4gYCR7Wk9NQklFRF9DTElFTlRTX0tFWV9QUkVGSVh9XyR7dGhpcy5wZXJzaXN0ZW5jZUtleX1fJHtjbGllbnRJZH1gO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGEgdHlwZWQgU2ltcGxlRGJTdG9yZSBmb3IgdGhlIHByaW1hcnkgY2xpZW50IG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIHByaW1hcnlDbGllbnRTdG9yZSh0eG4pIHtcclxuICAgIHJldHVybiBnZXRTdG9yZSh0eG4sIERiUHJpbWFyeUNsaWVudC5zdG9yZSk7XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgYSB0eXBlZCBTaW1wbGVEYlN0b3JlIGZvciB0aGUgY2xpZW50IG1ldGFkYXRhIG9iamVjdCBzdG9yZS5cclxuICovXHJcbmZ1bmN0aW9uIGNsaWVudE1ldGFkYXRhU3RvcmUodHhuKSB7XHJcbiAgICByZXR1cm4gZ2V0U3RvcmUodHhuLCBEYkNsaWVudE1ldGFkYXRhLnN0b3JlKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHVzZWQgYXMgYSBwcmVmaXggd2hlbiBzdG9yaW5nIGRhdGEgaW4gSW5kZXhlZERCIGFuZFxyXG4gKiBMb2NhbFN0b3JhZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbmRleGVkRGJTdG9yYWdlUHJlZml4KGRhdGFiYXNlSWQsIHBlcnNpc3RlbmNlS2V5KSB7XHJcbiAgICAvLyBVc2UgdHdvIGRpZmZlcmVudCBwcmVmaXggZm9ybWF0czpcclxuICAgIC8vXHJcbiAgICAvLyAgICogZmlyZXN0b3JlIC8gcGVyc2lzdGVuY2VLZXkgLyBwcm9qZWN0SUQgLiBkYXRhYmFzZUlEIC8gLi4uXHJcbiAgICAvLyAgICogZmlyZXN0b3JlIC8gcGVyc2lzdGVuY2VLZXkgLyBwcm9qZWN0SUQgLyAuLi5cclxuICAgIC8vXHJcbiAgICAvLyBwcm9qZWN0SURzIGFyZSBETlMtY29tcGF0aWJsZSBuYW1lcyBhbmQgY2Fubm90IGNvbnRhaW4gZG90c1xyXG4gICAgLy8gc28gdGhlcmUncyBubyBkYW5nZXIgb2YgY29sbGlzaW9ucy5cclxuICAgIGxldCBkYXRhYmFzZSA9IGRhdGFiYXNlSWQucHJvamVjdElkO1xyXG4gICAgaWYgKCFkYXRhYmFzZUlkLmlzRGVmYXVsdERhdGFiYXNlKSB7XHJcbiAgICAgICAgZGF0YWJhc2UgKz0gJy4nICsgZGF0YWJhc2VJZC5kYXRhYmFzZTtcclxuICAgIH1cclxuICAgIHJldHVybiAnZmlyZXN0b3JlLycgKyBwZXJzaXN0ZW5jZUtleSArICcvJyArIGRhdGFiYXNlICsgJy8nO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGluZGV4ZWREYkNsZWFyUGVyc2lzdGVuY2UocGVyc2lzdGVuY2VLZXkpIHtcclxuICAgIGlmICghU2ltcGxlRGIuaXNBdmFpbGFibGUoKSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRiTmFtZSA9IHBlcnNpc3RlbmNlS2V5ICsgTUFJTl9EQVRBQkFTRTtcclxuICAgIGF3YWl0IFNpbXBsZURiLmRlbGV0ZShkYk5hbWUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHJlYWRvbmx5IHZpZXcgb2YgdGhlIGxvY2FsIHN0YXRlIG9mIGFsbCBkb2N1bWVudHMgd2UncmUgdHJhY2tpbmcgKGkuZS4gd2VcclxuICogaGF2ZSBhIGNhY2hlZCB2ZXJzaW9uIGluIHJlbW90ZURvY3VtZW50Q2FjaGUgb3IgbG9jYWwgbXV0YXRpb25zIGZvciB0aGVcclxuICogZG9jdW1lbnQpLiBUaGUgdmlldyBpcyBjb21wdXRlZCBieSBhcHBseWluZyB0aGUgbXV0YXRpb25zIGluIHRoZVxyXG4gKiBNdXRhdGlvblF1ZXVlIHRvIHRoZSBSZW1vdGVEb2N1bWVudENhY2hlLlxyXG4gKi9cclxuY2xhc3MgTG9jYWxEb2N1bWVudHNWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbW90ZURvY3VtZW50Q2FjaGUsIG11dGF0aW9uUXVldWUsIGluZGV4TWFuYWdlcikge1xyXG4gICAgICAgIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZSA9IHJlbW90ZURvY3VtZW50Q2FjaGU7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlID0gbXV0YXRpb25RdWV1ZTtcclxuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IGluZGV4TWFuYWdlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsb2NhbCB2aWV3IG9mIHRoZSBkb2N1bWVudCBpZGVudGlmaWVkIGJ5IGBrZXlgLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIExvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50IG9yIG51bGwgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY2FjaGVkXHJcbiAgICAgKiBzdGF0ZSBmb3IgaXQuXHJcbiAgICAgKi9cclxuICAgIGdldERvY3VtZW50KHRyYW5zYWN0aW9uLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tdXRhdGlvblF1ZXVlXHJcbiAgICAgICAgICAgIC5nZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleSh0cmFuc2FjdGlvbiwga2V5KVxyXG4gICAgICAgICAgICAubmV4dChiYXRjaGVzID0+IHRoaXMuZ2V0RG9jdW1lbnRJbnRlcm5hbCh0cmFuc2FjdGlvbiwga2V5LCBiYXRjaGVzKSk7XHJcbiAgICB9XHJcbiAgICAvKiogSW50ZXJuYWwgdmVyc2lvbiBvZiBgZ2V0RG9jdW1lbnRgIHRoYXQgYWxsb3dzIHJldXNpbmcgYmF0Y2hlcy4gKi9cclxuICAgIGdldERvY3VtZW50SW50ZXJuYWwodHJhbnNhY3Rpb24sIGtleSwgaW5CYXRjaGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZS5nZXRFbnRyeSh0cmFuc2FjdGlvbiwga2V5KS5uZXh0KGRvYyA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgaW5CYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5hcHBseVRvTG9jYWxWaWV3KGRvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRvYztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIHZpZXcgb2YgdGhlIGdpdmVuIGBkb2NzYCBhcyB0aGV5IHdvdWxkIGFwcGVhciBhZnRlciBhcHBseWluZ1xyXG4gICAgLy8gYWxsIG11dGF0aW9ucyBpbiB0aGUgZ2l2ZW4gYGJhdGNoZXNgLlxyXG4gICAgYXBwbHlMb2NhbE11dGF0aW9uc1RvRG9jdW1lbnRzKGRvY3MsIGJhdGNoZXMpIHtcclxuICAgICAgICBkb2NzLmZvckVhY2goKGtleSwgbG9jYWxWaWV3KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgYmF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guYXBwbHlUb0xvY2FsVmlldyhsb2NhbFZpZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50cyBpZGVudGlmaWVkIGJ5IGBrZXlzYC5cclxuICAgICAqXHJcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzdGF0ZSBmb3IgYSBkb2N1bWVudCBpbiBga2V5c2AsIGEgTm9Eb2N1bWVudCB3aWxsXHJcbiAgICAgKiBiZSBzdG9yZWQgZm9yIHRoYXQga2V5IGluIHRoZSByZXN1bHRpbmcgc2V0LlxyXG4gICAgICovXHJcbiAgICBnZXREb2N1bWVudHModHJhbnNhY3Rpb24sIGtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlXHJcbiAgICAgICAgICAgIC5nZXRFbnRyaWVzKHRyYW5zYWN0aW9uLCBrZXlzKVxyXG4gICAgICAgICAgICAubmV4dChkb2NzID0+IHRoaXMuYXBwbHlMb2NhbFZpZXdUb0RvY3VtZW50cyh0cmFuc2FjdGlvbiwgZG9jcykubmV4dCgoKSA9PiBkb2NzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGxvY2FsIHZpZXcgdGhlIGdpdmVuIGBiYXNlRG9jc2Agd2l0aG91dCByZXRyaWV2aW5nIGRvY3VtZW50c1xyXG4gICAgICogZnJvbSB0aGUgbG9jYWwgc3RvcmUuXHJcbiAgICAgKi9cclxuICAgIGFwcGx5TG9jYWxWaWV3VG9Eb2N1bWVudHModHJhbnNhY3Rpb24sIGJhc2VEb2NzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXV0YXRpb25RdWV1ZVxyXG4gICAgICAgICAgICAuZ2V0QWxsTXV0YXRpb25CYXRjaGVzQWZmZWN0aW5nRG9jdW1lbnRLZXlzKHRyYW5zYWN0aW9uLCBiYXNlRG9jcylcclxuICAgICAgICAgICAgLm5leHQoYmF0Y2hlcyA9PiB0aGlzLmFwcGx5TG9jYWxNdXRhdGlvbnNUb0RvY3VtZW50cyhiYXNlRG9jcywgYmF0Y2hlcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIHF1ZXJ5IGFnYWluc3QgdGhlIGxvY2FsIHZpZXcgb2YgYWxsIGRvY3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUaGUgcGVyc2lzdGVuY2UgdHJhbnNhY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdG8gbWF0Y2ggZG9jdW1lbnRzIGFnYWluc3QuXHJcbiAgICAgKiBAcGFyYW0gc2luY2VSZWFkVGltZSAtIElmIG5vdCBzZXQgdG8gU25hcHNob3RWZXJzaW9uLm1pbigpLCByZXR1cm4gb25seVxyXG4gICAgICogICAgIGRvY3VtZW50cyB0aGF0IGhhdmUgYmVlbiByZWFkIHNpbmNlIHRoaXMgc25hcHNob3QgdmVyc2lvbiAoZXhjbHVzaXZlKS5cclxuICAgICAqL1xyXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIHNpbmNlUmVhZFRpbWUpIHtcclxuICAgICAgICBpZiAoaXNEb2N1bWVudFF1ZXJ5JDEocXVlcnkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nRG9jdW1lbnRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkucGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQ29sbGVjdGlvbkdyb3VwUXVlcnkocXVlcnkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvbkdyb3VwUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBzaW5jZVJlYWRUaW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSwgc2luY2VSZWFkVGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0RG9jdW1lbnRzTWF0Y2hpbmdEb2N1bWVudFF1ZXJ5KHRyYW5zYWN0aW9uLCBkb2NQYXRoKSB7XHJcbiAgICAgICAgLy8gSnVzdCBkbyBhIHNpbXBsZSBkb2N1bWVudCBsb29rdXAuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RG9jdW1lbnQodHJhbnNhY3Rpb24sIG5ldyBEb2N1bWVudEtleShkb2NQYXRoKSkubmV4dChkb2N1bWVudCA9PiB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBkb2N1bWVudE1hcCgpO1xyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvbkdyb3VwUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBzaW5jZVJlYWRUaW1lKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcXVlcnkuY29sbGVjdGlvbkdyb3VwO1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gZG9jdW1lbnRNYXAoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXJcclxuICAgICAgICAgICAgLmdldENvbGxlY3Rpb25QYXJlbnRzKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uSWQpXHJcbiAgICAgICAgICAgIC5uZXh0KHBhcmVudHMgPT4ge1xyXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGEgY29sbGVjdGlvbiBxdWVyeSBhZ2FpbnN0IGVhY2ggcGFyZW50IHRoYXQgY29udGFpbnMgdGhlXHJcbiAgICAgICAgICAgIC8vIGNvbGxlY3Rpb25JZCBhbmQgYWdncmVnYXRlIHRoZSByZXN1bHRzLlxyXG4gICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLmZvckVhY2gocGFyZW50cywgKHBhcmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblF1ZXJ5ID0gYXNDb2xsZWN0aW9uUXVlcnlBdFBhdGgocXVlcnksIHBhcmVudC5jaGlsZChjb2xsZWN0aW9uSWQpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50c01hdGNoaW5nQ29sbGVjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uUXVlcnksIHNpbmNlUmVhZFRpbWUpLm5leHQociA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgci5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoa2V5LCBkb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLm5leHQoKCkgPT4gcmVzdWx0cyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudHNNYXRjaGluZ0NvbGxlY3Rpb25RdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIHNpbmNlUmVhZFRpbWUpIHtcclxuICAgICAgICAvLyBRdWVyeSB0aGUgcmVtb3RlIGRvY3VtZW50cyBhbmQgb3ZlcmxheSBtdXRhdGlvbnMuXHJcbiAgICAgICAgbGV0IHJlc3VsdHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlRG9jdW1lbnRDYWNoZVxyXG4gICAgICAgICAgICAuZ2V0QWxsKHRyYW5zYWN0aW9uLCBxdWVyeS5wYXRoLCBzaW5jZVJlYWRUaW1lKVxyXG4gICAgICAgICAgICAubmV4dChxdWVyeVJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHRzID0gcXVlcnlSZXN1bHRzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdXRhdGlvblF1ZXVlLmdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ1F1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQobXV0YXRpb25CYXRjaGVzID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBtdXRhdGlvbkJhdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgYmF0Y2gubXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbXV0YXRpb24ua2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudCA9IHJlc3VsdHMuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGludmFsaWQgZG9jdW1lbnQgdG8gYXBwbHkgbXV0YXRpb25zIG9uIHRvcCBvZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudCA9IE11dGFibGVEb2N1bWVudC5uZXdJbnZhbGlkRG9jdW1lbnQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuaW5zZXJ0KGtleSwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkFwcGx5VG9Mb2NhbFZpZXcobXV0YXRpb24sIGRvY3VtZW50LCBiYXRjaC5sb2NhbFdyaXRlVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIGZpbHRlciBvdXQgYW55IGRvY3VtZW50cyB0aGF0IGRvbid0IGFjdHVhbGx5IG1hdGNoXHJcbiAgICAgICAgICAgIC8vIHRoZSBxdWVyeS5cclxuICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeU1hdGNoZXMocXVlcnksIGRvYykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5yZW1vdmUoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckYyA9ICdMb2NhbFN0b3JlJztcclxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIHRpbWUgdG8gbGVhdmUgYSByZXN1bWUgdG9rZW4gYnVmZmVyZWQgd2l0aG91dCB3cml0aW5nIGl0IG91dC5cclxuICogVGhpcyB2YWx1ZSBpcyBhcmJpdHJhcnk6IGl0J3MgbG9uZyBlbm91Z2ggdG8gYXZvaWQgc2V2ZXJhbCB3cml0ZXNcclxuICogKHBvc3NpYmx5IGluZGVmaW5pdGVseSBpZiB1cGRhdGVzIGNvbWUgbW9yZSBmcmVxdWVudGx5IHRoYW4gdGhpcykgYnV0XHJcbiAqIHNob3J0IGVub3VnaCB0aGF0IHJlc3RhcnRpbmcgYWZ0ZXIgY3Jhc2hpbmcgd2lsbCBzdGlsbCBoYXZlIGEgcHJldHR5XHJcbiAqIHJlY2VudCByZXN1bWUgdG9rZW4uXHJcbiAqL1xyXG5jb25zdCBSRVNVTUVfVE9LRU5fTUFYX0FHRV9NSUNST1MgPSA1ICogNjAgKiAxZTY7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGBMb2NhbFN0b3JlYCBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIE5vdGU6IHNvbWUgZmllbGQgZGVmaW5lZCBpbiB0aGlzIGNsYXNzIG1pZ2h0IGhhdmUgcHVibGljIGFjY2VzcyBsZXZlbCwgYnV0XHJcbiAqIHRoZSBjbGFzcyBpcyBub3QgZXhwb3J0ZWQgc28gdGhleSBhcmUgb25seSBhY2Nlc3NpYmxlIGZyb20gdGhpcyBtb2R1bGUuXHJcbiAqIFRoaXMgaXMgdXNlZnVsIHRvIGltcGxlbWVudCBvcHRpb25hbCBmZWF0dXJlcyAobGlrZSBidW5kbGVzKSBpbiBmcmVlXHJcbiAqIGZ1bmN0aW9ucywgc3VjaCB0aGF0IHRoZXkgYXJlIHRyZWUtc2hha2VhYmxlLlxyXG4gKi9cclxuY2xhc3MgTG9jYWxTdG9yZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogTWFuYWdlcyBvdXIgaW4tbWVtb3J5IG9yIGR1cmFibGUgcGVyc2lzdGVuY2UuICovXHJcbiAgICBwZXJzaXN0ZW5jZSwgcXVlcnlFbmdpbmUsIGluaXRpYWxVc2VyLCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xyXG4gICAgICAgIHRoaXMucXVlcnlFbmdpbmUgPSBxdWVyeUVuZ2luZTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hcHMgYSB0YXJnZXRJRCB0byBkYXRhIGFib3V0IGl0cyB0YXJnZXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBQT1JUSU5HIE5PVEU6IFdlIGFyZSB1c2luZyBhbiBpbW11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgb24gV2ViIHRvIG1ha2UgcmUtcnVuc1xyXG4gICAgICAgICAqIG9mIGBhcHBseVJlbW90ZUV2ZW50KClgIGlkZW1wb3RlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YXJnZXREYXRhQnlUYXJnZXQgPSBuZXcgU29ydGVkTWFwKHByaW1pdGl2ZUNvbXBhcmF0b3IpO1xyXG4gICAgICAgIC8qKiBNYXBzIGEgdGFyZ2V0IHRvIGl0cyB0YXJnZXRJRC4gKi9cclxuICAgICAgICAvLyBUT0RPKHd1YW5keSk6IEV2YWx1YXRlIGlmIFRhcmdldElkIGNhbiBiZSBwYXJ0IG9mIFRhcmdldC5cclxuICAgICAgICB0aGlzLnRhcmdldElkQnlUYXJnZXQgPSBuZXcgT2JqZWN0TWFwKHQgPT4gY2Fub25pZnlUYXJnZXQodCksIHRhcmdldEVxdWFscyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlYWQgdGltZSBvZiB0aGUgbGFzdCBlbnRyeSBwcm9jZXNzZWQgYnkgYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFBPUlRJTkcgTk9URTogVGhpcyBpcyBvbmx5IHVzZWQgZm9yIG11bHRpLXRhYiBzeW5jaHJvbml6YXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sYXN0RG9jdW1lbnRDaGFuZ2VSZWFkVGltZSA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cyA9IHBlcnNpc3RlbmNlLmdldFJlbW90ZURvY3VtZW50Q2FjaGUoKTtcclxuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gcGVyc2lzdGVuY2UuZ2V0VGFyZ2V0Q2FjaGUoKTtcclxuICAgICAgICB0aGlzLmJ1bmRsZUNhY2hlID0gcGVyc2lzdGVuY2UuZ2V0QnVuZGxlQ2FjaGUoKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVVc2VyQ29tcG9uZW50cyhpbml0aWFsVXNlcik7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplVXNlckNvbXBvbmVudHModXNlcikge1xyXG4gICAgICAgIC8vIFRPRE8oaW5kZXhpbmcpOiBBZGQgc3BlYyB0ZXN0cyB0aGF0IHRlc3QgdGhlc2UgY29tcG9uZW50cyBjaGFuZ2UgYWZ0ZXIgYVxyXG4gICAgICAgIC8vIHVzZXIgY2hhbmdlXHJcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSB0aGlzLnBlcnNpc3RlbmNlLmdldEluZGV4TWFuYWdlcih1c2VyKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldE11dGF0aW9uUXVldWUodXNlciwgdGhpcy5pbmRleE1hbmFnZXIpO1xyXG4gICAgICAgIHRoaXMubG9jYWxEb2N1bWVudHMgPSBuZXcgTG9jYWxEb2N1bWVudHNWaWV3KHRoaXMucmVtb3RlRG9jdW1lbnRzLCB0aGlzLm11dGF0aW9uUXVldWUsIHRoaXMuaW5kZXhNYW5hZ2VyKTtcclxuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50cy5zZXRJbmRleE1hbmFnZXIodGhpcy5pbmRleE1hbmFnZXIpO1xyXG4gICAgICAgIHRoaXMucXVlcnlFbmdpbmUuc2V0TG9jYWxEb2N1bWVudHNWaWV3KHRoaXMubG9jYWxEb2N1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgY29sbGVjdEdhcmJhZ2UoZ2FyYmFnZUNvbGxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdDb2xsZWN0IGdhcmJhZ2UnLCAncmVhZHdyaXRlLXByaW1hcnknLCB0eG4gPT4gZ2FyYmFnZUNvbGxlY3Rvci5jb2xsZWN0KHR4biwgdGhpcy50YXJnZXREYXRhQnlUYXJnZXQpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdMb2NhbFN0b3JlKFxyXG4vKiogTWFuYWdlcyBvdXIgaW4tbWVtb3J5IG9yIGR1cmFibGUgcGVyc2lzdGVuY2UuICovXHJcbnBlcnNpc3RlbmNlLCBxdWVyeUVuZ2luZSwgaW5pdGlhbFVzZXIsIHNlcmlhbGl6ZXIpIHtcclxuICAgIHJldHVybiBuZXcgTG9jYWxTdG9yZUltcGwocGVyc2lzdGVuY2UsIHF1ZXJ5RW5naW5lLCBpbml0aWFsVXNlciwgc2VyaWFsaXplcik7XHJcbn1cclxuLyoqXHJcbiAqIFRlbGxzIHRoZSBMb2NhbFN0b3JlIHRoYXQgdGhlIGN1cnJlbnRseSBhdXRoZW50aWNhdGVkIHVzZXIgaGFzIGNoYW5nZWQuXHJcbiAqXHJcbiAqIEluIHJlc3BvbnNlIHRoZSBsb2NhbCBzdG9yZSBzd2l0Y2hlcyB0aGUgbXV0YXRpb24gcXVldWUgdG8gdGhlIG5ldyB1c2VyIGFuZFxyXG4gKiByZXR1cm5zIGFueSByZXN1bHRpbmcgZG9jdW1lbnQgY2hhbmdlcy5cclxuICovXHJcbi8vIFBPUlRJTkcgTk9URTogQW5kcm9pZCBhbmQgaU9TIG9ubHkgcmV0dXJuIHRoZSBkb2N1bWVudHMgYWZmZWN0ZWQgYnkgdGhlXHJcbi8vIGNoYW5nZS5cclxuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZUhhbmRsZVVzZXJDaGFuZ2UobG9jYWxTdG9yZSwgdXNlcikge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignSGFuZGxlIHVzZXIgY2hhbmdlJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcclxuICAgICAgICAvLyBTd2FwIG91dCB0aGUgbXV0YXRpb24gcXVldWUsIGdyYWJiaW5nIHRoZSBwZW5kaW5nIG11dGF0aW9uIGJhdGNoZXNcclxuICAgICAgICAvLyBiZWZvcmUgYW5kIGFmdGVyLlxyXG4gICAgICAgIGxldCBvbGRCYXRjaGVzO1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlXHJcbiAgICAgICAgICAgIC5nZXRBbGxNdXRhdGlvbkJhdGNoZXModHhuKVxyXG4gICAgICAgICAgICAubmV4dChwcm9taXNlZE9sZEJhdGNoZXMgPT4ge1xyXG4gICAgICAgICAgICBvbGRCYXRjaGVzID0gcHJvbWlzZWRPbGRCYXRjaGVzO1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC5pbml0aWFsaXplVXNlckNvbXBvbmVudHModXNlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLmdldEFsbE11dGF0aW9uQmF0Y2hlcyh0eG4pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KG5ld0JhdGNoZXMgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkQmF0Y2hJZHMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgYWRkZWRCYXRjaElkcyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBVbmlvbiB0aGUgb2xkL25ldyBjaGFuZ2VkIGtleXMuXHJcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2Ygb2xkQmF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlZEJhdGNoSWRzLnB1c2goYmF0Y2guYmF0Y2hJZCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIGJhdGNoLm11dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRLZXlzID0gY2hhbmdlZEtleXMuYWRkKG11dGF0aW9uLmtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBuZXdCYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRlZEJhdGNoSWRzLnB1c2goYmF0Y2guYmF0Y2hJZCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIGJhdGNoLm11dGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRLZXlzID0gY2hhbmdlZEtleXMuYWRkKG11dGF0aW9uLmtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZXQgb2YgYWxsIChwb3RlbnRpYWxseSkgY2hhbmdlZCBkb2N1bWVudHMgYW5kIHRoZSBsaXN0XHJcbiAgICAgICAgICAgIC8vIG9mIG11dGF0aW9uIGJhdGNoIElEcyB0aGF0IHdlcmUgYWZmZWN0ZWQgYnkgY2hhbmdlLlxyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHNcclxuICAgICAgICAgICAgICAgIC5nZXREb2N1bWVudHModHhuLCBjaGFuZ2VkS2V5cylcclxuICAgICAgICAgICAgICAgIC5uZXh0KGFmZmVjdGVkRG9jdW1lbnRzID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWREb2N1bWVudHMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEJhdGNoSWRzLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkQmF0Y2hJZHNcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qIEFjY2VwdHMgbG9jYWxseSBnZW5lcmF0ZWQgTXV0YXRpb25zIGFuZCBjb21taXQgdGhlbSB0byBzdG9yYWdlLiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlV3JpdGVMb2NhbGx5KGxvY2FsU3RvcmUsIG11dGF0aW9ucykge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCBsb2NhbFdyaXRlVGltZSA9IFRpbWVzdGFtcC5ub3coKTtcclxuICAgIGNvbnN0IGtleXMgPSBtdXRhdGlvbnMucmVkdWNlKChrZXlzLCBtKSA9PiBrZXlzLmFkZChtLmtleSksIGRvY3VtZW50S2V5U2V0KCkpO1xyXG4gICAgbGV0IGV4aXN0aW5nRG9jcztcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZVxyXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignTG9jYWxseSB3cml0ZSBtdXRhdGlvbnMnLCAncmVhZHdyaXRlJywgdHhuID0+IHtcclxuICAgICAgICAvLyBMb2FkIGFuZCBhcHBseSBhbGwgZXhpc3RpbmcgbXV0YXRpb25zLiBUaGlzIGxldHMgdXMgY29tcHV0ZSB0aGVcclxuICAgICAgICAvLyBjdXJyZW50IGJhc2Ugc3RhdGUgZm9yIGFsbCBub24taWRlbXBvdGVudCB0cmFuc2Zvcm1zIGJlZm9yZSBhcHBseWluZ1xyXG4gICAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHVzZXItcHJvdmlkZWQgd3JpdGVzLlxyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50c1xyXG4gICAgICAgICAgICAuZ2V0RG9jdW1lbnRzKHR4biwga2V5cylcclxuICAgICAgICAgICAgLm5leHQoZG9jcyA9PiB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nRG9jcyA9IGRvY3M7XHJcbiAgICAgICAgICAgIC8vIEZvciBub24taWRlbXBvdGVudCBtdXRhdGlvbnMgKHN1Y2ggYXMgYEZpZWxkVmFsdWUuaW5jcmVtZW50KClgKSxcclxuICAgICAgICAgICAgLy8gd2UgcmVjb3JkIHRoZSBiYXNlIHN0YXRlIGluIGEgc2VwYXJhdGUgcGF0Y2ggbXV0YXRpb24uIFRoaXMgaXNcclxuICAgICAgICAgICAgLy8gbGF0ZXIgdXNlZCB0byBndWFyYW50ZWUgY29uc2lzdGVudCB2YWx1ZXMgYW5kIHByZXZlbnRzIGZsaWNrZXJcclxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGUgYmFja2VuZCBzZW5kcyB1cyBhbiB1cGRhdGUgdGhhdCBhbHJlYWR5IGluY2x1ZGVzIG91clxyXG4gICAgICAgICAgICAvLyB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgIGNvbnN0IGJhc2VNdXRhdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IG11dGF0aW9uRXh0cmFjdEJhc2VWYWx1ZShtdXRhdGlvbiwgZXhpc3RpbmdEb2NzLmdldChtdXRhdGlvbi5rZXkpKTtcclxuICAgICAgICAgICAgICAgIGlmIChiYXNlVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IFRoZSBiYXNlIHN0YXRlIHNob3VsZCBvbmx5IGJlIGFwcGxpZWQgaWYgdGhlcmUncyBzb21lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgZG9jdW1lbnQgdG8gb3ZlcnJpZGUsIHNvIHVzZSBhIFByZWNvbmRpdGlvbiBvZlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4aXN0cz10cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZU11dGF0aW9ucy5wdXNoKG5ldyBQYXRjaE11dGF0aW9uKG11dGF0aW9uLmtleSwgYmFzZVZhbHVlLCBleHRyYWN0RmllbGRNYXNrKGJhc2VWYWx1ZS52YWx1ZS5tYXBWYWx1ZSksIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5hZGRNdXRhdGlvbkJhdGNoKHR4biwgbG9jYWxXcml0ZVRpbWUsIGJhc2VNdXRhdGlvbnMsIG11dGF0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KVxyXG4gICAgICAgIC50aGVuKGJhdGNoID0+IHtcclxuICAgICAgICBiYXRjaC5hcHBseVRvTG9jYWxEb2N1bWVudFNldChleGlzdGluZ0RvY3MpO1xyXG4gICAgICAgIHJldHVybiB7IGJhdGNoSWQ6IGJhdGNoLmJhdGNoSWQsIGNoYW5nZXM6IGV4aXN0aW5nRG9jcyB9O1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEFja25vd2xlZGdlcyB0aGUgZ2l2ZW4gYmF0Y2guXHJcbiAqXHJcbiAqIE9uIHRoZSBoYXBweSBwYXRoIHdoZW4gYSBiYXRjaCBpcyBhY2tub3dsZWRnZWQsIHRoZSBsb2NhbCBzdG9yZSB3aWxsXHJcbiAqXHJcbiAqICArIHJlbW92ZSB0aGUgYmF0Y2ggZnJvbSB0aGUgbXV0YXRpb24gcXVldWU7XHJcbiAqICArIGFwcGx5IHRoZSBjaGFuZ2VzIHRvIHRoZSByZW1vdGUgZG9jdW1lbnQgY2FjaGU7XHJcbiAqICArIHJlY2FsY3VsYXRlIHRoZSBsYXRlbmN5IGNvbXBlbnNhdGVkIHZpZXcgaW1wbGllZCBieSB0aG9zZSBjaGFuZ2VzICh0aGVyZVxyXG4gKiAgICBtYXkgYmUgbXV0YXRpb25zIGluIHRoZSBxdWV1ZSB0aGF0IGFmZmVjdCB0aGUgZG9jdW1lbnRzIGJ1dCBoYXZlbid0IGJlZW5cclxuICogICAgYWNrbm93bGVkZ2VkIHlldCk7IGFuZFxyXG4gKiAgKyBnaXZlIHRoZSBjaGFuZ2VkIGRvY3VtZW50cyBiYWNrIHRoZSBzeW5jIGVuZ2luZVxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIChtb2RpZmllZCkgZG9jdW1lbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUFja25vd2xlZGdlQmF0Y2gobG9jYWxTdG9yZSwgYmF0Y2hSZXN1bHQpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdBY2tub3dsZWRnZSBiYXRjaCcsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XHJcbiAgICAgICAgY29uc3QgYWZmZWN0ZWQgPSBiYXRjaFJlc3VsdC5iYXRjaC5rZXlzKCk7XHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnRCdWZmZXIgPSBsb2NhbFN0b3JlSW1wbC5yZW1vdGVEb2N1bWVudHMubmV3Q2hhbmdlQnVmZmVyKHtcclxuICAgICAgICAgICAgdHJhY2tSZW1vdmFsczogdHJ1ZSAvLyBNYWtlIHN1cmUgZG9jdW1lbnQgcmVtb3ZhbHMgc2hvdyB1cCBpbiBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFwcGx5V3JpdGVUb1JlbW90ZURvY3VtZW50cyhsb2NhbFN0b3JlSW1wbCwgdHhuLCBiYXRjaFJlc3VsdCwgZG9jdW1lbnRCdWZmZXIpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvY3VtZW50QnVmZmVyLmFwcGx5KHR4bikpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUucGVyZm9ybUNvbnNpc3RlbmN5Q2hlY2sodHhuKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwgYWZmZWN0ZWQpKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIG11dGF0aW9ucyBmcm9tIHRoZSBNdXRhdGlvblF1ZXVlIGZvciB0aGUgc3BlY2lmaWVkIGJhdGNoO1xyXG4gKiBMb2NhbERvY3VtZW50cyB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cclxuICpcclxuICogQHJldHVybnMgVGhlIHJlc3VsdGluZyBtb2RpZmllZCBkb2N1bWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlUmVqZWN0QmF0Y2gobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1JlamVjdCBiYXRjaCcsICdyZWFkd3JpdGUtcHJpbWFyeScsIHR4biA9PiB7XHJcbiAgICAgICAgbGV0IGFmZmVjdGVkS2V5cztcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZVxyXG4gICAgICAgICAgICAubG9va3VwTXV0YXRpb25CYXRjaCh0eG4sIGJhdGNoSWQpXHJcbiAgICAgICAgICAgIC5uZXh0KChiYXRjaCkgPT4ge1xyXG4gICAgICAgICAgICBoYXJkQXNzZXJ0KGJhdGNoICE9PSBudWxsKTtcclxuICAgICAgICAgICAgYWZmZWN0ZWRLZXlzID0gYmF0Y2gua2V5cygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5yZW1vdmVNdXRhdGlvbkJhdGNoKHR4biwgYmF0Y2gpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUucGVyZm9ybUNvbnNpc3RlbmN5Q2hlY2sodHhuKSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwgYWZmZWN0ZWRLZXlzKSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbGFyZ2VzdCAobGF0ZXN0KSBiYXRjaCBpZCBpbiBtdXRhdGlvbiBxdWV1ZSB0aGF0IGlzIHBlbmRpbmdcclxuICogc2VydmVyIHJlc3BvbnNlLlxyXG4gKlxyXG4gKiBSZXR1cm5zIGBCQVRDSElEX1VOS05PV05gIGlmIHRoZSBxdWV1ZSBpcyBlbXB0eS5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKGxvY2FsU3RvcmUpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgaGlnaGVzdCB1bmFja25vd2xlZGdlZCBiYXRjaCBpZCcsICdyZWFkb25seScsIHR4biA9PiBsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlLmdldEhpZ2hlc3RVbmFja25vd2xlZGdlZEJhdGNoSWQodHhuKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGxhc3QgY29uc2lzdGVudCBzbmFwc2hvdCBwcm9jZXNzZWQgKHVzZWQgYnkgdGhlIFJlbW90ZVN0b3JlIHRvXHJcbiAqIGRldGVybWluZSB3aGV0aGVyIHRvIGJ1ZmZlciBpbmNvbWluZyBzbmFwc2hvdHMgZnJvbSB0aGUgYmFja2VuZCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbihsb2NhbFN0b3JlKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignR2V0IGxhc3QgcmVtb3RlIHNuYXBzaG90IHZlcnNpb24nLCAncmVhZG9ubHknLCB0eG4gPT4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuZ2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbih0eG4pKTtcclxufVxyXG4vKipcclxuICogVXBkYXRlcyB0aGUgXCJncm91bmQtc3RhdGVcIiAocmVtb3RlKSBkb2N1bWVudHMuIFdlIGFzc3VtZSB0aGF0IHRoZSByZW1vdGVcclxuICogZXZlbnQgcmVmbGVjdHMgYW55IHdyaXRlIGJhdGNoZXMgdGhhdCBoYXZlIGJlZW4gYWNrbm93bGVkZ2VkIG9yIHJlamVjdGVkXHJcbiAqIChpLmUuIHdlIGRvIG5vdCByZS1hcHBseSBsb2NhbCBtdXRhdGlvbnMgdG8gdXBkYXRlcyBmcm9tIHRoaXMgZXZlbnQpLlxyXG4gKlxyXG4gKiBMb2NhbERvY3VtZW50cyBhcmUgcmUtY2FsY3VsYXRlZCBpZiB0aGVyZSBhcmUgcmVtYWluaW5nIG11dGF0aW9ucyBpbiB0aGVcclxuICogcXVldWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlQXBwbHlSZW1vdGVFdmVudFRvTG9jYWxDYWNoZShsb2NhbFN0b3JlLCByZW1vdGVFdmVudCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCByZW1vdGVWZXJzaW9uID0gcmVtb3RlRXZlbnQuc25hcHNob3RWZXJzaW9uO1xyXG4gICAgbGV0IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldDtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZVxyXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignQXBwbHkgcmVtb3RlIGV2ZW50JywgJ3JlYWR3cml0ZS1wcmltYXJ5JywgdHhuID0+IHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudEJ1ZmZlciA9IGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50cy5uZXdDaGFuZ2VCdWZmZXIoe1xyXG4gICAgICAgICAgICB0cmFja1JlbW92YWxzOiB0cnVlIC8vIE1ha2Ugc3VyZSBkb2N1bWVudCByZW1vdmFscyBzaG93IHVwIGluIGBnZXROZXdEb2N1bWVudENoYW5nZXMoKWBcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBSZXNldCBuZXdUYXJnZXREYXRhQnlUYXJnZXRNYXAgaW4gY2FzZSB0aGlzIHRyYW5zYWN0aW9uIGdldHMgcmUtcnVuLlxyXG4gICAgICAgIG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldDtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIHJlbW90ZUV2ZW50LnRhcmdldENoYW5nZXMuZm9yRWFjaCgoY2hhbmdlLCB0YXJnZXRJZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRUYXJnZXREYXRhID0gbmV3VGFyZ2V0RGF0YUJ5VGFyZ2V0TWFwLmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIGlmICghb2xkVGFyZ2V0RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSByZW1vdGUga2V5cyBpZiB0aGUgdGFyZ2V0IGlzIHN0aWxsIGFjdGl2ZS4gVGhpc1xyXG4gICAgICAgICAgICAvLyBlbnN1cmVzIHRoYXQgd2UgY2FuIHBlcnNpc3QgdGhlIHVwZGF0ZWQgdGFyZ2V0IGRhdGEgYWxvbmcgd2l0aFxyXG4gICAgICAgICAgICAvLyB0aGUgdXBkYXRlZCBhc3NpZ25tZW50LlxyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXHJcbiAgICAgICAgICAgICAgICAucmVtb3ZlTWF0Y2hpbmdLZXlzKHR4biwgY2hhbmdlLnJlbW92ZWREb2N1bWVudHMsIHRhcmdldElkKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLmFkZE1hdGNoaW5nS2V5cyh0eG4sIGNoYW5nZS5hZGRlZERvY3VtZW50cywgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdUYXJnZXREYXRhID0gb2xkVGFyZ2V0RGF0YS53aXRoU2VxdWVuY2VOdW1iZXIodHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgICAgIGlmIChyZW1vdGVFdmVudC50YXJnZXRNaXNtYXRjaGVzLmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1RhcmdldERhdGEgPSBuZXdUYXJnZXREYXRhXHJcbiAgICAgICAgICAgICAgICAgICAgLndpdGhSZXN1bWVUb2tlbihCeXRlU3RyaW5nLkVNUFRZX0JZVEVfU1RSSU5HLCBTbmFwc2hvdFZlcnNpb24ubWluKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgLndpdGhMYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uKFNuYXBzaG90VmVyc2lvbi5taW4oKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnJlc3VtZVRva2VuLmFwcHJveGltYXRlQnl0ZVNpemUoKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIG5ld1RhcmdldERhdGEgPSBuZXdUYXJnZXREYXRhLndpdGhSZXN1bWVUb2tlbihjaGFuZ2UucmVzdW1lVG9rZW4sIHJlbW90ZVZlcnNpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld1RhcmdldERhdGFCeVRhcmdldE1hcCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcC5pbnNlcnQodGFyZ2V0SWQsIG5ld1RhcmdldERhdGEpO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRhcmdldCBkYXRhIGlmIHRoZXJlIGFyZSB0YXJnZXQgY2hhbmdlcyAob3IgaWZcclxuICAgICAgICAgICAgLy8gc3VmZmljaWVudCB0aW1lIGhhcyBwYXNzZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlKS5cclxuICAgICAgICAgICAgaWYgKHNob3VsZFBlcnNpc3RUYXJnZXREYXRhKG9sZFRhcmdldERhdGEsIG5ld1RhcmdldERhdGEsIGNoYW5nZSkpIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUudXBkYXRlVGFyZ2V0RGF0YSh0eG4sIG5ld1RhcmdldERhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBjaGFuZ2VkRG9jcyA9IG11dGFibGVEb2N1bWVudE1hcCgpO1xyXG4gICAgICAgIHJlbW90ZUV2ZW50LmRvY3VtZW50VXBkYXRlcy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZW1vdGVFdmVudC5yZXNvbHZlZExpbWJvRG9jdW1lbnRzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLnVwZGF0ZUxpbWJvRG9jdW1lbnQodHhuLCBrZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEVhY2ggbG9vcCBpdGVyYXRpb24gb25seSBhZmZlY3RzIGl0cyBcIm93blwiIGRvYywgc28gaXQncyBzYWZlIHRvIGdldCBhbGwgdGhlIHJlbW90ZVxyXG4gICAgICAgIC8vIGRvY3VtZW50cyBpbiBhZHZhbmNlIGluIGEgc2luZ2xlIGNhbGwuXHJcbiAgICAgICAgcHJvbWlzZXMucHVzaChwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIHJlbW90ZUV2ZW50LmRvY3VtZW50VXBkYXRlcykubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICBjaGFuZ2VkRG9jcyA9IHJlc3VsdDtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgLy8gSEFDSzogVGhlIG9ubHkgcmVhc29uIHdlIGFsbG93IGEgbnVsbCBzbmFwc2hvdCB2ZXJzaW9uIGlzIHNvIHRoYXQgd2VcclxuICAgICAgICAvLyBjYW4gc3ludGhlc2l6ZSByZW1vdGUgZXZlbnRzIHdoZW4gd2UgZ2V0IHBlcm1pc3Npb24gZGVuaWVkIGVycm9ycyB3aGlsZVxyXG4gICAgICAgIC8vIHRyeWluZyB0byByZXNvbHZlIHRoZSBzdGF0ZSBvZiBhIGxvY2FsbHkgY2FjaGVkIGRvY3VtZW50IHRoYXQgaXMgaW5cclxuICAgICAgICAvLyBsaW1iby5cclxuICAgICAgICBpZiAoIXJlbW90ZVZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVJlbW90ZVZlcnNpb24gPSBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxyXG4gICAgICAgICAgICAgICAgLmdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24odHhuKVxyXG4gICAgICAgICAgICAgICAgLm5leHQobGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUuc2V0VGFyZ2V0c01ldGFkYXRhKHR4biwgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlciwgcmVtb3RlVmVyc2lvbik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHVwZGF0ZVJlbW90ZVZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLndhaXRGb3IocHJvbWlzZXMpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGRvY3VtZW50QnVmZmVyLmFwcGx5KHR4bikpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLmxvY2FsRG9jdW1lbnRzLmFwcGx5TG9jYWxWaWV3VG9Eb2N1bWVudHModHhuLCBjaGFuZ2VkRG9jcykpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGNoYW5nZWREb2NzKTtcclxuICAgIH0pXHJcbiAgICAgICAgLnRoZW4oY2hhbmdlZERvY3MgPT4ge1xyXG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9IG5ld1RhcmdldERhdGFCeVRhcmdldE1hcDtcclxuICAgICAgICByZXR1cm4gY2hhbmdlZERvY3M7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUG9wdWxhdGVzIGRvY3VtZW50IGNoYW5nZSBidWZmZXIgd2l0aCBkb2N1bWVudHMgZnJvbSBiYWNrZW5kIG9yIGEgYnVuZGxlLlxyXG4gKiBSZXR1cm5zIHRoZSBkb2N1bWVudCBjaGFuZ2VzIHJlc3VsdGluZyBmcm9tIGFwcGx5aW5nIHRob3NlIGRvY3VtZW50cy5cclxuICpcclxuICogQHBhcmFtIHR4biAtIFRyYW5zYWN0aW9uIHRvIHVzZSB0byByZWFkIGV4aXN0aW5nIGRvY3VtZW50cyBmcm9tIHN0b3JhZ2UuXHJcbiAqIEBwYXJhbSBkb2N1bWVudEJ1ZmZlciAtIERvY3VtZW50IGJ1ZmZlciB0byBjb2xsZWN0IHRoZSByZXN1bHRlZCBjaGFuZ2VzIHRvIGJlXHJcbiAqICAgICAgICBhcHBsaWVkIHRvIHN0b3JhZ2UuXHJcbiAqIEBwYXJhbSBkb2N1bWVudHMgLSBEb2N1bWVudHMgdG8gYmUgYXBwbGllZC5cclxuICogQHBhcmFtIGdsb2JhbFZlcnNpb24gLSBBIGBTbmFwc2hvdFZlcnNpb25gIHJlcHJlc2VudGluZyB0aGUgcmVhZCB0aW1lIGlmIGFsbFxyXG4gKiAgICAgICAgZG9jdW1lbnRzIGhhdmUgdGhlIHNhbWUgcmVhZCB0aW1lLlxyXG4gKiBAcGFyYW0gZG9jdW1lbnRWZXJzaW9ucyAtIEEgRG9jdW1lbnRLZXktdG8tU25hcHNob3RWZXJzaW9uIG1hcCBpZiBkb2N1bWVudHNcclxuICogICAgICAgIGhhdmUgdGhlaXIgb3duIHJlYWQgdGltZS5cclxuICpcclxuICogTm90ZTogdGhpcyBmdW5jdGlvbiB3aWxsIHVzZSBgZG9jdW1lbnRWZXJzaW9uc2AgaWYgaXQgaXMgZGVmaW5lZDtcclxuICogd2hlbiBpdCBpcyBub3QgZGVmaW5lZCwgcmVzb3J0cyB0byBgZ2xvYmFsVmVyc2lvbmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBwb3B1bGF0ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHR4biwgZG9jdW1lbnRCdWZmZXIsIGRvY3VtZW50cykge1xyXG4gICAgbGV0IHVwZGF0ZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgIGRvY3VtZW50cy5mb3JFYWNoKGsgPT4gKHVwZGF0ZWRLZXlzID0gdXBkYXRlZEtleXMuYWRkKGspKSk7XHJcbiAgICByZXR1cm4gZG9jdW1lbnRCdWZmZXIuZ2V0RW50cmllcyh0eG4sIHVwZGF0ZWRLZXlzKS5uZXh0KGV4aXN0aW5nRG9jcyA9PiB7XHJcbiAgICAgICAgbGV0IGNoYW5nZWREb2NzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgZG9jdW1lbnRzLmZvckVhY2goKGtleSwgZG9jKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRG9jID0gZXhpc3RpbmdEb2NzLmdldChrZXkpO1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGUgb3JkZXIgb2YgdGhlIHN0ZXBzIGJlbG93IGlzIGltcG9ydGFudCwgc2luY2Ugd2Ugd2FudFxyXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgdGhhdCByZWplY3RlZCBsaW1ibyByZXNvbHV0aW9ucyAod2hpY2ggZmFicmljYXRlXHJcbiAgICAgICAgICAgIC8vIE5vRG9jdW1lbnRzIHdpdGggU25hcHNob3RWZXJzaW9uLm1pbigpKSBuZXZlciBhZGQgZG9jdW1lbnRzIHRvXHJcbiAgICAgICAgICAgIC8vIGNhY2hlLlxyXG4gICAgICAgICAgICBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpICYmIGRvYy52ZXJzaW9uLmlzRXF1YWwoU25hcHNob3RWZXJzaW9uLm1pbigpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9Eb2N1bWVudHMgd2l0aCBTbmFwc2hvdFZlcnNpb24ubWluKCkgYXJlIHVzZWQgaW4gbWFudWZhY3R1cmVkXHJcbiAgICAgICAgICAgICAgICAvLyBldmVudHMuIFdlIHJlbW92ZSB0aGVzZSBkb2N1bWVudHMgZnJvbSBjYWNoZSBzaW5jZSB3ZSBsb3N0XHJcbiAgICAgICAgICAgICAgICAvLyBhY2Nlc3MuXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudEJ1ZmZlci5yZW1vdmVFbnRyeShrZXksIGRvYy5yZWFkVGltZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRG9jcyA9IGNoYW5nZWREb2NzLmluc2VydChrZXksIGRvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nRG9jLmlzVmFsaWREb2N1bWVudCgpIHx8XHJcbiAgICAgICAgICAgICAgICBkb2MudmVyc2lvbi5jb21wYXJlVG8oZXhpc3RpbmdEb2MudmVyc2lvbikgPiAwIHx8XHJcbiAgICAgICAgICAgICAgICAoZG9jLnZlcnNpb24uY29tcGFyZVRvKGV4aXN0aW5nRG9jLnZlcnNpb24pID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdEb2MuaGFzUGVuZGluZ1dyaXRlcykpIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFkZEVudHJ5KGRvYyk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRG9jcyA9IGNoYW5nZWREb2NzLmluc2VydChrZXksIGRvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGMsICdJZ25vcmluZyBvdXRkYXRlZCB3YXRjaCB1cGRhdGUgZm9yICcsIGtleSwgJy4gQ3VycmVudCB2ZXJzaW9uOicsIGV4aXN0aW5nRG9jLnZlcnNpb24sICcgV2F0Y2ggdmVyc2lvbjonLCBkb2MudmVyc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2hhbmdlZERvY3M7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBuZXdUYXJnZXREYXRhIHNob3VsZCBiZSBwZXJzaXN0ZWQgZHVyaW5nIGFuIHVwZGF0ZSBvZlxyXG4gKiBhbiBhY3RpdmUgdGFyZ2V0LiBUYXJnZXREYXRhIHNob3VsZCBhbHdheXMgYmUgcGVyc2lzdGVkIHdoZW4gYSB0YXJnZXQgaXNcclxuICogYmVpbmcgcmVsZWFzZWQgYW5kIHNob3VsZCBub3QgY2FsbCB0aGlzIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBXaGlsZSB0aGUgdGFyZ2V0IGlzIGFjdGl2ZSwgVGFyZ2V0RGF0YSB1cGRhdGVzIGNhbiBiZSBvbWl0dGVkIHdoZW4gbm90aGluZ1xyXG4gKiBhYm91dCB0aGUgdGFyZ2V0IGhhcyBjaGFuZ2VkIGV4Y2VwdCBtZXRhZGF0YSBsaWtlIHRoZSByZXN1bWUgdG9rZW4gb3JcclxuICogc25hcHNob3QgdmVyc2lvbi4gT2NjYXNpb25hbGx5IGl0J3Mgd29ydGggdGhlIGV4dHJhIHdyaXRlIHRvIHByZXZlbnQgdGhlc2VcclxuICogdmFsdWVzIGZyb20gZ2V0dGluZyB0b28gc3RhbGUgYWZ0ZXIgYSBjcmFzaCwgYnV0IHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlXHJcbiAqIHRvbyBmcmVxdWVudC5cclxuICovXHJcbmZ1bmN0aW9uIHNob3VsZFBlcnNpc3RUYXJnZXREYXRhKG9sZFRhcmdldERhdGEsIG5ld1RhcmdldERhdGEsIGNoYW5nZSkge1xyXG4gICAgLy8gQWx3YXlzIHBlcnNpc3QgdGFyZ2V0IGRhdGEgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgcmVzdW1lIHRva2VuLlxyXG4gICAgaWYgKG9sZFRhcmdldERhdGEucmVzdW1lVG9rZW4uYXBwcm94aW1hdGVCeXRlU2l6ZSgpID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBEb24ndCBhbGxvdyByZXN1bWUgdG9rZW4gY2hhbmdlcyB0byBiZSBidWZmZXJlZCBpbmRlZmluaXRlbHkuIFRoaXNcclxuICAgIC8vIGFsbG93cyB1cyB0byBiZSByZWFzb25hYmx5IHVwLXRvLWRhdGUgYWZ0ZXIgYSBjcmFzaCBhbmQgYXZvaWRzIG5lZWRpbmdcclxuICAgIC8vIHRvIGxvb3Agb3ZlciBhbGwgYWN0aXZlIHF1ZXJpZXMgb24gc2h1dGRvd24uIEVzcGVjaWFsbHkgaW4gdGhlIGJyb3dzZXJcclxuICAgIC8vIHdlIG1heSBub3QgZ2V0IHRpbWUgdG8gZG8gYW55dGhpbmcgaW50ZXJlc3Rpbmcgd2hpbGUgdGhlIGN1cnJlbnQgdGFiIGlzXHJcbiAgICAvLyBjbG9zaW5nLlxyXG4gICAgY29uc3QgdGltZURlbHRhID0gbmV3VGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9NaWNyb3NlY29uZHMoKSAtXHJcbiAgICAgICAgb2xkVGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24udG9NaWNyb3NlY29uZHMoKTtcclxuICAgIGlmICh0aW1lRGVsdGEgPj0gUkVTVU1FX1RPS0VOX01BWF9BR0VfTUlDUk9TKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBPdGhlcndpc2UgaWYgdGhlIG9ubHkgdGhpbmcgdGhhdCBoYXMgY2hhbmdlZCBhYm91dCBhIHRhcmdldCBpcyBpdHMgcmVzdW1lXHJcbiAgICAvLyB0b2tlbiBpdCdzIG5vdCB3b3J0aCBwZXJzaXN0aW5nLiBOb3RlIHRoYXQgdGhlIFJlbW90ZVN0b3JlIGtlZXBzIGFuXHJcbiAgICAvLyBpbi1tZW1vcnkgdmlldyBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YXJnZXRzIHdoaWNoIGluY2x1ZGVzIHRoZSBjdXJyZW50XHJcbiAgICAvLyByZXN1bWUgdG9rZW4sIHNvIHN0cmVhbSBmYWlsdXJlIG9yIHVzZXIgY2hhbmdlcyB3aWxsIHN0aWxsIHVzZSBhblxyXG4gICAgLy8gdXAtdG8tZGF0ZSByZXN1bWUgdG9rZW4gcmVnYXJkbGVzcyBvZiB3aGF0IHdlIGRvIGhlcmUuXHJcbiAgICBjb25zdCBjaGFuZ2VzID0gY2hhbmdlLmFkZGVkRG9jdW1lbnRzLnNpemUgK1xyXG4gICAgICAgIGNoYW5nZS5tb2RpZmllZERvY3VtZW50cy5zaXplICtcclxuICAgICAgICBjaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5zaXplO1xyXG4gICAgcmV0dXJuIGNoYW5nZXMgPiAwO1xyXG59XHJcbi8qKlxyXG4gKiBOb3RpZmllcyBsb2NhbCBzdG9yZSBvZiB0aGUgY2hhbmdlZCB2aWV3cyB0byBsb2NhbGx5IHBpbiBkb2N1bWVudHMuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlTm90aWZ5TG9jYWxWaWV3Q2hhbmdlcyhsb2NhbFN0b3JlLCB2aWV3Q2hhbmdlcykge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdub3RpZnlMb2NhbFZpZXdDaGFuZ2VzJywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh2aWV3Q2hhbmdlcywgKHZpZXdDaGFuZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh2aWV3Q2hhbmdlLmFkZGVkS2V5cywgKGtleSkgPT4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUuYWRkUmVmZXJlbmNlKHR4biwgdmlld0NoYW5nZS50YXJnZXRJZCwga2V5KSkubmV4dCgoKSA9PiBQZXJzaXN0ZW5jZVByb21pc2UuZm9yRWFjaCh2aWV3Q2hhbmdlLnJlbW92ZWRLZXlzLCAoa2V5KSA9PiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5yZWZlcmVuY2VEZWxlZ2F0ZS5yZW1vdmVSZWZlcmVuY2UodHhuLCB2aWV3Q2hhbmdlLnRhcmdldElkLCBrZXkpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoaXNJbmRleGVkRGJUcmFuc2FjdGlvbkVycm9yKGUpKSB7XHJcbiAgICAgICAgICAgIC8vIElmIGBub3RpZnlMb2NhbFZpZXdDaGFuZ2VzYCBmYWlscywgd2UgZGlkIG5vdCBhZHZhbmNlIHRoZSBzZXF1ZW5jZVxyXG4gICAgICAgICAgICAvLyBudW1iZXIgZm9yIHRoZSBkb2N1bWVudHMgdGhhdCB3ZXJlIGluY2x1ZGVkIGluIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgICAgIC8vIFRoaXMgbWlnaHQgdHJpZ2dlciB0aGVtIHRvIGJlIGRlbGV0ZWQgZWFybGllciB0aGFuIHRoZXkgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgIC8vIHdvdWxkIGhhdmUsIGJ1dCBpdCBzaG91bGQgbm90IGludmFsaWRhdGUgdGhlIGludGVncml0eSBvZiB0aGUgZGF0YS5cclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRjLCAnRmFpbGVkIHRvIHVwZGF0ZSBzZXF1ZW5jZSBudW1iZXJzOiAnICsgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qgdmlld0NoYW5nZSBvZiB2aWV3Q2hhbmdlcykge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gdmlld0NoYW5nZS50YXJnZXRJZDtcclxuICAgICAgICBpZiAoIXZpZXdDaGFuZ2UuZnJvbUNhY2hlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcclxuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgbGFzdCBsaW1ibyBmcmVlIHNuYXBzaG90IHZlcnNpb25cclxuICAgICAgICAgICAgY29uc3QgbGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiA9IHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uO1xyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkVGFyZ2V0RGF0YSA9IHRhcmdldERhdGEud2l0aExhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24obGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbik7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuaW5zZXJ0KHRhcmdldElkLCB1cGRhdGVkVGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBtdXRhdGlvbiBiYXRjaCBhZnRlciB0aGUgcGFzc2VkIGluIGJhdGNoSWQgaW4gdGhlIG11dGF0aW9uIHF1ZXVlXHJcbiAqIG9yIG51bGwgaWYgZW1wdHkuXHJcbiAqIEBwYXJhbSBhZnRlckJhdGNoSWQgLSBJZiBwcm92aWRlZCwgdGhlIGJhdGNoIHRvIHNlYXJjaCBhZnRlci5cclxuICogQHJldHVybnMgVGhlIG5leHQgbXV0YXRpb24gb3IgbnVsbCBpZiB0aGVyZSB3YXNuJ3Qgb25lLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldE5leHRNdXRhdGlvbkJhdGNoKGxvY2FsU3RvcmUsIGFmdGVyQmF0Y2hJZCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBuZXh0IG11dGF0aW9uIGJhdGNoJywgJ3JlYWRvbmx5JywgdHhuID0+IHtcclxuICAgICAgICBpZiAoYWZ0ZXJCYXRjaElkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYWZ0ZXJCYXRjaElkID0gQkFUQ0hJRF9VTktOT1dOO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubXV0YXRpb25RdWV1ZS5nZXROZXh0TXV0YXRpb25CYXRjaEFmdGVyQmF0Y2hJZCh0eG4sIGFmdGVyQmF0Y2hJZCk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmVhZHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBEb2N1bWVudCB3aXRoIGEgZ2l2ZW4ga2V5IG9yIG51bGwgaWYgbm90XHJcbiAqIGZvdW5kIC0gdXNlZCBmb3IgdGVzdGluZy5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVSZWFkRG9jdW1lbnQobG9jYWxTdG9yZSwga2V5KSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbigncmVhZCBkb2N1bWVudCcsICdyZWFkb25seScsIHR4biA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5nZXREb2N1bWVudCh0eG4sIGtleSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBc3NpZ25zIHRoZSBnaXZlbiB0YXJnZXQgYW4gaW50ZXJuYWwgSUQgc28gdGhhdCBpdHMgcmVzdWx0cyBjYW4gYmUgcGlubmVkIHNvXHJcbiAqIHRoZXkgZG9uJ3QgZ2V0IEdDJ2QuIEEgdGFyZ2V0IG11c3QgYmUgYWxsb2NhdGVkIGluIHRoZSBsb2NhbCBzdG9yZSBiZWZvcmVcclxuICogdGhlIHN0b3JlIGNhbiBiZSB1c2VkIHRvIG1hbmFnZSBpdHMgdmlldy5cclxuICpcclxuICogQWxsb2NhdGluZyBhbiBhbHJlYWR5IGFsbG9jYXRlZCBgVGFyZ2V0YCB3aWxsIHJldHVybiB0aGUgZXhpc3RpbmcgYFRhcmdldERhdGFgXHJcbiAqIGZvciB0aGF0IGBUYXJnZXRgLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KGxvY2FsU3RvcmUsIHRhcmdldCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2VcclxuICAgICAgICAucnVuVHJhbnNhY3Rpb24oJ0FsbG9jYXRlIHRhcmdldCcsICdyZWFkd3JpdGUnLCB0eG4gPT4ge1xyXG4gICAgICAgIGxldCB0YXJnZXREYXRhO1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxyXG4gICAgICAgICAgICAuZ2V0VGFyZ2V0RGF0YSh0eG4sIHRhcmdldClcclxuICAgICAgICAgICAgLm5leHQoKGNhY2hlZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHRhcmdldCBoYXMgYmVlbiBsaXN0ZW5lZCB0byBwcmV2aW91c2x5LCBzbyByZXVzZSB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHRhcmdldElELlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyhtY2cpOiBmcmVzaGVuIGxhc3QgYWNjZXNzZWQgZGF0ZT9cclxuICAgICAgICAgICAgICAgIHRhcmdldERhdGEgPSBjYWNoZWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAuYWxsb2NhdGVUYXJnZXRJZCh0eG4pXHJcbiAgICAgICAgICAgICAgICAgICAgLm5leHQodGFyZ2V0SWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldERhdGEgPSBuZXcgVGFyZ2V0RGF0YSh0YXJnZXQsIHRhcmdldElkLCAwIC8qIExpc3RlbiAqLywgdHhuLmN1cnJlbnRTZXF1ZW5jZU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRUYXJnZXREYXRhKHR4biwgdGFyZ2V0RGF0YSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gdGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSlcclxuICAgICAgICAudGhlbih0YXJnZXREYXRhID0+IHtcclxuICAgICAgICAvLyBJZiBNdWx0aS1UYWIgaXMgZW5hYmxlZCwgdGhlIGV4aXN0aW5nIHRhcmdldCBkYXRhIG1heSBiZSBuZXdlciB0aGFuXHJcbiAgICAgICAgLy8gdGhlIGluLW1lbW9yeSBkYXRhXHJcbiAgICAgICAgY29uc3QgY2FjaGVkVGFyZ2V0RGF0YSA9IGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0RGF0YS50YXJnZXRJZCk7XHJcbiAgICAgICAgaWYgKGNhY2hlZFRhcmdldERhdGEgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgdGFyZ2V0RGF0YS5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKGNhY2hlZFRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uKSA+XHJcbiAgICAgICAgICAgICAgICAwKSB7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XHJcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuaW5zZXJ0KHRhcmdldERhdGEudGFyZ2V0SWQsIHRhcmdldERhdGEpO1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXRJZEJ5VGFyZ2V0LnNldCh0YXJnZXQsIHRhcmdldERhdGEudGFyZ2V0SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0RGF0YTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBUYXJnZXREYXRhIGFzIHNlZW4gYnkgdGhlIExvY2FsU3RvcmUsIGluY2x1ZGluZyB1cGRhdGVzIHRoYXQgbWF5XHJcbiAqIGhhdmUgbm90IHlldCBiZWVuIHBlcnNpc3RlZCB0byB0aGUgVGFyZ2V0Q2FjaGUuXHJcbiAqL1xyXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nLlxyXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0VGFyZ2V0RGF0YShsb2NhbFN0b3JlLCB0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IHRhcmdldElkID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0SWRCeVRhcmdldC5nZXQodGFyZ2V0KTtcclxuICAgIGlmICh0YXJnZXRJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldC5nZXQodGFyZ2V0SWQpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5nZXRUYXJnZXREYXRhKHRyYW5zYWN0aW9uLCB0YXJnZXQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVbnBpbnMgYWxsIHRoZSBkb2N1bWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiB0YXJnZXQuIElmXHJcbiAqIGBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YWAgaXMgc2V0IHRvIGZhbHNlIGFuZCBFYWdlciBHQyBlbmFibGVkLCB0aGUgbWV0aG9kXHJcbiAqIGRpcmVjdGx5IHJlbW92ZXMgdGhlIGFzc29jaWF0ZWQgdGFyZ2V0IGRhdGEgZnJvbSB0aGUgdGFyZ2V0IGNhY2hlLlxyXG4gKlxyXG4gKiBSZWxlYXNpbmcgYSBub24tZXhpc3RpbmcgYFRhcmdldGAgaXMgYSBuby1vcC5cclxuICovXHJcbi8vIFBPUlRJTkcgTk9URTogYGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhYCBpcyBtdWx0aS10YWIgb25seS5cclxuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQobG9jYWxTdG9yZSwgdGFyZ2V0SWQsIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IHRhcmdldERhdGEgPSBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcclxuICAgIGNvbnN0IG1vZGUgPSBrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSA/ICdyZWFkd3JpdGUnIDogJ3JlYWR3cml0ZS1wcmltYXJ5JztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCFrZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YSkge1xyXG4gICAgICAgICAgICBhd2FpdCBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignUmVsZWFzZSB0YXJnZXQnLCBtb2RlLCB0eG4gPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlLnJlbW92ZVRhcmdldCh0eG4sIHRhcmdldERhdGEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChpc0luZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IoZSkpIHtcclxuICAgICAgICAgICAgLy8gQWxsIGByZWxlYXNlVGFyZ2V0YCBkb2VzIGlzIHJlY29yZCB0aGUgZmluYWwgbWV0YWRhdGEgc3RhdGUgZm9yIHRoZVxyXG4gICAgICAgICAgICAvLyB0YXJnZXQsIGJ1dCB3ZSd2ZSBiZWVuIHJlY29yZGluZyB0aGlzIHBlcmlvZGljYWxseSBkdXJpbmcgdGFyZ2V0XHJcbiAgICAgICAgICAgIC8vIGFjdGl2aXR5LiBJZiB3ZSBsb3NlIHRoaXMgd3JpdGUgdGhpcyBjb3VsZCBjYXVzZSBhIHZlcnkgc2xpZ2h0XHJcbiAgICAgICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gdGhlIG9yZGVyIG9mIHRhcmdldCBkZWxldGlvbiBkdXJpbmcgR0MsIGJ1dCB3ZVxyXG4gICAgICAgICAgICAvLyBkb24ndCBkZWZpbmUgZXhhY3QgTFJVIHNlbWFudGljcyBzbyB0aGlzIGlzIGFjY2VwdGFibGUuXHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckYywgYEZhaWxlZCB0byB1cGRhdGUgc2VxdWVuY2UgbnVtYmVycyBmb3IgdGFyZ2V0ICR7dGFyZ2V0SWR9OiAke2V9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxvY2FsU3RvcmVJbXBsLnRhcmdldERhdGFCeVRhcmdldCA9XHJcbiAgICAgICAgbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LnJlbW92ZSh0YXJnZXRJZCk7XHJcbiAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXRJZEJ5VGFyZ2V0LmRlbGV0ZSh0YXJnZXREYXRhLnRhcmdldCk7XHJcbn1cclxuLyoqXHJcbiAqIFJ1bnMgdGhlIHNwZWNpZmllZCBxdWVyeSBhZ2FpbnN0IHRoZSBsb2NhbCBzdG9yZSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyxcclxuICogcG90ZW50aWFsbHkgdGFraW5nIGFkdmFudGFnZSBvZiBxdWVyeSBkYXRhIGZyb20gcHJldmlvdXMgZXhlY3V0aW9ucyAoc3VjaFxyXG4gKiBhcyB0aGUgc2V0IG9mIHJlbW90ZSBrZXlzKS5cclxuICpcclxuICogQHBhcmFtIHVzZVByZXZpb3VzUmVzdWx0cyAtIFdoZXRoZXIgcmVzdWx0cyBmcm9tIHByZXZpb3VzIGV4ZWN1dGlvbnMgY2FuXHJcbiAqIGJlIHVzZWQgdG8gb3B0aW1pemUgdGhpcyBxdWVyeSBleGVjdXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KGxvY2FsU3RvcmUsIHF1ZXJ5LCB1c2VQcmV2aW91c1Jlc3VsdHMpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgbGV0IGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCk7XHJcbiAgICBsZXQgcmVtb3RlS2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0V4ZWN1dGUgcXVlcnknLCAncmVhZG9ubHknLCB0eG4gPT4ge1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlR2V0VGFyZ2V0RGF0YShsb2NhbFN0b3JlSW1wbCwgdHhuLCBxdWVyeVRvVGFyZ2V0KHF1ZXJ5KSlcclxuICAgICAgICAgICAgLm5leHQodGFyZ2V0RGF0YSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uID1cclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXREYXRhLmxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0TWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB0YXJnZXREYXRhLnRhcmdldElkKVxyXG4gICAgICAgICAgICAgICAgICAgIC5uZXh0KHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlS2V5cyA9IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwucXVlcnlFbmdpbmUuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0eG4sIHF1ZXJ5LCB1c2VQcmV2aW91c1Jlc3VsdHNcclxuICAgICAgICAgICAgPyBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uXHJcbiAgICAgICAgICAgIDogU25hcHNob3RWZXJzaW9uLm1pbigpLCB1c2VQcmV2aW91c1Jlc3VsdHMgPyByZW1vdGVLZXlzIDogZG9jdW1lbnRLZXlTZXQoKSkpXHJcbiAgICAgICAgICAgIC5uZXh0KGRvY3VtZW50cyA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGRvY3VtZW50cywgcmVtb3RlS2V5cyB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlXcml0ZVRvUmVtb3RlRG9jdW1lbnRzKGxvY2FsU3RvcmVJbXBsLCB0eG4sIGJhdGNoUmVzdWx0LCBkb2N1bWVudEJ1ZmZlcikge1xyXG4gICAgY29uc3QgYmF0Y2ggPSBiYXRjaFJlc3VsdC5iYXRjaDtcclxuICAgIGNvbnN0IGRvY0tleXMgPSBiYXRjaC5rZXlzKCk7XHJcbiAgICBsZXQgcHJvbWlzZUNoYWluID0gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIGRvY0tleXMuZm9yRWFjaChkb2NLZXkgPT4ge1xyXG4gICAgICAgIHByb21pc2VDaGFpbiA9IHByb21pc2VDaGFpblxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBkb2N1bWVudEJ1ZmZlci5nZXRFbnRyeSh0eG4sIGRvY0tleSkpXHJcbiAgICAgICAgICAgIC5uZXh0KGRvYyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFja1ZlcnNpb24gPSBiYXRjaFJlc3VsdC5kb2NWZXJzaW9ucy5nZXQoZG9jS2V5KTtcclxuICAgICAgICAgICAgaGFyZEFzc2VydChhY2tWZXJzaW9uICE9PSBudWxsKTtcclxuICAgICAgICAgICAgaWYgKGRvYy52ZXJzaW9uLmNvbXBhcmVUbyhhY2tWZXJzaW9uKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoLmFwcGx5VG9SZW1vdGVEb2N1bWVudChkb2MsIGJhdGNoUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIGlmIChkb2MuaXNWYWxpZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhlIGNvbW1pdFZlcnNpb24gYXMgdGhlIHJlYWRUaW1lIHJhdGhlciB0aGFuIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50J3MgdXBkYXRlVGltZSBzaW5jZSB0aGUgdXBkYXRlVGltZSBpcyBub3QgYWR2YW5jZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdXBkYXRlcyB0aGF0IGRvIG5vdCBtb2RpZnkgdGhlIHVuZGVybHlpbmcgZG9jdW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgZG9jLnNldFJlYWRUaW1lKGJhdGNoUmVzdWx0LmNvbW1pdFZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50QnVmZmVyLmFkZEVudHJ5KGRvYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHByb21pc2VDaGFpbi5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLm11dGF0aW9uUXVldWUucmVtb3ZlTXV0YXRpb25CYXRjaCh0eG4sIGJhdGNoKSk7XHJcbn1cclxuLyoqIFJldHVybnMgdGhlIGxvY2FsIHZpZXcgb2YgdGhlIGRvY3VtZW50cyBhZmZlY3RlZCBieSBhIG11dGF0aW9uIGJhdGNoLiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5mdW5jdGlvbiBsb2NhbFN0b3JlTG9va3VwTXV0YXRpb25Eb2N1bWVudHMobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCBtdXRhdGlvblF1ZXVlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlSW1wbC5tdXRhdGlvblF1ZXVlKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZS5ydW5UcmFuc2FjdGlvbignTG9va3VwIG11dGF0aW9uIGRvY3VtZW50cycsICdyZWFkb25seScsIHR4biA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uUXVldWVJbXBsLmxvb2t1cE11dGF0aW9uS2V5cyh0eG4sIGJhdGNoSWQpLm5leHQoa2V5cyA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXlzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwubG9jYWxEb2N1bWVudHMuZ2V0RG9jdW1lbnRzKHR4biwga2V5cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVSZW1vdmVDYWNoZWRNdXRhdGlvbkJhdGNoTWV0YWRhdGEobG9jYWxTdG9yZSwgYmF0Y2hJZCkge1xyXG4gICAgY29uc3QgbXV0YXRpb25RdWV1ZUltcGwgPSBkZWJ1Z0Nhc3QoZGVidWdDYXN0KGxvY2FsU3RvcmUsIExvY2FsU3RvcmVJbXBsKS5tdXRhdGlvblF1ZXVlKTtcclxuICAgIG11dGF0aW9uUXVldWVJbXBsLnJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cyhiYXRjaElkKTtcclxufVxyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0QWN0aXZlQ2xpZW50cyhsb2NhbFN0b3JlKSB7XHJcbiAgICBjb25zdCBwZXJzaXN0ZW5jZUltcGwgPSBkZWJ1Z0Nhc3QoZGVidWdDYXN0KGxvY2FsU3RvcmUsIExvY2FsU3RvcmVJbXBsKS5wZXJzaXN0ZW5jZSk7XHJcbiAgICByZXR1cm4gcGVyc2lzdGVuY2VJbXBsLmdldEFjdGl2ZUNsaWVudHMoKTtcclxufVxyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5mdW5jdGlvbiBsb2NhbFN0b3JlR2V0Q2FjaGVkVGFyZ2V0KGxvY2FsU3RvcmUsIHRhcmdldElkKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIGNvbnN0IHRhcmdldENhY2hlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZSk7XHJcbiAgICBjb25zdCBjYWNoZWRUYXJnZXREYXRhID0gbG9jYWxTdG9yZUltcGwudGFyZ2V0RGF0YUJ5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICBpZiAoY2FjaGVkVGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FjaGVkVGFyZ2V0RGF0YS50YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdHZXQgdGFyZ2V0IGRhdGEnLCAncmVhZG9ubHknLCB0eG4gPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Q2FjaGVJbXBsXHJcbiAgICAgICAgICAgICAgICAuZ2V0VGFyZ2V0RGF0YUZvclRhcmdldCh0eG4sIHRhcmdldElkKVxyXG4gICAgICAgICAgICAgICAgLm5leHQodGFyZ2V0RGF0YSA9PiAodGFyZ2V0RGF0YSA/IHRhcmdldERhdGEudGFyZ2V0IDogbnVsbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHVwZGF0ZWQgc2luY2UgdGhlIGxhc3QgY2FsbC5cclxuICogSWYgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgcmV0dXJucyB0aGUgc2V0IG9mIGNoYW5nZXMgc2luY2UgY2xpZW50XHJcbiAqIGluaXRpYWxpemF0aW9uLiBGdXJ0aGVyIGludm9jYXRpb25zIHdpbGwgcmV0dXJuIGRvY3VtZW50IHRoYXQgaGF2ZSBjaGFuZ2VkXHJcbiAqIHNpbmNlIHRoZSBwcmlvciBjYWxsLlxyXG4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gbG9jYWxTdG9yZUdldE5ld0RvY3VtZW50Q2hhbmdlcyhsb2NhbFN0b3JlKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZVxyXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignR2V0IG5ldyBkb2N1bWVudCBjaGFuZ2VzJywgJ3JlYWRvbmx5JywgdHhuID0+IHJlbW90ZURvY3VtZW50Q2FjaGVHZXROZXdEb2N1bWVudENoYW5nZXMobG9jYWxTdG9yZUltcGwucmVtb3RlRG9jdW1lbnRzLCB0eG4sIGxvY2FsU3RvcmVJbXBsLmxhc3REb2N1bWVudENoYW5nZVJlYWRUaW1lKSlcclxuICAgICAgICAudGhlbigoeyBjaGFuZ2VkRG9jcywgcmVhZFRpbWUgfSkgPT4ge1xyXG4gICAgICAgIGxvY2FsU3RvcmVJbXBsLmxhc3REb2N1bWVudENoYW5nZVJlYWRUaW1lID0gcmVhZFRpbWU7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZWREb2NzO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlYWRzIHRoZSBuZXdlc3QgZG9jdW1lbnQgY2hhbmdlIGZyb20gcGVyc2lzdGVuY2UgYW5kIG1vdmVzIHRoZSBpbnRlcm5hbFxyXG4gKiBzeW5jaHJvbml6YXRpb24gbWFya2VyIGZvcndhcmQgc28gdGhhdCBjYWxscyB0byBgZ2V0TmV3RG9jdW1lbnRDaGFuZ2VzKClgXHJcbiAqIG9ubHkgcmV0dXJuIGNoYW5nZXMgdGhhdCBoYXBwZW5lZCBhZnRlciBjbGllbnQgaW5pdGlhbGl6YXRpb24uXHJcbiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5hc3luYyBmdW5jdGlvbiBsb2NhbFN0b3JlU3luY2hyb25pemVMYXN0RG9jdW1lbnRDaGFuZ2VSZWFkVGltZShsb2NhbFN0b3JlKSB7XHJcbiAgICBjb25zdCBsb2NhbFN0b3JlSW1wbCA9IGRlYnVnQ2FzdChsb2NhbFN0b3JlKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZVxyXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignU3luY2hyb25pemUgbGFzdCBkb2N1bWVudCBjaGFuZ2UgcmVhZCB0aW1lJywgJ3JlYWRvbmx5JywgdHhuID0+IHJlbW90ZURvY3VtZW50Q2FjaGVHZXRMYXN0UmVhZFRpbWUodHhuKSlcclxuICAgICAgICAudGhlbihyZWFkVGltZSA9PiB7XHJcbiAgICAgICAgbG9jYWxTdG9yZUltcGwubGFzdERvY3VtZW50Q2hhbmdlUmVhZFRpbWUgPSByZWFkVGltZTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHRhcmdldCB1c2luZyB0aGUgZ2l2ZW4gYnVuZGxlIG5hbWUsIHdoaWNoIHdpbGwgYmUgdXNlZCB0b1xyXG4gKiBob2xkIHRoZSBrZXlzIG9mIGFsbCBkb2N1bWVudHMgZnJvbSB0aGUgYnVuZGxlIGluIHF1ZXJ5LWRvY3VtZW50IG1hcHBpbmdzLlxyXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgbG9hZGVkIGRvY3VtZW50cyBkbyBub3QgZ2V0IGdhcmJhZ2UgY29sbGVjdGVkXHJcbiAqIHJpZ2h0IGF3YXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB1bWJyZWxsYVRhcmdldChidW5kbGVOYW1lKSB7XHJcbiAgICAvLyBJdCBpcyBPSyB0aGF0IHRoZSBwYXRoIHVzZWQgZm9yIHRoZSBxdWVyeSBpcyBub3QgdmFsaWQsIGJlY2F1c2UgdGhpcyB3aWxsXHJcbiAgICAvLyBub3QgYmUgcmVhZCBhbmQgcXVlcmllZC5cclxuICAgIHJldHVybiBxdWVyeVRvVGFyZ2V0KG5ld1F1ZXJ5Rm9yUGF0aChSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhgX19idW5kbGVfXy9kb2NzLyR7YnVuZGxlTmFtZX1gKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBkb2N1bWVudHMgZnJvbSBhIGJ1bmRsZSB0byB0aGUgXCJncm91bmQtc3RhdGVcIiAocmVtb3RlKVxyXG4gKiBkb2N1bWVudHMuXHJcbiAqXHJcbiAqIExvY2FsRG9jdW1lbnRzIGFyZSByZS1jYWxjdWxhdGVkIGlmIHRoZXJlIGFyZSByZW1haW5pbmcgbXV0YXRpb25zIGluIHRoZVxyXG4gKiBxdWV1ZS5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGxvY2FsU3RvcmVBcHBseUJ1bmRsZWREb2N1bWVudHMobG9jYWxTdG9yZSwgYnVuZGxlQ29udmVydGVyLCBkb2N1bWVudHMsIGJ1bmRsZU5hbWUpIHtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgbGV0IGRvY3VtZW50S2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICBsZXQgZG9jdW1lbnRNYXAgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgIGZvciAoY29uc3QgYnVuZGxlRG9jIG9mIGRvY3VtZW50cykge1xyXG4gICAgICAgIGNvbnN0IGRvY3VtZW50S2V5ID0gYnVuZGxlQ29udmVydGVyLnRvRG9jdW1lbnRLZXkoYnVuZGxlRG9jLm1ldGFkYXRhLm5hbWUpO1xyXG4gICAgICAgIGlmIChidW5kbGVEb2MuZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnRLZXlzID0gZG9jdW1lbnRLZXlzLmFkZChkb2N1bWVudEtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRvYyA9IGJ1bmRsZUNvbnZlcnRlci50b011dGFibGVEb2N1bWVudChidW5kbGVEb2MpO1xyXG4gICAgICAgIGRvYy5zZXRSZWFkVGltZShidW5kbGVDb252ZXJ0ZXIudG9TbmFwc2hvdFZlcnNpb24oYnVuZGxlRG9jLm1ldGFkYXRhLnJlYWRUaW1lKSk7XHJcbiAgICAgICAgZG9jdW1lbnRNYXAgPSBkb2N1bWVudE1hcC5pbnNlcnQoZG9jdW1lbnRLZXksIGRvYyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkb2N1bWVudEJ1ZmZlciA9IGxvY2FsU3RvcmVJbXBsLnJlbW90ZURvY3VtZW50cy5uZXdDaGFuZ2VCdWZmZXIoe1xyXG4gICAgICAgIHRyYWNrUmVtb3ZhbHM6IHRydWUgLy8gTWFrZSBzdXJlIGRvY3VtZW50IHJlbW92YWxzIHNob3cgdXAgaW4gYGdldE5ld0RvY3VtZW50Q2hhbmdlcygpYFxyXG4gICAgfSk7XHJcbiAgICAvLyBBbGxvY2F0ZXMgYSB0YXJnZXQgdG8gaG9sZCBhbGwgZG9jdW1lbnQga2V5cyBmcm9tIHRoZSBidW5kbGUsIHN1Y2ggdGhhdFxyXG4gICAgLy8gdGhleSB3aWxsIG5vdCBnZXQgZ2FyYmFnZSBjb2xsZWN0ZWQgcmlnaHQgYXdheS5cclxuICAgIGNvbnN0IHVtYnJlbGxhVGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChsb2NhbFN0b3JlSW1wbCwgdW1icmVsbGFUYXJnZXQoYnVuZGxlTmFtZSkpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdBcHBseSBidW5kbGUgZG9jdW1lbnRzJywgJ3JlYWR3cml0ZScsIHR4biA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHBvcHVsYXRlRG9jdW1lbnRDaGFuZ2VCdWZmZXIodHhuLCBkb2N1bWVudEJ1ZmZlciwgZG9jdW1lbnRNYXApXHJcbiAgICAgICAgICAgIC5uZXh0KGNoYW5nZWREb2NzID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnRCdWZmZXIuYXBwbHkodHhuKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWREb2NzO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5uZXh0KGNoYW5nZWREb2NzID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlXHJcbiAgICAgICAgICAgICAgICAucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHhuLCB1bWJyZWxsYVRhcmdldERhdGEudGFyZ2V0SWQpXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZS5hZGRNYXRjaGluZ0tleXModHhuLCBkb2N1bWVudEtleXMsIHVtYnJlbGxhVGFyZ2V0RGF0YS50YXJnZXRJZCkpXHJcbiAgICAgICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5sb2NhbERvY3VtZW50cy5hcHBseUxvY2FsVmlld1RvRG9jdW1lbnRzKHR4biwgY2hhbmdlZERvY3MpKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gY2hhbmdlZERvY3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIG9mIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSBpZiB0aGUgZ2l2ZW4gYnVuZGxlIGhhcyBhbHJlYWR5XHJcbiAqIGJlZW4gbG9hZGVkIGFuZCB0aGUgY3JlYXRlIHRpbWUgaXMgbmV3ZXIgdGhhbiB0aGUgY3VycmVudCBsb2FkaW5nIGJ1bmRsZS5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVIYXNOZXdlckJ1bmRsZShsb2NhbFN0b3JlLCBidW5kbGVNZXRhZGF0YSkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICBjb25zdCBjdXJyZW50UmVhZFRpbWUgPSBmcm9tVmVyc2lvbihidW5kbGVNZXRhZGF0YS5jcmVhdGVUaW1lKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5wZXJzaXN0ZW5jZVxyXG4gICAgICAgIC5ydW5UcmFuc2FjdGlvbignaGFzTmV3ZXJCdW5kbGUnLCAncmVhZG9ubHknLCB0cmFuc2FjdGlvbiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLmdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YS5pZCk7XHJcbiAgICB9KVxyXG4gICAgICAgIC50aGVuKGNhY2hlZCA9PiB7XHJcbiAgICAgICAgcmV0dXJuICEhY2FjaGVkICYmIGNhY2hlZC5jcmVhdGVUaW1lLmNvbXBhcmVUbyhjdXJyZW50UmVhZFRpbWUpID49IDA7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogU2F2ZXMgdGhlIGdpdmVuIGBCdW5kbGVNZXRhZGF0YWAgdG8gbG9jYWwgcGVyc2lzdGVuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFN0b3JlU2F2ZUJ1bmRsZShsb2NhbFN0b3JlLCBidW5kbGVNZXRhZGF0YSkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ1NhdmUgYnVuZGxlJywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IHtcclxuICAgICAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwuYnVuZGxlQ2FjaGUuc2F2ZUJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVNZXRhZGF0YSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHByb21pc2Ugb2YgYSBgTmFtZWRRdWVyeWAgYXNzb2NpYXRlZCB3aXRoIGdpdmVuIHF1ZXJ5IG5hbWUuIFByb21pc2VcclxuICogcmVzb2x2ZXMgdG8gdW5kZWZpbmVkIGlmIG5vIHBlcnNpc3RlZCBkYXRhIGNhbiBiZSBmb3VuZC5cclxuICovXHJcbmZ1bmN0aW9uIGxvY2FsU3RvcmVHZXROYW1lZFF1ZXJ5KGxvY2FsU3RvcmUsIHF1ZXJ5TmFtZSkge1xyXG4gICAgY29uc3QgbG9jYWxTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QobG9jYWxTdG9yZSk7XHJcbiAgICByZXR1cm4gbG9jYWxTdG9yZUltcGwucGVyc2lzdGVuY2UucnVuVHJhbnNhY3Rpb24oJ0dldCBuYW1lZCBxdWVyeScsICdyZWFkb25seScsIHRyYW5zYWN0aW9uID0+IGxvY2FsU3RvcmVJbXBsLmJ1bmRsZUNhY2hlLmdldE5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5TmFtZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBTYXZlcyB0aGUgZ2l2ZW4gYE5hbWVkUXVlcnlgIHRvIGxvY2FsIHBlcnNpc3RlbmNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbG9jYWxTdG9yZVNhdmVOYW1lZFF1ZXJ5KGxvY2FsU3RvcmUsIHF1ZXJ5LCBkb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpKSB7XHJcbiAgICAvLyBBbGxvY2F0ZSBhIHRhcmdldCBmb3IgdGhlIG5hbWVkIHF1ZXJ5IHN1Y2ggdGhhdCBpdCBjYW4gYmUgcmVzdW1lZFxyXG4gICAgLy8gZnJvbSBhc3NvY2lhdGVkIHJlYWQgdGltZSBpZiB1c2VycyB1c2UgaXQgdG8gbGlzdGVuLlxyXG4gICAgLy8gTk9URTogdGhpcyBhbHNvIG1lYW5zIGlmIG5vIGNvcnJlc3BvbmRpbmcgdGFyZ2V0IGV4aXN0cywgdGhlIG5ldyB0YXJnZXRcclxuICAgIC8vIHdpbGwgcmVtYWluIGFjdGl2ZSBhbmQgd2lsbCBub3QgZ2V0IGNvbGxlY3RlZCwgdW5sZXNzIHVzZXJzIGhhcHBlbiB0b1xyXG4gICAgLy8gdW5saXN0ZW4gdGhlIHF1ZXJ5IHNvbWVob3cuXHJcbiAgICBjb25zdCBhbGxvY2F0ZWQgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQobG9jYWxTdG9yZSwgcXVlcnlUb1RhcmdldChmcm9tQnVuZGxlZFF1ZXJ5KHF1ZXJ5LmJ1bmRsZWRRdWVyeSkpKTtcclxuICAgIGNvbnN0IGxvY2FsU3RvcmVJbXBsID0gZGVidWdDYXN0KGxvY2FsU3RvcmUpO1xyXG4gICAgcmV0dXJuIGxvY2FsU3RvcmVJbXBsLnBlcnNpc3RlbmNlLnJ1blRyYW5zYWN0aW9uKCdTYXZlIG5hbWVkIHF1ZXJ5JywgJ3JlYWR3cml0ZScsIHRyYW5zYWN0aW9uID0+IHtcclxuICAgICAgICBjb25zdCByZWFkVGltZSA9IGZyb21WZXJzaW9uKHF1ZXJ5LnJlYWRUaW1lKTtcclxuICAgICAgICAvLyBTaW1wbHkgc2F2ZSB0aGUgcXVlcnkgaXRzZWxmIGlmIGl0IGlzIG9sZGVyIHRoYW4gd2hhdCB0aGUgU0RLIGFscmVhZHlcclxuICAgICAgICAvLyBoYXMuXHJcbiAgICAgICAgaWYgKGFsbG9jYXRlZC5zbmFwc2hvdFZlcnNpb24uY29tcGFyZVRvKHJlYWRUaW1lKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5zYXZlTmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgdGFyZ2V0IGRhdGEgYmVjYXVzZSB0aGUgcXVlcnkgZnJvbSB0aGUgYnVuZGxlIGlzIG5ld2VyLlxyXG4gICAgICAgIGNvbnN0IG5ld1RhcmdldERhdGEgPSBhbGxvY2F0ZWQud2l0aFJlc3VtZVRva2VuKEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIHJlYWRUaW1lKTtcclxuICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQgPVxyXG4gICAgICAgICAgICBsb2NhbFN0b3JlSW1wbC50YXJnZXREYXRhQnlUYXJnZXQuaW5zZXJ0KG5ld1RhcmdldERhdGEudGFyZ2V0SWQsIG5ld1RhcmdldERhdGEpO1xyXG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JlSW1wbC50YXJnZXRDYWNoZVxyXG4gICAgICAgICAgICAudXBkYXRlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgbmV3VGFyZ2V0RGF0YSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gbG9jYWxTdG9yZUltcGwudGFyZ2V0Q2FjaGUucmVtb3ZlTWF0Y2hpbmdLZXlzRm9yVGFyZ2V0SWQodHJhbnNhY3Rpb24sIGFsbG9jYXRlZC50YXJnZXRJZCkpXHJcbiAgICAgICAgICAgIC5uZXh0KCgpID0+IGxvY2FsU3RvcmVJbXBsLnRhcmdldENhY2hlLmFkZE1hdGNoaW5nS2V5cyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRzLCBhbGxvY2F0ZWQudGFyZ2V0SWQpKVxyXG4gICAgICAgICAgICAubmV4dCgoKSA9PiBsb2NhbFN0b3JlSW1wbC5idW5kbGVDYWNoZS5zYXZlTmFtZWRRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE1lbW9yeUJ1bmRsZUNhY2hlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZXIpIHtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm5hbWVkUXVlcmllcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldEJ1bmRsZU1ldGFkYXRhKHRyYW5zYWN0aW9uLCBidW5kbGVJZCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLmJ1bmRsZXMuZ2V0KGJ1bmRsZUlkKSk7XHJcbiAgICB9XHJcbiAgICBzYXZlQnVuZGxlTWV0YWRhdGEodHJhbnNhY3Rpb24sIGJ1bmRsZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5idW5kbGVzLnNldChidW5kbGVNZXRhZGF0YS5pZCwgZnJvbUJ1bmRsZU1ldGFkYXRhKGJ1bmRsZU1ldGFkYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXROYW1lZFF1ZXJ5KHRyYW5zYWN0aW9uLCBxdWVyeU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5uYW1lZFF1ZXJpZXMuZ2V0KHF1ZXJ5TmFtZSkpO1xyXG4gICAgfVxyXG4gICAgc2F2ZU5hbWVkUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5uYW1lZFF1ZXJpZXMuc2V0KHF1ZXJ5Lm5hbWUsIGZyb21Qcm90b05hbWVkUXVlcnkocXVlcnkpKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW4tbWVtb3J5IGltcGxlbWVudGF0aW9uIG9mIERvY3VtZW50T3ZlcmxheUNhY2hlLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5RG9jdW1lbnRPdmVybGF5Q2FjaGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gQSBtYXAgc29ydGVkIGJ5IERvY3VtZW50S2V5LCB3aG9zZSB2YWx1ZSBpcyBhIHBhaXIgb2YgdGhlIGxhcmdlc3QgYmF0Y2ggaWRcclxuICAgICAgICAvLyBmb3IgdGhlIG92ZXJsYXkgYW5kIHRoZSBvdmVybGF5IGl0c2VsZi5cclxuICAgICAgICB0aGlzLm92ZXJsYXlzID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuICAgICAgICB0aGlzLm92ZXJsYXlCeUJhdGNoSWQgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRPdmVybGF5KHRyYW5zYWN0aW9uLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5vdmVybGF5cy5nZXQoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBzYXZlT3ZlcmxheXModHJhbnNhY3Rpb24sIGxhcmdlc3RCYXRjaElkLCBvdmVybGF5cykge1xyXG4gICAgICAgIG92ZXJsYXlzLmZvckVhY2gobXV0YXRpb24gPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlT3ZlcmxheXNGb3JCYXRjaElkKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMsIGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5vdmVybGF5QnlCYXRjaElkLmdldChiYXRjaElkKTtcclxuICAgICAgICBpZiAoa2V5cyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gKHRoaXMub3ZlcmxheXMgPSB0aGlzLm92ZXJsYXlzLnJlbW92ZShrZXkpKSk7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5kZWxldGUoYmF0Y2hJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxheXNGb3JDb2xsZWN0aW9uKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uLCBzaW5jZUJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgY29uc3QgaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGggKyAxO1xyXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5ldyBEb2N1bWVudEtleShjb2xsZWN0aW9uLmNoaWxkKCcnKSk7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMub3ZlcmxheXMuZ2V0SXRlcmF0b3JGcm9tKHByZWZpeCk7XHJcbiAgICAgICAgd2hpbGUgKGl0ZXIuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBlbnRyeS52YWx1ZTtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gb3ZlcmxheS5nZXRLZXkoKTtcclxuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uLmlzUHJlZml4T2Yoa2V5LnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEb2N1bWVudHMgZnJvbSBzdWItY29sbGVjdGlvbnNcclxuICAgICAgICAgICAgaWYgKGtleS5wYXRoLmxlbmd0aCAhPT0gaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3ZlcmxheS5sYXJnZXN0QmF0Y2hJZCA+IHNpbmNlQmF0Y2hJZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH1cclxuICAgIGdldE92ZXJsYXlzRm9yQ29sbGVjdGlvbkdyb3VwKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uR3JvdXAsIHNpbmNlQmF0Y2hJZCwgY291bnQpIHtcclxuICAgICAgICBsZXQgYmF0Y2hJZFRvT3ZlcmxheXMgPSBuZXcgU29ydGVkTWFwKChrZXkxLCBrZXkyKSA9PiBrZXkxIC0ga2V5Mik7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IHRoaXMub3ZlcmxheXMuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICB3aGlsZSAoaXRlci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IGVudHJ5LnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBvdmVybGF5LmdldEtleSgpO1xyXG4gICAgICAgICAgICBpZiAoa2V5LmdldENvbGxlY3Rpb25Hcm91cCgpICE9PSBjb2xsZWN0aW9uR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvdmVybGF5Lmxhcmdlc3RCYXRjaElkID4gc2luY2VCYXRjaElkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3ZlcmxheXNGb3JCYXRjaElkID0gYmF0Y2hJZFRvT3ZlcmxheXMuZ2V0KG92ZXJsYXkubGFyZ2VzdEJhdGNoSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXlzRm9yQmF0Y2hJZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlzRm9yQmF0Y2hJZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaElkVG9PdmVybGF5cyA9IGJhdGNoSWRUb092ZXJsYXlzLmluc2VydChvdmVybGF5Lmxhcmdlc3RCYXRjaElkLCBvdmVybGF5c0ZvckJhdGNoSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3ZlcmxheXNGb3JCYXRjaElkLnNldChvdmVybGF5LmdldEtleSgpLCBvdmVybGF5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgY29uc3QgYmF0Y2hJdGVyID0gYmF0Y2hJZFRvT3ZlcmxheXMuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICB3aGlsZSAoYmF0Y2hJdGVyLmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGJhdGNoSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlzID0gZW50cnkudmFsdWU7XHJcbiAgICAgICAgICAgIG92ZXJsYXlzLmZvckVhY2goKG92ZXJsYXksIGtleSkgPT4gcmVzdWx0LnNldChrZXksIG92ZXJsYXkpKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zaXplID49IGNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH1cclxuICAgIHNhdmVPdmVybGF5KHRyYW5zYWN0aW9uLCBsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pIHtcclxuICAgICAgICBpZiAobXV0YXRpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIGFzc29jaWF0aW9uIG9mIHRoZSBvdmVybGF5IHRvIGl0cyBiYXRjaCBpZC5cclxuICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMub3ZlcmxheXMuZ2V0KG11dGF0aW9uLmtleSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5nZXQoZXhpc3RpbmcubGFyZ2VzdEJhdGNoSWQpLmRlbGV0ZShtdXRhdGlvbi5rZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm92ZXJsYXlzID0gdGhpcy5vdmVybGF5cy5pbnNlcnQobXV0YXRpb24ua2V5LCBuZXcgT3ZlcmxheShsYXJnZXN0QmF0Y2hJZCwgbXV0YXRpb24pKTtcclxuICAgICAgICAvLyBDcmVhdGUgdGhlIGFzc29jaWF0aW9uIG9mIHRoaXMgb3ZlcmxheSB0byB0aGUgZ2l2ZW4gbGFyZ2VzdEJhdGNoSWQuXHJcbiAgICAgICAgbGV0IGJhdGNoID0gdGhpcy5vdmVybGF5QnlCYXRjaElkLmdldChsYXJnZXN0QmF0Y2hJZCk7XHJcbiAgICAgICAgaWYgKGJhdGNoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYmF0Y2ggPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUJ5QmF0Y2hJZC5zZXQobGFyZ2VzdEJhdGNoSWQsIGJhdGNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmF0Y2guYWRkKG11dGF0aW9uLmtleSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiByZWZlcmVuY2VzIHRvIGEgZG9jdW1lbnQgZnJvbSBzb21lIGtpbmQgb2YgbnVtYmVyZWQgZW50aXR5XHJcbiAqIChlaXRoZXIgYSB0YXJnZXQgSUQgb3IgYmF0Y2ggSUQpLiBBcyByZWZlcmVuY2VzIGFyZSBhZGRlZCB0byBvciByZW1vdmVkIGZyb21cclxuICogdGhlIHNldCBjb3JyZXNwb25kaW5nIGV2ZW50cyBhcmUgZW1pdHRlZCB0byBhIHJlZ2lzdGVyZWQgZ2FyYmFnZSBjb2xsZWN0b3IuXHJcbiAqXHJcbiAqIEVhY2ggcmVmZXJlbmNlIGlzIHJlcHJlc2VudGVkIGJ5IGEgRG9jdW1lbnRSZWZlcmVuY2Ugb2JqZWN0LiBFYWNoIG9mIHRoZW1cclxuICogY29udGFpbnMgZW5vdWdoIGluZm9ybWF0aW9uIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSByZWZlcmVuY2UuIFRoZXkgYXJlIGFsbFxyXG4gKiBzdG9yZWQgcHJpbWFyaWx5IGluIGEgc2V0IHNvcnRlZCBieSBrZXkuIEEgZG9jdW1lbnQgaXMgY29uc2lkZXJlZCBnYXJiYWdlIGlmXHJcbiAqIHRoZXJlJ3Mgbm8gcmVmZXJlbmNlcyBpbiB0aGF0IHNldCAodGhpcyBjYW4gYmUgZWZmaWNpZW50bHkgY2hlY2tlZCB0aGFua3MgdG9cclxuICogc29ydGluZyBieSBrZXkpLlxyXG4gKlxyXG4gKiBSZWZlcmVuY2VTZXQgYWxzbyBrZWVwcyBhIHNlY29uZGFyeSBzZXQgdGhhdCBjb250YWlucyByZWZlcmVuY2VzIHNvcnRlZCBieVxyXG4gKiBJRHMuIFRoaXMgb25lIGlzIHVzZWQgdG8gZWZmaWNpZW50bHkgaW1wbGVtZW50IHJlbW92YWwgb2YgYWxsIHJlZmVyZW5jZXMgYnlcclxuICogc29tZSB0YXJnZXQgSUQuXHJcbiAqL1xyXG5jbGFzcyBSZWZlcmVuY2VTZXQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLy8gQSBzZXQgb2Ygb3V0c3RhbmRpbmcgcmVmZXJlbmNlcyB0byBhIGRvY3VtZW50IHNvcnRlZCBieSBrZXkuXHJcbiAgICAgICAgdGhpcy5yZWZzQnlLZXkgPSBuZXcgU29ydGVkU2V0KERvY1JlZmVyZW5jZS5jb21wYXJlQnlLZXkpO1xyXG4gICAgICAgIC8vIEEgc2V0IG9mIG91dHN0YW5kaW5nIHJlZmVyZW5jZXMgdG8gYSBkb2N1bWVudCBzb3J0ZWQgYnkgdGFyZ2V0IGlkLlxyXG4gICAgICAgIHRoaXMucmVmc0J5VGFyZ2V0ID0gbmV3IFNvcnRlZFNldChEb2NSZWZlcmVuY2UuY29tcGFyZUJ5VGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIHNldCBjb250YWlucyBubyByZWZlcmVuY2VzLiAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWZzQnlLZXkuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqIEFkZHMgYSByZWZlcmVuY2UgdG8gdGhlIGdpdmVuIGRvY3VtZW50IGtleSBmb3IgdGhlIGdpdmVuIElELiAqL1xyXG4gICAgYWRkUmVmZXJlbmNlKGtleSwgaWQpIHtcclxuICAgICAgICBjb25zdCByZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGtleSwgaWQpO1xyXG4gICAgICAgIHRoaXMucmVmc0J5S2V5ID0gdGhpcy5yZWZzQnlLZXkuYWRkKHJlZik7XHJcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQgPSB0aGlzLnJlZnNCeVRhcmdldC5hZGQocmVmKTtcclxuICAgIH1cclxuICAgIC8qKiBBZGQgcmVmZXJlbmNlcyB0byB0aGUgZ2l2ZW4gZG9jdW1lbnQga2V5cyBmb3IgdGhlIGdpdmVuIElELiAqL1xyXG4gICAgYWRkUmVmZXJlbmNlcyhrZXlzLCBpZCkge1xyXG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5hZGRSZWZlcmVuY2Uoa2V5LCBpZCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBrZXkgZm9yIHRoZSBnaXZlblxyXG4gICAgICogSUQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVJlZmVyZW5jZShrZXksIGlkKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVSZWYobmV3IERvY1JlZmVyZW5jZShrZXksIGlkKSk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVSZWZlcmVuY2VzKGtleXMsIGlkKSB7XHJcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB0aGlzLnJlbW92ZVJlZmVyZW5jZShrZXksIGlkKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgcmVmZXJlbmNlcyB3aXRoIGEgZ2l2ZW4gSUQuIENhbGxzIHJlbW92ZVJlZigpIGZvciBlYWNoIGtleVxyXG4gICAgICogcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlUmVmZXJlbmNlc0ZvcklkKGlkKSB7XHJcbiAgICAgICAgY29uc3QgZW1wdHlLZXkgPSBuZXcgRG9jdW1lbnRLZXkobmV3IFJlc291cmNlUGF0aChbXSkpO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UmVmID0gbmV3IERvY1JlZmVyZW5jZShlbXB0eUtleSwgaWQpO1xyXG4gICAgICAgIGNvbnN0IGVuZFJlZiA9IG5ldyBEb2NSZWZlcmVuY2UoZW1wdHlLZXksIGlkICsgMSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgICAgIHRoaXMucmVmc0J5VGFyZ2V0LmZvckVhY2hJblJhbmdlKFtzdGFydFJlZiwgZW5kUmVmXSwgcmVmID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVSZWYocmVmKTtcclxuICAgICAgICAgICAga2V5cy5wdXNoKHJlZi5rZXkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQWxsUmVmZXJlbmNlcygpIHtcclxuICAgICAgICB0aGlzLnJlZnNCeUtleS5mb3JFYWNoKHJlZiA9PiB0aGlzLnJlbW92ZVJlZihyZWYpKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVJlZihyZWYpIHtcclxuICAgICAgICB0aGlzLnJlZnNCeUtleSA9IHRoaXMucmVmc0J5S2V5LmRlbGV0ZShyZWYpO1xyXG4gICAgICAgIHRoaXMucmVmc0J5VGFyZ2V0ID0gdGhpcy5yZWZzQnlUYXJnZXQuZGVsZXRlKHJlZik7XHJcbiAgICB9XHJcbiAgICByZWZlcmVuY2VzRm9ySWQoaWQpIHtcclxuICAgICAgICBjb25zdCBlbXB0eUtleSA9IG5ldyBEb2N1bWVudEtleShuZXcgUmVzb3VyY2VQYXRoKFtdKSk7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRSZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGVtcHR5S2V5LCBpZCk7XHJcbiAgICAgICAgY29uc3QgZW5kUmVmID0gbmV3IERvY1JlZmVyZW5jZShlbXB0eUtleSwgaWQgKyAxKTtcclxuICAgICAgICBsZXQga2V5cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgdGhpcy5yZWZzQnlUYXJnZXQuZm9yRWFjaEluUmFuZ2UoW3N0YXJ0UmVmLCBlbmRSZWZdLCByZWYgPT4ge1xyXG4gICAgICAgICAgICBrZXlzID0ga2V5cy5hZGQocmVmLmtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9XHJcbiAgICBjb250YWluc0tleShrZXkpIHtcclxuICAgICAgICBjb25zdCByZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGtleSwgMCk7XHJcbiAgICAgICAgY29uc3QgZmlyc3RSZWYgPSB0aGlzLnJlZnNCeUtleS5maXJzdEFmdGVyT3JFcXVhbChyZWYpO1xyXG4gICAgICAgIHJldHVybiBmaXJzdFJlZiAhPT0gbnVsbCAmJiBrZXkuaXNFcXVhbChmaXJzdFJlZi5rZXkpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIERvY1JlZmVyZW5jZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHRhcmdldE9yQmF0Y2hJZCkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0T3JCYXRjaElkID0gdGFyZ2V0T3JCYXRjaElkO1xyXG4gICAgfVxyXG4gICAgLyoqIENvbXBhcmUgYnkga2V5IHRoZW4gYnkgSUQgKi9cclxuICAgIHN0YXRpYyBjb21wYXJlQnlLZXkobGVmdCwgcmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gKERvY3VtZW50S2V5LmNvbXBhcmF0b3IobGVmdC5rZXksIHJpZ2h0LmtleSkgfHxcclxuICAgICAgICAgICAgcHJpbWl0aXZlQ29tcGFyYXRvcihsZWZ0LnRhcmdldE9yQmF0Y2hJZCwgcmlnaHQudGFyZ2V0T3JCYXRjaElkKSk7XHJcbiAgICB9XHJcbiAgICAvKiogQ29tcGFyZSBieSBJRCB0aGVuIGJ5IGtleSAqL1xyXG4gICAgc3RhdGljIGNvbXBhcmVCeVRhcmdldElkKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIChwcmltaXRpdmVDb21wYXJhdG9yKGxlZnQudGFyZ2V0T3JCYXRjaElkLCByaWdodC50YXJnZXRPckJhdGNoSWQpIHx8XHJcbiAgICAgICAgICAgIERvY3VtZW50S2V5LmNvbXBhcmF0b3IobGVmdC5rZXksIHJpZ2h0LmtleSkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE1lbW9yeU11dGF0aW9uUXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXhNYW5hZ2VyLCByZWZlcmVuY2VEZWxlZ2F0ZSkge1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUgPSByZWZlcmVuY2VEZWxlZ2F0ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2V0IG9mIGFsbCBtdXRhdGlvbnMgdGhhdCBoYXZlIGJlZW4gc2VudCBidXQgbm90IHlldCBiZWVuIGFwcGxpZWQgdG9cclxuICAgICAgICAgKiB0aGUgYmFja2VuZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUgPSBbXTtcclxuICAgICAgICAvKiogTmV4dCB2YWx1ZSB0byB1c2Ugd2hlbiBhc3NpZ25pbmcgc2VxdWVudGlhbCBJRHMgdG8gZWFjaCBtdXRhdGlvbiBiYXRjaC4gKi9cclxuICAgICAgICB0aGlzLm5leHRCYXRjaElkID0gMTtcclxuICAgICAgICAvKiogQW4gb3JkZXJlZCBtYXBwaW5nIGJldHdlZW4gZG9jdW1lbnRzIGFuZCB0aGUgbXV0YXRpb25zIGJhdGNoIElEcy4gKi9cclxuICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5ID0gbmV3IFNvcnRlZFNldChEb2NSZWZlcmVuY2UuY29tcGFyZUJ5S2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrRW1wdHkodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICBhZGRNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBsb2NhbFdyaXRlVGltZSwgYmFzZU11dGF0aW9ucywgbXV0YXRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgYmF0Y2hJZCA9IHRoaXMubmV4dEJhdGNoSWQ7XHJcbiAgICAgICAgdGhpcy5uZXh0QmF0Y2hJZCsrO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uUXVldWVbdGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBiYXRjaCA9IG5ldyBNdXRhdGlvbkJhdGNoKGJhdGNoSWQsIGxvY2FsV3JpdGVUaW1lLCBiYXNlTXV0YXRpb25zLCBtdXRhdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZS5wdXNoKGJhdGNoKTtcclxuICAgICAgICAvLyBUcmFjayByZWZlcmVuY2VzIGJ5IGRvY3VtZW50IGtleSBhbmQgaW5kZXggY29sbGVjdGlvbiBwYXJlbnRzLlxyXG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXkgPSB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmFkZChuZXcgRG9jUmVmZXJlbmNlKG11dGF0aW9uLmtleSwgYmF0Y2hJZCkpO1xyXG4gICAgICAgICAgICB0aGlzLmluZGV4TWFuYWdlci5hZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwgbXV0YXRpb24ua2V5LnBhdGgucG9wTGFzdCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGJhdGNoKTtcclxuICAgIH1cclxuICAgIGxvb2t1cE11dGF0aW9uQmF0Y2godHJhbnNhY3Rpb24sIGJhdGNoSWQpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5maW5kTXV0YXRpb25CYXRjaChiYXRjaElkKSk7XHJcbiAgICB9XHJcbiAgICBnZXROZXh0TXV0YXRpb25CYXRjaEFmdGVyQmF0Y2hJZCh0cmFuc2FjdGlvbiwgYmF0Y2hJZCkge1xyXG4gICAgICAgIGNvbnN0IG5leHRCYXRjaElkID0gYmF0Y2hJZCArIDE7XHJcbiAgICAgICAgLy8gVGhlIHJlcXVlc3RlZCBiYXRjaElkIG1heSBzdGlsbCBiZSBvdXQgb2YgcmFuZ2Ugc28gbm9ybWFsaXplIGl0IHRvIHRoZVxyXG4gICAgICAgIC8vIHN0YXJ0IG9mIHRoZSBxdWV1ZS5cclxuICAgICAgICBjb25zdCByYXdJbmRleCA9IHRoaXMuaW5kZXhPZkJhdGNoSWQobmV4dEJhdGNoSWQpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmF3SW5kZXggPCAwID8gMCA6IHJhd0luZGV4O1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID4gaW5kZXggPyB0aGlzLm11dGF0aW9uUXVldWVbaW5kZXhdIDogbnVsbCk7XHJcbiAgICB9XHJcbiAgICBnZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKCkge1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoID09PSAwID8gQkFUQ0hJRF9VTktOT1dOIDogdGhpcy5uZXh0QmF0Y2hJZCAtIDEpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsTXV0YXRpb25CYXRjaGVzKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubXV0YXRpb25RdWV1ZS5zbGljZSgpKTtcclxuICAgIH1cclxuICAgIGdldEFsbE11dGF0aW9uQmF0Y2hlc0FmZmVjdGluZ0RvY3VtZW50S2V5KHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleSkge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgMCk7XHJcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERvY1JlZmVyZW5jZShkb2N1bWVudEtleSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmZvckVhY2hJblJhbmdlKFtzdGFydCwgZW5kXSwgcmVmID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmZpbmRNdXRhdGlvbkJhdGNoKHJlZi50YXJnZXRPckJhdGNoSWQpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXRjaCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdEb2N1bWVudEtleXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cykge1xyXG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XHJcbiAgICAgICAgZG9jdW1lbnRLZXlzLmZvckVhY2goZG9jdW1lbnRLZXkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEb2NSZWZlcmVuY2UoZG9jdW1lbnRLZXksIDApO1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBuZXcgRG9jUmVmZXJlbmNlKGRvY3VtZW50S2V5LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmZvckVhY2hJblJhbmdlKFtzdGFydCwgZW5kXSwgcmVmID0+IHtcclxuICAgICAgICAgICAgICAgIHVuaXF1ZUJhdGNoSURzID0gdW5pcXVlQmF0Y2hJRHMuYWRkKHJlZi50YXJnZXRPckJhdGNoSWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5maW5kTXV0YXRpb25CYXRjaGVzKHVuaXF1ZUJhdGNoSURzKSk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGxNdXRhdGlvbkJhdGNoZXNBZmZlY3RpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnkpIHtcclxuICAgICAgICAvLyBVc2UgdGhlIHF1ZXJ5IHBhdGggYXMgYSBwcmVmaXggZm9yIHRlc3RpbmcgaWYgYSBkb2N1bWVudCBtYXRjaGVzIHRoZVxyXG4gICAgICAgIC8vIHF1ZXJ5LlxyXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHF1ZXJ5LnBhdGg7XHJcbiAgICAgICAgY29uc3QgaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIDE7XHJcbiAgICAgICAgLy8gQ29uc3RydWN0IGEgZG9jdW1lbnQgcmVmZXJlbmNlIGZvciBhY3R1YWxseSBzY2FubmluZyB0aGUgaW5kZXguIFVubGlrZVxyXG4gICAgICAgIC8vIHRoZSBwcmVmaXggdGhlIGRvY3VtZW50IGtleSBpbiB0aGlzIHJlZmVyZW5jZSBtdXN0IGhhdmUgYW4gZXZlbiBudW1iZXIgb2ZcclxuICAgICAgICAvLyBzZWdtZW50cy4gVGhlIGVtcHR5IHNlZ21lbnQgY2FuIGJlIHVzZWQgYSBzdWZmaXggb2YgdGhlIHF1ZXJ5IHBhdGhcclxuICAgICAgICAvLyBiZWNhdXNlIGl0IHByZWNlZGVzIGFsbCBvdGhlciBzZWdtZW50cyBpbiBhbiBvcmRlcmVkIHRyYXZlcnNhbC5cclxuICAgICAgICBsZXQgc3RhcnRQYXRoID0gcHJlZml4O1xyXG4gICAgICAgIGlmICghRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShzdGFydFBhdGgpKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UGF0aCA9IHN0YXJ0UGF0aC5jaGlsZCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERvY1JlZmVyZW5jZShuZXcgRG9jdW1lbnRLZXkoc3RhcnRQYXRoKSwgMCk7XHJcbiAgICAgICAgLy8gRmluZCB1bmlxdWUgYmF0Y2hJRHMgcmVmZXJlbmNlZCBieSBhbGwgZG9jdW1lbnRzIHBvdGVudGlhbGx5IG1hdGNoaW5nIHRoZVxyXG4gICAgICAgIC8vIHF1ZXJ5LlxyXG4gICAgICAgIGxldCB1bmlxdWVCYXRjaElEcyA9IG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvcik7XHJcbiAgICAgICAgdGhpcy5iYXRjaGVzQnlEb2N1bWVudEtleS5mb3JFYWNoV2hpbGUocmVmID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgcm93S2V5UGF0aCA9IHJlZi5rZXkucGF0aDtcclxuICAgICAgICAgICAgaWYgKCFwcmVmaXguaXNQcmVmaXhPZihyb3dLZXlQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUm93cyB3aXRoIGRvY3VtZW50IGtleXMgbW9yZSB0aGFuIG9uZSBzZWdtZW50IGxvbmdlciB0aGFuIHRoZSBxdWVyeVxyXG4gICAgICAgICAgICAgICAgLy8gcGF0aCBjYW4ndCBiZSBtYXRjaGVzLiBGb3IgZXhhbXBsZSwgYSBxdWVyeSBvbiAncm9vbXMnIGNhbid0IG1hdGNoXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZG9jdW1lbnQgL3Jvb21zL2FiYy9tZXNzYWdlcy94eXguXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1jZyk6IHdlJ2xsIG5lZWQgYSBkaWZmZXJlbnQgc2Nhbm5lciB3aGVuIHdlIGltcGxlbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jZXN0b3IgcXVlcmllcy5cclxuICAgICAgICAgICAgICAgIGlmIChyb3dLZXlQYXRoLmxlbmd0aCA9PT0gaW1tZWRpYXRlQ2hpbGRyZW5QYXRoTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlQmF0Y2hJRHMgPSB1bmlxdWVCYXRjaElEcy5hZGQocmVmLnRhcmdldE9yQmF0Y2hJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHN0YXJ0KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5maW5kTXV0YXRpb25CYXRjaGVzKHVuaXF1ZUJhdGNoSURzKSk7XHJcbiAgICB9XHJcbiAgICBmaW5kTXV0YXRpb25CYXRjaGVzKGJhdGNoSURzKSB7XHJcbiAgICAgICAgLy8gQ29uc3RydWN0IGFuIGFycmF5IG9mIG1hdGNoaW5nIGJhdGNoZXMsIHNvcnRlZCBieSBiYXRjaElEIHRvIGVuc3VyZSB0aGF0XHJcbiAgICAgICAgLy8gbXVsdGlwbGUgbXV0YXRpb25zIGFmZmVjdGluZyB0aGUgc2FtZSBkb2N1bWVudCBrZXkgYXJlIGFwcGxpZWQgaW4gb3JkZXIuXHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgYmF0Y2hJRHMuZm9yRWFjaChiYXRjaElkID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmZpbmRNdXRhdGlvbkJhdGNoKGJhdGNoSWQpO1xyXG4gICAgICAgICAgICBpZiAoYmF0Y2ggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICByZW1vdmVNdXRhdGlvbkJhdGNoKHRyYW5zYWN0aW9uLCBiYXRjaCkge1xyXG4gICAgICAgIC8vIEZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBiYXRjaCBmb3IgcmVtb3ZhbC5cclxuICAgICAgICBjb25zdCBiYXRjaEluZGV4ID0gdGhpcy5pbmRleE9mRXhpc3RpbmdCYXRjaElkKGJhdGNoLmJhdGNoSWQsICdyZW1vdmVkJyk7XHJcbiAgICAgICAgaGFyZEFzc2VydChiYXRjaEluZGV4ID09PSAwKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uUXVldWUuc2hpZnQoKTtcclxuICAgICAgICBsZXQgcmVmZXJlbmNlcyA9IHRoaXMuYmF0Y2hlc0J5RG9jdW1lbnRLZXk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKGJhdGNoLm11dGF0aW9ucywgKG11dGF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IG5ldyBEb2NSZWZlcmVuY2UobXV0YXRpb24ua2V5LCBiYXRjaC5iYXRjaElkKTtcclxuICAgICAgICAgICAgcmVmZXJlbmNlcyA9IHJlZmVyZW5jZXMuZGVsZXRlKHJlZik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZURlbGVnYXRlLm1hcmtQb3RlbnRpYWxseU9ycGhhbmVkKHRyYW5zYWN0aW9uLCBtdXRhdGlvbi5rZXkpO1xyXG4gICAgICAgIH0pLm5leHQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5ID0gcmVmZXJlbmNlcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlbW92ZUNhY2hlZE11dGF0aW9uS2V5cyhiYXRjaElkKSB7XHJcbiAgICAgICAgLy8gTm8tb3Agc2luY2UgdGhlIG1lbW9yeSBtdXRhdGlvbiBxdWV1ZSBkb2VzIG5vdCBtYWludGFpbiBhIHNlcGFyYXRlIGNhY2hlLlxyXG4gICAgfVxyXG4gICAgY29udGFpbnNLZXkodHhuLCBrZXkpIHtcclxuICAgICAgICBjb25zdCByZWYgPSBuZXcgRG9jUmVmZXJlbmNlKGtleSwgMCk7XHJcbiAgICAgICAgY29uc3QgZmlyc3RSZWYgPSB0aGlzLmJhdGNoZXNCeURvY3VtZW50S2V5LmZpcnN0QWZ0ZXJPckVxdWFsKHJlZik7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKGtleS5pc0VxdWFsKGZpcnN0UmVmICYmIGZpcnN0UmVmLmtleSkpO1xyXG4gICAgfVxyXG4gICAgcGVyZm9ybUNvbnNpc3RlbmN5Q2hlY2sodHhuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25RdWV1ZS5sZW5ndGggPT09IDApIDtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBiYXRjaElkIGluIHRoZSBtdXRhdGlvbiBxdWV1ZSBhbmQgYXNzZXJ0cyB0aGF0XHJcbiAgICAgKiB0aGUgcmVzdWx0aW5nIGluZGV4IGlzIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYmF0Y2hJZCAtIFRoZSBiYXRjaElkIHRvIHNlYXJjaCBmb3JcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBBIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhlIGNhbGxlciBpcyBkb2luZywgcGhyYXNlZCBpbiBwYXNzaXZlXHJcbiAgICAgKiBmb3JtIChlLmcuIFwiYWNrbm93bGVkZ2VkXCIgaW4gYSByb3V0aW5lIHRoYXQgYWNrbm93bGVkZ2VzIGJhdGNoZXMpLlxyXG4gICAgICovXHJcbiAgICBpbmRleE9mRXhpc3RpbmdCYXRjaElkKGJhdGNoSWQsIGFjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleE9mQmF0Y2hJZChiYXRjaElkKTtcclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gYmF0Y2hJZCBpbiB0aGUgbXV0YXRpb24gcXVldWUuIFRoaXMgb3BlcmF0aW9uXHJcbiAgICAgKiBpcyBPKDEpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBjb21wdXRlZCBpbmRleCBvZiB0aGUgYmF0Y2ggd2l0aCB0aGUgZ2l2ZW4gYmF0Y2hJZCwgYmFzZWQgb25cclxuICAgICAqIHRoZSBzdGF0ZSBvZiB0aGUgcXVldWUuIE5vdGUgdGhpcyBpbmRleCBjYW4gYmUgbmVnYXRpdmUgaWYgdGhlIHJlcXVlc3RlZFxyXG4gICAgICogYmF0Y2hJZCBoYXMgYWxyZWFkeSBiZWVuIHJlbXZvZWQgZnJvbSB0aGUgcXVldWUgb3IgcGFzdCB0aGUgZW5kIG9mIHRoZVxyXG4gICAgICogcXVldWUgaWYgdGhlIGJhdGNoSWQgaXMgbGFyZ2VyIHRoYW4gdGhlIGxhc3QgYWRkZWQgYmF0Y2guXHJcbiAgICAgKi9cclxuICAgIGluZGV4T2ZCYXRjaElkKGJhdGNoSWQpIHtcclxuICAgICAgICBpZiAodGhpcy5tdXRhdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBBcyBhbiBpbmRleCB0aGlzIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgcXVldWVcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEV4YW1pbmUgdGhlIGZyb250IG9mIHRoZSBxdWV1ZSB0byBmaWd1cmUgb3V0IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlXHJcbiAgICAgICAgLy8gYmF0Y2hJZCBhbmQgaW5kZXhlcyBpbiB0aGUgYXJyYXkuIE5vdGUgdGhhdCBzaW5jZSB0aGUgcXVldWUgaXMgb3JkZXJlZFxyXG4gICAgICAgIC8vIGJ5IGJhdGNoSWQsIGlmIHRoZSBmaXJzdCBiYXRjaCBoYXMgYSBsYXJnZXIgYmF0Y2hJZCB0aGVuIHRoZSByZXF1ZXN0ZWRcclxuICAgICAgICAvLyBiYXRjaElkIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHF1ZXVlLlxyXG4gICAgICAgIGNvbnN0IGZpcnN0QmF0Y2hJZCA9IHRoaXMubXV0YXRpb25RdWV1ZVswXS5iYXRjaElkO1xyXG4gICAgICAgIHJldHVybiBiYXRjaElkIC0gZmlyc3RCYXRjaElkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHZlcnNpb24gb2YgbG9va3VwTXV0YXRpb25CYXRjaCB0aGF0IGRvZXNuJ3QgcmV0dXJuIGEgcHJvbWlzZSwgdGhpcyBtYWtlc1xyXG4gICAgICogb3RoZXIgZnVuY3Rpb25zIHRoYXQgdXNlcyB0aGlzIGNvZGUgZWFzaWVyIHRvIHJlYWQgYW5kIG1vcmUgZWZmaWNlbnQuXHJcbiAgICAgKi9cclxuICAgIGZpbmRNdXRhdGlvbkJhdGNoKGJhdGNoSWQpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXhPZkJhdGNoSWQoYmF0Y2hJZCk7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLm11dGF0aW9uUXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMubXV0YXRpb25RdWV1ZVtpbmRleF07XHJcbiAgICAgICAgcmV0dXJuIGJhdGNoO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGRvY3VtZW50RW50cnlNYXAoKSB7XHJcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxufVxyXG4vKipcclxuICogVGhlIG1lbW9yeS1vbmx5IFJlbW90ZURvY3VtZW50Q2FjaGUgZm9yIEluZGV4ZWREYi4gVG8gY29uc3RydWN0LCBpbnZva2VcclxuICogYG5ld01lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUoKWAuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlSW1wbCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBzaXplciAtIFVzZWQgdG8gYXNzZXNzIHRoZSBzaXplIG9mIGEgZG9jdW1lbnQuIEZvciBlYWdlciBHQywgdGhpcyBpc1xyXG4gICAgICogZXhwZWN0ZWQgdG8ganVzdCByZXR1cm4gMCB0byBhdm9pZCB1bm5lY2Vzc2FyaWx5IGRvaW5nIHRoZSB3b3JrIG9mXHJcbiAgICAgKiBjYWxjdWxhdGluZyB0aGUgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2l6ZXIpIHtcclxuICAgICAgICB0aGlzLnNpemVyID0gc2l6ZXI7XHJcbiAgICAgICAgLyoqIFVuZGVybHlpbmcgY2FjaGUgb2YgZG9jdW1lbnRzIGFuZCB0aGVpciByZWFkIHRpbWVzLiAqL1xyXG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3VtZW50RW50cnlNYXAoKTtcclxuICAgICAgICAvKiogU2l6ZSBvZiBhbGwgY2FjaGVkIGRvY3VtZW50cy4gKi9cclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgfVxyXG4gICAgc2V0SW5kZXhNYW5hZ2VyKGluZGV4TWFuYWdlcikge1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gaW5kZXhNYW5hZ2VyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBzdXBwbGllZCBlbnRyeSB0byB0aGUgY2FjaGUgYW5kIHVwZGF0ZXMgdGhlIGNhY2hlIHNpemUgYXMgYXBwcm9wcmlhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQWxsIGNhbGxzIG9mIGBhZGRFbnRyeWAgIGFyZSByZXF1aXJlZCB0byBnbyB0aHJvdWdoIHRoZSBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlclxyXG4gICAgICogcmV0dXJuZWQgYnkgYG5ld0NoYW5nZUJ1ZmZlcigpYC5cclxuICAgICAqL1xyXG4gICAgYWRkRW50cnkodHJhbnNhY3Rpb24sIGRvYykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGRvYy5rZXk7XHJcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGtleSk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNTaXplID0gZW50cnkgPyBlbnRyeS5zaXplIDogMDtcclxuICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZXIoZG9jKTtcclxuICAgICAgICB0aGlzLmRvY3MgPSB0aGlzLmRvY3MuaW5zZXJ0KGtleSwge1xyXG4gICAgICAgICAgICBkb2N1bWVudDogZG9jLm11dGFibGVDb3B5KCksXHJcbiAgICAgICAgICAgIHNpemU6IGN1cnJlbnRTaXplXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zaXplICs9IGN1cnJlbnRTaXplIC0gcHJldmlvdXNTaXplO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlci5hZGRUb0NvbGxlY3Rpb25QYXJlbnRJbmRleCh0cmFuc2FjdGlvbiwga2V5LnBhdGgucG9wTGFzdCgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGVudHJ5IGZyb20gdGhlIGNhY2hlIGFuZCB1cGRhdGVzIHRoZSBjYWNoZSBzaXplIGFzIGFwcHJvcHJpYXRlLlxyXG4gICAgICpcclxuICAgICAqIEFsbCBjYWxscyBvZiBgcmVtb3ZlRW50cnlgIGFyZSByZXF1aXJlZCB0byBnbyB0aHJvdWdoIHRoZSBSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlclxyXG4gICAgICogcmV0dXJuZWQgYnkgYG5ld0NoYW5nZUJ1ZmZlcigpYC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRW50cnkoZG9jdW1lbnRLZXkpIHtcclxuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZG9jcy5nZXQoZG9jdW1lbnRLZXkpO1xyXG4gICAgICAgIGlmIChlbnRyeSkge1xyXG4gICAgICAgICAgICB0aGlzLmRvY3MgPSB0aGlzLmRvY3MucmVtb3ZlKGRvY3VtZW50S2V5KTtcclxuICAgICAgICAgICAgdGhpcy5zaXplIC09IGVudHJ5LnNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0RW50cnkodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmRvY3MuZ2V0KGRvY3VtZW50S2V5KTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoZW50cnlcclxuICAgICAgICAgICAgPyBlbnRyeS5kb2N1bWVudC5tdXRhYmxlQ29weSgpXHJcbiAgICAgICAgICAgIDogTXV0YWJsZURvY3VtZW50Lm5ld0ludmFsaWREb2N1bWVudChkb2N1bWVudEtleSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0RW50cmllcyh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXlzKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBtdXRhYmxlRG9jdW1lbnRNYXAoKTtcclxuICAgICAgICBkb2N1bWVudEtleXMuZm9yRWFjaChkb2N1bWVudEtleSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5kb2NzLmdldChkb2N1bWVudEtleSk7XHJcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmluc2VydChkb2N1bWVudEtleSwgZW50cnlcclxuICAgICAgICAgICAgICAgID8gZW50cnkuZG9jdW1lbnQubXV0YWJsZUNvcHkoKVxyXG4gICAgICAgICAgICAgICAgOiBNdXRhYmxlRG9jdW1lbnQubmV3SW52YWxpZERvY3VtZW50KGRvY3VtZW50S2V5KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsKHRyYW5zYWN0aW9uLCBjb2xsZWN0aW9uUGF0aCwgc2luY2VSZWFkVGltZSkge1xyXG4gICAgICAgIGxldCByZXN1bHRzID0gbXV0YWJsZURvY3VtZW50TWFwKCk7XHJcbiAgICAgICAgLy8gRG9jdW1lbnRzIGFyZSBvcmRlcmVkIGJ5IGtleSwgc28gd2UgY2FuIHVzZSBhIHByZWZpeCBzY2FuIHRvIG5hcnJvdyBkb3duXHJcbiAgICAgICAgLy8gdGhlIGRvY3VtZW50cyB3ZSBuZWVkIHRvIG1hdGNoIHRoZSBxdWVyeSBhZ2FpbnN0LlxyXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5ldyBEb2N1bWVudEtleShjb2xsZWN0aW9uUGF0aC5jaGlsZCgnJykpO1xyXG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5kb2NzLmdldEl0ZXJhdG9yRnJvbShwcmVmaXgpO1xyXG4gICAgICAgIHdoaWxlIChpdGVyYXRvci5oYXNOZXh0KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlOiB7IGRvY3VtZW50IH0gfSA9IGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9uUGF0aC5pc1ByZWZpeE9mKGtleS5wYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGtleS5wYXRoLmxlbmd0aCA+IGNvbGxlY3Rpb25QYXRoLmxlbmd0aCArIDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgZW50cmllcyBmcm9tIHN1YmNvbGxlY3Rpb25zLlxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWRUaW1lLmNvbXBhcmVUbyhzaW5jZVJlYWRUaW1lKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5pbnNlcnQoZG9jdW1lbnQua2V5LCBkb2N1bWVudC5tdXRhYmxlQ29weSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaERvY3VtZW50S2V5KHRyYW5zYWN0aW9uLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHRoaXMuZG9jcywgKGtleSkgPT4gZihrZXkpKTtcclxuICAgIH1cclxuICAgIG5ld0NoYW5nZUJ1ZmZlcihvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gYHRyYWNrUmVtb3ZhbHNgIGlzIGlnbm9yZXMgc2luY2UgdGhlIE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUga2VlcHNcclxuICAgICAgICAvLyBhIHNlcGFyYXRlIGNoYW5nZWxvZyBhbmQgZG9lcyBub3QgbmVlZCBzcGVjaWFsIGhhbmRsaW5nIGZvciByZW1vdmFscy5cclxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0U2l6ZSh0eG4pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5zaXplKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtZW1vcnktb25seSBSZW1vdGVEb2N1bWVudENhY2hlLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2l6ZXIgLSBVc2VkIHRvIGFzc2VzcyB0aGUgc2l6ZSBvZiBhIGRvY3VtZW50LiBGb3IgZWFnZXIgR0MsIHRoaXMgaXNcclxuICogZXhwZWN0ZWQgdG8ganVzdCByZXR1cm4gMCB0byBhdm9pZCB1bm5lY2Vzc2FyaWx5IGRvaW5nIHRoZSB3b3JrIG9mXHJcbiAqIGNhbGN1bGF0aW5nIHRoZSBzaXplLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3TWVtb3J5UmVtb3RlRG9jdW1lbnRDYWNoZShzaXplcikge1xyXG4gICAgcmV0dXJuIG5ldyBNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlSW1wbChzaXplcik7XHJcbn1cclxuLyoqXHJcbiAqIEhhbmRsZXMgdGhlIGRldGFpbHMgb2YgYWRkaW5nIGFuZCB1cGRhdGluZyBkb2N1bWVudHMgaW4gdGhlIE1lbW9yeVJlbW90ZURvY3VtZW50Q2FjaGUuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlSZW1vdGVEb2N1bWVudENoYW5nZUJ1ZmZlciBleHRlbmRzIFJlbW90ZURvY3VtZW50Q2hhbmdlQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50Q2FjaGUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRDYWNoZSA9IGRvY3VtZW50Q2FjaGU7XHJcbiAgICB9XHJcbiAgICBhcHBseUNoYW5nZXModHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlcy5mb3JFYWNoKChrZXksIGRvYykgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZG9jLmlzVmFsaWREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuZG9jdW1lbnRDYWNoZS5hZGRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50Q2FjaGUucmVtb3ZlRW50cnkoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2Uud2FpdEZvcihwcm9taXNlcyk7XHJcbiAgICB9XHJcbiAgICBnZXRGcm9tQ2FjaGUodHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRDYWNoZS5nZXRFbnRyeSh0cmFuc2FjdGlvbiwgZG9jdW1lbnRLZXkpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsRnJvbUNhY2hlKHRyYW5zYWN0aW9uLCBkb2N1bWVudEtleXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudENhY2hlLmdldEVudHJpZXModHJhbnNhY3Rpb24sIGRvY3VtZW50S2V5cyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5VGFyZ2V0Q2FjaGUge1xyXG4gICAgY29uc3RydWN0b3IocGVyc2lzdGVuY2UpIHtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFwcyBhIHRhcmdldCB0byB0aGUgZGF0YSBhYm91dCB0aGF0IHRhcmdldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IG5ldyBPYmplY3RNYXAodCA9PiBjYW5vbmlmeVRhcmdldCh0KSwgdGFyZ2V0RXF1YWxzKTtcclxuICAgICAgICAvKiogVGhlIGxhc3QgcmVjZWl2ZWQgc25hcHNob3QgdmVyc2lvbi4gKi9cclxuICAgICAgICB0aGlzLmxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24gPSBTbmFwc2hvdFZlcnNpb24ubWluKCk7XHJcbiAgICAgICAgLyoqIFRoZSBoaWdoZXN0IG51bWJlcmVkIHRhcmdldCBJRCBlbmNvdW50ZXJlZC4gKi9cclxuICAgICAgICB0aGlzLmhpZ2hlc3RUYXJnZXRJZCA9IDA7XHJcbiAgICAgICAgLyoqIFRoZSBoaWdoZXN0IHNlcXVlbmNlIG51bWJlciBlbmNvdW50ZXJlZC4gKi9cclxuICAgICAgICB0aGlzLmhpZ2hlc3RTZXF1ZW5jZU51bWJlciA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBvcmRlcmVkIGJpZGlyZWN0aW9uYWwgbWFwcGluZyBiZXR3ZWVuIGRvY3VtZW50cyBhbmQgdGhlIHJlbW90ZSB0YXJnZXRcclxuICAgICAgICAgKiBJRHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gbmV3IFJlZmVyZW5jZVNldCgpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWRHZW5lcmF0b3IgPSBUYXJnZXRJZEdlbmVyYXRvci5mb3JUYXJnZXRDYWNoZSgpO1xyXG4gICAgfVxyXG4gICAgZm9yRWFjaFRhcmdldCh0eG4sIGYpIHtcclxuICAgICAgICB0aGlzLnRhcmdldHMuZm9yRWFjaCgoXywgdGFyZ2V0RGF0YSkgPT4gZih0YXJnZXREYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBnZXRMYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMubGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICBnZXRIaWdoZXN0U2VxdWVuY2VOdW1iZXIodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgYWxsb2NhdGVUYXJnZXRJZCh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gdGhpcy50YXJnZXRJZEdlbmVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMuaGlnaGVzdFRhcmdldElkKTtcclxuICAgIH1cclxuICAgIHNldFRhcmdldHNNZXRhZGF0YSh0cmFuc2FjdGlvbiwgaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyLCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgaWYgKGxhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uID0gbGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhpZ2hlc3RMaXN0ZW5TZXF1ZW5jZU51bWJlciA+IHRoaXMuaGlnaGVzdFNlcXVlbmNlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGVzdFNlcXVlbmNlTnVtYmVyID0gaGlnaGVzdExpc3RlblNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHNhdmVUYXJnZXREYXRhKHRhcmdldERhdGEpIHtcclxuICAgICAgICB0aGlzLnRhcmdldHMuc2V0KHRhcmdldERhdGEudGFyZ2V0LCB0YXJnZXREYXRhKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHRhcmdldERhdGEudGFyZ2V0SWQ7XHJcbiAgICAgICAgaWYgKHRhcmdldElkID4gdGhpcy5oaWdoZXN0VGFyZ2V0SWQpIHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXRJZEdlbmVyYXRvciA9IG5ldyBUYXJnZXRJZEdlbmVyYXRvcih0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGVzdFRhcmdldElkID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyID4gdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdoZXN0U2VxdWVuY2VOdW1iZXIgPSB0YXJnZXREYXRhLnNlcXVlbmNlTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZFRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcclxuICAgICAgICB0aGlzLnNhdmVUYXJnZXREYXRhKHRhcmdldERhdGEpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0Q291bnQgKz0gMTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVRhcmdldERhdGEodHJhbnNhY3Rpb24sIHRhcmdldERhdGEpIHtcclxuICAgICAgICB0aGlzLnNhdmVUYXJnZXREYXRhKHRhcmdldERhdGEpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlVGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0RGF0YSkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0cy5kZWxldGUodGFyZ2V0RGF0YS50YXJnZXQpO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0RGF0YS50YXJnZXRJZCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXRDb3VudCAtPSAxO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlVGFyZ2V0cyh0cmFuc2FjdGlvbiwgdXBwZXJCb3VuZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBjb25zdCByZW1vdmFscyA9IFtdO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0cy5mb3JFYWNoKChrZXksIHRhcmdldERhdGEpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIgPD0gdXBwZXJCb3VuZCAmJlxyXG4gICAgICAgICAgICAgICAgYWN0aXZlVGFyZ2V0SWRzLmdldCh0YXJnZXREYXRhLnRhcmdldElkKSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZhbHMucHVzaCh0aGlzLnJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHRyYW5zYWN0aW9uLCB0YXJnZXREYXRhLnRhcmdldElkKSk7XHJcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHJlbW92YWxzKS5uZXh0KCgpID0+IGNvdW50KTtcclxuICAgIH1cclxuICAgIGdldFRhcmdldENvdW50KHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMudGFyZ2V0Q291bnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0VGFyZ2V0RGF0YSh0cmFuc2FjdGlvbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRoaXMudGFyZ2V0cy5nZXQodGFyZ2V0KSB8fCBudWxsO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSh0YXJnZXREYXRhKTtcclxuICAgIH1cclxuICAgIGFkZE1hdGNoaW5nS2V5cyh0eG4sIGtleXMsIHRhcmdldElkKSB7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzLmFkZFJlZmVyZW5jZXMoa2V5cywgdGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTWF0Y2hpbmdLZXlzKHR4biwga2V5cywgdGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlcyhrZXlzLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlRGVsZWdhdGUgPSB0aGlzLnBlcnNpc3RlbmNlLnJlZmVyZW5jZURlbGVnYXRlO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgaWYgKHJlZmVyZW5jZURlbGVnYXRlKSB7XHJcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChyZWZlcmVuY2VEZWxlZ2F0ZS5tYXJrUG90ZW50aWFsbHlPcnBoYW5lZCh0eG4sIGtleSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS53YWl0Rm9yKHByb21pc2VzKTtcclxuICAgIH1cclxuICAgIHJlbW92ZU1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLnJlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlc0ZvcklkKHRhcmdldElkKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIGdldE1hdGNoaW5nS2V5c0ZvclRhcmdldElkKHR4biwgdGFyZ2V0SWQpIHtcclxuICAgICAgICBjb25zdCBtYXRjaGluZ0tleXMgPSB0aGlzLnJlZmVyZW5jZXMucmVmZXJlbmNlc0ZvcklkKHRhcmdldElkKTtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUobWF0Y2hpbmdLZXlzKTtcclxuICAgIH1cclxuICAgIGNvbnRhaW5zS2V5KHR4biwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVmZXJlbmNlcy5jb250YWluc0tleShrZXkpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJGIgPSAnTWVtb3J5UGVyc2lzdGVuY2UnO1xyXG4vKipcclxuICogQSBtZW1vcnktYmFja2VkIGluc3RhbmNlIG9mIFBlcnNpc3RlbmNlLiBEYXRhIGlzIHN0b3JlZCBvbmx5IGluIFJBTSBhbmRcclxuICogbm90IHBlcnNpc3RlZCBhY3Jvc3Mgc2Vzc2lvbnMuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlQZXJzaXN0ZW5jZSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBhY2NlcHRzIGEgZmFjdG9yeSBmb3IgY3JlYXRpbmcgYSByZWZlcmVuY2UgZGVsZWdhdGUuIFRoaXNcclxuICAgICAqIGFsbG93cyBib3RoIHRoZSBkZWxlZ2F0ZSBhbmQgdGhpcyBpbnN0YW5jZSB0byBoYXZlIHN0cm9uZyByZWZlcmVuY2VzIHRvXHJcbiAgICAgKiBlYWNoIG90aGVyIHdpdGhvdXQgaGF2aW5nIG51bGxhYmxlIGZpZWxkcyB0aGF0IHdvdWxkIHRoZW4gbmVlZCB0byBiZVxyXG4gICAgICogY2hlY2tlZCBvciBhc3NlcnRlZCBvbiBldmVyeSBhY2Nlc3MuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlZmVyZW5jZURlbGVnYXRlRmFjdG9yeSwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25RdWV1ZXMgPSB7fTtcclxuICAgICAgICB0aGlzLm92ZXJsYXlzID0ge307XHJcbiAgICAgICAgdGhpcy5saXN0ZW5TZXF1ZW5jZSA9IG5ldyBMaXN0ZW5TZXF1ZW5jZSgwKTtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZSA9IHJlZmVyZW5jZURlbGVnYXRlRmFjdG9yeSh0aGlzKTtcclxuICAgICAgICB0aGlzLnRhcmdldENhY2hlID0gbmV3IE1lbW9yeVRhcmdldENhY2hlKHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IHNpemVyID0gKGRvYykgPT4gdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZS5kb2N1bWVudFNpemUoZG9jKTtcclxuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IG5ldyBNZW1vcnlJbmRleE1hbmFnZXIoKTtcclxuICAgICAgICB0aGlzLnJlbW90ZURvY3VtZW50Q2FjaGUgPSBuZXdNZW1vcnlSZW1vdGVEb2N1bWVudENhY2hlKHNpemVyKTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXcgTG9jYWxTZXJpYWxpemVyKHNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHRoaXMuYnVuZGxlQ2FjaGUgPSBuZXcgTWVtb3J5QnVuZGxlQ2FjaGUodGhpcy5zZXJpYWxpemVyKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIC8vIE5vIGR1cmFibGUgc3RhdGUgdG8gZW5zdXJlIGlzIGNsb3NlZCBvbiBzaHV0ZG93bi5cclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7XHJcbiAgICB9XHJcbiAgICBzZXREYXRhYmFzZURlbGV0ZWRMaXN0ZW5lcigpIHtcclxuICAgICAgICAvLyBObyBvcC5cclxuICAgIH1cclxuICAgIHNldE5ldHdvcmtFbmFibGVkKCkge1xyXG4gICAgICAgIC8vIE5vIG9wLlxyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhNYW5hZ2VyKHVzZXIpIHtcclxuICAgICAgICAvLyBXZSBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgaW5kaWNlcyBmb3IgbWVtb3J5IHBlcnNpc3RlbmNlLCBzbyB3ZSBjYW5cclxuICAgICAgICAvLyByZXR1cm4gdGhlIHNhbWUgc2hhcmVkIGluc3RhbmNlIG9mIHRoZSBtZW1vcnkgaW5kZXggbWFuYWdlci5cclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXI7XHJcbiAgICB9XHJcbiAgICBnZXREb2N1bWVudE92ZXJsYXlDYWNoZSh1c2VyKSB7XHJcbiAgICAgICAgbGV0IG92ZXJsYXkgPSB0aGlzLm92ZXJsYXlzW3VzZXIudG9LZXkoKV07XHJcbiAgICAgICAgaWYgKCFvdmVybGF5KSB7XHJcbiAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgTWVtb3J5RG9jdW1lbnRPdmVybGF5Q2FjaGUoKTtcclxuICAgICAgICAgICAgdGhpcy5vdmVybGF5c1t1c2VyLnRvS2V5KCldID0gb3ZlcmxheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG92ZXJsYXk7XHJcbiAgICB9XHJcbiAgICBnZXRNdXRhdGlvblF1ZXVlKHVzZXIsIGluZGV4TWFuYWdlcikge1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IHRoaXMubXV0YXRpb25RdWV1ZXNbdXNlci50b0tleSgpXTtcclxuICAgICAgICBpZiAoIXF1ZXVlKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlID0gbmV3IE1lbW9yeU11dGF0aW9uUXVldWUoaW5kZXhNYW5hZ2VyLCB0aGlzLnJlZmVyZW5jZURlbGVnYXRlKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvblF1ZXVlc1t1c2VyLnRvS2V5KCldID0gcXVldWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBxdWV1ZTtcclxuICAgIH1cclxuICAgIGdldFRhcmdldENhY2hlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldENhY2hlO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVtb3RlRG9jdW1lbnRDYWNoZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVEb2N1bWVudENhY2hlO1xyXG4gICAgfVxyXG4gICAgZ2V0QnVuZGxlQ2FjaGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVuZGxlQ2FjaGU7XHJcbiAgICB9XHJcbiAgICBydW5UcmFuc2FjdGlvbihhY3Rpb24sIG1vZGUsIHRyYW5zYWN0aW9uT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRiLCAnU3RhcnRpbmcgdHJhbnNhY3Rpb246JywgYWN0aW9uKTtcclxuICAgICAgICBjb25zdCB0eG4gPSBuZXcgTWVtb3J5VHJhbnNhY3Rpb24odGhpcy5saXN0ZW5TZXF1ZW5jZS5uZXh0KCkpO1xyXG4gICAgICAgIHRoaXMucmVmZXJlbmNlRGVsZWdhdGUub25UcmFuc2FjdGlvblN0YXJ0ZWQoKTtcclxuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25PcGVyYXRpb24odHhuKVxyXG4gICAgICAgICAgICAubmV4dChyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VEZWxlZ2F0ZVxyXG4gICAgICAgICAgICAgICAgLm9uVHJhbnNhY3Rpb25Db21taXR0ZWQodHhuKVxyXG4gICAgICAgICAgICAgICAgLm5leHQoKCkgPT4gcmVzdWx0KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAudG9Qcm9taXNlKClcclxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdHhuLnJhaXNlT25Db21taXR0ZWRFdmVudCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbXV0YXRpb25RdWV1ZXNDb250YWluS2V5KHRyYW5zYWN0aW9uLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLm9yKE9iamVjdC52YWx1ZXModGhpcy5tdXRhdGlvblF1ZXVlcykubWFwKHF1ZXVlID0+ICgpID0+IHF1ZXVlLmNvbnRhaW5zS2V5KHRyYW5zYWN0aW9uLCBrZXkpKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1lbW9yeSBwZXJzaXN0ZW5jZSBpcyBub3QgYWN0dWFsbHkgdHJhbnNhY3Rpb25hbCwgYnV0IGZ1dHVyZSBpbXBsZW1lbnRhdGlvbnNcclxuICogbWF5IGhhdmUgdHJhbnNhY3Rpb24tc2NvcGVkIHN0YXRlLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5VHJhbnNhY3Rpb24gZXh0ZW5kcyBQZXJzaXN0ZW5jZVRyYW5zYWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGN1cnJlbnRTZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2VxdWVuY2VOdW1iZXIgPSBjdXJyZW50U2VxdWVuY2VOdW1iZXI7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTWVtb3J5RWFnZXJEZWxlZ2F0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcclxuICAgICAgICAvKiogVHJhY2tzIGFsbCBkb2N1bWVudHMgdGhhdCBhcmUgYWN0aXZlIGluIFF1ZXJ5IHZpZXdzLiAqL1xyXG4gICAgICAgIHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcyA9IG5ldyBSZWZlcmVuY2VTZXQoKTtcclxuICAgICAgICAvKiogVGhlIGxpc3Qgb2YgZG9jdW1lbnRzIHRoYXQgYXJlIHBvdGVudGlhbGx5IEdDZWQgYWZ0ZXIgZWFjaCB0cmFuc2FjdGlvbi4gKi9cclxuICAgICAgICB0aGlzLl9vcnBoYW5lZERvY3VtZW50cyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZmFjdG9yeShwZXJzaXN0ZW5jZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWVtb3J5RWFnZXJEZWxlZ2F0ZShwZXJzaXN0ZW5jZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgb3JwaGFuZWREb2N1bWVudHMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9vcnBoYW5lZERvY3VtZW50cykge1xyXG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JwaGFuZWREb2N1bWVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xyXG4gICAgICAgIHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5hZGRSZWZlcmVuY2Uoa2V5LCB0YXJnZXRJZCk7XHJcbiAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5kZWxldGUoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVmZXJlbmNlKHR4biwgdGFyZ2V0SWQsIGtleSkge1xyXG4gICAgICAgIHRoaXMubG9jYWxWaWV3UmVmZXJlbmNlcy5yZW1vdmVSZWZlcmVuY2Uoa2V5LCB0YXJnZXRJZCk7XHJcbiAgICAgICAgdGhpcy5vcnBoYW5lZERvY3VtZW50cy5hZGQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBQZXJzaXN0ZW5jZVByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgbWFya1BvdGVudGlhbGx5T3JwaGFuZWQodHhuLCBrZXkpIHtcclxuICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmFkZChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVUYXJnZXQodHhuLCB0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgb3JwaGFuZWQgPSB0aGlzLmxvY2FsVmlld1JlZmVyZW5jZXMucmVtb3ZlUmVmZXJlbmNlc0ZvcklkKHRhcmdldERhdGEudGFyZ2V0SWQpO1xyXG4gICAgICAgIG9ycGhhbmVkLmZvckVhY2goa2V5ID0+IHRoaXMub3JwaGFuZWREb2N1bWVudHMuYWRkKGtleS50b1N0cmluZygpKSk7XHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCk7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlXHJcbiAgICAgICAgICAgIC5nZXRNYXRjaGluZ0tleXNGb3JUYXJnZXRJZCh0eG4sIHRhcmdldERhdGEudGFyZ2V0SWQpXHJcbiAgICAgICAgICAgIC5uZXh0KGtleXMgPT4ge1xyXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHRoaXMub3JwaGFuZWREb2N1bWVudHMuYWRkKGtleS50b1N0cmluZygpKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLm5leHQoKCkgPT4gY2FjaGUucmVtb3ZlVGFyZ2V0RGF0YSh0eG4sIHRhcmdldERhdGEpKTtcclxuICAgIH1cclxuICAgIG9uVHJhbnNhY3Rpb25TdGFydGVkKCkge1xyXG4gICAgICAgIHRoaXMuX29ycGhhbmVkRG9jdW1lbnRzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgb25UcmFuc2FjdGlvbkNvbW1pdHRlZCh0eG4pIHtcclxuICAgICAgICAvLyBSZW1vdmUgbmV3bHkgb3JwaGFuZWQgZG9jdW1lbnRzLlxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wZXJzaXN0ZW5jZS5nZXRSZW1vdGVEb2N1bWVudENhY2hlKCk7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlQnVmZmVyID0gY2FjaGUubmV3Q2hhbmdlQnVmZmVyKCk7XHJcbiAgICAgICAgcmV0dXJuIFBlcnNpc3RlbmNlUHJvbWlzZS5mb3JFYWNoKHRoaXMub3JwaGFuZWREb2N1bWVudHMsIChwYXRoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IERvY3VtZW50S2V5LmZyb21QYXRoKHBhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZWQodHhuLCBrZXkpLm5leHQoaXNSZWZlcmVuY2VkID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNSZWZlcmVuY2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQnVmZmVyLnJlbW92ZUVudHJ5KGtleSwgU25hcHNob3RWZXJzaW9uLm1pbigpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSkubmV4dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX29ycGhhbmVkRG9jdW1lbnRzID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZUJ1ZmZlci5hcHBseSh0eG4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTGltYm9Eb2N1bWVudCh0eG4sIGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzUmVmZXJlbmNlZCh0eG4sIGtleSkubmV4dChpc1JlZmVyZW5jZWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmRlbGV0ZShrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ycGhhbmVkRG9jdW1lbnRzLmFkZChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRvY3VtZW50U2l6ZShkb2MpIHtcclxuICAgICAgICAvLyBGb3IgZWFnZXIgR0MsIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGRvY3VtZW50IHNpemUsIHRoZXJlIGFyZSBubyBzaXplIHRocmVzaG9sZHMuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBpc1JlZmVyZW5jZWQodHhuLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUGVyc2lzdGVuY2VQcm9taXNlLm9yKFtcclxuICAgICAgICAgICAgKCkgPT4gUGVyc2lzdGVuY2VQcm9taXNlLnJlc29sdmUodGhpcy5sb2NhbFZpZXdSZWZlcmVuY2VzLmNvbnRhaW5zS2V5KGtleSkpLFxyXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLmdldFRhcmdldENhY2hlKCkuY29udGFpbnNLZXkodHhuLCBrZXkpLFxyXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnBlcnNpc3RlbmNlLm11dGF0aW9uUXVldWVzQ29udGFpbktleSh0eG4sIGtleSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBxdWVyeSBlbmdpbmUgdGhhdCB0YWtlcyBhZHZhbnRhZ2Ugb2YgdGhlIHRhcmdldCBkb2N1bWVudCBtYXBwaW5nIGluIHRoZVxyXG4gKiBRdWVyeUNhY2hlLiBRdWVyeSBleGVjdXRpb24gaXMgb3B0aW1pemVkIGJ5IG9ubHkgcmVhZGluZyB0aGUgZG9jdW1lbnRzIHRoYXRcclxuICogcHJldmlvdXNseSBtYXRjaGVkIGEgcXVlcnkgcGx1cyBhbnkgZG9jdW1lbnRzIHRoYXQgd2VyZSBlZGl0ZWQgYWZ0ZXIgdGhlXHJcbiAqIHF1ZXJ5IHdhcyBsYXN0IGxpc3RlbmVkIHRvLlxyXG4gKlxyXG4gKiBUaGVyZSBhcmUgc29tZSBjYXNlcyB3aGVuIHRoaXMgb3B0aW1pemF0aW9uIGlzIG5vdCBndWFyYW50ZWVkIHRvIHByb2R1Y2VcclxuICogdGhlIHNhbWUgcmVzdWx0cyBhcyBmdWxsIGNvbGxlY3Rpb24gc2NhbnMuIEluIHRoZXNlIGNhc2VzLCBxdWVyeVxyXG4gKiBwcm9jZXNzaW5nIGZhbGxzIGJhY2sgdG8gZnVsbCBzY2Fucy4gVGhlc2UgY2FzZXMgYXJlOlxyXG4gKlxyXG4gKiAtIExpbWl0IHF1ZXJpZXMgd2hlcmUgYSBkb2N1bWVudCB0aGF0IG1hdGNoZWQgdGhlIHF1ZXJ5IHByZXZpb3VzbHkgbm8gbG9uZ2VyXHJcbiAqICAgbWF0Y2hlcyB0aGUgcXVlcnkuXHJcbiAqXHJcbiAqIC0gTGltaXQgcXVlcmllcyB3aGVyZSBhIGRvY3VtZW50IGVkaXQgbWF5IGNhdXNlIHRoZSBkb2N1bWVudCB0byBzb3J0IGJlbG93XHJcbiAqICAgYW5vdGhlciBkb2N1bWVudCB0aGF0IGlzIGluIHRoZSBsb2NhbCBjYWNoZS5cclxuICpcclxuICogLSBRdWVyaWVzIHRoYXQgaGF2ZSBuZXZlciBiZWVuIENVUlJFTlQgb3IgZnJlZSBvZiBsaW1ibyBkb2N1bWVudHMuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUVuZ2luZSB7XHJcbiAgICAvKiogU2V0cyB0aGUgZG9jdW1lbnQgdmlldyB0byBxdWVyeSBhZ2FpbnN0LiAqL1xyXG4gICAgc2V0TG9jYWxEb2N1bWVudHNWaWV3KGxvY2FsRG9jdW1lbnRzKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcgPSBsb2NhbERvY3VtZW50cztcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGFsbCBsb2NhbCBkb2N1bWVudHMgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBxdWVyeS4gKi9cclxuICAgIGdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBsYXN0TGltYm9GcmVlU25hcHNob3RWZXJzaW9uLCByZW1vdGVLZXlzKSB7XHJcbiAgICAgICAgLy8gUXVlcmllcyB0aGF0IG1hdGNoIGFsbCBkb2N1bWVudHMgZG9uJ3QgYmVuZWZpdCBmcm9tIHVzaW5nXHJcbiAgICAgICAgLy8ga2V5LWJhc2VkIGxvb2t1cHMuIEl0IGlzIG1vcmUgZWZmaWNpZW50IHRvIHNjYW4gYWxsIGRvY3VtZW50cyBpbiBhXHJcbiAgICAgICAgLy8gY29sbGVjdGlvbiwgcmF0aGVyIHRoYW4gdG8gcGVyZm9ybSBpbmRpdmlkdWFsIGxvb2t1cHMuXHJcbiAgICAgICAgaWYgKG1hdGNoZXNBbGxEb2N1bWVudHMocXVlcnkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVGdWxsQ29sbGVjdGlvblNjYW4odHJhbnNhY3Rpb24sIHF1ZXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUXVlcmllcyB0aGF0IGhhdmUgbmV2ZXIgc2VlbiBhIHNuYXBzaG90IHdpdGhvdXQgbGltYm8gZnJlZSBkb2N1bWVudHNcclxuICAgICAgICAvLyBzaG91bGQgYWxzbyBiZSBydW4gYXMgYSBmdWxsIGNvbGxlY3Rpb24gc2Nhbi5cclxuICAgICAgICBpZiAobGFzdExpbWJvRnJlZVNuYXBzaG90VmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZUZ1bGxDb2xsZWN0aW9uU2Nhbih0cmFuc2FjdGlvbiwgcXVlcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcuZ2V0RG9jdW1lbnRzKHRyYW5zYWN0aW9uLCByZW1vdGVLZXlzKS5uZXh0KGRvY3VtZW50cyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUmVzdWx0cyA9IHRoaXMuYXBwbHlRdWVyeShxdWVyeSwgZG9jdW1lbnRzKTtcclxuICAgICAgICAgICAgaWYgKChoYXNMaW1pdFRvRmlyc3QocXVlcnkpIHx8IGhhc0xpbWl0VG9MYXN0KHF1ZXJ5KSkgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNSZWZpbGwocXVlcnkubGltaXRUeXBlLCBwcmV2aW91c1Jlc3VsdHMsIHJlbW90ZUtleXMsIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlRnVsbENvbGxlY3Rpb25TY2FuKHRyYW5zYWN0aW9uLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKCdRdWVyeUVuZ2luZScsICdSZS11c2luZyBwcmV2aW91cyByZXN1bHQgZnJvbSAlcyB0byBleGVjdXRlIHF1ZXJ5OiAlcycsIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24udG9TdHJpbmcoKSwgc3RyaW5naWZ5UXVlcnkocXVlcnkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXRyaWV2ZSBhbGwgcmVzdWx0cyBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZSB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0XHJcbiAgICAgICAgICAgIC8vIGxpbWJvLWRvY3VtZW50IGZyZWUgcmVtb3RlIHNuYXBzaG90LlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbERvY3VtZW50c1ZpZXcuZ2V0RG9jdW1lbnRzTWF0Y2hpbmdRdWVyeSh0cmFuc2FjdGlvbiwgcXVlcnksIGxhc3RMaW1ib0ZyZWVTbmFwc2hvdFZlcnNpb24pLm5leHQodXBkYXRlZFJlc3VsdHMgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbWVyZ2UgYHByZXZpb3VzUmVzdWx0c2AgaW50byBgdXBkYXRlUmVzdWx0c2AsIHNpbmNlXHJcbiAgICAgICAgICAgICAgICAvLyBgdXBkYXRlUmVzdWx0c2AgaXMgYWxyZWFkeSBhIERvY3VtZW50TWFwLiBJZiBhIGRvY3VtZW50IGlzXHJcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZWQgaW4gYm90aCBsaXN0cywgdGhlbiBpdHMgY29udGVudHMgYXJlIHRoZSBzYW1lLlxyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZXN1bHRzLmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkUmVzdWx0cyA9IHVwZGF0ZWRSZXN1bHRzLmluc2VydChkb2Mua2V5LCBkb2MpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlZFJlc3VsdHM7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEFwcGxpZXMgdGhlIHF1ZXJ5IGZpbHRlciBhbmQgc29ydGluZyB0byB0aGUgcHJvdmlkZWQgZG9jdW1lbnRzLiAgKi9cclxuICAgIGFwcGx5UXVlcnkocXVlcnksIGRvY3VtZW50cykge1xyXG4gICAgICAgIC8vIFNvcnQgdGhlIGRvY3VtZW50cyBhbmQgcmUtYXBwbHkgdGhlIHF1ZXJ5IGZpbHRlciBzaW5jZSBwcmV2aW91c2x5XHJcbiAgICAgICAgLy8gbWF0Y2hpbmcgZG9jdW1lbnRzIGRvIG5vdCBuZWNlc3NhcmlseSBzdGlsbCBtYXRjaCB0aGUgcXVlcnkuXHJcbiAgICAgICAgbGV0IHF1ZXJ5UmVzdWx0cyA9IG5ldyBTb3J0ZWRTZXQobmV3UXVlcnlDb21wYXJhdG9yKHF1ZXJ5KSk7XHJcbiAgICAgICAgZG9jdW1lbnRzLmZvckVhY2goKF8sIG1heWJlRG9jKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeU1hdGNoZXMocXVlcnksIG1heWJlRG9jKSkge1xyXG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzID0gcXVlcnlSZXN1bHRzLmFkZChtYXliZURvYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcXVlcnlSZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgbGltaXQgcXVlcnkgbmVlZHMgdG8gYmUgcmVmaWxsZWQgZnJvbSBjYWNoZSwgbWFraW5nIGl0XHJcbiAgICAgKiBpbmVsaWdpYmxlIGZvciBpbmRleC1mcmVlIGV4ZWN1dGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc29ydGVkUHJldmlvdXNSZXN1bHRzIC0gVGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoZWQgdGhlIHF1ZXJ5IHdoZW4gaXRcclxuICAgICAqIHdhcyBsYXN0IHN5bmNocm9uaXplZCwgc29ydGVkIGJ5IHRoZSBxdWVyeSdzIGNvbXBhcmF0b3IuXHJcbiAgICAgKiBAcGFyYW0gcmVtb3RlS2V5cyAtIFRoZSBkb2N1bWVudCBrZXlzIHRoYXQgbWF0Y2hlZCB0aGUgcXVlcnkgYXQgdGhlIGxhc3RcclxuICAgICAqIHNuYXBzaG90LlxyXG4gICAgICogQHBhcmFtIGxpbWJvRnJlZVNuYXBzaG90VmVyc2lvbiAtIFRoZSB2ZXJzaW9uIG9mIHRoZSBzbmFwc2hvdCB3aGVuIHRoZVxyXG4gICAgICogcXVlcnkgd2FzIGxhc3Qgc3luY2hyb25pemVkLlxyXG4gICAgICovXHJcbiAgICBuZWVkc1JlZmlsbChsaW1pdFR5cGUsIHNvcnRlZFByZXZpb3VzUmVzdWx0cywgcmVtb3RlS2V5cywgbGltYm9GcmVlU25hcHNob3RWZXJzaW9uKSB7XHJcbiAgICAgICAgLy8gVGhlIHF1ZXJ5IG5lZWRzIHRvIGJlIHJlZmlsbGVkIGlmIGEgcHJldmlvdXNseSBtYXRjaGluZyBkb2N1bWVudCBub1xyXG4gICAgICAgIC8vIGxvbmdlciBtYXRjaGVzLlxyXG4gICAgICAgIGlmIChyZW1vdGVLZXlzLnNpemUgIT09IHNvcnRlZFByZXZpb3VzUmVzdWx0cy5zaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMaW1pdCBxdWVyaWVzIGFyZSBub3QgZWxpZ2libGUgZm9yIGluZGV4LWZyZWUgcXVlcnkgZXhlY3V0aW9uIGlmIHRoZXJlIGlzXHJcbiAgICAgICAgLy8gYSBwb3RlbnRpYWwgdGhhdCBhbiBvbGRlciBkb2N1bWVudCBmcm9tIGNhY2hlIG5vdyBzb3J0cyBiZWZvcmUgYSBkb2N1bWVudFxyXG4gICAgICAgIC8vIHRoYXQgd2FzIHByZXZpb3VzbHkgcGFydCBvZiB0aGUgbGltaXQuIFRoaXMsIGhvd2V2ZXIsIGNhbiBvbmx5IGhhcHBlbiBpZlxyXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCBhdCB0aGUgZWRnZSBvZiB0aGUgbGltaXQgZ29lcyBvdXQgb2YgbGltaXQuXHJcbiAgICAgICAgLy8gSWYgYSBkb2N1bWVudCB0aGF0IGlzIG5vdCB0aGUgbGltaXQgYm91bmRhcnkgc29ydHMgZGlmZmVyZW50bHksXHJcbiAgICAgICAgLy8gdGhlIGJvdW5kYXJ5IG9mIHRoZSBsaW1pdCBpdHNlbGYgZGlkIG5vdCBjaGFuZ2UgYW5kIGRvY3VtZW50cyBmcm9tIGNhY2hlXHJcbiAgICAgICAgLy8gd2lsbCBjb250aW51ZSB0byBiZSBcInJlamVjdGVkXCIgYnkgdGhpcyBib3VuZGFyeS4gVGhlcmVmb3JlLCB3ZSBjYW4gaWdub3JlXHJcbiAgICAgICAgLy8gYW55IG1vZGlmaWNhdGlvbnMgdGhhdCBkb24ndCBhZmZlY3QgdGhlIGxhc3QgZG9jdW1lbnQuXHJcbiAgICAgICAgY29uc3QgZG9jQXRMaW1pdEVkZ2UgPSBsaW1pdFR5cGUgPT09IFwiRlwiIC8qIEZpcnN0ICovXHJcbiAgICAgICAgICAgID8gc29ydGVkUHJldmlvdXNSZXN1bHRzLmxhc3QoKVxyXG4gICAgICAgICAgICA6IHNvcnRlZFByZXZpb3VzUmVzdWx0cy5maXJzdCgpO1xyXG4gICAgICAgIGlmICghZG9jQXRMaW1pdEVkZ2UpIHtcclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZWZpbGwgdGhlIHF1ZXJ5IGlmIHRoZXJlIHdlcmUgYWxyZWFkeSBubyBkb2N1bWVudHMuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChkb2NBdExpbWl0RWRnZS5oYXNQZW5kaW5nV3JpdGVzIHx8XHJcbiAgICAgICAgICAgIGRvY0F0TGltaXRFZGdlLnZlcnNpb24uY29tcGFyZVRvKGxpbWJvRnJlZVNuYXBzaG90VmVyc2lvbikgPiAwKTtcclxuICAgIH1cclxuICAgIGV4ZWN1dGVGdWxsQ29sbGVjdGlvblNjYW4odHJhbnNhY3Rpb24sIHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPD0gTG9nTGV2ZWwuREVCVUcpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoJ1F1ZXJ5RW5naW5lJywgJ1VzaW5nIGZ1bGwgY29sbGVjdGlvbiBzY2FuIHRvIGV4ZWN1dGUgcXVlcnk6Jywgc3RyaW5naWZ5UXVlcnkocXVlcnkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxEb2N1bWVudHNWaWV3LmdldERvY3VtZW50c01hdGNoaW5nUXVlcnkodHJhbnNhY3Rpb24sIHF1ZXJ5LCBTbmFwc2hvdFZlcnNpb24ubWluKCkpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIFRoZSBmb3JtYXQgb2YgdGhlIExvY2FsU3RvcmFnZSBrZXkgdGhhdCBzdG9yZXMgdGhlIGNsaWVudCBzdGF0ZSBpczpcclxuLy8gICAgIGZpcmVzdG9yZV9jbGllbnRzXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxpbnN0YW5jZV9rZXk+XHJcbmNvbnN0IENMSUVOVF9TVEFURV9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9jbGllbnRzJztcclxuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciBhIGNsaWVudCBzdGF0ZSBpbiBXZWJTdG9yYWdlICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VDbGllbnRTdGF0ZUtleShwZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQpIHtcclxuICAgIHJldHVybiBgJHtDTElFTlRfU1RBVEVfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1fJHtjbGllbnRJZH1gO1xyXG59XHJcbi8vIFRoZSBmb3JtYXQgb2YgdGhlIFdlYlN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIHRoZSBtdXRhdGlvbiBzdGF0ZSBpczpcclxuLy8gICAgIGZpcmVzdG9yZV9tdXRhdGlvbnNfPHBlcnNpc3RlbmNlX3ByZWZpeD5fPGJhdGNoX2lkPlxyXG4vLyAgICAgKGZvciB1bmF1dGhlbnRpY2F0ZWQgdXNlcnMpXHJcbi8vIG9yOiBmaXJlc3RvcmVfbXV0YXRpb25zXzxwZXJzaXN0ZW5jZV9wcmVmaXg+XzxiYXRjaF9pZD5fPHVzZXJfdWlkPlxyXG4vL1xyXG4vLyAndXNlcl91aWQnIGlzIGxhc3QgdG8gYXZvaWQgbmVlZGluZyB0byBlc2NhcGUgJ18nIGNoYXJhY3RlcnMgdGhhdCBpdCBtaWdodFxyXG4vLyBjb250YWluLlxyXG5jb25zdCBNVVRBVElPTl9CQVRDSF9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9tdXRhdGlvbnMnO1xyXG4vKiogQXNzZW1ibGVzIHRoZSBrZXkgZm9yIGEgbXV0YXRpb24gYmF0Y2ggaW4gV2ViU3RvcmFnZSAqL1xyXG5mdW5jdGlvbiBjcmVhdGVXZWJTdG9yYWdlTXV0YXRpb25CYXRjaEtleShwZXJzaXN0ZW5jZUtleSwgdXNlciwgYmF0Y2hJZCkge1xyXG4gICAgbGV0IG11dGF0aW9uS2V5ID0gYCR7TVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWH1fJHtwZXJzaXN0ZW5jZUtleX1fJHtiYXRjaElkfWA7XHJcbiAgICBpZiAodXNlci5pc0F1dGhlbnRpY2F0ZWQoKSkge1xyXG4gICAgICAgIG11dGF0aW9uS2V5ICs9IGBfJHt1c2VyLnVpZH1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG11dGF0aW9uS2V5O1xyXG59XHJcbi8vIFRoZSBmb3JtYXQgb2YgdGhlIFdlYlN0b3JhZ2Uga2V5IHRoYXQgc3RvcmVzIGEgcXVlcnkgdGFyZ2V0J3MgbWV0YWRhdGEgaXM6XHJcbi8vICAgICBmaXJlc3RvcmVfdGFyZ2V0c188cGVyc2lzdGVuY2VfcHJlZml4Pl88dGFyZ2V0X2lkPlxyXG5jb25zdCBRVUVSWV9UQVJHRVRfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfdGFyZ2V0cyc7XHJcbi8qKiBBc3NlbWJsZXMgdGhlIGtleSBmb3IgYSBxdWVyeSBzdGF0ZSBpbiBXZWJTdG9yYWdlICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhS2V5KHBlcnNpc3RlbmNlS2V5LCB0YXJnZXRJZCkge1xyXG4gICAgcmV0dXJuIGAke1FVRVJZX1RBUkdFVF9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fV8ke3RhcmdldElkfWA7XHJcbn1cclxuLy8gVGhlIFdlYlN0b3JhZ2UgcHJlZml4IHRoYXQgc3RvcmVzIHRoZSBwcmltYXJ5IHRhYidzIG9ubGluZSBzdGF0ZS4gVGhlXHJcbi8vIGZvcm1hdCBvZiB0aGUga2V5IGlzOlxyXG4vLyAgICAgZmlyZXN0b3JlX29ubGluZV9zdGF0ZV88cGVyc2lzdGVuY2VfcHJlZml4PlxyXG5jb25zdCBPTkxJTkVfU1RBVEVfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfb25saW5lX3N0YXRlJztcclxuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciB0aGUgb25saW5lIHN0YXRlIG9mIHRoZSBwcmltYXJ5IHRhYi4gKi9cclxuZnVuY3Rpb24gY3JlYXRlV2ViU3RvcmFnZU9ubGluZVN0YXRlS2V5KHBlcnNpc3RlbmNlS2V5KSB7XHJcbiAgICByZXR1cm4gYCR7T05MSU5FX1NUQVRFX0tFWV9QUkVGSVh9XyR7cGVyc2lzdGVuY2VLZXl9YDtcclxufVxyXG4vLyBUaGUgV2ViU3RvcmFnZSBwcmVmaXggdGhhdCBwbGF5cyBhcyBhIGV2ZW50IHRvIGluZGljYXRlIHRoZSByZW1vdGUgZG9jdW1lbnRzXHJcbi8vIG1pZ2h0IGhhdmUgY2hhbmdlZCBkdWUgdG8gc29tZSBzZWNvbmRhcnkgdGFicyBsb2FkaW5nIGEgYnVuZGxlLlxyXG4vLyBmb3JtYXQgb2YgdGhlIGtleSBpczpcclxuLy8gICAgIGZpcmVzdG9yZV9idW5kbGVfbG9hZGVkXzxwZXJzaXN0ZW5jZUtleT5cclxuY29uc3QgQlVORExFX0xPQURFRF9LRVlfUFJFRklYID0gJ2ZpcmVzdG9yZV9idW5kbGVfbG9hZGVkJztcclxuZnVuY3Rpb24gY3JlYXRlQnVuZGxlTG9hZGVkS2V5KHBlcnNpc3RlbmNlS2V5KSB7XHJcbiAgICByZXR1cm4gYCR7QlVORExFX0xPQURFRF9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fWA7XHJcbn1cclxuLy8gVGhlIFdlYlN0b3JhZ2Uga2V5IHByZWZpeCBmb3IgdGhlIGtleSB0aGF0IHN0b3JlcyB0aGUgbGFzdCBzZXF1ZW5jZSBudW1iZXIgYWxsb2NhdGVkLiBUaGUga2V5XHJcbi8vIGxvb2tzIGxpa2UgJ2ZpcmVzdG9yZV9zZXF1ZW5jZV9udW1iZXJfPHBlcnNpc3RlbmNlX3ByZWZpeD4nLlxyXG5jb25zdCBTRVFVRU5DRV9OVU1CRVJfS0VZX1BSRUZJWCA9ICdmaXJlc3RvcmVfc2VxdWVuY2VfbnVtYmVyJztcclxuLyoqIEFzc2VtYmxlcyB0aGUga2V5IGZvciB0aGUgY3VycmVudCBzZXF1ZW5jZSBudW1iZXIuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYlN0b3JhZ2VTZXF1ZW5jZU51bWJlcktleShwZXJzaXN0ZW5jZUtleSkge1xyXG4gICAgcmV0dXJuIGAke1NFUVVFTkNFX05VTUJFUl9LRVlfUFJFRklYfV8ke3BlcnNpc3RlbmNlS2V5fWA7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyRhID0gJ1NoYXJlZENsaWVudFN0YXRlJztcclxuLyoqXHJcbiAqIEhvbGRzIHRoZSBzdGF0ZSBvZiBhIG11dGF0aW9uIGJhdGNoLCBpbmNsdWRpbmcgaXRzIHVzZXIgSUQsIGJhdGNoIElEIGFuZFxyXG4gKiB3aGV0aGVyIHRoZSBiYXRjaCBpcyAncGVuZGluZycsICdhY2tub3dsZWRnZWQnIG9yICdyZWplY3RlZCcuXHJcbiAqL1xyXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXHJcbmNsYXNzIE11dGF0aW9uTWV0YWRhdGEge1xyXG4gICAgY29uc3RydWN0b3IodXNlciwgYmF0Y2hJZCwgc3RhdGUsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcclxuICAgICAgICB0aGlzLmJhdGNoSWQgPSBiYXRjaElkO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyBhIE11dGF0aW9uTWV0YWRhdGEgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiBpbiBXZWJTdG9yYWdlLlxyXG4gICAgICogTG9ncyBhIHdhcm5pbmcgYW5kIHJldHVybnMgbnVsbCBpZiB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhIGlzIG5vdCB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21XZWJTdG9yYWdlRW50cnkodXNlciwgYmF0Y2hJZCwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbkJhdGNoID0gSlNPTi5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgbGV0IHZhbGlkRGF0YSA9IHR5cGVvZiBtdXRhdGlvbkJhdGNoID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICBbJ3BlbmRpbmcnLCAnYWNrbm93bGVkZ2VkJywgJ3JlamVjdGVkJ10uaW5kZXhPZihtdXRhdGlvbkJhdGNoLnN0YXRlKSAhPT1cclxuICAgICAgICAgICAgICAgIC0xICYmXHJcbiAgICAgICAgICAgIChtdXRhdGlvbkJhdGNoLmVycm9yID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBtdXRhdGlvbkJhdGNoLmVycm9yID09PSAnb2JqZWN0Jyk7XHJcbiAgICAgICAgbGV0IGZpcmVzdG9yZUVycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh2YWxpZERhdGEgJiYgbXV0YXRpb25CYXRjaC5lcnJvcikge1xyXG4gICAgICAgICAgICB2YWxpZERhdGEgPVxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIG11dGF0aW9uQmF0Y2guZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbXV0YXRpb25CYXRjaC5lcnJvci5jb2RlID09PSAnc3RyaW5nJztcclxuICAgICAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZmlyZXN0b3JlRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IobXV0YXRpb25CYXRjaC5lcnJvci5jb2RlLCBtdXRhdGlvbkJhdGNoLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWxpZERhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdXRhdGlvbk1ldGFkYXRhKHVzZXIsIGJhdGNoSWQsIG11dGF0aW9uQmF0Y2guc3RhdGUsIGZpcmVzdG9yZUVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKExPR19UQUckYSwgYEZhaWxlZCB0byBwYXJzZSBtdXRhdGlvbiBzdGF0ZSBmb3IgSUQgJyR7YmF0Y2hJZH0nOiAke3ZhbHVlfWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1dlYlN0b3JhZ2VKU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGJhdGNoTWV0YWRhdGEgPSB7XHJcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxyXG4gICAgICAgICAgICB1cGRhdGVUaW1lTXM6IERhdGUubm93KCkgLy8gTW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byB0cmlnZ2VyIHVwZGF0ZS5cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XHJcbiAgICAgICAgICAgIGJhdGNoTWV0YWRhdGEuZXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlOiB0aGlzLmVycm9yLmNvZGUsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmVycm9yLm1lc3NhZ2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJhdGNoTWV0YWRhdGEpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIb2xkcyB0aGUgc3RhdGUgb2YgYSBxdWVyeSB0YXJnZXQsIGluY2x1ZGluZyBpdHMgdGFyZ2V0IElEIGFuZCB3aGV0aGVyIHRoZVxyXG4gKiB0YXJnZXQgaXMgJ25vdC1jdXJyZW50JywgJ2N1cnJlbnQnIG9yICdyZWplY3RlZCcuXHJcbiAqL1xyXG4vLyBWaXNpYmxlIGZvciB0ZXN0aW5nXHJcbmNsYXNzIFF1ZXJ5VGFyZ2V0TWV0YWRhdGEge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBRdWVyeVRhcmdldE1ldGFkYXRhIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gaW4gV2ViU3RvcmFnZS5cclxuICAgICAqIExvZ3MgYSB3YXJuaW5nIGFuZCByZXR1cm5zIG51bGwgaWYgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YSBpcyBub3QgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tV2ViU3RvcmFnZUVudHJ5KHRhcmdldElkLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgbGV0IHZhbGlkRGF0YSA9IHR5cGVvZiB0YXJnZXRTdGF0ZSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgWydub3QtY3VycmVudCcsICdjdXJyZW50JywgJ3JlamVjdGVkJ10uaW5kZXhPZih0YXJnZXRTdGF0ZS5zdGF0ZSkgIT09XHJcbiAgICAgICAgICAgICAgICAtMSAmJlxyXG4gICAgICAgICAgICAodGFyZ2V0U3RhdGUuZXJyb3IgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFN0YXRlLmVycm9yID09PSAnb2JqZWN0Jyk7XHJcbiAgICAgICAgbGV0IGZpcmVzdG9yZUVycm9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh2YWxpZERhdGEgJiYgdGFyZ2V0U3RhdGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgdmFsaWREYXRhID1cclxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRTdGF0ZS5lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRTdGF0ZS5lcnJvci5jb2RlID09PSAnc3RyaW5nJztcclxuICAgICAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgZmlyZXN0b3JlRXJyb3IgPSBuZXcgRmlyZXN0b3JlRXJyb3IodGFyZ2V0U3RhdGUuZXJyb3IuY29kZSwgdGFyZ2V0U3RhdGUuZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5VGFyZ2V0TWV0YWRhdGEodGFyZ2V0SWQsIHRhcmdldFN0YXRlLnN0YXRlLCBmaXJlc3RvcmVFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGEsIGBGYWlsZWQgdG8gcGFyc2UgdGFyZ2V0IHN0YXRlIGZvciBJRCAnJHt0YXJnZXRJZH0nOiAke3ZhbHVlfWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1dlYlN0b3JhZ2VKU09OKCkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFN0YXRlID0ge1xyXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcclxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5lcnJvcikge1xyXG4gICAgICAgICAgICB0YXJnZXRTdGF0ZS5lcnJvciA9IHtcclxuICAgICAgICAgICAgICAgIGNvZGU6IHRoaXMuZXJyb3IuY29kZSxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuZXJyb3IubWVzc2FnZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGFyZ2V0U3RhdGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIGltbXV0YWJsZSBDbGllbnRTdGF0ZSBmb3IgYSBjbGllbnQgcmVhZCBmcm9tXHJcbiAqIFdlYlN0b3JhZ2UsIGNvbnRhaW5pbmcgdGhlIGxpc3Qgb2YgYWN0aXZlIHF1ZXJ5IHRhcmdldHMuXHJcbiAqL1xyXG5jbGFzcyBSZW1vdGVDbGllbnRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgYWN0aXZlVGFyZ2V0SWRzKSB7XHJcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gYWN0aXZlVGFyZ2V0SWRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBSZW1vdGVDbGllbnRTdGF0ZSBmcm9tIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIGluIFdlYlN0b3JhZ2UuXHJcbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVdlYlN0b3JhZ2VFbnRyeShjbGllbnRJZCwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IEpTT04ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgIGxldCB2YWxpZERhdGEgPSB0eXBlb2YgY2xpZW50U3RhdGUgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgIGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkcyBpbnN0YW5jZW9mIEFycmF5O1xyXG4gICAgICAgIGxldCBhY3RpdmVUYXJnZXRJZHNTZXQgPSB0YXJnZXRJZFNldCgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyB2YWxpZERhdGEgJiYgaSA8IGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YWxpZERhdGEgPSBpc1NhZmVJbnRlZ2VyKGNsaWVudFN0YXRlLmFjdGl2ZVRhcmdldElkc1tpXSk7XHJcbiAgICAgICAgICAgIGFjdGl2ZVRhcmdldElkc1NldCA9IGFjdGl2ZVRhcmdldElkc1NldC5hZGQoY2xpZW50U3RhdGUuYWN0aXZlVGFyZ2V0SWRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlbW90ZUNsaWVudFN0YXRlKGNsaWVudElkLCBhY3RpdmVUYXJnZXRJZHNTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCBgRmFpbGVkIHRvIHBhcnNlIGNsaWVudCBkYXRhIGZvciBpbnN0YW5jZSAnJHtjbGllbnRJZH0nOiAke3ZhbHVlfWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgb25saW5lIHN0YXRlIGZvciBhbGwgY2xpZW50cyBwYXJ0aWNpcGF0aW5nIGluXHJcbiAqIG11bHRpLXRhYi4gVGhlIG9ubGluZSBzdGF0ZSBpcyBvbmx5IHdyaXR0ZW4gdG8gYnkgdGhlIHByaW1hcnkgY2xpZW50LCBhbmRcclxuICogdXNlZCBpbiBzZWNvbmRhcnkgY2xpZW50cyB0byB1cGRhdGUgdGhlaXIgcXVlcnkgdmlld3MuXHJcbiAqL1xyXG5jbGFzcyBTaGFyZWRPbmxpbmVTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgb25saW5lU3RhdGUpIHtcclxuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZSA9IG9ubGluZVN0YXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBTaGFyZWRPbmxpbmVTdGF0ZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIGluIFdlYlN0b3JhZ2UuXHJcbiAgICAgKiBMb2dzIGEgd2FybmluZyBhbmQgcmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGEgaXMgbm90IHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVdlYlN0b3JhZ2VFbnRyeSh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG9ubGluZVN0YXRlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgdmFsaWREYXRhID0gdHlwZW9mIG9ubGluZVN0YXRlID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICBbJ1Vua25vd24nLCAnT25saW5lJywgJ09mZmxpbmUnXS5pbmRleE9mKG9ubGluZVN0YXRlLm9ubGluZVN0YXRlKSAhPT1cclxuICAgICAgICAgICAgICAgIC0xICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBvbmxpbmVTdGF0ZS5jbGllbnRJZCA9PT0gJ3N0cmluZyc7XHJcbiAgICAgICAgaWYgKHZhbGlkRGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYXJlZE9ubGluZVN0YXRlKG9ubGluZVN0YXRlLmNsaWVudElkLCBvbmxpbmVTdGF0ZS5vbmxpbmVTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsb2dFcnJvcihMT0dfVEFHJGEsIGBGYWlsZWQgdG8gcGFyc2Ugb25saW5lIHN0YXRlOiAke3ZhbHVlfWApO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1ldGFkYXRhIHN0YXRlIG9mIHRoZSBsb2NhbCBjbGllbnQuIFVubGlrZSBgUmVtb3RlQ2xpZW50U3RhdGVgLCB0aGlzIGNsYXNzIGlzXHJcbiAqIG11dGFibGUgYW5kIGtlZXBzIHRyYWNrIG9mIGFsbCBwZW5kaW5nIG11dGF0aW9ucywgd2hpY2ggYWxsb3dzIHVzIHRvXHJcbiAqIHVwZGF0ZSB0aGUgcmFuZ2Ugb2YgcGVuZGluZyBtdXRhdGlvbiBiYXRjaCBJRHMgYXMgbmV3IG11dGF0aW9ucyBhcmUgYWRkZWQgb3JcclxuICogcmVtb3ZlZC5cclxuICpcclxuICogVGhlIGRhdGEgaW4gYExvY2FsQ2xpZW50U3RhdGVgIGlzIG5vdCByZWFkIGZyb20gV2ViU3RvcmFnZSBhbmQgaW5zdGVhZFxyXG4gKiB1cGRhdGVkIHZpYSBpdHMgaW5zdGFuY2UgbWV0aG9kcy4gVGhlIHVwZGF0ZWQgc3RhdGUgY2FuIGJlIHNlcmlhbGl6ZWQgdmlhXHJcbiAqIGB0b1dlYlN0b3JhZ2VKU09OKClgLlxyXG4gKi9cclxuLy8gVmlzaWJsZSBmb3IgdGVzdGluZy5cclxuY2xhc3MgTG9jYWxDbGllbnRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZVRhcmdldElkcyA9IHRhcmdldElkU2V0KCk7XHJcbiAgICB9XHJcbiAgICBhZGRRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0SWRzID0gdGhpcy5hY3RpdmVUYXJnZXRJZHMuYWRkKHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRJZHMgPSB0aGlzLmFjdGl2ZVRhcmdldElkcy5kZWxldGUodGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIGVudHJ5IGludG8gYSBKU09OLWVuY29kZWQgZm9ybWF0IHdlIGNhbiB1c2UgZm9yIFdlYlN0b3JhZ2UuXHJcbiAgICAgKiBEb2VzIG5vdCBlbmNvZGUgYGNsaWVudElkYCBhcyBpdCBpcyBwYXJ0IG9mIHRoZSBrZXkgaW4gV2ViU3RvcmFnZS5cclxuICAgICAqL1xyXG4gICAgdG9XZWJTdG9yYWdlSlNPTigpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0ge1xyXG4gICAgICAgICAgICBhY3RpdmVUYXJnZXRJZHM6IHRoaXMuYWN0aXZlVGFyZ2V0SWRzLnRvQXJyYXkoKSxcclxuICAgICAgICAgICAgdXBkYXRlVGltZU1zOiBEYXRlLm5vdygpIC8vIE1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdHJpZ2dlciB1cGRhdGUuXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGVgIHVzZXMgV2ViU3RvcmFnZSAod2luZG93LmxvY2FsU3RvcmFnZSkgYXMgdGhlXHJcbiAqIGJhY2tpbmcgc3RvcmUgZm9yIHRoZSBTaGFyZWRDbGllbnRTdGF0ZS4gSXQga2VlcHMgdHJhY2sgb2YgYWxsIGFjdGl2ZVxyXG4gKiBjbGllbnRzIGFuZCBzdXBwb3J0cyBtb2RpZmljYXRpb25zIG9mIHRoZSBsb2NhbCBjbGllbnQncyBkYXRhLlxyXG4gKi9cclxuY2xhc3MgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpbmRvdywgcXVldWUsIHBlcnNpc3RlbmNlS2V5LCBsb2NhbENsaWVudElkLCBpbml0aWFsVXNlcikge1xyXG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xyXG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XHJcbiAgICAgICAgdGhpcy5sb2NhbENsaWVudElkID0gbG9jYWxDbGllbnRJZDtcclxuICAgICAgICB0aGlzLnN5bmNFbmdpbmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVySGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdG9yYWdlTGlzdGVuZXIgPSB0aGlzLmhhbmRsZVdlYlN0b3JhZ2VFdmVudC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50cyA9IG5ldyBTb3J0ZWRNYXAocHJpbWl0aXZlQ29tcGFyYXRvcik7XHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FwdHVyZXMgV2ViU3RvcmFnZSBldmVudHMgdGhhdCBvY2N1ciBiZWZvcmUgYHN0YXJ0KClgIGlzIGNhbGxlZC4gVGhlc2VcclxuICAgICAgICAgKiBldmVudHMgYXJlIHJlcGxheWVkIG9uY2UgYFdlYlN0b3JhZ2VTaGFyZWRDbGllbnRTdGF0ZWAgaXMgc3RhcnRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVhcmx5RXZlbnRzID0gW107XHJcbiAgICAgICAgLy8gRXNjYXBlIHRoZSBzcGVjaWFsIGNoYXJhY3RlcnMgbWVudGlvbmVkIGhlcmU6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zXHJcbiAgICAgICAgY29uc3QgZXNjYXBlZFBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXkucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcclxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB0aGlzLndpbmRvdy5sb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IGluaXRpYWxVc2VyO1xyXG4gICAgICAgIHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5ID0gY3JlYXRlV2ViU3RvcmFnZUNsaWVudFN0YXRlS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRoaXMubG9jYWxDbGllbnRJZCk7XHJcbiAgICAgICAgdGhpcy5zZXF1ZW5jZU51bWJlcktleSA9IGNyZWF0ZVdlYlN0b3JhZ2VTZXF1ZW5jZU51bWJlcktleSh0aGlzLnBlcnNpc3RlbmNlS2V5KTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMgPSB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KHRoaXMubG9jYWxDbGllbnRJZCwgbmV3IExvY2FsQ2xpZW50U3RhdGUoKSk7XHJcbiAgICAgICAgdGhpcy5jbGllbnRTdGF0ZUtleVJlID0gbmV3IFJlZ0V4cChgXiR7Q0xJRU5UX1NUQVRFX0tFWV9QUkVGSVh9XyR7ZXNjYXBlZFBlcnNpc3RlbmNlS2V5fV8oW15fXSopJGApO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25CYXRjaEtleVJlID0gbmV3IFJlZ0V4cChgXiR7TVVUQVRJT05fQkFUQ0hfS0VZX1BSRUZJWH1fJHtlc2NhcGVkUGVyc2lzdGVuY2VLZXl9XyhcXFxcZCspKD86XyguKikpPyRgKTtcclxuICAgICAgICB0aGlzLnF1ZXJ5VGFyZ2V0S2V5UmUgPSBuZXcgUmVnRXhwKGBeJHtRVUVSWV9UQVJHRVRfS0VZX1BSRUZJWH1fJHtlc2NhcGVkUGVyc2lzdGVuY2VLZXl9XyhcXFxcZCspJGApO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVLZXkgPSBjcmVhdGVXZWJTdG9yYWdlT25saW5lU3RhdGVLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSk7XHJcbiAgICAgICAgdGhpcy5idW5kbGVMb2FkZWRLZXkgPSBjcmVhdGVCdW5kbGVMb2FkZWRLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSk7XHJcbiAgICAgICAgLy8gUmF0aGVyIHRoYW4gYWRkaW5nIHRoZSBzdG9yYWdlIG9ic2VydmVyIGR1cmluZyBzdGFydCgpLCB3ZSBhZGQgdGhlXHJcbiAgICAgICAgLy8gc3RvcmFnZSBvYnNlcnZlciBkdXJpbmcgaW5pdGlhbGl6YXRpb24uIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGNvbGxlY3RcclxuICAgICAgICAvLyBldmVudHMgYmVmb3JlIG90aGVyIGNvbXBvbmVudHMgcG9wdWxhdGUgdGhlaXIgaW5pdGlhbCBzdGF0ZSAoZHVyaW5nIHRoZWlyXHJcbiAgICAgICAgLy8gcmVzcGVjdGl2ZSBzdGFydCgpIGNhbGxzKS4gT3RoZXJ3aXNlLCB3ZSBtaWdodCBmb3IgZXhhbXBsZSBtaXNzIGFcclxuICAgICAgICAvLyBtdXRhdGlvbiB0aGF0IGlzIGFkZGVkIGFmdGVyIExvY2FsU3RvcmUncyBzdGFydCgpIHByb2Nlc3NlZCB0aGUgZXhpc3RpbmdcclxuICAgICAgICAvLyBtdXRhdGlvbnMgYnV0IGJlZm9yZSB3ZSBvYnNlcnZlIFdlYlN0b3JhZ2UgZXZlbnRzLlxyXG4gICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCB0aGlzLnN0b3JhZ2VMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyAndHJ1ZScgaWYgV2ViU3RvcmFnZSBpcyBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICovXHJcbiAgICBzdGF0aWMgaXNBdmFpbGFibGUod2luZG93KSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHdpbmRvdyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKTtcclxuICAgIH1cclxuICAgIGFzeW5jIHN0YXJ0KCkge1xyXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNsaWVudHMgdG8gYmFja2ZpbGwgdGhlIGRhdGEgaW5cclxuICAgICAgICAvLyBTaGFyZWRDbGllbnRTdGF0ZS5cclxuICAgICAgICBjb25zdCBleGlzdGluZ0NsaWVudHMgPSBhd2FpdCB0aGlzLnN5bmNFbmdpbmUuZ2V0QWN0aXZlQ2xpZW50cygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2xpZW50SWQgb2YgZXhpc3RpbmdDbGllbnRzKSB7XHJcbiAgICAgICAgICAgIGlmIChjbGllbnRJZCA9PT0gdGhpcy5sb2NhbENsaWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdG9yYWdlSXRlbSA9IHRoaXMuZ2V0SXRlbShjcmVhdGVXZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkodGhpcy5wZXJzaXN0ZW5jZUtleSwgY2xpZW50SWQpKTtcclxuICAgICAgICAgICAgaWYgKHN0b3JhZ2VJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IFJlbW90ZUNsaWVudFN0YXRlLmZyb21XZWJTdG9yYWdlRW50cnkoY2xpZW50SWQsIHN0b3JhZ2VJdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChjbGllbnRTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50cyA9IHRoaXMuYWN0aXZlQ2xpZW50cy5pbnNlcnQoY2xpZW50U3RhdGUuY2xpZW50SWQsIGNsaWVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBlcnNpc3RDbGllbnRTdGF0ZSgpO1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIG9ubGluZSBzdGF0ZSBhbmQgY2FsbCB0aGUgY2FsbGJhY2sgaGFuZGxlclxyXG4gICAgICAgIC8vIGlmIGFwcGxpY2FibGUuXHJcbiAgICAgICAgY29uc3Qgb25saW5lU3RhdGVKU09OID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5vbmxpbmVTdGF0ZUtleSk7XHJcbiAgICAgICAgaWYgKG9ubGluZVN0YXRlSlNPTikge1xyXG4gICAgICAgICAgICBjb25zdCBvbmxpbmVTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZUpTT04pO1xyXG4gICAgICAgICAgICBpZiAob25saW5lU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiB0aGlzLmVhcmx5RXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlV2ViU3RvcmFnZUV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lYXJseUV2ZW50cyA9IFtdO1xyXG4gICAgICAgIC8vIFJlZ2lzdGVyIGEgd2luZG93IHVubG9hZCBob29rIHRvIHJlbW92ZSB0aGUgY2xpZW50IG1ldGFkYXRhIGVudHJ5IGZyb21cclxuICAgICAgICAvLyBXZWJTdG9yYWdlIGV2ZW4gaWYgYHNodXRkb3duKClgIHdhcyBub3QgY2FsbGVkLlxyXG4gICAgICAgIHRoaXMud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgKCkgPT4gdGhpcy5zaHV0ZG93bigpKTtcclxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgd3JpdGVTZXF1ZW5jZU51bWJlcihzZXF1ZW5jZU51bWJlcikge1xyXG4gICAgICAgIHRoaXMuc2V0SXRlbSh0aGlzLnNlcXVlbmNlTnVtYmVyS2V5LCBKU09OLnN0cmluZ2lmeShzZXF1ZW5jZU51bWJlcikpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxsQWN0aXZlUXVlcnlUYXJnZXRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHModGhpcy5hY3RpdmVDbGllbnRzKTtcclxuICAgIH1cclxuICAgIGlzQWN0aXZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUNsaWVudHMuZm9yRWFjaCgoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH1cclxuICAgIGFkZFBlbmRpbmdNdXRhdGlvbihiYXRjaElkKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCAncGVuZGluZycpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnBlcnNpc3RNdXRhdGlvblN0YXRlKGJhdGNoSWQsIHN0YXRlLCBlcnJvcik7XHJcbiAgICAgICAgLy8gT25jZSBhIGZpbmFsIG11dGF0aW9uIHJlc3VsdCBpcyBvYnNlcnZlZCBieSBvdGhlciBjbGllbnRzLCB0aGV5IG5vIGxvbmdlclxyXG4gICAgICAgIC8vIGFjY2VzcyB0aGUgbXV0YXRpb24ncyBtZXRhZGF0YSBlbnRyeS4gU2luY2UgV2ViU3RvcmFnZSByZXBsYXlzIGV2ZW50c1xyXG4gICAgICAgIC8vIGluIG9yZGVyLCBpdCBpcyBzYWZlIHRvIGRlbGV0ZSB0aGUgZW50cnkgcmlnaHQgYWZ0ZXIgdXBkYXRpbmcgaXQuXHJcbiAgICAgICAgdGhpcy5yZW1vdmVNdXRhdGlvblN0YXRlKGJhdGNoSWQpO1xyXG4gICAgfVxyXG4gICAgYWRkTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIGxldCBxdWVyeVN0YXRlID0gJ25vdC1jdXJyZW50JztcclxuICAgICAgICAvLyBMb29rdXAgYW4gZXhpc3RpbmcgcXVlcnkgc3RhdGUgaWYgdGhlIHRhcmdldCBJRCB3YXMgYWxyZWFkeSByZWdpc3RlcmVkXHJcbiAgICAgICAgLy8gYnkgYW5vdGhlciB0YWJcclxuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdG9yYWdlSXRlbSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGNyZWF0ZVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRhcmdldElkKSk7XHJcbiAgICAgICAgICAgIGlmIChzdG9yYWdlSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBRdWVyeVRhcmdldE1ldGFkYXRhLmZyb21XZWJTdG9yYWdlRW50cnkodGFyZ2V0SWQsIHN0b3JhZ2VJdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RhdGUgPSBtZXRhZGF0YS5zdGF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsQ2xpZW50U3RhdGUuYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHRoaXMucGVyc2lzdENsaWVudFN0YXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5U3RhdGU7XHJcbiAgICB9XHJcbiAgICByZW1vdmVMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbENsaWVudFN0YXRlLnJlbW92ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcclxuICAgICAgICB0aGlzLnBlcnNpc3RDbGllbnRTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgaXNMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxDbGllbnRTdGF0ZS5hY3RpdmVUYXJnZXRJZHMuaGFzKHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIGNsZWFyUXVlcnlTdGF0ZSh0YXJnZXRJZCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShjcmVhdGVXZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YUtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0YXJnZXRJZCkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUXVlcnlTdGF0ZSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0UXVlcnlUYXJnZXRTdGF0ZSh0YXJnZXRJZCwgc3RhdGUsIGVycm9yKTtcclxuICAgIH1cclxuICAgIGhhbmRsZVVzZXJDaGFuZ2UodXNlciwgcmVtb3ZlZEJhdGNoSWRzLCBhZGRlZEJhdGNoSWRzKSB7XHJcbiAgICAgICAgcmVtb3ZlZEJhdGNoSWRzLmZvckVhY2goYmF0Y2hJZCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gdXNlcjtcclxuICAgICAgICBhZGRlZEJhdGNoSWRzLmZvckVhY2goYmF0Y2hJZCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ011dGF0aW9uKGJhdGNoSWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0T25saW5lU3RhdGUob25saW5lU3RhdGUpIHtcclxuICAgICAgICB0aGlzLnBlcnNpc3RPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBub3RpZnlCdW5kbGVMb2FkZWQoKSB7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0QnVuZGxlTG9hZGVkU3RhdGUoKTtcclxuICAgIH1cclxuICAgIHNodXRkb3duKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIHRoaXMuc3RvcmFnZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVJdGVtKHRoaXMubG9jYWxDbGllbnRTdG9yYWdlS2V5KTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0SXRlbShrZXkpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnUkVBRCcsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckYSwgJ1NFVCcsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlSXRlbShrZXkpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJGEsICdSRU1PVkUnLCBrZXkpO1xyXG4gICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVXZWJTdG9yYWdlRXZlbnQoZXZlbnQpIHtcclxuICAgICAgICAvLyBOb3RlOiBUaGUgZnVuY3Rpb24gaXMgdHlwZWQgdG8gdGFrZSBFdmVudCB0byBiZSBpbnRlcmZhY2UtY29tcGF0aWJsZSB3aXRoXHJcbiAgICAgICAgLy8gYFdpbmRvdy5hZGRFdmVudExpc3RlbmVyYC5cclxuICAgICAgICBjb25zdCBzdG9yYWdlRXZlbnQgPSBldmVudDtcclxuICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LnN0b3JhZ2VBcmVhID09PSB0aGlzLnN0b3JhZ2UpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCAnRVZFTlQnLCBzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gdGhpcy5sb2NhbENsaWVudFN0b3JhZ2VLZXkpIHtcclxuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdSZWNlaXZlZCBXZWJTdG9yYWdlIG5vdGlmaWNhdGlvbiBmb3IgbG9jYWwgY2hhbmdlLiBBbm90aGVyIGNsaWVudCBtaWdodCBoYXZlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdnYXJiYWdlLWNvbGxlY3RlZCBvdXIgc3RhdGUnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmVucXVldWVSZXRyeWFibGUoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RXZlbnRzLnB1c2goc3RvcmFnZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50LmtleSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudFN0YXRlS2V5UmUudGVzdChzdG9yYWdlRXZlbnQua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlRXZlbnQubmV3VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRTdGF0ZSA9IHRoaXMuZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpZW50U3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNsaWVudFN0YXRlRXZlbnQoY2xpZW50U3RhdGUuY2xpZW50SWQsIGNsaWVudFN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50SWQgPSB0aGlzLmZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkoc3RvcmFnZUV2ZW50LmtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNsaWVudFN0YXRlRXZlbnQoY2xpZW50SWQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubXV0YXRpb25CYXRjaEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uTWV0YWRhdGEgPSB0aGlzLmZyb21XZWJTdG9yYWdlTXV0YXRpb25NZXRhZGF0YShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YXRpb25NZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlTXV0YXRpb25CYXRjaEV2ZW50KG11dGF0aW9uTWV0YWRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5xdWVyeVRhcmdldEtleVJlLnRlc3Qoc3RvcmFnZUV2ZW50LmtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VGFyZ2V0TWV0YWRhdGEgPSB0aGlzLmZyb21XZWJTdG9yYWdlUXVlcnlUYXJnZXRNZXRhZGF0YShzdG9yYWdlRXZlbnQua2V5LCBzdG9yYWdlRXZlbnQubmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlUYXJnZXRNZXRhZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUXVlcnlUYXJnZXRFdmVudChxdWVyeVRhcmdldE1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0b3JhZ2VFdmVudC5rZXkgPT09IHRoaXMub25saW5lU3RhdGVLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZUV2ZW50Lm5ld1ZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ubGluZVN0YXRlID0gdGhpcy5mcm9tV2ViU3RvcmFnZU9ubGluZVN0YXRlKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmxpbmVTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLnNlcXVlbmNlTnVtYmVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBmcm9tV2ViU3RvcmFnZVNlcXVlbmNlTnVtYmVyKHN0b3JhZ2VFdmVudC5uZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSBMaXN0ZW5TZXF1ZW5jZS5JTlZBTElEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VxdWVuY2VOdW1iZXJIYW5kbGVyKHNlcXVlbmNlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdG9yYWdlRXZlbnQua2V5ID09PSB0aGlzLmJ1bmRsZUxvYWRlZEtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bmNFbmdpbmUuc3luY2hyb25pemVXaXRoQ2hhbmdlZERvY3VtZW50cygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgbG9jYWxDbGllbnRTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVDbGllbnRzLmdldCh0aGlzLmxvY2FsQ2xpZW50SWQpO1xyXG4gICAgfVxyXG4gICAgcGVyc2lzdENsaWVudFN0YXRlKCkge1xyXG4gICAgICAgIHRoaXMuc2V0SXRlbSh0aGlzLmxvY2FsQ2xpZW50U3RvcmFnZUtleSwgdGhpcy5sb2NhbENsaWVudFN0YXRlLnRvV2ViU3RvcmFnZUpTT04oKSk7XHJcbiAgICB9XHJcbiAgICBwZXJzaXN0TXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICBjb25zdCBtdXRhdGlvblN0YXRlID0gbmV3IE11dGF0aW9uTWV0YWRhdGEodGhpcy5jdXJyZW50VXNlciwgYmF0Y2hJZCwgc3RhdGUsIGVycm9yKTtcclxuICAgICAgICBjb25zdCBtdXRhdGlvbktleSA9IGNyZWF0ZVdlYlN0b3JhZ2VNdXRhdGlvbkJhdGNoS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRoaXMuY3VycmVudFVzZXIsIGJhdGNoSWQpO1xyXG4gICAgICAgIHRoaXMuc2V0SXRlbShtdXRhdGlvbktleSwgbXV0YXRpb25TdGF0ZS50b1dlYlN0b3JhZ2VKU09OKCkpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTXV0YXRpb25TdGF0ZShiYXRjaElkKSB7XHJcbiAgICAgICAgY29uc3QgbXV0YXRpb25LZXkgPSBjcmVhdGVXZWJTdG9yYWdlTXV0YXRpb25CYXRjaEtleSh0aGlzLnBlcnNpc3RlbmNlS2V5LCB0aGlzLmN1cnJlbnRVc2VyLCBiYXRjaElkKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0obXV0YXRpb25LZXkpO1xyXG4gICAgfVxyXG4gICAgcGVyc2lzdE9ubGluZVN0YXRlKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZW50cnkgPSB7XHJcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmxvY2FsQ2xpZW50SWQsXHJcbiAgICAgICAgICAgIG9ubGluZVN0YXRlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLm9ubGluZVN0YXRlS2V5LCBKU09OLnN0cmluZ2lmeShlbnRyeSkpO1xyXG4gICAgfVxyXG4gICAgcGVyc2lzdFF1ZXJ5VGFyZ2V0U3RhdGUodGFyZ2V0SWQsIHN0YXRlLCBlcnJvcikge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldEtleSA9IGNyZWF0ZVdlYlN0b3JhZ2VRdWVyeVRhcmdldE1ldGFkYXRhS2V5KHRoaXMucGVyc2lzdGVuY2VLZXksIHRhcmdldElkKTtcclxuICAgICAgICBjb25zdCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBRdWVyeVRhcmdldE1ldGFkYXRhKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpO1xyXG4gICAgICAgIHRoaXMuc2V0SXRlbSh0YXJnZXRLZXksIHRhcmdldE1ldGFkYXRhLnRvV2ViU3RvcmFnZUpTT04oKSk7XHJcbiAgICB9XHJcbiAgICBwZXJzaXN0QnVuZGxlTG9hZGVkU3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRJdGVtKHRoaXMuYnVuZGxlTG9hZGVkS2V5LCAndmFsdWUtbm90LXVzZWQnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgY2xpZW50IHN0YXRlIGtleSBpbiBXZWJTdG9yYWdlLiBSZXR1cm5zIG51bGwgaWYgdGhlIGtleSBkb2VzIG5vdFxyXG4gICAgICogbWF0Y2ggdGhlIGV4cGVjdGVkIGtleSBmb3JtYXQuXHJcbiAgICAgKi9cclxuICAgIGZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLmNsaWVudFN0YXRlS2V5UmUuZXhlYyhrZXkpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgY2xpZW50IHN0YXRlIGluIFdlYlN0b3JhZ2UuIFJldHVybnMgJ251bGwnIGlmIHRoZSB2YWx1ZSBjb3VsZCBub3RcclxuICAgICAqIGJlIHBhcnNlZC5cclxuICAgICAqL1xyXG4gICAgZnJvbVdlYlN0b3JhZ2VDbGllbnRTdGF0ZShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgY2xpZW50SWQgPSB0aGlzLmZyb21XZWJTdG9yYWdlQ2xpZW50U3RhdGVLZXkoa2V5KTtcclxuICAgICAgICByZXR1cm4gUmVtb3RlQ2xpZW50U3RhdGUuZnJvbVdlYlN0b3JhZ2VFbnRyeShjbGllbnRJZCwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYSBtdXRhdGlvbiBiYXRjaCBzdGF0ZSBpbiBXZWJTdG9yYWdlLiBSZXR1cm5zICdudWxsJyBpZiB0aGUgdmFsdWVcclxuICAgICAqIGNvdWxkIG5vdCBiZSBwYXJzZWQuXHJcbiAgICAgKi9cclxuICAgIGZyb21XZWJTdG9yYWdlTXV0YXRpb25NZXRhZGF0YShrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLm11dGF0aW9uQmF0Y2hLZXlSZS5leGVjKGtleSk7XHJcbiAgICAgICAgY29uc3QgYmF0Y2hJZCA9IE51bWJlcihtYXRjaFsxXSk7XHJcbiAgICAgICAgY29uc3QgdXNlcklkID0gbWF0Y2hbMl0gIT09IHVuZGVmaW5lZCA/IG1hdGNoWzJdIDogbnVsbDtcclxuICAgICAgICByZXR1cm4gTXV0YXRpb25NZXRhZGF0YS5mcm9tV2ViU3RvcmFnZUVudHJ5KG5ldyBVc2VyKHVzZXJJZCksIGJhdGNoSWQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgcXVlcnkgdGFyZ2V0IHN0YXRlIGZyb20gV2ViU3RvcmFnZS4gUmV0dXJucyAnbnVsbCcgaWYgdGhlIHZhbHVlXHJcbiAgICAgKiBjb3VsZCBub3QgYmUgcGFyc2VkLlxyXG4gICAgICovXHJcbiAgICBmcm9tV2ViU3RvcmFnZVF1ZXJ5VGFyZ2V0TWV0YWRhdGEoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5xdWVyeVRhcmdldEtleVJlLmV4ZWMoa2V5KTtcclxuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IE51bWJlcihtYXRjaFsxXSk7XHJcbiAgICAgICAgcmV0dXJuIFF1ZXJ5VGFyZ2V0TWV0YWRhdGEuZnJvbVdlYlN0b3JhZ2VFbnRyeSh0YXJnZXRJZCwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgYW4gb25saW5lIHN0YXRlIGZyb20gV2ViU3RvcmFnZS4gUmV0dXJucyAnbnVsbCcgaWYgdGhlIHZhbHVlXHJcbiAgICAgKiBjb3VsZCBub3QgYmUgcGFyc2VkLlxyXG4gICAgICovXHJcbiAgICBmcm9tV2ViU3RvcmFnZU9ubGluZVN0YXRlKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYXJlZE9ubGluZVN0YXRlLmZyb21XZWJTdG9yYWdlRW50cnkodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgaGFuZGxlTXV0YXRpb25CYXRjaEV2ZW50KG11dGF0aW9uQmF0Y2gpIHtcclxuICAgICAgICBpZiAobXV0YXRpb25CYXRjaC51c2VyLnVpZCAhPT0gdGhpcy5jdXJyZW50VXNlci51aWQpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyRhLCBgSWdub3JpbmcgbXV0YXRpb24gZm9yIG5vbi1hY3RpdmUgdXNlciAke211dGF0aW9uQmF0Y2gudXNlci51aWR9YCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseUJhdGNoU3RhdGUobXV0YXRpb25CYXRjaC5iYXRjaElkLCBtdXRhdGlvbkJhdGNoLnN0YXRlLCBtdXRhdGlvbkJhdGNoLmVycm9yKTtcclxuICAgIH1cclxuICAgIGhhbmRsZVF1ZXJ5VGFyZ2V0RXZlbnQodGFyZ2V0TWV0YWRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zeW5jRW5naW5lLmFwcGx5VGFyZ2V0U3RhdGUodGFyZ2V0TWV0YWRhdGEudGFyZ2V0SWQsIHRhcmdldE1ldGFkYXRhLnN0YXRlLCB0YXJnZXRNZXRhZGF0YS5lcnJvcik7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVDbGllbnRTdGF0ZUV2ZW50KGNsaWVudElkLCBjbGllbnRTdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDbGllbnRzID0gY2xpZW50U3RhdGVcclxuICAgICAgICAgICAgPyB0aGlzLmFjdGl2ZUNsaWVudHMuaW5zZXJ0KGNsaWVudElkLCBjbGllbnRTdGF0ZSlcclxuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZUNsaWVudHMucmVtb3ZlKGNsaWVudElkKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ1RhcmdldHMgPSB0aGlzLmV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHModGhpcy5hY3RpdmVDbGllbnRzKTtcclxuICAgICAgICBjb25zdCBuZXdUYXJnZXRzID0gdGhpcy5leHRyYWN0QWN0aXZlUXVlcnlUYXJnZXRzKHVwZGF0ZWRDbGllbnRzKTtcclxuICAgICAgICBjb25zdCBhZGRlZFRhcmdldHMgPSBbXTtcclxuICAgICAgICBjb25zdCByZW1vdmVkVGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgIG5ld1RhcmdldHMuZm9yRWFjaCh0YXJnZXRJZCA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgIGFkZGVkVGFyZ2V0cy5wdXNoKHRhcmdldElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV4aXN0aW5nVGFyZ2V0cy5mb3JFYWNoKHRhcmdldElkID0+IHtcclxuICAgICAgICAgICAgaWYgKCFuZXdUYXJnZXRzLmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRUYXJnZXRzLnB1c2godGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luY0VuZ2luZS5hcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2UoYWRkZWRUYXJnZXRzLCByZW1vdmVkVGFyZ2V0cykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2xpZW50cyA9IHVwZGF0ZWRDbGllbnRzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlT25saW5lU3RhdGVFdmVudChvbmxpbmVTdGF0ZSkge1xyXG4gICAgICAgIC8vIFdlIGNoZWNrIHdoZXRoZXIgdGhlIGNsaWVudCB0aGF0IHdyb3RlIHRoaXMgb25saW5lIHN0YXRlIGlzIHN0aWxsIGFjdGl2ZVxyXG4gICAgICAgIC8vIGJ5IGNvbXBhcmluZyBpdHMgY2xpZW50IElEIHRvIHRoZSBsaXN0IG9mIGNsaWVudHMga2VwdCBhY3RpdmUgaW5cclxuICAgICAgICAvLyBJbmRleGVkRGIuIElmIGEgY2xpZW50IGRvZXMgbm90IHVwZGF0ZSB0aGVpciBJbmRleGVkRGIgY2xpZW50IHN0YXRlXHJcbiAgICAgICAgLy8gd2l0aGluIDUgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBpbmFjdGl2ZSBhbmQgd2UgZG9uJ3QgZW1pdCBhbiBvbmxpbmVcclxuICAgICAgICAvLyBzdGF0ZSBldmVudC5cclxuICAgICAgICBpZiAodGhpcy5hY3RpdmVDbGllbnRzLmdldChvbmxpbmVTdGF0ZS5jbGllbnRJZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZUhhbmRsZXIob25saW5lU3RhdGUub25saW5lU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4dHJhY3RBY3RpdmVRdWVyeVRhcmdldHMoY2xpZW50cykge1xyXG4gICAgICAgIGxldCBhY3RpdmVUYXJnZXRzID0gdGFyZ2V0SWRTZXQoKTtcclxuICAgICAgICBjbGllbnRzLmZvckVhY2goKGtldiwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cyA9IGFjdGl2ZVRhcmdldHMudW5pb25XaXRoKHZhbHVlLmFjdGl2ZVRhcmdldElkcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVRhcmdldHM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZnJvbVdlYlN0b3JhZ2VTZXF1ZW5jZU51bWJlcihzZXFTdHJpbmcpIHtcclxuICAgIGxldCBzZXF1ZW5jZU51bWJlciA9IExpc3RlblNlcXVlbmNlLklOVkFMSUQ7XHJcbiAgICBpZiAoc2VxU3RyaW5nICE9IG51bGwpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNlcVN0cmluZyk7XHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQodHlwZW9mIHBhcnNlZCA9PT0gJ251bWJlcicpO1xyXG4gICAgICAgICAgICBzZXF1ZW5jZU51bWJlciA9IHBhcnNlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbG9nRXJyb3IoTE9HX1RBRyRhLCAnRmFpbGVkIHRvIHJlYWQgc2VxdWVuY2UgbnVtYmVyIGZyb20gV2ViU3RvcmFnZScsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzZXF1ZW5jZU51bWJlcjtcclxufVxyXG4vKipcclxuICogYE1lbW9yeVNoYXJlZENsaWVudFN0YXRlYCBpcyBhIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBTaGFyZWRDbGllbnRTdGF0ZSBmb3JcclxuICogY2xpZW50cyB1c2luZyBtZW1vcnkgcGVyc2lzdGVuY2UuIFRoZSBzdGF0ZSBpbiB0aGlzIGNsYXNzIHJlbWFpbnMgZnVsbHlcclxuICogaXNvbGF0ZWQgYW5kIG5vIHN5bmNocm9uaXphdGlvbiBpcyBwZXJmb3JtZWQuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlTaGFyZWRDbGllbnRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RhdGUgPSBuZXcgTG9jYWxDbGllbnRTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMucXVlcnlTdGF0ZSA9IHt9O1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNlcXVlbmNlTnVtYmVySGFuZGxlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBhZGRQZW5kaW5nTXV0YXRpb24oYmF0Y2hJZCkge1xyXG4gICAgICAgIC8vIE5vIG9wLlxyXG4gICAgfVxyXG4gICAgdXBkYXRlTXV0YXRpb25TdGF0ZShiYXRjaElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICAvLyBObyBvcC5cclxuICAgIH1cclxuICAgIGFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RhdGUuYWRkUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdIHx8ICdub3QtY3VycmVudCc7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVRdWVyeVN0YXRlKHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5U3RhdGVbdGFyZ2V0SWRdID0gc3RhdGU7XHJcbiAgICB9XHJcbiAgICByZW1vdmVMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlLnJlbW92ZVF1ZXJ5VGFyZ2V0KHRhcmdldElkKTtcclxuICAgIH1cclxuICAgIGlzTG9jYWxRdWVyeVRhcmdldCh0YXJnZXRJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGUuYWN0aXZlVGFyZ2V0SWRzLmhhcyh0YXJnZXRJZCk7XHJcbiAgICB9XHJcbiAgICBjbGVhclF1ZXJ5U3RhdGUodGFyZ2V0SWQpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5xdWVyeVN0YXRlW3RhcmdldElkXTtcclxuICAgIH1cclxuICAgIGdldEFsbEFjdGl2ZVF1ZXJ5VGFyZ2V0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcztcclxuICAgIH1cclxuICAgIGlzQWN0aXZlUXVlcnlUYXJnZXQodGFyZ2V0SWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFN0YXRlLmFjdGl2ZVRhcmdldElkcy5oYXModGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsQ2xpZW50U3RhdGUoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlbW92ZWRCYXRjaElkcywgYWRkZWRCYXRjaElkcykge1xyXG4gICAgICAgIC8vIE5vIG9wLlxyXG4gICAgfVxyXG4gICAgc2V0T25saW5lU3RhdGUob25saW5lU3RhdGUpIHtcclxuICAgICAgICAvLyBObyBvcC5cclxuICAgIH1cclxuICAgIHNodXRkb3duKCkgeyB9XHJcbiAgICB3cml0ZVNlcXVlbmNlTnVtYmVyKHNlcXVlbmNlTnVtYmVyKSB7IH1cclxuICAgIG5vdGlmeUJ1bmRsZUxvYWRlZCgpIHtcclxuICAgICAgICAvLyBObyBvcC5cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBOb29wQ29ubmVjdGl2aXR5TW9uaXRvciB7XHJcbiAgICBhZGRDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gICAgICAgIC8vIE5vLW9wLlxyXG4gICAgfVxyXG4gICAgc2h1dGRvd24oKSB7XHJcbiAgICAgICAgLy8gTm8tb3AuXHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgc2ltcGxlIGhlbHBlciBjbGFzcyB0aGF0IGltcGxlbWVudHMgdGhlIFN0cmVhbSBpbnRlcmZhY2UgdG9cclxuICogYnJpZGdlIHRvIG90aGVyIGltcGxlbWVudGF0aW9ucyB0aGF0IGFyZSBzdHJlYW1zIGJ1dCBkbyBub3QgaW1wbGVtZW50IHRoZVxyXG4gKiBpbnRlcmZhY2UuIFRoZSBzdHJlYW0gY2FsbGJhY2tzIGFyZSBpbnZva2VkIHdpdGggdGhlIGNhbGxPbi4uLiBtZXRob2RzLlxyXG4gKi9cclxuY2xhc3MgU3RyZWFtQnJpZGdlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcclxuICAgICAgICB0aGlzLnNlbmRGbiA9IGFyZ3Muc2VuZEZuO1xyXG4gICAgICAgIHRoaXMuY2xvc2VGbiA9IGFyZ3MuY2xvc2VGbjtcclxuICAgIH1cclxuICAgIG9uT3BlbihjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uT3BlbiA9IGNhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgb25DbG9zZShjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uQ2xvc2UgPSBjYWxsYmFjaztcclxuICAgIH1cclxuICAgIG9uTWVzc2FnZShjYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uTWVzc2FnZSA9IGNhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5jbG9zZUZuKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kKG1zZykge1xyXG4gICAgICAgIHRoaXMuc2VuZEZuKG1zZyk7XHJcbiAgICB9XHJcbiAgICBjYWxsT25PcGVuKCkge1xyXG4gICAgICAgIHRoaXMud3JhcHBlZE9uT3BlbigpO1xyXG4gICAgfVxyXG4gICAgY2FsbE9uQ2xvc2UoZXJyKSB7XHJcbiAgICAgICAgdGhpcy53cmFwcGVkT25DbG9zZShlcnIpO1xyXG4gICAgfVxyXG4gICAgY2FsbE9uTWVzc2FnZShtc2cpIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRPbk1lc3NhZ2UobXNnKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKlxyXG4gKiBVdGlsaXRpZXMgZm9yIGRlYWxpbmcgd2l0aCBub2RlLmpzLXN0eWxlIEFQSXMuIFNlZSBub2RlUHJvbWlzZSBmb3IgbW9yZVxyXG4gKiBkZXRhaWxzLlxyXG4gKi9cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIHRoYXQgcmVzb2x2ZXMgb3IgcmVqZWN0cyBhIG5ldyBQcm9taXNlLiBUaGVcclxuICogY2FsbGJhY2sgaXMgcGFzc2VkIHRvIHRoZSBnaXZlbiBhY3Rpb24gd2hpY2ggY2FuIHRoZW4gdXNlIHRoZSBjYWxsYmFjayBhc1xyXG4gKiBhIHBhcmFtZXRlciB0byBhIG5vZGUtc3R5bGUgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFRoZSBpbnRlbnQgaXMgdG8gZGlyZWN0bHkgYnJpZGdlIGEgbm9kZS1zdHlsZSBmdW5jdGlvbiAod2hpY2ggdGFrZXMgYVxyXG4gKiBjYWxsYmFjaykgaW50byBhIFByb21pc2Ugd2l0aG91dCBtYW51YWxseSBjb252ZXJ0aW5nIGJldHdlZW4gdGhlIG5vZGUtc3R5bGVcclxuICogY2FsbGJhY2sgYW5kIHRoZSBwcm9taXNlIGF0IGVhY2ggY2FsbC5cclxuICpcclxuICogSW4gZWZmZWN0IGl0IGFsbG93cyB5b3UgdG8gY29udmVydDpcclxuICpcclxuICogQGV4YW1wbGVcclxuICogbmV3IFByb21pc2UoKHJlc29sdmU6ICh2YWx1ZT86IGZzLlN0YXRzKSA9PiB2b2lkLFxyXG4gKiAgICAgICAgICAgICAgcmVqZWN0OiAoZXJyb3I/OiBhbnkpID0+IHZvaWQpID0+IHtcclxuICogICBmcy5zdGF0KHBhdGgsIChlcnJvcj86IGFueSwgc3RhdD86IGZzLlN0YXRzKSA9PiB7XHJcbiAqICAgICBpZiAoZXJyb3IpIHtcclxuICogICAgICAgcmVqZWN0KGVycm9yKTtcclxuICogICAgIH0gZWxzZSB7XHJcbiAqICAgICAgIHJlc29sdmUoc3RhdCk7XHJcbiAqICAgICB9XHJcbiAqICAgfSk7XHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBJbnRvXHJcbiAqIEBleGFtcGxlXHJcbiAqIG5vZGVQcm9taXNlKChjYWxsYmFjazogTm9kZUNhbGxiYWNrPGZzLlN0YXRzPikgPT4ge1xyXG4gKiAgIGZzLnN0YXQocGF0aCwgY2FsbGJhY2spO1xyXG4gKiB9KTtcclxuICpcclxuICogQHBhcmFtIGFjdGlvbiAtIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgYW4gYXJndW1lbnRcclxuICogICAgIGFuZCB0aGVuIHVzZXMgdGhhdCBjYWxsYmFjayB0byBpbnZva2Ugc29tZSBub2RlLXN0eWxlIEFQSS5cclxuICogQHJldHVybnMgYSBuZXcgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlamVjdGVkIGlmIHRoZSBjYWxsYmFjayBpcyBnaXZlbiB0aGVcclxuICogICAgIGZpcnN0IEVycm9yIHBhcmFtZXRlciBvciB3aWxsIHJlc29sdmUgdG8gdGhlIHZhbHVlIGdpdmVuIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIG5vZGVQcm9taXNlKGFjdGlvbikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBhY3Rpb24oKGVycm9yLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gVE9ETzogRmV0Y2ggcnVudGltZSB2ZXJzaW9uIGZyb20gZ3JwYy1qcy9wYWNrYWdlLmpzb24gaW5zdGVhZFxyXG4vLyB3aGVuIHRoZXJlJ3MgYSBjbGVhbmVyIHdheSB0byBkeW5hbWljIHJlcXVpcmUgSlNPTiBpbiBib3RoIE5vZGUgRVNNIGFuZCBDSlNcclxuY29uc3QgZ3JwY1ZlcnNpb24gPSAnMS4zLjcnO1xyXG5jb25zdCBMT0dfVEFHJDkgPSAnQ29ubmVjdGlvbic7XHJcbmNvbnN0IFhfR09PR19BUElfQ0xJRU5UX1ZBTFVFID0gYGdsLW5vZGUvJHtwcm9jZXNzLnZlcnNpb25zLm5vZGV9IGZpcmUvJHtTREtfVkVSU0lPTn0gZ3JwYy8ke2dycGNWZXJzaW9ufWA7XHJcbmZ1bmN0aW9uIGNyZWF0ZU1ldGFkYXRhKGRhdGFiYXNlUGF0aCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCBhcHBJZCkge1xyXG4gICAgaGFyZEFzc2VydChhdXRoVG9rZW4gPT09IG51bGwgfHwgYXV0aFRva2VuLnR5cGUgPT09ICdPQXV0aCcpO1xyXG4gICAgY29uc3QgbWV0YWRhdGEgPSBuZXcgZ3JwYy5NZXRhZGF0YSgpO1xyXG4gICAgaWYgKGF1dGhUb2tlbikge1xyXG4gICAgICAgIGF1dGhUb2tlbi5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IG1ldGFkYXRhLnNldChrZXksIHZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgIGFwcENoZWNrVG9rZW4uaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBtZXRhZGF0YS5zZXQoa2V5LCB2YWx1ZSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGFwcElkKSB7XHJcbiAgICAgICAgbWV0YWRhdGEuc2V0KCdYLUZpcmViYXNlLUdNUElEJywgYXBwSWQpO1xyXG4gICAgfVxyXG4gICAgbWV0YWRhdGEuc2V0KCdYLUdvb2ctQXBpLUNsaWVudCcsIFhfR09PR19BUElfQ0xJRU5UX1ZBTFVFKTtcclxuICAgIC8vIFRoaXMgaGVhZGVyIGlzIHVzZWQgdG8gaW1wcm92ZSByb3V0aW5nIGFuZCBwcm9qZWN0IGlzb2xhdGlvbiBieSB0aGVcclxuICAgIC8vIGJhY2tlbmQuXHJcbiAgICBtZXRhZGF0YS5zZXQoJ0dvb2dsZS1DbG91ZC1SZXNvdXJjZS1QcmVmaXgnLCBkYXRhYmFzZVBhdGgpO1xyXG4gICAgcmV0dXJuIG1ldGFkYXRhO1xyXG59XHJcbi8qKlxyXG4gKiBBIENvbm5lY3Rpb24gaW1wbGVtZW50ZWQgYnkgR1JQQy1Ob2RlLlxyXG4gKi9cclxuY2xhc3MgR3JwY0Nvbm5lY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IocHJvdG9zLCBkYXRhYmFzZUluZm8pIHtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlSW5mbyA9IGRhdGFiYXNlSW5mbztcclxuICAgICAgICAvLyBXZSBjYWNoZSBzdHVicyBmb3IgdGhlIG1vc3QtcmVjZW50bHktdXNlZCB0b2tlbi5cclxuICAgICAgICB0aGlzLmNhY2hlZFN0dWIgPSBudWxsO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdGhpcy5maXJlc3RvcmUgPSBwcm90b3NbJ2dvb2dsZSddWydmaXJlc3RvcmUnXVsndjEnXTtcclxuICAgICAgICB0aGlzLmRhdGFiYXNlUGF0aCA9IGBwcm9qZWN0cy8ke2RhdGFiYXNlSW5mby5kYXRhYmFzZUlkLnByb2plY3RJZH0vZGF0YWJhc2VzLyR7ZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQuZGF0YWJhc2V9YDtcclxuICAgIH1cclxuICAgIGVuc3VyZUFjdGl2ZVN0dWIoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlZFN0dWIpIHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCAnQ3JlYXRpbmcgRmlyZXN0b3JlIHN0dWIuJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gdGhpcy5kYXRhYmFzZUluZm8uc3NsXHJcbiAgICAgICAgICAgICAgICA/IGdycGMuY3JlZGVudGlhbHMuY3JlYXRlU3NsKClcclxuICAgICAgICAgICAgICAgIDogZ3JwYy5jcmVkZW50aWFscy5jcmVhdGVJbnNlY3VyZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlZFN0dWIgPSBuZXcgdGhpcy5maXJlc3RvcmUuRmlyZXN0b3JlKHRoaXMuZGF0YWJhc2VJbmZvLmhvc3QsIGNyZWRlbnRpYWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkU3R1YjtcclxuICAgIH1cclxuICAgIGludm9rZVJQQyhycGNOYW1lLCBwYXRoLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVNZXRhZGF0YSh0aGlzLmRhdGFiYXNlUGF0aCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCB0aGlzLmRhdGFiYXNlSW5mby5hcHBJZCk7XHJcbiAgICAgICAgY29uc3QganNvblJlcXVlc3QgPSBPYmplY3QuYXNzaWduKHsgZGF0YWJhc2U6IHRoaXMuZGF0YWJhc2VQYXRoIH0sIHJlcXVlc3QpO1xyXG4gICAgICAgIHJldHVybiBub2RlUHJvbWlzZSgoY2FsbGJhY2spID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCBgUlBDICcke3JwY05hbWV9JyBpbnZva2VkIHdpdGggcmVxdWVzdDpgLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0dWJbcnBjTmFtZV0oanNvblJlcXVlc3QsIG1ldGFkYXRhLCAoZ3JwY0Vycm9yLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdycGNFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgZmFpbGVkIHdpdGggZXJyb3I6YCwgZ3JwY0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRmlyZXN0b3JlRXJyb3IobWFwQ29kZUZyb21ScGNDb2RlKGdycGNFcnJvci5jb2RlKSwgZ3JwY0Vycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgY29tcGxldGVkIHdpdGggcmVzcG9uc2U6YCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGludm9rZVN0cmVhbWluZ1JQQyhycGNOYW1lLCBwYXRoLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2VEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgaW52b2tlZCAoc3RyZWFtaW5nKSB3aXRoIHJlcXVlc3Q6YCwgcmVxdWVzdCk7XHJcbiAgICAgICAgY29uc3Qgc3R1YiA9IHRoaXMuZW5zdXJlQWN0aXZlU3R1YigpO1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWV0YWRhdGEodGhpcy5kYXRhYmFzZVBhdGgsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbiwgdGhpcy5kYXRhYmFzZUluZm8uYXBwSWQpO1xyXG4gICAgICAgIGNvbnN0IGpzb25SZXF1ZXN0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBkYXRhYmFzZTogdGhpcy5kYXRhYmFzZVBhdGggfSk7XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gc3R1YltycGNOYW1lXShqc29uUmVxdWVzdCwgbWV0YWRhdGEpO1xyXG4gICAgICAgIHN0cmVhbS5vbignZGF0YScsIChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJHtycGNOYW1lfSByZWNlaXZlZCByZXN1bHQ6YCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzcG9uc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksIGBSUEMgJyR7cnBjTmFtZX0nIGNvbXBsZXRlZC5gKTtcclxuICAgICAgICAgICAgcmVzcG9uc2VEZWZlcnJlZC5yZXNvbHZlKHJlc3VsdHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCAoZ3JwY0Vycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgYFJQQyAnJHtycGNOYW1lfScgZmFpbGVkIHdpdGggZXJyb3I6YCwgZ3JwY0Vycm9yKTtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IG1hcENvZGVGcm9tUnBjQ29kZShncnBjRXJyb3IuY29kZSk7XHJcbiAgICAgICAgICAgIHJlc3BvbnNlRGVmZXJyZWQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihjb2RlLCBncnBjRXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXNwb25zZURlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPKG1pa2VsZWhlbik6IFRoaXMgXCJtZXRob2RcIiBpcyBhIG1vbnN0ZXIuIFNob3VsZCBiZSByZWZhY3RvcmVkLlxyXG4gICAgb3BlblN0cmVhbShycGNOYW1lLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICBjb25zdCBzdHViID0gdGhpcy5lbnN1cmVBY3RpdmVTdHViKCk7XHJcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVNZXRhZGF0YSh0aGlzLmRhdGFiYXNlUGF0aCwgYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuLCB0aGlzLmRhdGFiYXNlSW5mby5hcHBJZCk7XHJcbiAgICAgICAgY29uc3QgZ3JwY1N0cmVhbSA9IHN0dWJbcnBjTmFtZV0obWV0YWRhdGEpO1xyXG4gICAgICAgIGxldCBjbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBjbG9zZSA9IChlcnIpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFjbG9zZWQpIHtcclxuICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0uY2FsbE9uQ2xvc2UoZXJyKTtcclxuICAgICAgICAgICAgICAgIGdycGNTdHJlYW0uZW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW1CcmlkZ2Uoe1xyXG4gICAgICAgICAgICBzZW5kRm46IChtc2cpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCAnR1JQQyBzdHJlYW0gc2VuZGluZzonLCBtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdycGNTdHJlYW0ud3JpdGUobXNnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwcm9iYWJseSBtZWFucyB3ZSBkaWRuJ3QgY29uZm9ybSB0byB0aGUgcHJvdG8uICBNYWtlIHN1cmUgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9nIHRoZSBtZXNzYWdlIHdlIHNlbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKCdGYWlsdXJlIHNlbmRpbmc6JywgbXNnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXJyb3IoJ0Vycm9yOicsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgJ05vdCBzZW5kaW5nIGJlY2F1c2UgZ1JQQyBzdHJlYW0gaXMgY2xvc2VkOicsIG1zZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNsb3NlRm46ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckOSwgJ0dSUEMgc3RyZWFtIGNsb3NlZCBsb2NhbGx5IHZpYSBjbG9zZSgpLicpO1xyXG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2RhdGEnLCAobXNnKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDksICdHUlBDIHN0cmVhbSByZWNlaXZlZDonLCBtc2cpO1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbGxPbk1lc3NhZ2UobXNnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGdycGNTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCAnR1JQQyBzdHJlYW0gZW5kZWQuJyk7XHJcbiAgICAgICAgICAgIGNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZ3JwY1N0cmVhbS5vbignZXJyb3InLCAoZ3JwY0Vycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dXYXJuKExPR19UQUckOSwgJ0dSUEMgc3RyZWFtIGVycm9yLiBDb2RlOicsIGdycGNFcnJvci5jb2RlLCAnTWVzc2FnZTonLCBncnBjRXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gbWFwQ29kZUZyb21ScGNDb2RlKGdycGNFcnJvci5jb2RlKTtcclxuICAgICAgICAgICAgICAgIGNsb3NlKG5ldyBGaXJlc3RvcmVFcnJvcihjb2RlLCBncnBjRXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ5LCAnT3BlbmluZyBHUlBDIHN0cmVhbScpO1xyXG4gICAgICAgIC8vIFRPRE8oZGltb25kKTogU2luY2UgZ3JwYyBoYXMgbm8gZXhwbGljaXQgb3BlbiBzdGF0dXMgKG9yIGRvZXMgaXQ/KSB3ZVxyXG4gICAgICAgIC8vIHNpbXVsYXRlIGFuIG9uT3BlbiBpbiB0aGUgbmV4dCBsb29wIGFmdGVyIHRoZSBzdHJlYW0gaGFkIGl0J3MgbGlzdGVuZXJzXHJcbiAgICAgICAgLy8gcmVnaXN0ZXJlZFxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBzdHJlYW0uY2FsbE9uT3BlbigpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIHJldHVybiBzdHJlYW07XHJcbiAgICB9XHJcbn1cblxuY29uc3QgbmVzdGVkID0ge1xuXHRnb29nbGU6IHtcblx0XHRuZXN0ZWQ6IHtcblx0XHRcdHByb3RvYnVmOiB7XG5cdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRjc2hhcnBfbmFtZXNwYWNlOiBcIkdvb2dsZS5Qcm90b2J1Zi5XZWxsS25vd25UeXBlc1wiLFxuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ2l0aHViLmNvbS9nb2xhbmcvcHJvdG9idWYvcHR5cGVzL3dyYXBwZXJzXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUucHJvdG9idWZcIixcblx0XHRcdFx0XHRqYXZhX291dGVyX2NsYXNzbmFtZTogXCJXcmFwcGVyc1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9tdWx0aXBsZV9maWxlczogdHJ1ZSxcblx0XHRcdFx0XHRvYmpjX2NsYXNzX3ByZWZpeDogXCJHUEJcIixcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlLFxuXHRcdFx0XHRcdG9wdGltaXplX2ZvcjogXCJTUEVFRFwiXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFRpbWVzdGFtcDoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHNlY29uZHM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmFub3M6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZURlc2NyaXB0b3JTZXQ6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsZURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpbGVEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcInBhY2thZ2VcIjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHB1YmxpY0RlcGVuZGVuY3k6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMCxcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYWNrZWQ6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR3ZWFrRGVwZW5kZW5jeToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhY2tlZDogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2VUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZW51bVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VydmljZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZpY2VEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRleHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpbGVPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c291cmNlQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNvdXJjZUNvZGVJbmZvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDlcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3ludGF4OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkRGVzY3JpcHRvclByb3RvXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bmVzdGVkVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGVudW1UeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRW51bURlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGV4dGVuc2lvblJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRXh0ZW5zaW9uUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvbmVvZkRlY2w6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZkRlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1lc3NhZ2VPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cmVzZXJ2ZWRSYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlc2VydmVkUmFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRyZXNlcnZlZE5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTBcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRFeHRlbnNpb25SYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRSZXNlcnZlZFJhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZpZWxkRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhYmVsOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMYWJlbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlR5cGVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR0eXBlTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZXh0ZW5kZWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b25lb2ZJbmRleDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqc29uTmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9ET1VCTEU6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0ZMT0FUOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQ2NDogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfVUlOVDY0OiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9JTlQzMjogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQ2NDogNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfRklYRUQzMjogNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfQk9PTDogOCxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU1RSSU5HOiA5LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9HUk9VUDogMTAsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX01FU1NBR0U6IDExLFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9CWVRFUzogMTIsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1VJTlQzMjogMTMsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX0VOVU06IDE0LFxuXHRcdFx0XHRcdFx0XHRcdFx0VFlQRV9TRklYRUQzMjogMTUsXG5cdFx0XHRcdFx0XHRcdFx0XHRUWVBFX1NGSVhFRDY0OiAxNixcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDMyOiAxNyxcblx0XHRcdFx0XHRcdFx0XHRcdFRZUEVfU0lOVDY0OiAxOFxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGFiZWw6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdExBQkVMX09QVElPTkFMOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0TEFCRUxfUkVRVUlSRUQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRMQUJFTF9SRVBFQVRFRDogM1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0T25lb2ZEZXNjcmlwdG9yUHJvdG86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPbmVvZk9wdGlvbnNcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRFbnVtRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1WYWx1ZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG51bWJlcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJFbnVtVmFsdWVPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U2VydmljZURlc2NyaXB0b3JQcm90bzoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG1ldGhvZDoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk1ldGhvZERlc2NyaXB0b3JQcm90b1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZpY2VPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0TWV0aG9kRGVzY3JpcHRvclByb3RvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0aW5wdXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvdXRwdXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJNZXRob2RPcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2xpZW50U3RyZWFtaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VydmVyU3RyZWFtaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmlsZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRqYXZhUGFja2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0amF2YU91dGVyQ2xhc3NuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhTXVsdGlwbGVGaWxlczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRqYXZhR2VuZXJhdGVFcXVhbHNBbmRIYXNoOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDIwLFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHRydWVcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFTdHJpbmdDaGVja1V0Zjg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMjdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0b3B0aW1pemVGb3I6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wdGltaXplTW9kZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5LFxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFwiZGVmYXVsdFwiOiBcIlNQRUVEXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGdvUGFja2FnZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNjR2VuZXJpY1NlcnZpY2VzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDE2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGphdmFHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMTdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cHlHZW5lcmljU2VydmljZXM6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMThcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjY0VuYWJsZUFyZW5hczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRvYmpjQ2xhc3NQcmVmaXg6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjc2hhcnBOYW1lc3BhY2U6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzN1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MzgsXG5cdFx0XHRcdFx0XHRcdFx0Mzhcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdFx0XHRPcHRpbWl6ZU1vZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFNQRUVEOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0Q09ERV9TSVpFOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0TElURV9SVU5USU1FOiAzXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXNzYWdlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2VTZXRXaXJlRm9ybWF0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bm9TdGFuZGFyZERlc2NyaXB0b3JBY2Nlc3Nvcjoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRtYXBFbnRyeToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJVbmludGVycHJldGVkT3B0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDk5OVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZXh0ZW5zaW9uczogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0MTAwMCxcblx0XHRcdFx0XHRcdFx0XHQ1MzY4NzA5MTFcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHJlc2VydmVkOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQ4LFxuXHRcdFx0XHRcdFx0XHRcdDhcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGRPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Y3R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiU1RSSU5HXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhY2tlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGpzdHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiSlNUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDYsXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWZhdWx0XCI6IFwiSlNfTk9STUFMXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxhenk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0d2Vhazoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRyZXNlcnZlZDogW1xuXHRcdFx0XHRcdFx0XHRbXG5cdFx0XHRcdFx0XHRcdFx0NCxcblx0XHRcdFx0XHRcdFx0XHQ0XG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0Q1R5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFNUUklORzogMCxcblx0XHRcdFx0XHRcdFx0XHRcdENPUkQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRTVFJJTkdfUElFQ0U6IDJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEpTVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTk9STUFMOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfU1RSSU5HOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0SlNfTlVNQkVSOiAyXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRPbmVvZk9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1PcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0YWxsb3dBbGlhczoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVudW1WYWx1ZU9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRkZXByZWNhdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTZXJ2aWNlT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdGRlcHJlY2F0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMzNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0dW5pbnRlcnByZXRlZE9wdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuaW50ZXJwcmV0ZWRPcHRpb25cIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOTk5XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRleHRlbnNpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0XHQxMDAwLFxuXHRcdFx0XHRcdFx0XHRcdDUzNjg3MDkxMVxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRNZXRob2RPcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0ZGVwcmVjYXRlZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR1bmludGVycHJldGVkT3B0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVW5pbnRlcnByZXRlZE9wdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA5OTlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbnM6IFtcblx0XHRcdFx0XHRcdFx0W1xuXHRcdFx0XHRcdFx0XHRcdDEwMDAsXG5cdFx0XHRcdFx0XHRcdFx0NTM2ODcwOTExXG5cdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVuaW50ZXJwcmV0ZWRPcHRpb246IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTmFtZVBhcnRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRpZGVudGlmaWVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBvc2l0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdG5lZ2F0aXZlSW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZG91YmxlVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogOFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdE5hbWVQYXJ0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lUGFydDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcXVpcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0aXNFeHRlbnNpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXF1aXJlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFNvdXJjZUNvZGVJbmZvOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMb2NhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0TG9jYXRpb246IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhdGg6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3Bhbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsZWFkaW5nQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFpbGluZ0NvbW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGVhZGluZ0RldGFjaGVkQ29tbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0R2VuZXJhdGVkQ29kZUluZm86IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRhbm5vdGF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQW5ub3RhdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0QW5ub3RhdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzb3VyY2VGaWxlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0YmVnaW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRTdHJ1Y3Q6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRWYWx1ZToge1xuXHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdGtpbmQ6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XCJudWxsVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwibnVtYmVyVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwic3RyaW5nVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiYm9vbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcImxpc3RWYWx1ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdG51bGxWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bnVtYmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRib29sVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzdHJ1Y3RWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiU3RydWN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bGlzdFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJMaXN0VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHROdWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHROVUxMX1ZBTFVFOiAwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRMaXN0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEVtcHR5OiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdERvdWJsZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEZsb2F0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZmxvYXRcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRJbnQ2NFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0VUludDY0VmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwidWludDY0XCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0SW50MzJWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFVJbnQzMlZhbHVlOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInVpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEJvb2xWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0U3RyaW5nVmFsdWU6IHtcblx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Qnl0ZXNWYWx1ZToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEFueToge1xuXHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdHR5cGVVcmw6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmaXJlc3RvcmU6IHtcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0djE6IHtcblx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0Y3NoYXJwX25hbWVzcGFjZTogXCJHb29nbGUuQ2xvdWQuRmlyZXN0b3JlLlYxXCIsXG5cdFx0XHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9maXJlc3RvcmUvdjE7ZmlyZXN0b3JlXCIsXG5cdFx0XHRcdFx0XHRcdGphdmFfbXVsdGlwbGVfZmlsZXM6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIldyaXRlUHJvdG9cIixcblx0XHRcdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUuZmlyZXN0b3JlLnYxXCIsXG5cdFx0XHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdDRlNcIixcblx0XHRcdFx0XHRcdFx0cGhwX25hbWVzcGFjZTogXCJHb29nbGVcXFxcQ2xvdWRcXFxcRmlyZXN0b3JlXFxcXFYxXCIsXG5cdFx0XHRcdFx0XHRcdHJ1YnlfcGFja2FnZTogXCJHb29nbGU6OkNsb3VkOjpGaXJlc3RvcmU6OlYxXCJcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRNYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFBhdGhzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFByZWNvbmRpdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uZGl0aW9uVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZXhpc3RzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1cGRhdGVUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRleGlzdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFRyYW5zYWN0aW9uT3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZE9ubHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRXcml0ZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZE9ubHk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJSZWFkT25seVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlJlYWRXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRSZWFkV3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0cnlUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRSZWFkT25seToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3JlYXRlVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR1cGRhdGVUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJib29sZWFuVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImludGVnZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG91YmxlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRpbWVzdGFtcFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJpbmdWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYnl0ZXNWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVmZXJlbmNlVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImdlb1BvaW50VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImFycmF5VmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1hcFZhbHVlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRudWxsVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuTnVsbFZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJvb2xlYW5WYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJvb2xcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlZ2VyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQ2NFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvdWJsZVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGltZXN0YW1wVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cmluZ1ZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxN1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGJ5dGVzVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMThcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWZlcmVuY2VWYWx1ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGdlb1BvaW50VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUudHlwZS5MYXRMbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhcnJheVZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogOVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hcFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiTWFwVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEFycmF5VmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdE1hcFZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0a2V5VHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RmlyZXN0b3JlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5kZWZhdWx0X2hvc3QpXCI6IFwiZmlyZXN0b3JlLmdvb2dsZWFwaXMuY29tXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm9hdXRoX3Njb3BlcylcIjogXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtLGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvZGF0YXN0b3JlXCJcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdG1ldGhvZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEdldERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkdldERvY3VtZW50UmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZ2V0XCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRnZXQ6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRMaXN0RG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkxpc3REb2N1bWVudHNSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJMaXN0RG9jdW1lbnRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZ2V0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0ve2NvbGxlY3Rpb25faWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRnZXQ6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn0ve2NvbGxlY3Rpb25faWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRVcGRhdGVEb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJVcGRhdGVEb2N1bWVudFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBhdGNoXCI6IFwiL3YxL3tkb2N1bWVudC5uYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiZG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZG9jdW1lbnQsdXBkYXRlX21hc2tcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhdGNoOiBcIi92MS97ZG9jdW1lbnQubmFtZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcImRvY3VtZW50XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkb2N1bWVudCx1cGRhdGVfbWFza1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RGVsZXRlRG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiRGVsZXRlRG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJnb29nbGUucHJvdG9idWYuRW1wdHlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuZGVsZXRlXCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcIm5hbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCI6IFwiL3YxL3tuYW1lPXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJuYW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRCYXRjaEdldERvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJCYXRjaEdldERvY3VtZW50c1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkJhdGNoR2V0RG9jdW1lbnRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaEdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6YmF0Y2hHZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRCZWdpblRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkJlZ2luVHJhbnNhY3Rpb25SZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJCZWdpblRyYW5zYWN0aW9uUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJlZ2luVHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOmJlZ2luVHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q29tbWl0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkNvbW1pdFJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkNvbW1pdFJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpjb21taXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcImRhdGFiYXNlLHdyaXRlc1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpjb21taXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx3cml0ZXNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFJvbGxiYWNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIlJvbGxiYWNrUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkVtcHR5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpyb2xsYmFja1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLm1ldGhvZF9zaWduYXR1cmUpXCI6IFwiZGF0YWJhc2UsdHJhbnNhY3Rpb25cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6cm9sbGJhY2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkubWV0aG9kX3NpZ25hdHVyZSlcIjogXCJkYXRhYmFzZSx0cmFuc2FjdGlvblwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UnVuUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiUnVuUXVlcnlSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJSdW5RdWVyeVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYWRkaXRpb25hbF9iaW5kaW5ncy5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cnVuUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MuYm9keVwiOiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZWRPcHRpb25zOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKVwiOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHN9OnJ1blF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhZGRpdGlvbmFsX2JpbmRpbmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50cy8qLyoqfTpydW5RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJQYXJ0aXRpb25RdWVyeVJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIlBhcnRpdGlvblF1ZXJ5UmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9OnBhcnRpdGlvblF1ZXJ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLmJvZHlcIjogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpwYXJ0aXRpb25RdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWRkaXRpb25hbF9iaW5kaW5nczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBvc3Q6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKi8qKn06cGFydGl0aW9uUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRib2R5OiBcIipcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0V3JpdGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiV3JpdGVSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RTdHJlYW06IHRydWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJXcml0ZVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6d3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmJvZHlcIjogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97ZGF0YWJhc2U9cHJvamVjdHMvKi9kYXRhYmFzZXMvKn0vZG9jdW1lbnRzOndyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0TGlzdGVuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RUeXBlOiBcIkxpc3RlblJlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFN0cmVhbTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkxpc3RlblJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3tkYXRhYmFzZT1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qfS9kb2N1bWVudHM6bGlzdGVuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpsaXN0ZW5cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRMaXN0Q29sbGVjdGlvbklkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJMaXN0Q29sbGVjdGlvbklkc1JlcXVlc3RcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VUeXBlOiBcIkxpc3RDb2xsZWN0aW9uSWRzUmVzcG9uc2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzfTpsaXN0Q29sbGVjdGlvbklkc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcIipcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLmFkZGl0aW9uYWxfYmluZGluZ3MucG9zdFwiOiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5hZGRpdGlvbmFsX2JpbmRpbmdzLmJvZHlcIjogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcInBhcmVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve3BhcmVudD1wcm9qZWN0cy8qL2RhdGFiYXNlcy8qL2RvY3VtZW50c306bGlzdENvbGxlY3Rpb25JZHNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxfYmluZGluZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyovKip9Omxpc3RDb2xsZWN0aW9uSWRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCIqXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5tZXRob2Rfc2lnbmF0dXJlKVwiOiBcInBhcmVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0QmF0Y2hXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0VHlwZTogXCJCYXRjaFdyaXRlUmVxdWVzdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZVR5cGU6IFwiQmF0Y2hXcml0ZVJlc3BvbnNlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApLnBvc3RcIjogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaFdyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5ib2R5XCI6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhcnNlZE9wdGlvbnM6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmh0dHApXCI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cG9zdDogXCIvdjEve2RhdGFiYXNlPXByb2plY3RzLyovZGF0YWJhc2VzLyp9L2RvY3VtZW50czpiYXRjaFdyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJvZHk6IFwiKlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Q3JlYXRlRG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmVxdWVzdFR5cGU6IFwiQ3JlYXRlRG9jdW1lbnRSZXF1ZXN0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5odHRwKS5wb3N0XCI6IFwiL3YxL3twYXJlbnQ9cHJvamVjdHMvKi9kYXRhYmFzZXMvKi9kb2N1bWVudHMvKip9L3tjb2xsZWN0aW9uX2lkfVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cCkuYm9keVwiOiBcImRvY3VtZW50XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyc2VkT3B0aW9uczogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuaHR0cClcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwb3N0OiBcIi92MS97cGFyZW50PXByb2plY3RzLyovZGF0YWJhc2VzLyovZG9jdW1lbnRzLyoqfS97Y29sbGVjdGlvbl9pZH1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ym9keTogXCJkb2N1bWVudFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRHZXREb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNpc3RlbmN5U2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInRyYW5zYWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3REb2N1bWVudHNSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVhZFRpbWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JkZXJCeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDdcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHNob3dNaXNzaW5nOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMTJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3REb2N1bWVudHNSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5leHRQYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdENyZWF0ZURvY3VtZW50UmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2xsZWN0aW9uSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRVcGRhdGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZU1hc2s6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudE1hc2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJlY29uZGl0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREZWxldGVEb2N1bWVudFJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnREb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlByZWNvbmRpdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hHZXREb2N1bWVudHNSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibmV3VHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRtYXNrOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRNYXNrXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld1RyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVHJhbnNhY3Rpb25PcHRpb25zXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZvdW5kXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJtaXNzaW5nXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3VuZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bWlzc2luZzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEJlZ2luVHJhbnNhY3Rpb25SZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmVnaW5UcmFuc2FjdGlvblJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDb21taXRSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhYmFzZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJXcml0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdENvbW1pdFJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tbWl0VGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFJvbGxiYWNrUmVxdWVzdDoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YWJhc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UnVuUXVlcnlSZXF1ZXN0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRxdWVyeVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInN0cnVjdHVyZWRRdWVyeVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zaXN0ZW5jeVNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2FjdGlvblwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwibmV3VHJhbnNhY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlYWRUaW1lXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDVcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2FjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRyYW5zYWN0aW9uT3B0aW9uc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0UnVuUXVlcnlSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNhY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJieXRlc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRza2lwcGVkUmVzdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic3RydWN0dXJlZFF1ZXJ5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIihnb29nbGUuYXBpLmZpZWxkX2JlaGF2aW9yKVwiOiBcIlJFUVVJUkVEXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlN0cnVjdHVyZWRRdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhcnRpdGlvbkNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50NjRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlVG9rZW46IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYWdlU2l6ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRQYXJ0aXRpb25RdWVyeVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJ0aXRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDdXJzb3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0UGFnZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1Ub2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZVJlc3BvbnNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHJlYW1JZDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0cmVhbVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZVJlc3VsdHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlUmVzdWx0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tbWl0VGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdExpc3RlblJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYWRkVGFyZ2V0XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZW1vdmVUYXJnZXRcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRhZGRUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUYXJnZXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVUYXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGxhYmVsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRrZXlUeXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGlzdGVuUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidGFyZ2V0Q2hhbmdlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkb2N1bWVudENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnREZWxldGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRvY3VtZW50UmVtb3ZlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmaWx0ZXJcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldENoYW5nZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlRhcmdldENoYW5nZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRG9jdW1lbnRDaGFuZ2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudERlbGV0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50RGVsZXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRSZW1vdmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJEb2N1bWVudFJlbW92ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkV4aXN0ZW5jZUZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0VGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJxdWVyeVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiZG9jdW1lbnRzXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInJlc3VtZVRva2VuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJyZWFkVGltZVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0cXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJRdWVyeVRhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50c1RhcmdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VtZVRva2VuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYnl0ZXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9uY2U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdERvY3VtZW50c1RhcmdldDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFF1ZXJ5VGFyZ2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHF1ZXJ5VHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJzdHJ1Y3R1cmVkUXVlcnlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN0cnVjdHVyZWRRdWVyeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJTdHJ1Y3R1cmVkUXVlcnlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRUYXJnZXRDaGFuZ2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldENoYW5nZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJUYXJnZXRDaGFuZ2VUeXBlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNhdXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnJwYy5TdGF0dXNcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bWVUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImJ5dGVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZFRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFRhcmdldENoYW5nZVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Tk9fQ0hBTkdFOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFERDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRSRU1PVkU6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Q1VSUkVOVDogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRSRVNFVDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRMaXN0Q29sbGVjdGlvbklkc1JlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiKGdvb2dsZS5hcGkuZmllbGRfYmVoYXZpb3IpXCI6IFwiUkVRVUlSRURcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cGFnZVNpemU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHBhZ2VUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0TGlzdENvbGxlY3Rpb25JZHNSZXNwb25zZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29sbGVjdGlvbklkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV4dFBhZ2VUb2tlbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0QmF0Y2hXcml0ZVJlcXVlc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCIoZ29vZ2xlLmFwaS5maWVsZF9iZWhhdmlvcilcIjogXCJSRVFVSVJFRFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3cml0ZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIldyaXRlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0bGFiZWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGtleVR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRCYXRjaFdyaXRlUmVzcG9uc2U6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlUmVzdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiV3JpdGVSZXN1bHRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5ycGMuU3RhdHVzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRTdHJ1Y3R1cmVkUXVlcnk6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlByb2plY3Rpb25cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmcm9tOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDb2xsZWN0aW9uU2VsZWN0b3JcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR3aGVyZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdG9yZGVyQnk6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9yZGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRBdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkN1cnNvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZEF0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQ3Vyc29yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA4XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0b2Zmc2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRsaW1pdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5JbnQzMlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdENvbGxlY3Rpb25TZWxlY3Rvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb2xsZWN0aW9uSWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWxsRGVzY2VuZGFudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYm9vbFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2ZzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlsdGVyVHlwZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b25lb2Y6IFtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJjb21wb3NpdGVGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJmaWVsZEZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcInVuYXJ5RmlsdGVyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbXBvc2l0ZUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJDb21wb3NpdGVGaWx0ZXJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZEZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJGaWVsZEZpbHRlclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuYXJ5RmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlVuYXJ5RmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdENvbXBvc2l0ZUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcGVyYXRvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpbHRlcnM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmlsdGVyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0T3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPUEVSQVRPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0QU5EOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RmllbGRGaWx0ZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJPcGVyYXRvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0T3BlcmF0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPUEVSQVRPUl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0TEVTU19USEFOOiAxLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRMRVNTX1RIQU5fT1JfRVFVQUw6IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEdSRUFURVJfVEhBTjogMyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0R1JFQVRFUl9USEFOX09SX0VRVUFMOiA0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRFUVVBTDogNSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Tk9UX0VRVUFMOiA2LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBUlJBWV9DT05UQUlOUzogNyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0SU46IDgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFSUkFZX0NPTlRBSU5TX0FOWTogOSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Tk9UX0lOOiAxMFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFVuYXJ5RmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhbmRUeXBlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbmVvZjogW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImZpZWxkXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIk9wZXJhdG9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRPcGVyYXRvcjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdE9QRVJBVE9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRJU19OQU46IDIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05VTEw6IDMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05PVF9OQU46IDQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdElTX05PVF9OVUxMOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0T3JkZXI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmllbGQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRGlyZWN0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkUmVmZXJlbmNlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0UHJvamVjdGlvbjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiRmllbGRSZWZlcmVuY2VcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0RGlyZWN0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdERJUkVDVElPTl9VTlNQRUNJRklFRDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBU0NFTkRJTkc6IDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0REVTQ0VORElORzogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRDdXJzb3I6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRiZWZvcmU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJib29sXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRXcml0ZToge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3BlcmF0aW9uOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ1cGRhdGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImRlbGV0ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwidmVyaWZ5XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJ0cmFuc2Zvcm1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHZlcmlmeToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dXBkYXRlTWFzazoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50TWFza1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50VHJhbnNmb3JtLkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudERvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiUHJlY29uZGl0aW9uXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudFRyYW5zZm9ybToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZFRyYW5zZm9ybXM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkZpZWxkVHJhbnNmb3JtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdEZpZWxkVHJhbnNmb3JtOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybVR5cGU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwic2V0VG9TZXJ2ZXJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcImluY3JlbWVudFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcIm1heGltdW1cIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XCJtaW5pbXVtXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiYXBwZW5kTWlzc2luZ0VsZW1lbnRzXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwicmVtb3ZlQWxsRnJvbUFycmF5XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpZWxkUGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRUb1NlcnZlclZhbHVlOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlNlcnZlclZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIlZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4aW11bToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pbmltdW06IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcHBlbmRNaXNzaW5nRWxlbWVudHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiQXJyYXlWYWx1ZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZUFsbEZyb21BcnJheToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJBcnJheVZhbHVlXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0U2VydmVyVmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRTRVJWRVJfVkFMVUVfVU5TUEVDSUZJRUQ6IDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFJFUVVFU1RfVElNRTogMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0V3JpdGVSZXN1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHVwZGF0ZVRpbWU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtUmVzdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiVmFsdWVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdERvY3VtZW50Q2hhbmdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZmllbGRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkRvY3VtZW50XCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZWRUYXJnZXRJZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImludDMyXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiA2XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHREb2N1bWVudERlbGV0ZToge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZG9jdW1lbnQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVkVGFyZ2V0SWRzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWRUaW1lOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogNFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0RG9jdW1lbnRSZW1vdmU6IHtcblx0XHRcdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRvY3VtZW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlZFRhcmdldElkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkVGltZToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDRcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdEV4aXN0ZW5jZUZpbHRlcjoge1xuXHRcdFx0XHRcdFx0XHRcdGZpZWxkczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0SWQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJpbnQzMlwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhcGk6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGdvX3BhY2thZ2U6IFwiZ29vZ2xlLmdvbGFuZy5vcmcvZ2VucHJvdG8vZ29vZ2xlYXBpcy9hcGkvYW5ub3RhdGlvbnM7YW5ub3RhdGlvbnNcIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIkh0dHBQcm90b1wiLFxuXHRcdFx0XHRcdGphdmFfcGFja2FnZTogXCJjb20uZ29vZ2xlLmFwaVwiLFxuXHRcdFx0XHRcdG9iamNfY2xhc3NfcHJlZml4OiBcIkdBUElcIixcblx0XHRcdFx0XHRjY19lbmFibGVfYXJlbmFzOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5lc3RlZDoge1xuXHRcdFx0XHRcdGh0dHA6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiSHR0cFJ1bGVcIixcblx0XHRcdFx0XHRcdGlkOiA3MjI5NTcyOCxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuTWV0aG9kT3B0aW9uc1wiXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRIdHRwOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0cnVsZXM6IHtcblx0XHRcdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJIdHRwUnVsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEh0dHBSdWxlOiB7XG5cdFx0XHRcdFx0XHRvbmVvZnM6IHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjoge1xuXHRcdFx0XHRcdFx0XHRcdG9uZW9mOiBbXG5cdFx0XHRcdFx0XHRcdFx0XHRcImdldFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJwdXRcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicG9zdFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJkZWxldGVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwicGF0Y2hcIixcblx0XHRcdFx0XHRcdFx0XHRcdFwiY3VzdG9tXCJcblx0XHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Z2V0OiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRwdXQ6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBvc3Q6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA0XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFwiZGVsZXRlXCI6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA1XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdHBhdGNoOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogNlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjdXN0b206IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkN1c3RvbUh0dHBQYXR0ZXJuXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDhcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c2VsZWN0b3I6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGJvZHk6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiA3XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGFkZGl0aW9uYWxCaW5kaW5nczoge1xuXHRcdFx0XHRcdFx0XHRcdHJ1bGU6IFwicmVwZWF0ZWRcIixcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcIkh0dHBSdWxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDExXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdEN1c3RvbUh0dHBQYXR0ZXJuOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0a2luZDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDFcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0cGF0aDoge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0bWV0aG9kU2lnbmF0dXJlOiB7XG5cdFx0XHRcdFx0XHRydWxlOiBcInJlcGVhdGVkXCIsXG5cdFx0XHRcdFx0XHR0eXBlOiBcInN0cmluZ1wiLFxuXHRcdFx0XHRcdFx0aWQ6IDEwNTEsXG5cdFx0XHRcdFx0XHRleHRlbmQ6IFwiZ29vZ2xlLnByb3RvYnVmLk1ldGhvZE9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZGVmYXVsdEhvc3Q6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA0OSxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuU2VydmljZU9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0b2F1dGhTY29wZXM6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwic3RyaW5nXCIsXG5cdFx0XHRcdFx0XHRpZDogMTA1MCxcblx0XHRcdFx0XHRcdGV4dGVuZDogXCJnb29nbGUucHJvdG9idWYuU2VydmljZU9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0ZmllbGRCZWhhdmlvcjoge1xuXHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0dHlwZTogXCJnb29nbGUuYXBpLkZpZWxkQmVoYXZpb3JcIixcblx0XHRcdFx0XHRcdGlkOiAxMDUyLFxuXHRcdFx0XHRcdFx0ZXh0ZW5kOiBcImdvb2dsZS5wcm90b2J1Zi5GaWVsZE9wdGlvbnNcIlxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0RmllbGRCZWhhdmlvcjoge1xuXHRcdFx0XHRcdFx0dmFsdWVzOiB7XG5cdFx0XHRcdFx0XHRcdEZJRUxEX0JFSEFWSU9SX1VOU1BFQ0lGSUVEOiAwLFxuXHRcdFx0XHRcdFx0XHRPUFRJT05BTDogMSxcblx0XHRcdFx0XHRcdFx0UkVRVUlSRUQ6IDIsXG5cdFx0XHRcdFx0XHRcdE9VVFBVVF9PTkxZOiAzLFxuXHRcdFx0XHRcdFx0XHRJTlBVVF9PTkxZOiA0LFxuXHRcdFx0XHRcdFx0XHRJTU1VVEFCTEU6IDUsXG5cdFx0XHRcdFx0XHRcdFVOT1JERVJFRF9MSVNUOiA2LFxuXHRcdFx0XHRcdFx0XHROT05fRU1QVFlfREVGQVVMVDogN1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHR5cGU6IHtcblx0XHRcdFx0b3B0aW9uczoge1xuXHRcdFx0XHRcdGNjX2VuYWJsZV9hcmVuYXM6IHRydWUsXG5cdFx0XHRcdFx0Z29fcGFja2FnZTogXCJnb29nbGUuZ29sYW5nLm9yZy9nZW5wcm90by9nb29nbGVhcGlzL3R5cGUvbGF0bG5nO2xhdGxuZ1wiLFxuXHRcdFx0XHRcdGphdmFfbXVsdGlwbGVfZmlsZXM6IHRydWUsXG5cdFx0XHRcdFx0amF2YV9vdXRlcl9jbGFzc25hbWU6IFwiTGF0TG5nUHJvdG9cIixcblx0XHRcdFx0XHRqYXZhX3BhY2thZ2U6IFwiY29tLmdvb2dsZS50eXBlXCIsXG5cdFx0XHRcdFx0b2JqY19jbGFzc19wcmVmaXg6IFwiR1RQXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0TGF0TG5nOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0bGF0aXR1ZGU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImRvdWJsZVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAxXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGxvbmdpdHVkZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZG91YmxlXCIsXG5cdFx0XHRcdFx0XHRcdFx0aWQ6IDJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJwYzoge1xuXHRcdFx0XHRvcHRpb25zOiB7XG5cdFx0XHRcdFx0Y2NfZW5hYmxlX2FyZW5hczogdHJ1ZSxcblx0XHRcdFx0XHRnb19wYWNrYWdlOiBcImdvb2dsZS5nb2xhbmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvcnBjL3N0YXR1cztzdGF0dXNcIixcblx0XHRcdFx0XHRqYXZhX211bHRpcGxlX2ZpbGVzOiB0cnVlLFxuXHRcdFx0XHRcdGphdmFfb3V0ZXJfY2xhc3NuYW1lOiBcIlN0YXR1c1Byb3RvXCIsXG5cdFx0XHRcdFx0amF2YV9wYWNrYWdlOiBcImNvbS5nb29nbGUucnBjXCIsXG5cdFx0XHRcdFx0b2JqY19jbGFzc19wcmVmaXg6IFwiUlBDXCJcblx0XHRcdFx0fSxcblx0XHRcdFx0bmVzdGVkOiB7XG5cdFx0XHRcdFx0U3RhdHVzOiB7XG5cdFx0XHRcdFx0XHRmaWVsZHM6IHtcblx0XHRcdFx0XHRcdFx0Y29kZToge1xuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiaW50MzJcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiB7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzdHJpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRpZDogMlxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cnVsZTogXCJyZXBlYXRlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZ29vZ2xlLnByb3RvYnVmLkFueVwiLFxuXHRcdFx0XHRcdFx0XHRcdGlkOiAzXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG52YXIgcHJvdG9zID0ge1xuXHRuZXN0ZWQ6IG5lc3RlZFxufTtcblxudmFyIHByb3RvcyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIG5lc3RlZDogbmVzdGVkLFxuICAnZGVmYXVsdCc6IHByb3Rvc1xufSk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBVc2VkIGJ5IHRlc3RzIHNvIHdlIGNhbiBtYXRjaCBAZ3JwYy9wcm90by1sb2FkZXIgYmVoYXZpb3IuICovXHJcbmNvbnN0IHByb3RvTG9hZGVyT3B0aW9ucyA9IHtcclxuICAgIGxvbmdzOiBTdHJpbmcsXHJcbiAgICBlbnVtczogU3RyaW5nLFxyXG4gICAgZGVmYXVsdHM6IHRydWUsXHJcbiAgICBvbmVvZnM6IGZhbHNlXHJcbn07XHJcbi8qKlxyXG4gKiBMb2FkcyB0aGUgcHJvdG9jb2wgYnVmZmVyIGRlZmluaXRpb25zIGZvciBGaXJlc3RvcmUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBHcnBjT2JqZWN0IHJlcHJlc2VudGluZyBvdXIgcHJvdG9zLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9hZFByb3RvcygpIHtcclxuICAgIGNvbnN0IHBhY2thZ2VEZWZpbml0aW9uID0gcHJvdG9Mb2FkZXIuZnJvbUpTT04ocHJvdG9zJDEsIHByb3RvTG9hZGVyT3B0aW9ucyk7XHJcbiAgICByZXR1cm4gZ3JwYy5sb2FkUGFja2FnZURlZmluaXRpb24ocGFja2FnZURlZmluaXRpb24pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBMb2FkcyB0aGUgR1JQQyBzdGFjayAqL1xyXG5mdW5jdGlvbiBuZXdDb25uZWN0aW9uKGRhdGFiYXNlSW5mbykge1xyXG4gICAgY29uc3QgcHJvdG9zID0gbG9hZFByb3RvcygpO1xyXG4gICAgcmV0dXJuIG5ldyBHcnBjQ29ubmVjdGlvbihwcm90b3MsIGRhdGFiYXNlSW5mbyk7XHJcbn1cclxuLyoqIFJldHVybiB0aGUgUGxhdGZvcm0tc3BlY2lmaWMgY29ubmVjdGl2aXR5IG1vbml0b3IuICovXHJcbmZ1bmN0aW9uIG5ld0Nvbm5lY3Rpdml0eU1vbml0b3IoKSB7XHJcbiAgICByZXR1cm4gbmV3IE5vb3BDb25uZWN0aXZpdHlNb25pdG9yKCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFRoZSBQbGF0Zm9ybSdzICd3aW5kb3cnIGltcGxlbWVudGF0aW9uIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZS4gKi9cclxuZnVuY3Rpb24gZ2V0V2luZG93KCkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52LlVTRV9NT0NLX1BFUlNJU1RFTkNFID09PSAnWUVTJykge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqIFRoZSBQbGF0Zm9ybSdzICdkb2N1bWVudCcgaW1wbGVtZW50YXRpb24gb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlLiAqL1xyXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1NlcmlhbGl6ZXIoZGF0YWJhc2VJZCkge1xyXG4gICAgcmV0dXJuIG5ldyBKc29uUHJvdG9TZXJpYWxpemVyKGRhdGFiYXNlSWQsIC8qIHVzZVByb3RvM0pzb249ICovIGZhbHNlKTtcclxufVxyXG4vKipcclxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFBsYXRmb3JtJ3MgJ1RleHRFbmNvZGVyJyBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1RleHRFbmNvZGVyKCkge1xyXG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpO1xyXG59XHJcbi8qKlxyXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgUGxhdGZvcm0ncyAnVGV4dERlY29kZXInIGltcGxlbWVudGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3VGV4dERlY29kZXIoKSB7XHJcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckOCA9ICdFeHBvbmVudGlhbEJhY2tvZmYnO1xyXG4vKipcclxuICogSW5pdGlhbCBiYWNrb2ZmIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGFmdGVyIGFuIGVycm9yLlxyXG4gKiBTZXQgdG8gMXMgYWNjb3JkaW5nIHRvIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9hcGlzL2Rlc2lnbi9lcnJvcnMuXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfSU5JVElBTF9ERUxBWV9NUyA9IDEwMDA7XHJcbmNvbnN0IERFRkFVTFRfQkFDS09GRl9GQUNUT1IgPSAxLjU7XHJcbi8qKiBNYXhpbXVtIGJhY2tvZmYgdGltZSBpbiBtaWxsaXNlY29uZHMgKi9cclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX01BWF9ERUxBWV9NUyA9IDYwICogMTAwMDtcclxuLyoqXHJcbiAqIEEgaGVscGVyIGZvciBydW5uaW5nIGRlbGF5ZWQgdGFza3MgZm9sbG93aW5nIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYgY3VydmVcclxuICogYmV0d2VlbiBhdHRlbXB0cy5cclxuICpcclxuICogRWFjaCBkZWxheSBpcyBtYWRlIHVwIG9mIGEgXCJiYXNlXCIgZGVsYXkgd2hpY2ggZm9sbG93cyB0aGUgZXhwb25lbnRpYWxcclxuICogYmFja29mZiBjdXJ2ZSwgYW5kIGEgKy8tIDUwJSBcImppdHRlclwiIHRoYXQgaXMgY2FsY3VsYXRlZCBhbmQgYWRkZWQgdG8gdGhlXHJcbiAqIGJhc2UgZGVsYXkuIFRoaXMgcHJldmVudHMgY2xpZW50cyBmcm9tIGFjY2lkZW50YWxseSBzeW5jaHJvbml6aW5nIHRoZWlyXHJcbiAqIGRlbGF5cyBjYXVzaW5nIHNwaWtlcyBvZiBsb2FkIHRvIHRoZSBiYWNrZW5kLlxyXG4gKi9cclxuY2xhc3MgRXhwb25lbnRpYWxCYWNrb2ZmIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgQXN5bmNRdWV1ZSB0byBydW4gYmFja29mZiBvcGVyYXRpb25zIG9uLlxyXG4gICAgICovXHJcbiAgICBxdWV1ZSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBJRCB0byB1c2Ugd2hlbiBzY2hlZHVsaW5nIGJhY2tvZmYgb3BlcmF0aW9ucyBvbiB0aGUgQXN5bmNRdWV1ZS5cclxuICAgICAqL1xyXG4gICAgdGltZXJJZCwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbml0aWFsIGRlbGF5ICh1c2VkIGFzIHRoZSBiYXNlIGRlbGF5IG9uIHRoZSBmaXJzdCByZXRyeSBhdHRlbXB0KS5cclxuICAgICAqIE5vdGUgdGhhdCBqaXR0ZXIgd2lsbCBzdGlsbCBiZSBhcHBsaWVkLCBzbyB0aGUgYWN0dWFsIGRlbGF5IGNvdWxkIGJlIGFzXHJcbiAgICAgKiBsaXR0bGUgYXMgMC41KmluaXRpYWxEZWxheU1zLlxyXG4gICAgICovXHJcbiAgICBpbml0aWFsRGVsYXlNcyA9IERFRkFVTFRfQkFDS09GRl9JTklUSUFMX0RFTEFZX01TLCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG11bHRpcGxpZXIgdG8gdXNlIHRvIGRldGVybWluZSB0aGUgZXh0ZW5kZWQgYmFzZSBkZWxheSBhZnRlciBlYWNoXHJcbiAgICAgKiBhdHRlbXB0LlxyXG4gICAgICovXHJcbiAgICBiYWNrb2ZmRmFjdG9yID0gREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIGJhc2UgZGVsYXkgYWZ0ZXIgd2hpY2ggbm8gZnVydGhlciBiYWNrb2ZmIGlzIHBlcmZvcm1lZC5cclxuICAgICAqIE5vdGUgdGhhdCBqaXR0ZXIgd2lsbCBzdGlsbCBiZSBhcHBsaWVkLCBzbyB0aGUgYWN0dWFsIGRlbGF5IGNvdWxkIGJlIGFzXHJcbiAgICAgKiBtdWNoIGFzIDEuNSptYXhEZWxheU1zLlxyXG4gICAgICovXHJcbiAgICBtYXhEZWxheU1zID0gREVGQVVMVF9CQUNLT0ZGX01BWF9ERUxBWV9NUykge1xyXG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSB0aW1lcklkO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbERlbGF5TXMgPSBpbml0aWFsRGVsYXlNcztcclxuICAgICAgICB0aGlzLmJhY2tvZmZGYWN0b3IgPSBiYWNrb2ZmRmFjdG9yO1xyXG4gICAgICAgIHRoaXMubWF4RGVsYXlNcyA9IG1heERlbGF5TXM7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gMDtcclxuICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgLyoqIFRoZSBsYXN0IGJhY2tvZmYgYXR0ZW1wdCwgYXMgZXBvY2ggbWlsbGlzZWNvbmRzLiAqL1xyXG4gICAgICAgIHRoaXMubGFzdEF0dGVtcHRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgYmFja29mZiBkZWxheS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgdmVyeSBuZXh0IGJhY2tvZmZBbmRXYWl0KCkgd2lsbCBoYXZlIG5vIGRlbGF5LiBJZiBpdCBpcyBjYWxsZWQgYWdhaW5cclxuICAgICAqIChpLmUuIGR1ZSB0byBhbiBlcnJvciksIGluaXRpYWxEZWxheU1zIChwbHVzIGppdHRlcikgd2lsbCBiZSB1c2VkLCBhbmRcclxuICAgICAqIHN1YnNlcXVlbnQgb25lcyB3aWxsIGluY3JlYXNlIGFjY29yZGluZyB0byB0aGUgYmFja29mZkZhY3Rvci5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBiYWNrb2ZmIGRlbGF5IHRvIHRoZSBtYXhpbXVtIGRlbGF5IChlLmcuIGZvciB1c2UgYWZ0ZXIgYVxyXG4gICAgICogUkVTT1VSQ0VfRVhIQVVTVEVEIGVycm9yKS5cclxuICAgICAqL1xyXG4gICAgcmVzZXRUb01heCgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgPSB0aGlzLm1heERlbGF5TXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgY3VycmVudERlbGF5TXMsIGFuZCBpbmNyZWFzZXMgdGhlXHJcbiAgICAgKiBkZWxheSBmb3IgYW55IHN1YnNlcXVlbnQgYXR0ZW1wdHMuIElmIHRoZXJlIHdhcyBhIHBlbmRpbmcgYmFja29mZiBvcGVyYXRpb25cclxuICAgICAqIGFscmVhZHksIGl0IHdpbGwgYmUgY2FuY2VsZWQuXHJcbiAgICAgKi9cclxuICAgIGJhY2tvZmZBbmRSdW4ob3ApIHtcclxuICAgICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgYmFja29mZiBvcGVyYXRpb24uXHJcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcclxuICAgICAgICAvLyBGaXJzdCBzY2hlZHVsZSB1c2luZyB0aGUgY3VycmVudCBiYXNlICh3aGljaCBtYXkgYmUgMCBhbmQgc2hvdWxkIGJlXHJcbiAgICAgICAgLy8gaG9ub3JlZCBhcyBzdWNoKS5cclxuICAgICAgICBjb25zdCBkZXNpcmVkRGVsYXlXaXRoSml0dGVyTXMgPSBNYXRoLmZsb29yKHRoaXMuY3VycmVudEJhc2VNcyArIHRoaXMuaml0dGVyRGVsYXlNcygpKTtcclxuICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IGxhc3RBdHRlbXB0VGltZSBiZWluZyBpbiB0aGUgZnV0dXJlIGR1ZSB0byBhIGNsb2NrIGNoYW5nZS5cclxuICAgICAgICBjb25zdCBkZWxheVNvRmFyTXMgPSBNYXRoLm1heCgwLCBEYXRlLm5vdygpIC0gdGhpcy5sYXN0QXR0ZW1wdFRpbWUpO1xyXG4gICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIGJhY2tvZmYgZGVsYXkgYWxyZWFkeSBiZWluZyBwYXN0LlxyXG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0RlbGF5TXMgPSBNYXRoLm1heCgwLCBkZXNpcmVkRGVsYXlXaXRoSml0dGVyTXMgLSBkZWxheVNvRmFyTXMpO1xyXG4gICAgICAgIGlmIChyZW1haW5pbmdEZWxheU1zID4gMCkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDgsIGBCYWNraW5nIG9mZiBmb3IgJHtyZW1haW5pbmdEZWxheU1zfSBtcyBgICtcclxuICAgICAgICAgICAgICAgIGAoYmFzZSBkZWxheTogJHt0aGlzLmN1cnJlbnRCYXNlTXN9IG1zLCBgICtcclxuICAgICAgICAgICAgICAgIGBkZWxheSB3aXRoIGppdHRlcjogJHtkZXNpcmVkRGVsYXlXaXRoSml0dGVyTXN9IG1zLCBgICtcclxuICAgICAgICAgICAgICAgIGBsYXN0IGF0dGVtcHQ6ICR7ZGVsYXlTb0Zhck1zfSBtcyBhZ28pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gdGhpcy5xdWV1ZS5lbnF1ZXVlQWZ0ZXJEZWxheSh0aGlzLnRpbWVySWQsIHJlbWFpbmluZ0RlbGF5TXMsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0QXR0ZW1wdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3AoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBBcHBseSBiYWNrb2ZmIGZhY3RvciB0byBkZXRlcm1pbmUgbmV4dCBkZWxheSBhbmQgZW5zdXJlIGl0IGlzIHdpdGhpblxyXG4gICAgICAgIC8vIGJvdW5kcy5cclxuICAgICAgICB0aGlzLmN1cnJlbnRCYXNlTXMgKj0gdGhpcy5iYWNrb2ZmRmFjdG9yO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCYXNlTXMgPCB0aGlzLmluaXRpYWxEZWxheU1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJhc2VNcyA9IHRoaXMuaW5pdGlhbERlbGF5TXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCYXNlTXMgPiB0aGlzLm1heERlbGF5TXMpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmFzZU1zID0gdGhpcy5tYXhEZWxheU1zO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNraXBCYWNrb2ZmKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVyUHJvbWlzZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVyUHJvbWlzZS5za2lwRGVsYXkoKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lclByb21pc2UgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lclByb21pc2UuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXJQcm9taXNlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIHJhbmRvbSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWy1jdXJyZW50QmFzZU1zLzIsIGN1cnJlbnRCYXNlTXMvMl0gKi9cclxuICAgIGppdHRlckRlbGF5TXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMuY3VycmVudEJhc2VNcztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJDcgPSAnUGVyc2lzdGVudFN0cmVhbSc7XHJcbi8qKiBUaGUgdGltZSBhIHN0cmVhbSBzdGF5cyBvcGVuIGFmdGVyIGl0IGlzIG1hcmtlZCBpZGxlLiAqL1xyXG5jb25zdCBJRExFX1RJTUVPVVRfTVMgPSA2MCAqIDEwMDA7XHJcbi8qKiBUaGUgdGltZSBhIHN0cmVhbSBzdGF5cyBvcGVuIHVudGlsIHdlIGNvbnNpZGVyIGl0IGhlYWx0aHkuICovXHJcbmNvbnN0IEhFQUxUSFlfVElNRU9VVF9NUyA9IDEwICogMTAwMDtcclxuLyoqXHJcbiAqIEEgUGVyc2lzdGVudFN0cmVhbSBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHN0cmVhbWluZyBSUENcclxuICogdG8gdGhlIEZpcmVzdG9yZSBiYWNrZW5kLiBJdCdzIGJ1aWx0IG9uIHRvcCBvZiB0aGUgY29ubmVjdGlvbnMgb3duIHN1cHBvcnRcclxuICogZm9yIHN0cmVhbWluZyBSUENzLCBhbmQgYWRkcyBzZXZlcmFsIGNyaXRpY2FsIGZlYXR1cmVzIGZvciBvdXIgY2xpZW50czpcclxuICpcclxuICogICAtIEV4cG9uZW50aWFsIGJhY2tvZmYgb24gZmFpbHVyZVxyXG4gKiAgIC0gQXV0aGVudGljYXRpb24gdmlhIENyZWRlbnRpYWxzUHJvdmlkZXJcclxuICogICAtIERpc3BhdGNoaW5nIGFsbCBjYWxsYmFja3MgaW50byB0aGUgc2hhcmVkIHdvcmtlciBxdWV1ZVxyXG4gKiAgIC0gQ2xvc2luZyBpZGxlIHN0cmVhbXMgYWZ0ZXIgNjAgc2Vjb25kcyBvZiBpbmFjdGl2aXR5XHJcbiAqXHJcbiAqIFN1YmNsYXNzZXMgb2YgUGVyc2lzdGVudFN0cmVhbSBpbXBsZW1lbnQgc2VyaWFsaXphdGlvbiBvZiBtb2RlbHMgdG8gYW5kXHJcbiAqIGZyb20gdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHByb3RvY29sIGJ1ZmZlcnMgZm9yIGEgc3BlY2lmaWNcclxuICogc3RyZWFtaW5nIFJQQy5cclxuICpcclxuICogIyMgU3RhcnRpbmcgYW5kIFN0b3BwaW5nXHJcbiAqXHJcbiAqIFN0cmVhbWluZyBSUENzIGFyZSBzdGF0ZWZ1bCBhbmQgbmVlZCB0byBiZSBzdGFydCgpZWQgYmVmb3JlIG1lc3NhZ2VzIGNhblxyXG4gKiBiZSBzZW50IGFuZCByZWNlaXZlZC4gVGhlIFBlcnNpc3RlbnRTdHJlYW0gd2lsbCBjYWxsIHRoZSBvbk9wZW4oKSBmdW5jdGlvblxyXG4gKiBvZiB0aGUgbGlzdGVuZXIgb25jZSB0aGUgc3RyZWFtIGlzIHJlYWR5IHRvIGFjY2VwdCByZXF1ZXN0cy5cclxuICpcclxuICogU2hvdWxkIGEgc3RhcnQoKSBmYWlsLCBQZXJzaXN0ZW50U3RyZWFtIHdpbGwgY2FsbCB0aGUgcmVnaXN0ZXJlZCBvbkNsb3NlKClcclxuICogbGlzdGVuZXIgd2l0aCBhIEZpcmVzdG9yZUVycm9yIGluZGljYXRpbmcgd2hhdCB3ZW50IHdyb25nLlxyXG4gKlxyXG4gKiBBIFBlcnNpc3RlbnRTdHJlYW0gY2FuIGJlIHN0YXJ0ZWQgYW5kIHN0b3BwZWQgcmVwZWF0ZWRseS5cclxuICpcclxuICogR2VuZXJpYyB0eXBlczpcclxuICogIFNlbmRUeXBlOiBUaGUgdHlwZSBvZiB0aGUgb3V0Z29pbmcgbWVzc2FnZSBvZiB0aGUgdW5kZXJseWluZ1xyXG4gKiAgICBjb25uZWN0aW9uIHN0cmVhbVxyXG4gKiAgUmVjZWl2ZVR5cGU6IFRoZSB0eXBlIG9mIHRoZSBpbmNvbWluZyBtZXNzYWdlIG9mIHRoZSB1bmRlcmx5aW5nXHJcbiAqICAgIGNvbm5lY3Rpb24gc3RyZWFtXHJcbiAqICBMaXN0ZW5lclR5cGU6IFRoZSB0eXBlIG9mIHRoZSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgY2FsbGJhY2tzXHJcbiAqL1xyXG5jbGFzcyBQZXJzaXN0ZW50U3RyZWFtIHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXVlLCBjb25uZWN0aW9uVGltZXJJZCwgaWRsZVRpbWVySWQsIGhlYWx0aFRpbWVySWQsIGNvbm5lY3Rpb24sIGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLCBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHF1ZXVlO1xyXG4gICAgICAgIHRoaXMuaWRsZVRpbWVySWQgPSBpZGxlVGltZXJJZDtcclxuICAgICAgICB0aGlzLmhlYWx0aFRpbWVySWQgPSBoZWFsdGhUaW1lcklkO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHNQcm92aWRlciA9IGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyID0gYXBwQ2hlY2tDcmVkZW50aWFsc1Byb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBJbml0aWFsICovO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xvc2UgY291bnQgdGhhdCdzIGluY3JlbWVudGVkIGV2ZXJ5IHRpbWUgdGhlIHN0cmVhbSBpcyBjbG9zZWQ7IHVzZWQgYnlcclxuICAgICAgICAgKiBnZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKCkgdG8gaW52YWxpZGF0ZSBjYWxsYmFja3MgdGhhdCBoYXBwZW4gYWZ0ZXJcclxuICAgICAgICAgKiBjbG9zZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsb3NlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhlYWx0aENoZWNrID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IEV4cG9uZW50aWFsQmFja29mZihxdWV1ZSwgY29ubmVjdGlvblRpbWVySWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3RhcnQoKSBoYXMgYmVlbiBjYWxsZWQgYW5kIG5vIGVycm9yIGhhcyBvY2N1cnJlZC4gVHJ1ZVxyXG4gICAgICogaW5kaWNhdGVzIHRoZSBzdHJlYW0gaXMgb3BlbiBvciBpbiB0aGUgcHJvY2VzcyBvZiBvcGVuaW5nICh3aGljaFxyXG4gICAgICogZW5jb21wYXNzZXMgcmVzcGVjdGluZyBiYWNrb2ZmLCBnZXR0aW5nIGF1dGggdG9rZW5zLCBhbmQgc3RhcnRpbmcgdGhlXHJcbiAgICAgKiBhY3R1YWwgUlBDKS4gVXNlIGlzT3BlbigpIHRvIGRldGVybWluZSBpZiB0aGUgc3RyZWFtIGlzIG9wZW4gYW5kIHJlYWR5IGZvclxyXG4gICAgICogb3V0Ym91bmQgcmVxdWVzdHMuXHJcbiAgICAgKi9cclxuICAgIGlzU3RhcnRlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IDEgLyogU3RhcnRpbmcgKi8gfHxcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gNSAvKiBCYWNrb2ZmICovIHx8XHJcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHVuZGVybHlpbmcgUlBDIGlzIG9wZW4gKHRoZSBvbk9wZW4oKSBsaXN0ZW5lciBoYXMgYmVlblxyXG4gICAgICogY2FsbGVkKSBhbmQgdGhlIHN0cmVhbSBpcyByZWFkeSBmb3Igb3V0Ym91bmQgcmVxdWVzdHMuXHJcbiAgICAgKi9cclxuICAgIGlzT3BlbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3RhdGUgPT09IDIgLyogT3BlbiAqLyB8fFxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSAzIC8qIEhlYWx0aHkgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIFJQQy4gT25seSBhbGxvd2VkIGlmIGlzU3RhcnRlZCgpIHJldHVybnMgZmFsc2UuIFRoZSBzdHJlYW0gaXNcclxuICAgICAqIG5vdCBpbW1lZGlhdGVseSByZWFkeSBmb3IgdXNlOiBvbk9wZW4oKSB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgUlBDIGlzXHJcbiAgICAgKiByZWFkeSBmb3Igb3V0Ym91bmQgcmVxdWVzdHMsIGF0IHdoaWNoIHBvaW50IGlzT3BlbigpIHdpbGwgcmV0dXJuIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBzdGFydCByZXR1cm5zLCBpc1N0YXJ0ZWQoKSB3aWxsIHJldHVybiB0cnVlLlxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gNCAvKiBFcnJvciAqLykge1xyXG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1CYWNrb2ZmKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hdXRoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSBSUEMuIFRoaXMgY2FsbCBpcyBpZGVtcG90ZW50IGFuZCBhbGxvd2VkIHJlZ2FyZGxlc3Mgb2YgdGhlXHJcbiAgICAgKiBjdXJyZW50IGlzU3RhcnRlZCgpIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gc3RvcCByZXR1cm5zLCBpc1N0YXJ0ZWQoKSBhbmQgaXNPcGVuKCkgd2lsbCBib3RoIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgc3RvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0ZWQoKSkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsb3NlKDAgLyogSW5pdGlhbCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZnRlciBhbiBlcnJvciB0aGUgc3RyZWFtIHdpbGwgdXN1YWxseSBiYWNrIG9mZiBvbiB0aGUgbmV4dCBhdHRlbXB0IHRvXHJcbiAgICAgKiBzdGFydCBpdC4gSWYgdGhlIGVycm9yIHdhcnJhbnRzIGFuIGltbWVkaWF0ZSByZXN0YXJ0IG9mIHRoZSBzdHJlYW0sIHRoZVxyXG4gICAgICogc2VuZGVyIGNhbiB1c2UgdGhpcyB0byBpbmRpY2F0ZSB0aGF0IHRoZSByZWNlaXZlciBzaG91bGQgbm90IGJhY2sgb2ZmLlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggZXJyb3Igd2lsbCBjYWxsIHRoZSBvbkNsb3NlKCkgbGlzdGVuZXIuIFRoYXQgZnVuY3Rpb24gY2FuIGRlY2lkZSB0b1xyXG4gICAgICogaW5oaWJpdCBiYWNrb2ZmIGlmIHJlcXVpcmVkLlxyXG4gICAgICovXHJcbiAgICBpbmhpYml0QmFja29mZigpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMCAvKiBJbml0aWFsICovO1xyXG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXJrcyB0aGlzIHN0cmVhbSBhcyBpZGxlLiBJZiBubyBmdXJ0aGVyIGFjdGlvbnMgYXJlIHBlcmZvcm1lZCBvbiB0aGVcclxuICAgICAqIHN0cmVhbSBmb3Igb25lIG1pbnV0ZSwgdGhlIHN0cmVhbSB3aWxsIGF1dG9tYXRpY2FsbHkgY2xvc2UgaXRzZWxmIGFuZFxyXG4gICAgICogbm90aWZ5IHRoZSBzdHJlYW0ncyBvbkNsb3NlKCkgaGFuZGxlciB3aXRoIFN0YXR1cy5PSy4gVGhlIHN0cmVhbSB3aWxsIHRoZW5cclxuICAgICAqIGJlIGluIGEgIWlzU3RhcnRlZCgpIHN0YXRlLCByZXF1aXJpbmcgdGhlIGNhbGxlciB0byBzdGFydCB0aGUgc3RyZWFtIGFnYWluXHJcbiAgICAgKiBiZWZvcmUgZnVydGhlciB1c2UuXHJcbiAgICAgKlxyXG4gICAgICogT25seSBzdHJlYW1zIHRoYXQgYXJlIGluIHN0YXRlICdPcGVuJyBjYW4gYmUgbWFya2VkIGlkbGUsIGFzIGFsbCBvdGhlclxyXG4gICAgICogc3RhdGVzIGltcGx5IHBlbmRpbmcgbmV0d29yayBvcGVyYXRpb25zLlxyXG4gICAgICovXHJcbiAgICBtYXJrSWRsZSgpIHtcclxuICAgICAgICAvLyBTdGFydHMgdGhlIGlkbGUgdGltZSBpZiB3ZSBhcmUgaW4gc3RhdGUgJ09wZW4nIGFuZCBhcmUgbm90IHlldCBhbHJlYWR5XHJcbiAgICAgICAgLy8gcnVubmluZyBhIHRpbWVyIChpbiB3aGljaCBjYXNlIHRoZSBwcmV2aW91cyBpZGxlIHRpbWVvdXQgc3RpbGwgYXBwbGllcykuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkgJiYgdGhpcy5pZGxlVGltZXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KHRoaXMuaWRsZVRpbWVySWQsIElETEVfVElNRU9VVF9NUywgKCkgPT4gdGhpcy5oYW5kbGVJZGxlQ2xvc2VUaW1lcigpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSB1bmRlcmx5aW5nIHN0cmVhbS4gKi9cclxuICAgIHNlbmRSZXF1ZXN0KG1zZykge1xyXG4gICAgICAgIHRoaXMuY2FuY2VsSWRsZUNoZWNrKCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0uc2VuZChtc2cpO1xyXG4gICAgfVxyXG4gICAgLyoqIENhbGxlZCBieSB0aGUgaWRsZSB0aW1lciB3aGVuIHRoZSBzdHJlYW0gc2hvdWxkIGNsb3NlIGR1ZSB0byBpbmFjdGl2aXR5LiAqL1xyXG4gICAgYXN5bmMgaGFuZGxlSWRsZUNsb3NlVGltZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcclxuICAgICAgICAgICAgLy8gV2hlbiB0aW1pbmcgb3V0IGFuIGlkbGUgc3RyZWFtIHRoZXJlJ3Mgbm8gcmVhc29uIHRvIGZvcmNlIHRoZSBzdHJlYW0gaW50byBiYWNrb2ZmIHdoZW5cclxuICAgICAgICAgICAgLy8gaXQgcmVzdGFydHMgc28gc2V0IHRoZSBzdHJlYW0gc3RhdGUgdG8gSW5pdGlhbCBpbnN0ZWFkIG9mIEVycm9yLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZSgwIC8qIEluaXRpYWwgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBNYXJrcyB0aGUgc3RyZWFtIGFzIGFjdGl2ZSBhZ2Fpbi4gKi9cclxuICAgIGNhbmNlbElkbGVDaGVjaygpIHtcclxuICAgICAgICBpZiAodGhpcy5pZGxlVGltZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQ2FuY2VscyB0aGUgaGVhbHRoIGNoZWNrIGRlbGF5ZWQgb3BlcmF0aW9uLiAqL1xyXG4gICAgY2FuY2VsSGVhbHRoQ2hlY2soKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2spIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGhDaGVjay5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGhDaGVjayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIHN0cmVhbSBhbmQgY2xlYW5zIHVwIGFzIG5lY2Vzc2FyeTpcclxuICAgICAqXHJcbiAgICAgKiAqIGNsb3NlcyB0aGUgdW5kZXJseWluZyBHUlBDIHN0cmVhbTtcclxuICAgICAqICogY2FsbHMgdGhlIG9uQ2xvc2UgaGFuZGxlciB3aXRoIHRoZSBnaXZlbiAnZXJyb3InO1xyXG4gICAgICogKiBzZXRzIGludGVybmFsIHN0cmVhbSBzdGF0ZSB0byAnZmluYWxTdGF0ZSc7XHJcbiAgICAgKiAqIGFkanVzdHMgdGhlIGJhY2tvZmYgdGltZXIgYmFzZWQgb24gdGhlIGVycm9yXHJcbiAgICAgKlxyXG4gICAgICogQSBuZXcgc3RyZWFtIGNhbiBiZSBvcGVuZWQgYnkgY2FsbGluZyBzdGFydCgpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaW5hbFN0YXRlIC0gdGhlIGludGVuZGVkIHN0YXRlIG9mIHRoZSBzdHJlYW0gYWZ0ZXIgY2xvc2luZy5cclxuICAgICAqIEBwYXJhbSBlcnJvciAtIHRoZSBlcnJvciB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIHdpdGguXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNsb3NlKGZpbmFsU3RhdGUsIGVycm9yKSB7XHJcbiAgICAgICAgLy8gQ2FuY2VsIGFueSBvdXRzdGFuZGluZyB0aW1lcnMgKHRoZXkncmUgZ3VhcmFudGVlZCBub3QgdG8gZXhlY3V0ZSkuXHJcbiAgICAgICAgdGhpcy5jYW5jZWxJZGxlQ2hlY2soKTtcclxuICAgICAgICB0aGlzLmNhbmNlbEhlYWx0aENoZWNrKCk7XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmLmNhbmNlbCgpO1xyXG4gICAgICAgIC8vIEludmFsaWRhdGVzIGFueSBzdHJlYW0tcmVsYXRlZCBjYWxsYmFja3MgKGUuZy4gZnJvbSBhdXRoIG9yIHRoZVxyXG4gICAgICAgIC8vIHVuZGVybHlpbmcgc3RyZWFtKSwgZ3VhcmFudGVlaW5nIHRoZXkgd29uJ3QgZXhlY3V0ZS5cclxuICAgICAgICB0aGlzLmNsb3NlQ291bnQrKztcclxuICAgICAgICBpZiAoZmluYWxTdGF0ZSAhPT0gNCAvKiBFcnJvciAqLykge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGludGVudGlvbmFsIGNsb3NlIGVuc3VyZSB3ZSBkb24ndCBkZWxheSBvdXIgbmV4dCBjb25uZWN0aW9uIGF0dGVtcHQuXHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlcnJvciAmJiBlcnJvci5jb2RlID09PSBDb2RlLlJFU09VUkNFX0VYSEFVU1RFRCkge1xyXG4gICAgICAgICAgICAvLyBMb2cgdGhlIGVycm9yLiAoUHJvYmFibHkgZWl0aGVyICdxdW90YSBleGNlZWRlZCcgb3IgJ21heCBxdWV1ZSBsZW5ndGggcmVhY2hlZCcuKVxyXG4gICAgICAgICAgICBsb2dFcnJvcihlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgbG9nRXJyb3IoJ1VzaW5nIG1heGltdW0gYmFja29mZiBkZWxheSB0byBwcmV2ZW50IG92ZXJsb2FkaW5nIHRoZSBiYWNrZW5kLicpO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXRUb01heCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlcnJvciAmJlxyXG4gICAgICAgICAgICBlcnJvci5jb2RlID09PSBDb2RlLlVOQVVUSEVOVElDQVRFRCAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSAzIC8qIEhlYWx0aHkgKi8pIHtcclxuICAgICAgICAgICAgLy8gXCJ1bmF1dGhlbnRpY2F0ZWRcIiBlcnJvciBtZWFucyB0aGUgdG9rZW4gd2FzIHJlamVjdGVkLiBUaGlzIHNob3VsZCByYXJlbHlcclxuICAgICAgICAgICAgLy8gaGFwcGVuIHNpbmNlIGJvdGggQXV0aCBhbmQgQXBwQ2hlY2sgZW5zdXJlIGEgc3VmZmljaWVudCBUVEwgd2hlbiB3ZVxyXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGEgdG9rZW4uIElmIGEgdXNlciBtYW51YWxseSByZXNldHMgdGhlaXIgc3lzdGVtIGNsb2NrIHRoaXMgY2FuXHJcbiAgICAgICAgICAgIC8vIGZhaWwsIGhvd2V2ZXIuIEluIHRoaXMgY2FzZSwgd2Ugc2hvdWxkIGdldCBhIENvZGUuVU5BVVRIRU5USUNBVEVEIGVycm9yXHJcbiAgICAgICAgICAgIC8vIGJlZm9yZSB3ZSByZWNlaXZlZCB0aGUgZmlyc3QgbWVzc2FnZSBhbmQgd2UgbmVlZCB0byBpbnZhbGlkYXRlIHRoZSB0b2tlblxyXG4gICAgICAgICAgICAvLyB0byBlbnN1cmUgdGhhdCB3ZSBmZXRjaCBhIG5ldyB0b2tlbi5cclxuICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHNQcm92aWRlci5pbnZhbGlkYXRlVG9rZW4oKTtcclxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFuIHVwIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBiZWNhdXNlIHdlIGFyZSBubyBsb25nZXIgaW50ZXJlc3RlZCBpbiBldmVudHMuXHJcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVhckRvd24oKTtcclxuICAgICAgICAgICAgdGhpcy5zdHJlYW0uY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGlzIHN0YXRlIG11c3QgYmUgYXNzaWduZWQgYmVmb3JlIGNhbGxpbmcgb25DbG9zZSgpIHRvIGFsbG93IHRoZSBjYWxsYmFjayB0b1xyXG4gICAgICAgIC8vIGluaGliaXQgYmFja29mZiBvciBvdGhlcndpc2UgbWFuaXB1bGF0ZSB0aGUgc3RhdGUgaW4gaXRzIG5vbi1zdGFydGVkIHN0YXRlLlxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBmaW5hbFN0YXRlO1xyXG4gICAgICAgIC8vIE5vdGlmeSB0aGUgbGlzdGVuZXIgdGhhdCB0aGUgc3RyZWFtIGNsb3NlZC5cclxuICAgICAgICBhd2FpdCB0aGlzLmxpc3RlbmVyLm9uQ2xvc2UoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW4gYmUgb3ZlcnJpZGRlbiB0byBwZXJmb3JtIGFkZGl0aW9uYWwgY2xlYW51cCBiZWZvcmUgdGhlIHN0cmVhbSBpcyBjbG9zZWQuXHJcbiAgICAgKiBDYWxsaW5nIHN1cGVyLnRlYXJEb3duKCkgaXMgbm90IHJlcXVpcmVkLlxyXG4gICAgICovXHJcbiAgICB0ZWFyRG93bigpIHsgfVxyXG4gICAgYXV0aCgpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMSAvKiBTdGFydGluZyAqLztcclxuICAgICAgICBjb25zdCBkaXNwYXRjaElmTm90Q2xvc2VkID0gdGhpcy5nZXRDbG9zZUd1YXJkZWREaXNwYXRjaGVyKHRoaXMuY2xvc2VDb3VudCk7XHJcbiAgICAgICAgLy8gVE9ETyhtaWtlbGVoZW4pOiBKdXN0IHVzZSBkaXNwYXRjaElmTm90Q2xvc2VkLCBidXQgc2VlIFRPRE8gYmVsb3cuXHJcbiAgICAgICAgY29uc3QgY2xvc2VDb3VudCA9IHRoaXMuY2xvc2VDb3VudDtcclxuICAgICAgICBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0VG9rZW4oKSxcclxuICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIuZ2V0VG9rZW4oKVxyXG4gICAgICAgIF0pLnRoZW4oKFthdXRoVG9rZW4sIGFwcENoZWNrVG9rZW5dKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFN0cmVhbSBjYW4gYmUgc3RvcHBlZCB3aGlsZSB3YWl0aW5nIGZvciBhdXRoZW50aWNhdGlvbi5cclxuICAgICAgICAgICAgLy8gVE9ETyhtaWtlbGVoZW4pOiBXZSByZWFsbHkgc2hvdWxkIGp1c3QgdXNlIGRpc3BhdGNoSWZOb3RDbG9zZWRcclxuICAgICAgICAgICAgLy8gYW5kIGxldCB0aGlzIGRpc3BhdGNoIG9udG8gdGhlIHF1ZXVlLCBidXQgdGhhdCBvcGVuZWQgYSBzcGVjIHRlc3QgY2FuXHJcbiAgICAgICAgICAgIC8vIG9mIHdvcm1zIHRoYXQgSSBkb24ndCB3YW50IHRvIGRlYWwgd2l0aCBpbiB0aGlzIFBSLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZUNvdW50ID09PSBjbG9zZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIGhhdmUgdG8gc2NoZWR1bGUgdGhlIGNhbGxiYWNrIG9uIHRoZSBBc3luY1F1ZXVlLlxyXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlIGZvbGxvd2luZyBjYWxscyBhcmUgc2FmZSB0byBiZSBjYWxsZWQgb3V0c2lkZSB0aGVcclxuICAgICAgICAgICAgICAgIC8vIEFzeW5jUXVldWUgc2luY2UgdGhleSBkb24ndCBjaGFpbiBhc3luY2hyb25vdXMgY2FsbHNcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdHJlYW0oYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBkaXNwYXRjaElmTm90Q2xvc2VkKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJwY0Vycm9yID0gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5LTk9XTiwgJ0ZldGNoaW5nIGF1dGggdG9rZW4gZmFpbGVkOiAnICsgZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdHJlYW1DbG9zZShycGNFcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhcnRTdHJlYW0oYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hJZk5vdENsb3NlZCA9IHRoaXMuZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlcih0aGlzLmNsb3NlQ291bnQpO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtID0gdGhpcy5zdGFydFJwYyhhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uT3BlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIgLyogT3BlbiAqLztcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2hlY2sgPSB0aGlzLnF1ZXVlLmVucXVldWVBZnRlckRlbGF5KHRoaXMuaGVhbHRoVGltZXJJZCwgSEVBTFRIWV9USU1FT1VUX01TLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMgLyogSGVhbHRoeSAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5vbk9wZW4oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0ub25DbG9zZSgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgZGlzcGF0Y2hJZk5vdENsb3NlZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdHJlYW1DbG9zZShlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uTWVzc2FnZSgobXNnKSA9PiB7XHJcbiAgICAgICAgICAgIGRpc3BhdGNoSWZOb3RDbG9zZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25NZXNzYWdlKG1zZyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcGVyZm9ybUJhY2tvZmYoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDUgLyogQmFja29mZiAqLztcclxuICAgICAgICB0aGlzLmJhY2tvZmYuYmFja29mZkFuZFJ1bihhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAwIC8qIEluaXRpYWwgKi87XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIFZpc2libGUgZm9yIHRlc3RzXHJcbiAgICBoYW5kbGVTdHJlYW1DbG9zZShlcnJvcikge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckNywgYGNsb3NlIHdpdGggZXJyb3I6ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xyXG4gICAgICAgIC8vIEluIHRoZW9yeSB0aGUgc3RyZWFtIGNvdWxkIGNsb3NlIGNsZWFubHksIGhvd2V2ZXIsIGluIG91ciBjdXJyZW50IG1vZGVsXHJcbiAgICAgICAgLy8gd2UgbmV2ZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlY2F1c2UgaWYgd2Ugc3RvcCBhIHN0cmVhbSBvdXJzZWx2ZXMsXHJcbiAgICAgICAgLy8gdGhpcyBjYWxsYmFjayB3aWxsIG5ldmVyIGJlIGNhbGxlZC4gVG8gcHJldmVudCBjYXNlcyB3aGVyZSB3ZSByZXRyeVxyXG4gICAgICAgIC8vIHdpdGhvdXQgYSBiYWNrb2ZmIGFjY2lkZW50YWxseSwgd2Ugc2V0IHRoZSBzdHJlYW0gdG8gZXJyb3IgaW4gYWxsIGNhc2VzLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKDQgLyogRXJyb3IgKi8sIGVycm9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIFwiZGlzcGF0Y2hlclwiIGZ1bmN0aW9uIHRoYXQgZGlzcGF0Y2hlcyBvcGVyYXRpb25zIG9udG8gdGhlXHJcbiAgICAgKiBBc3luY1F1ZXVlIGJ1dCBvbmx5IHJ1bnMgdGhlbSBpZiBjbG9zZUNvdW50IHJlbWFpbnMgdW5jaGFuZ2VkLiBUaGlzIGFsbG93c1xyXG4gICAgICogdXMgdG8gdHVybiBhdXRoIC8gc3RyZWFtIGNhbGxiYWNrcyBpbnRvIG5vLW9wcyBpZiB0aGUgc3RyZWFtIGlzIGNsb3NlZCAvXHJcbiAgICAgKiByZS1vcGVuZWQsIGV0Yy5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2xvc2VHdWFyZGVkRGlzcGF0Y2hlcihzdGFydENsb3NlQ291bnQpIHtcclxuICAgICAgICByZXR1cm4gKGZuKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbG9zZUNvdW50ID09PSBzdGFydENsb3NlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNywgJ3N0cmVhbSBjYWxsYmFjayBza2lwcGVkIGJ5IGdldENsb3NlR3VhcmRlZERpc3BhdGNoZXIuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIFBlcnNpc3RlbnRTdHJlYW0gdGhhdCBpbXBsZW1lbnRzIHRoZSBMaXN0ZW4gUlBDLlxyXG4gKlxyXG4gKiBPbmNlIHRoZSBMaXN0ZW4gc3RyZWFtIGhhcyBjYWxsZWQgdGhlIG9uT3BlbigpIGxpc3RlbmVyLCBhbnkgbnVtYmVyIG9mXHJcbiAqIGxpc3RlbigpIGFuZCB1bmxpc3RlbigpIGNhbGxzIGNhbiBiZSBtYWRlIHRvIGNvbnRyb2wgd2hhdCBjaGFuZ2VzIHdpbGwgYmVcclxuICogc2VudCBmcm9tIHRoZSBzZXJ2ZXIgZm9yIExpc3RlblJlc3BvbnNlcy5cclxuICovXHJcbmNsYXNzIFBlcnNpc3RlbnRMaXN0ZW5TdHJlYW0gZXh0ZW5kcyBQZXJzaXN0ZW50U3RyZWFtIHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXVlLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIHNlcmlhbGl6ZXIsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgc3VwZXIocXVldWUsIFwibGlzdGVuX3N0cmVhbV9jb25uZWN0aW9uX2JhY2tvZmZcIiAvKiBMaXN0ZW5TdHJlYW1Db25uZWN0aW9uQmFja29mZiAqLywgXCJsaXN0ZW5fc3RyZWFtX2lkbGVcIiAvKiBMaXN0ZW5TdHJlYW1JZGxlICovLCBcImhlYWx0aF9jaGVja190aW1lb3V0XCIgLyogSGVhbHRoQ2hlY2tUaW1lb3V0ICovLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIGxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgfVxyXG4gICAgc3RhcnRScGMoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5vcGVuU3RyZWFtKCdMaXN0ZW4nLCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgfVxyXG4gICAgb25NZXNzYWdlKHdhdGNoQ2hhbmdlUHJvdG8pIHtcclxuICAgICAgICAvLyBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgbWVhbnMgdGhlIHN0cmVhbSBpcyBoZWFsdGh5XHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XHJcbiAgICAgICAgY29uc3Qgd2F0Y2hDaGFuZ2UgPSBmcm9tV2F0Y2hDaGFuZ2UodGhpcy5zZXJpYWxpemVyLCB3YXRjaENoYW5nZVByb3RvKTtcclxuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHZlcnNpb25Gcm9tTGlzdGVuUmVzcG9uc2Uod2F0Y2hDaGFuZ2VQcm90byk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIub25XYXRjaENoYW5nZSh3YXRjaENoYW5nZSwgc25hcHNob3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcnMgaW50ZXJlc3QgaW4gdGhlIHJlc3VsdHMgb2YgdGhlIGdpdmVuIHRhcmdldC4gSWYgdGhlIHRhcmdldFxyXG4gICAgICogaW5jbHVkZXMgYSByZXN1bWVUb2tlbiBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LiBSZXN1bHRzIHRoYXRcclxuICAgICAqIGFmZmVjdCB0aGUgdGFyZ2V0IHdpbGwgYmUgc3RyZWFtZWQgYmFjayBhcyBXYXRjaENoYW5nZSBtZXNzYWdlcyB0aGF0XHJcbiAgICAgKiByZWZlcmVuY2UgdGhlIHRhcmdldElkLlxyXG4gICAgICovXHJcbiAgICB3YXRjaCh0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHt9O1xyXG4gICAgICAgIHJlcXVlc3QuZGF0YWJhc2UgPSBnZXRFbmNvZGVkRGF0YWJhc2VJZCh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHJlcXVlc3QuYWRkVGFyZ2V0ID0gdG9UYXJnZXQodGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKTtcclxuICAgICAgICBjb25zdCBsYWJlbHMgPSB0b0xpc3RlblJlcXVlc3RMYWJlbHModGhpcy5zZXJpYWxpemVyLCB0YXJnZXREYXRhKTtcclxuICAgICAgICBpZiAobGFiZWxzKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3QubGFiZWxzID0gbGFiZWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KHJlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnJlZ2lzdGVycyBpbnRlcmVzdCBpbiB0aGUgcmVzdWx0cyBvZiB0aGUgdGFyZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGVcclxuICAgICAqIGdpdmVuIHRhcmdldElkLlxyXG4gICAgICovXHJcbiAgICB1bndhdGNoKHRhcmdldElkKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHt9O1xyXG4gICAgICAgIHJlcXVlc3QuZGF0YWJhc2UgPSBnZXRFbmNvZGVkRGF0YWJhc2VJZCh0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgICAgIHJlcXVlc3QucmVtb3ZlVGFyZ2V0ID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBTdHJlYW0gdGhhdCBpbXBsZW1lbnRzIHRoZSBXcml0ZSBSUEMuXHJcbiAqXHJcbiAqIFRoZSBXcml0ZSBSUEMgcmVxdWlyZXMgdGhlIGNhbGxlciB0byBtYWludGFpbiBzcGVjaWFsIHN0cmVhbVRva2VuXHJcbiAqIHN0YXRlIGluIGJldHdlZW4gY2FsbHMsIHRvIGhlbHAgdGhlIHNlcnZlciB1bmRlcnN0YW5kIHdoaWNoIHJlc3BvbnNlcyB0aGVcclxuICogY2xpZW50IGhhcyBwcm9jZXNzZWQgYnkgdGhlIHRpbWUgdGhlIG5leHQgcmVxdWVzdCBpcyBtYWRlLiBFdmVyeSByZXNwb25zZVxyXG4gKiB3aWxsIGNvbnRhaW4gYSBzdHJlYW1Ub2tlbjsgdGhpcyB2YWx1ZSBtdXN0IGJlIHBhc3NlZCB0byB0aGUgbmV4dFxyXG4gKiByZXF1ZXN0LlxyXG4gKlxyXG4gKiBBZnRlciBjYWxsaW5nIHN0YXJ0KCkgb24gdGhpcyBzdHJlYW0sIHRoZSBuZXh0IHJlcXVlc3QgbXVzdCBiZSBhIGhhbmRzaGFrZSxcclxuICogY29udGFpbmluZyB3aGF0ZXZlciBzdHJlYW1Ub2tlbiBpcyBvbiBoYW5kLiBPbmNlIGEgcmVzcG9uc2UgdG8gdGhpc1xyXG4gKiByZXF1ZXN0IGlzIHJlY2VpdmVkLCBhbGwgcGVuZGluZyBtdXRhdGlvbnMgbWF5IGJlIHN1Ym1pdHRlZC4gV2hlblxyXG4gKiBzdWJtaXR0aW5nIG11bHRpcGxlIGJhdGNoZXMgb2YgbXV0YXRpb25zIGF0IHRoZSBzYW1lIHRpbWUsIGl0J3NcclxuICogb2theSB0byB1c2UgdGhlIHNhbWUgc3RyZWFtVG9rZW4gZm9yIHRoZSBjYWxscyB0byB3cml0ZU11dGF0aW9ucy5cclxuICpcclxuICogVE9ETyhiLzMzMjcxMjM1KTogVXNlIHByb3RvIHR5cGVzXHJcbiAqL1xyXG5jbGFzcyBQZXJzaXN0ZW50V3JpdGVTdHJlYW0gZXh0ZW5kcyBQZXJzaXN0ZW50U3RyZWFtIHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXVlLCBjb25uZWN0aW9uLCBhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIHNlcmlhbGl6ZXIsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgc3VwZXIocXVldWUsIFwid3JpdGVfc3RyZWFtX2Nvbm5lY3Rpb25fYmFja29mZlwiIC8qIFdyaXRlU3RyZWFtQ29ubmVjdGlvbkJhY2tvZmYgKi8sIFwid3JpdGVfc3RyZWFtX2lkbGVcIiAvKiBXcml0ZVN0cmVhbUlkbGUgKi8sIFwiaGVhbHRoX2NoZWNrX3RpbWVvdXRcIiAvKiBIZWFsdGhDaGVja1RpbWVvdXQgKi8sIGNvbm5lY3Rpb24sIGF1dGhDcmVkZW50aWFscywgYXBwQ2hlY2tDcmVkZW50aWFscywgbGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgdGhpcy5oYW5kc2hha2VDb21wbGV0ZV8gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhY2tzIHdoZXRoZXIgb3Igbm90IGEgaGFuZHNoYWtlIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGNoYW5nZWQgYW5kXHJcbiAgICAgKiB0aGUgc3RyZWFtIGlzIHJlYWR5IHRvIGFjY2VwdCBtdXRhdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGdldCBoYW5kc2hha2VDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kc2hha2VDb21wbGV0ZV87XHJcbiAgICB9XHJcbiAgICAvLyBPdmVycmlkZSBvZiBQZXJzaXN0ZW50U3RyZWFtLnN0YXJ0XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLmhhbmRzaGFrZUNvbXBsZXRlXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubGFzdFN0cmVhbVRva2VuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHN1cGVyLnN0YXJ0KCk7XHJcbiAgICB9XHJcbiAgICB0ZWFyRG93bigpIHtcclxuICAgICAgICBpZiAodGhpcy5oYW5kc2hha2VDb21wbGV0ZV8pIHtcclxuICAgICAgICAgICAgdGhpcy53cml0ZU11dGF0aW9ucyhbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnRScGMoYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5vcGVuU3RyZWFtKCdXcml0ZScsIGF1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbik7XHJcbiAgICB9XHJcbiAgICBvbk1lc3NhZ2UocmVzcG9uc2VQcm90bykge1xyXG4gICAgICAgIC8vIEFsd2F5cyBjYXB0dXJlIHRoZSBsYXN0IHN0cmVhbSB0b2tlbi5cclxuICAgICAgICBoYXJkQXNzZXJ0KCEhcmVzcG9uc2VQcm90by5zdHJlYW1Ub2tlbik7XHJcbiAgICAgICAgdGhpcy5sYXN0U3RyZWFtVG9rZW4gPSByZXNwb25zZVByb3RvLnN0cmVhbVRva2VuO1xyXG4gICAgICAgIGlmICghdGhpcy5oYW5kc2hha2VDb21wbGV0ZV8pIHtcclxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHJlc3BvbnNlIGlzIGFsd2F5cyB0aGUgaGFuZHNoYWtlIHJlc3BvbnNlXHJcbiAgICAgICAgICAgIGhhcmRBc3NlcnQoIXJlc3BvbnNlUHJvdG8ud3JpdGVSZXN1bHRzIHx8IHJlc3BvbnNlUHJvdG8ud3JpdGVSZXN1bHRzLmxlbmd0aCA9PT0gMCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZHNoYWtlQ29tcGxldGVfID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIub25IYW5kc2hha2VDb21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQSBzdWNjZXNzZnVsIGZpcnN0IHdyaXRlIHJlc3BvbnNlIG1lYW5zIHRoZSBzdHJlYW0gaXMgaGVhbHRoeSxcclxuICAgICAgICAgICAgLy8gTm90ZSwgdGhhdCB3ZSBjb3VsZCBjb25zaWRlciBhIHN1Y2Nlc3NmdWwgaGFuZHNoYWtlIGhlYWx0aHksIGhvd2V2ZXIsXHJcbiAgICAgICAgICAgIC8vIHRoZSB3cml0ZSBpdHNlbGYgbWlnaHQgYmUgY2F1c2luZyBhbiBlcnJvciB3ZSB3YW50IHRvIGJhY2sgb2ZmIGZyb20uXHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gZnJvbVdyaXRlUmVzdWx0cyhyZXNwb25zZVByb3RvLndyaXRlUmVzdWx0cywgcmVzcG9uc2VQcm90by5jb21taXRUaW1lKTtcclxuICAgICAgICAgICAgY29uc3QgY29tbWl0VmVyc2lvbiA9IGZyb21WZXJzaW9uKHJlc3BvbnNlUHJvdG8uY29tbWl0VGltZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLm9uTXV0YXRpb25SZXN1bHQoY29tbWl0VmVyc2lvbiwgcmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyBhbiBpbml0aWFsIHN0cmVhbVRva2VuIHRvIHRoZSBzZXJ2ZXIsIHBlcmZvcm1pbmcgdGhlIGhhbmRzaGFrZVxyXG4gICAgICogcmVxdWlyZWQgdG8gbWFrZSB0aGUgU3RyZWFtaW5nV3JpdGUgUlBDIHdvcmsuIFN1YnNlcXVlbnRcclxuICAgICAqIGNhbGxzIHNob3VsZCB3YWl0IHVudGlsIG9uSGFuZHNoYWtlQ29tcGxldGUgd2FzIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgd3JpdGVIYW5kc2hha2UoKSB7XHJcbiAgICAgICAgLy8gVE9ETyhkaW1vbmQpOiBTdXBwb3J0IHN0cmVhbSByZXN1bXB0aW9uLiBXZSBpbnRlbnRpb25hbGx5IGRvIG5vdCBzZXQgdGhlXHJcbiAgICAgICAgLy8gc3RyZWFtIHRva2VuIG9uIHRoZSBoYW5kc2hha2UsIGlnbm9yaW5nIGFueSBzdHJlYW0gdG9rZW4gd2UgbWlnaHQgaGF2ZS5cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge307XHJcbiAgICAgICAgcmVxdWVzdC5kYXRhYmFzZSA9IGdldEVuY29kZWREYXRhYmFzZUlkKHRoaXMuc2VyaWFsaXplcik7XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIC8qKiBTZW5kcyBhIGdyb3VwIG9mIG11dGF0aW9ucyB0byB0aGUgRmlyZXN0b3JlIGJhY2tlbmQgdG8gYXBwbHkuICovXHJcbiAgICB3cml0ZU11dGF0aW9ucyhtdXRhdGlvbnMpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBzdHJlYW1Ub2tlbjogdGhpcy5sYXN0U3RyZWFtVG9rZW4sXHJcbiAgICAgICAgICAgIHdyaXRlczogbXV0YXRpb25zLm1hcChtdXRhdGlvbiA9PiB0b011dGF0aW9uKHRoaXMuc2VyaWFsaXplciwgbXV0YXRpb24pKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGF0YXN0b3JlIGFuZCBpdHMgcmVsYXRlZCBtZXRob2RzIGFyZSBhIHdyYXBwZXIgYXJvdW5kIHRoZSBleHRlcm5hbCBHb29nbGVcclxuICogQ2xvdWQgRGF0YXN0b3JlIGdycGMgQVBJLCB3aGljaCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgdGhhdCBpcyBtb3JlIGNvbnZlbmllbnRcclxuICogZm9yIHRoZSByZXN0IG9mIHRoZSBjbGllbnQgU0RLIGFyY2hpdGVjdHVyZSB0byBjb25zdW1lLlxyXG4gKi9cclxuY2xhc3MgRGF0YXN0b3JlIHtcclxufVxyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgRGF0YXN0b3JlIHRoYXQgZXhwb3NlcyBhZGRpdGlvbmFsIHN0YXRlIGZvciBpbnRlcm5hbFxyXG4gKiBjb25zdW1wdGlvbi5cclxuICovXHJcbmNsYXNzIERhdGFzdG9yZUltcGwgZXh0ZW5kcyBEYXRhc3RvcmUge1xyXG4gICAgY29uc3RydWN0b3IoYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBjb25uZWN0aW9uLCBzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscyA9IGF1dGhDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMgPSBhcHBDaGVja0NyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHZlcmlmeUluaXRpYWxpemVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRlcm1pbmF0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1RoZSBjbGllbnQgaGFzIGFscmVhZHkgYmVlbiB0ZXJtaW5hdGVkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBJbnZva2VzIHRoZSBwcm92aWRlZCBSUEMgd2l0aCBhdXRoIGFuZCBBcHBDaGVjayB0b2tlbnMuICovXHJcbiAgICBpbnZva2VSUEMocnBjTmFtZSwgcGF0aCwgcmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5nZXRUb2tlbigpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKVxyXG4gICAgICAgIF0pXHJcbiAgICAgICAgICAgIC50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmludm9rZVJQQyhycGNOYW1lLCBwYXRoLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEludm9rZXMgdGhlIHByb3ZpZGVkIFJQQyB3aXRoIHN0cmVhbWVkIHJlc3VsdHMgd2l0aCBhdXRoIGFuZCBBcHBDaGVjayB0b2tlbnMuICovXHJcbiAgICBpbnZva2VTdHJlYW1pbmdSUEMocnBjTmFtZSwgcGF0aCwgcmVxdWVzdCkge1xyXG4gICAgICAgIHRoaXMudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5nZXRUb2tlbigpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMuZ2V0VG9rZW4oKVxyXG4gICAgICAgIF0pXHJcbiAgICAgICAgICAgIC50aGVuKChbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmludm9rZVN0cmVhbWluZ1JQQyhycGNOYW1lLCBwYXRoLCByZXF1ZXN0LCBhdXRoVG9rZW4sIGFwcENoZWNrVG9rZW4pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdGaXJlYmFzZUVycm9yJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IENvZGUuVU5BVVRIRU5USUNBVEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbHMuaW52YWxpZGF0ZVRva2VuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLmludmFsaWRhdGVUb2tlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTktOT1dOLCBlcnJvci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdGVybWluYXRlKCkge1xyXG4gICAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuLy8gVE9ETyhmaXJlc3RvcmV4cCk6IE1ha2Ugc3VyZSB0aGVyZSBpcyBvbmx5IG9uZSBEYXRhc3RvcmUgaW5zdGFuY2UgcGVyXHJcbi8vIGZpcmVzdG9yZS1leHAgY2xpZW50LlxyXG5mdW5jdGlvbiBuZXdEYXRhc3RvcmUoYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBjb25uZWN0aW9uLCBzZXJpYWxpemVyKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGFzdG9yZUltcGwoYXV0aENyZWRlbnRpYWxzLCBhcHBDaGVja0NyZWRlbnRpYWxzLCBjb25uZWN0aW9uLCBzZXJpYWxpemVyKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBpbnZva2VDb21taXRScGMoZGF0YXN0b3JlLCBtdXRhdGlvbnMpIHtcclxuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcclxuICAgIGNvbnN0IHBhdGggPSBnZXRFbmNvZGVkRGF0YWJhc2VJZChkYXRhc3RvcmVJbXBsLnNlcmlhbGl6ZXIpICsgJy9kb2N1bWVudHMnO1xyXG4gICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICB3cml0ZXM6IG11dGF0aW9ucy5tYXAobSA9PiB0b011dGF0aW9uKGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgbSkpXHJcbiAgICB9O1xyXG4gICAgYXdhaXQgZGF0YXN0b3JlSW1wbC5pbnZva2VSUEMoJ0NvbW1pdCcsIHBhdGgsIHJlcXVlc3QpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGludm9rZUJhdGNoR2V0RG9jdW1lbnRzUnBjKGRhdGFzdG9yZSwga2V5cykge1xyXG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xyXG4gICAgY29uc3QgcGF0aCA9IGdldEVuY29kZWREYXRhYmFzZUlkKGRhdGFzdG9yZUltcGwuc2VyaWFsaXplcikgKyAnL2RvY3VtZW50cyc7XHJcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgIGRvY3VtZW50czoga2V5cy5tYXAoayA9PiB0b05hbWUoZGF0YXN0b3JlSW1wbC5zZXJpYWxpemVyLCBrKSlcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGRhdGFzdG9yZUltcGwuaW52b2tlU3RyZWFtaW5nUlBDKCdCYXRjaEdldERvY3VtZW50cycsIHBhdGgsIHJlcXVlc3QpO1xyXG4gICAgY29uc3QgZG9jcyA9IG5ldyBNYXAoKTtcclxuICAgIHJlc3BvbnNlLmZvckVhY2gocHJvdG8gPT4ge1xyXG4gICAgICAgIGNvbnN0IGRvYyA9IGZyb21CYXRjaEdldERvY3VtZW50c1Jlc3BvbnNlKGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgcHJvdG8pO1xyXG4gICAgICAgIGRvY3Muc2V0KGRvYy5rZXkudG9TdHJpbmcoKSwgZG9jKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBjb25zdCBkb2MgPSBkb2NzLmdldChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgaGFyZEFzc2VydCghIWRvYyk7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goZG9jKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBuZXdQZXJzaXN0ZW50V3JpdGVTdHJlYW0oZGF0YXN0b3JlLCBxdWV1ZSwgbGlzdGVuZXIpIHtcclxuICAgIGNvbnN0IGRhdGFzdG9yZUltcGwgPSBkZWJ1Z0Nhc3QoZGF0YXN0b3JlKTtcclxuICAgIGRhdGFzdG9yZUltcGwudmVyaWZ5SW5pdGlhbGl6ZWQoKTtcclxuICAgIHJldHVybiBuZXcgUGVyc2lzdGVudFdyaXRlU3RyZWFtKHF1ZXVlLCBkYXRhc3RvcmVJbXBsLmNvbm5lY3Rpb24sIGRhdGFzdG9yZUltcGwuYXV0aENyZWRlbnRpYWxzLCBkYXRhc3RvcmVJbXBsLmFwcENoZWNrQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgbGlzdGVuZXIpO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1BlcnNpc3RlbnRXYXRjaFN0cmVhbShkYXRhc3RvcmUsIHF1ZXVlLCBsaXN0ZW5lcikge1xyXG4gICAgY29uc3QgZGF0YXN0b3JlSW1wbCA9IGRlYnVnQ2FzdChkYXRhc3RvcmUpO1xyXG4gICAgZGF0YXN0b3JlSW1wbC52ZXJpZnlJbml0aWFsaXplZCgpO1xyXG4gICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW50TGlzdGVuU3RyZWFtKHF1ZXVlLCBkYXRhc3RvcmVJbXBsLmNvbm5lY3Rpb24sIGRhdGFzdG9yZUltcGwuYXV0aENyZWRlbnRpYWxzLCBkYXRhc3RvcmVJbXBsLmFwcENoZWNrQ3JlZGVudGlhbHMsIGRhdGFzdG9yZUltcGwuc2VyaWFsaXplciwgbGlzdGVuZXIpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUckNiA9ICdPbmxpbmVTdGF0ZVRyYWNrZXInO1xyXG4vLyBUbyBkZWFsIHdpdGggdHJhbnNpZW50IGZhaWx1cmVzLCB3ZSBhbGxvdyBtdWx0aXBsZSBzdHJlYW0gYXR0ZW1wdHMgYmVmb3JlXHJcbi8vIGdpdmluZyB1cCBhbmQgdHJhbnNpdGlvbmluZyBmcm9tIE9ubGluZVN0YXRlLlVua25vd24gdG8gT2ZmbGluZS5cclxuLy8gVE9ETyhtaWtlbGVoZW4pOiBUaGlzIHVzZWQgdG8gYmUgc2V0IHRvIDIgYXMgYSBtaXRpZ2F0aW9uIGZvciBiLzY2MjI4Mzk0LlxyXG4vLyBAamRpbW9uZCB0aGlua3MgdGhhdCBidWcgaXMgc3VmZmljaWVudGx5IGZpeGVkIHNvIHRoYXQgd2UgY2FuIHNldCB0aGlzIGJhY2tcclxuLy8gdG8gMS4gSWYgdGhhdCB3b3JrcyBva2F5LCB3ZSBjb3VsZCBwb3RlbnRpYWxseSByZW1vdmUgdGhpcyBsb2dpYyBlbnRpcmVseS5cclxuY29uc3QgTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUyA9IDE7XHJcbi8vIFRvIGRlYWwgd2l0aCBzdHJlYW0gYXR0ZW1wdHMgdGhhdCBkb24ndCBzdWNjZWVkIG9yIGZhaWwgaW4gYSB0aW1lbHkgbWFubmVyLFxyXG4vLyB3ZSBoYXZlIGEgdGltZW91dCBmb3IgT25saW5lU3RhdGUgdG8gcmVhY2ggT25saW5lIG9yIE9mZmxpbmUuXHJcbi8vIElmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQsIHdlIHRyYW5zaXRpb24gdG8gT2ZmbGluZSByYXRoZXIgdGhhbiB3YWl0aW5nXHJcbi8vIGluZGVmaW5pdGVseS5cclxuY29uc3QgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMgPSAxMCAqIDEwMDA7XHJcbi8qKlxyXG4gKiBBIGNvbXBvbmVudCB1c2VkIGJ5IHRoZSBSZW1vdGVTdG9yZSB0byB0cmFjayB0aGUgT25saW5lU3RhdGUgKHRoYXQgaXMsXHJcbiAqIHdoZXRoZXIgb3Igbm90IHRoZSBjbGllbnQgYXMgYSB3aG9sZSBzaG91bGQgYmUgY29uc2lkZXJlZCB0byBiZSBvbmxpbmUgb3JcclxuICogb2ZmbGluZSksIGltcGxlbWVudGluZyB0aGUgYXBwcm9wcmlhdGUgaGV1cmlzdGljcy5cclxuICpcclxuICogSW4gcGFydGljdWxhciwgd2hlbiB0aGUgY2xpZW50IGlzIHRyeWluZyB0byBjb25uZWN0IHRvIHRoZSBiYWNrZW5kLCB3ZVxyXG4gKiBhbGxvdyB1cCB0byBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTIHdpdGhpbiBPTkxJTkVfU1RBVEVfVElNRU9VVF9NUyBmb3JcclxuICogYSBjb25uZWN0aW9uIHRvIHN1Y2NlZWQuIElmIHdlIGhhdmUgdG9vIG1hbnkgZmFpbHVyZXMgb3IgdGhlIHRpbWVvdXQgZWxhcHNlcyxcclxuICogdGhlbiB3ZSBzZXQgdGhlIE9ubGluZVN0YXRlIHRvIE9mZmxpbmUsIGFuZCB0aGUgY2xpZW50IHdpbGwgYmVoYXZlIGFzIGlmXHJcbiAqIGl0IGlzIG9mZmxpbmUgKGdldCgpcyB3aWxsIHJldHVybiBjYWNoZWQgZGF0YSwgZXRjLikuXHJcbiAqL1xyXG5jbGFzcyBPbmxpbmVTdGF0ZVRyYWNrZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlSGFuZGxlciA9IG9ubGluZVN0YXRlSGFuZGxlcjtcclxuICAgICAgICAvKiogVGhlIGN1cnJlbnQgT25saW5lU3RhdGUuICovXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiVW5rbm93blwiIC8qIFVua25vd24gKi87XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjb3VudCBvZiBjb25zZWN1dGl2ZSBmYWlsdXJlcyB0byBvcGVuIHRoZSBzdHJlYW0uIElmIGl0IHJlYWNoZXMgdGhlXHJcbiAgICAgICAgICogbWF4aW11bSBkZWZpbmVkIGJ5IE1BWF9XQVRDSF9TVFJFQU1fRkFJTFVSRVMsIHdlJ2xsIHNldCB0aGUgT25saW5lU3RhdGUgdG9cclxuICAgICAgICAgKiBPZmZsaW5lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud2F0Y2hTdHJlYW1GYWlsdXJlcyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB0aW1lciB0aGF0IGVsYXBzZXMgYWZ0ZXIgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMsIGF0IHdoaWNoIHBvaW50IHdlXHJcbiAgICAgICAgICogdHJhbnNpdGlvbiBmcm9tIE9ubGluZVN0YXRlLlVua25vd24gdG8gT25saW5lU3RhdGUuT2ZmbGluZSB3aXRob3V0IHdhaXRpbmdcclxuICAgICAgICAgKiBmb3IgdGhlIHN0cmVhbSB0byBhY3R1YWxseSBmYWlsIChNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTIHRpbWVzKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNsaWVudCBzaG91bGQgbG9nIGEgd2FybmluZyBtZXNzYWdlIGlmIGl0IGZhaWxzIHRvIGNvbm5lY3QgdG9cclxuICAgICAgICAgKiB0aGUgYmFja2VuZCAoaW5pdGlhbGx5IHRydWUsIGNsZWFyZWQgYWZ0ZXIgYSBzdWNjZXNzZnVsIHN0cmVhbSwgb3IgaWYgd2UndmVcclxuICAgICAgICAgKiBsb2dnZWQgdGhlIG1lc3NhZ2UgYWxyZWFkeSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IFJlbW90ZVN0b3JlIHdoZW4gYSB3YXRjaCBzdHJlYW0gaXMgc3RhcnRlZCAoaW5jbHVkaW5nIG9uIGVhY2hcclxuICAgICAqIGJhY2tvZmYgYXR0ZW1wdCkuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhpcyBpcyB0aGUgZmlyc3QgYXR0ZW1wdCwgaXQgc2V0cyB0aGUgT25saW5lU3RhdGUgdG8gVW5rbm93biBhbmQgc3RhcnRzXHJcbiAgICAgKiB0aGUgb25saW5lU3RhdGVUaW1lci5cclxuICAgICAqL1xyXG4gICAgaGFuZGxlV2F0Y2hTdHJlYW1TdGFydCgpIHtcclxuICAgICAgICBpZiAodGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KFwiVW5rbm93blwiIC8qIFVua25vd24gKi8pO1xyXG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIgPSB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFmdGVyRGVsYXkoXCJvbmxpbmVfc3RhdGVfdGltZW91dFwiIC8qIE9ubGluZVN0YXRlVGltZW91dCAqLywgT05MSU5FX1NUQVRFX1RJTUVPVVRfTVMsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0NsaWVudE9mZmxpbmVXYXJuaW5nSWZOZWNlc3NhcnkoYEJhY2tlbmQgZGlkbid0IHJlc3BvbmQgd2l0aGluICR7T05MSU5FX1NUQVRFX1RJTUVPVVRfTVMgLyAxMDAwfSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgc2Vjb25kcy5gKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KFwiT2ZmbGluZVwiIC8qIE9mZmxpbmUgKi8pO1xyXG4gICAgICAgICAgICAgICAgLy8gTk9URTogaGFuZGxlV2F0Y2hTdHJlYW1GYWlsdXJlKCkgd2lsbCBjb250aW51ZSB0byBpbmNyZW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHdhdGNoU3RyZWFtRmFpbHVyZXMgZXZlbiB0aG91Z2ggd2UgYXJlIGFscmVhZHkgbWFya2VkIE9mZmxpbmUsXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhpcyBpcyBub24taGFybWZ1bC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIG91ciBPbmxpbmVTdGF0ZSBhcyBhcHByb3ByaWF0ZSBhZnRlciB0aGUgd2F0Y2ggc3RyZWFtIHJlcG9ydHMgYVxyXG4gICAgICogZmFpbHVyZS4gVGhlIGZpcnN0IGZhaWx1cmUgbW92ZXMgdXMgdG8gdGhlICdVbmtub3duJyBzdGF0ZS4gV2UgdGhlbiBtYXlcclxuICAgICAqIGFsbG93IG11bHRpcGxlIGZhaWx1cmVzIChiYXNlZCBvbiBNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTKSBiZWZvcmUgd2VcclxuICAgICAqIGFjdHVhbGx5IHRyYW5zaXRpb24gdG8gdGhlICdPZmZsaW5lJyBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgaGFuZGxlV2F0Y2hTdHJlYW1GYWlsdXJlKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiT25saW5lXCIgLyogT25saW5lICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KFwiVW5rbm93blwiIC8qIFVua25vd24gKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy53YXRjaFN0cmVhbUZhaWx1cmVzKys7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLndhdGNoU3RyZWFtRmFpbHVyZXMgPj0gTUFYX1dBVENIX1NUUkVBTV9GQUlMVVJFUykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhck9ubGluZVN0YXRlVGltZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nQ2xpZW50T2ZmbGluZVdhcm5pbmdJZk5lY2Vzc2FyeShgQ29ubmVjdGlvbiBmYWlsZWQgJHtNQVhfV0FUQ0hfU1RSRUFNX0ZBSUxVUkVTfSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgdGltZXMuIE1vc3QgcmVjZW50IGVycm9yOiAke2Vycm9yLnRvU3RyaW5nKCl9YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFuZEJyb2FkY2FzdChcIk9mZmxpbmVcIiAvKiBPZmZsaW5lICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhwbGljaXRseSBzZXRzIHRoZSBPbmxpbmVTdGF0ZSB0byB0aGUgc3BlY2lmaWVkIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHJlc2V0cyBvdXIgdGltZXJzIC8gZmFpbHVyZSBjb3VudGVycywgZXRjLiB1c2VkIGJ5IG91clxyXG4gICAgICogT2ZmbGluZSBoZXVyaXN0aWNzLCBzbyBtdXN0IG5vdCBiZSB1c2VkIGluIHBsYWNlIG9mXHJcbiAgICAgKiBoYW5kbGVXYXRjaFN0cmVhbVN0YXJ0KCkgYW5kIGhhbmRsZVdhdGNoU3RyZWFtRmFpbHVyZSgpLlxyXG4gICAgICovXHJcbiAgICBzZXQobmV3U3RhdGUpIHtcclxuICAgICAgICB0aGlzLmNsZWFyT25saW5lU3RhdGVUaW1lcigpO1xyXG4gICAgICAgIHRoaXMud2F0Y2hTdHJlYW1GYWlsdXJlcyA9IDA7XHJcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSBcIk9ubGluZVwiIC8qIE9ubGluZSAqLykge1xyXG4gICAgICAgICAgICAvLyBXZSd2ZSBjb25uZWN0ZWQgdG8gd2F0Y2ggYXQgbGVhc3Qgb25jZS4gRG9uJ3Qgd2FybiB0aGUgZGV2ZWxvcGVyXHJcbiAgICAgICAgICAgIC8vIGFib3V0IGJlaW5nIG9mZmxpbmUgZ29pbmcgZm9yd2FyZC5cclxuICAgICAgICAgICAgdGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0QW5kQnJvYWRjYXN0KG5ld1N0YXRlKTtcclxuICAgIH1cclxuICAgIHNldEFuZEJyb2FkY2FzdChuZXdTdGF0ZSkge1xyXG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgICAgIHRoaXMub25saW5lU3RhdGVIYW5kbGVyKG5ld1N0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2dDbGllbnRPZmZsaW5lV2FybmluZ0lmTmVjZXNzYXJ5KGRldGFpbHMpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYENvdWxkIG5vdCByZWFjaCBDbG91ZCBGaXJlc3RvcmUgYmFja2VuZC4gJHtkZXRhaWxzfVxcbmAgK1xyXG4gICAgICAgICAgICBgVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIHRoYXQgeW91ciBkZXZpY2UgZG9lcyBub3QgaGF2ZSBhIGhlYWx0aHkgYCArXHJcbiAgICAgICAgICAgIGBJbnRlcm5ldCBjb25uZWN0aW9uIGF0IHRoZSBtb21lbnQuIFRoZSBjbGllbnQgd2lsbCBvcGVyYXRlIGluIG9mZmxpbmUgYCArXHJcbiAgICAgICAgICAgIGBtb2RlIHVudGlsIGl0IGlzIGFibGUgdG8gc3VjY2Vzc2Z1bGx5IGNvbm5lY3QgdG8gdGhlIGJhY2tlbmQuYDtcclxuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXJuQ2xpZW50SXNPZmZsaW5lKSB7XHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLnNob3VsZFdhcm5DbGllbnRJc09mZmxpbmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNiwgbWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJPbmxpbmVTdGF0ZVRpbWVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9ubGluZVN0YXRlVGltZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZVRpbWVyLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9ubGluZVN0YXRlVGltZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJDUgPSAnUmVtb3RlU3RvcmUnO1xyXG4vLyBUT0RPKGIvMzU4NTM0MDIpOiBOZWdvdGlhdGUgdGhpcyB3aXRoIHRoZSBzdHJlYW0uXHJcbmNvbnN0IE1BWF9QRU5ESU5HX1dSSVRFUyA9IDEwO1xyXG5jbGFzcyBSZW1vdGVTdG9yZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb2NhbCBzdG9yZSwgdXNlZCB0byBmaWxsIHRoZSB3cml0ZSBwaXBlbGluZSB3aXRoIG91dGJvdW5kIG11dGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgbG9jYWxTdG9yZSwgXHJcbiAgICAvKiogVGhlIGNsaWVudC1zaWRlIHByb3h5IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBiYWNrZW5kLiAqL1xyXG4gICAgZGF0YXN0b3JlLCBhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIsIGNvbm5lY3Rpdml0eU1vbml0b3IpIHtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xyXG4gICAgICAgIHRoaXMuZGF0YXN0b3JlID0gZGF0YXN0b3JlO1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTeW5jZXIgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgdXAgdG8gTUFYX1BFTkRJTkdfV1JJVEVTIHdyaXRlcyB0aGF0IHdlIGhhdmUgZmV0Y2hlZCBmcm9tIHRoZVxyXG4gICAgICAgICAqIExvY2FsU3RvcmUgdmlhIGZpbGxXcml0ZVBpcGVsaW5lKCkgYW5kIGhhdmUgb3Igd2lsbCBzZW5kIHRvIHRoZSB3cml0ZVxyXG4gICAgICAgICAqIHN0cmVhbS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdoZW5ldmVyIHdyaXRlUGlwZWxpbmUubGVuZ3RoID4gMCB0aGUgUmVtb3RlU3RvcmUgd2lsbCBhdHRlbXB0IHRvIHN0YXJ0IG9yXHJcbiAgICAgICAgICogcmVzdGFydCB0aGUgd3JpdGUgc3RyZWFtLiBXaGVuIHRoZSBzdHJlYW0gaXMgZXN0YWJsaXNoZWQgdGhlIHdyaXRlcyBpbiB0aGVcclxuICAgICAgICAgKiBwaXBlbGluZSB3aWxsIGJlIHNlbnQgaW4gb3JkZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXcml0ZXMgcmVtYWluIGluIHdyaXRlUGlwZWxpbmUgdW50aWwgdGhleSBhcmUgYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kXHJcbiAgICAgICAgICogYW5kIHRodXMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHJlLXNlbnQgaWYgdGhlIHN0cmVhbSBpcyBpbnRlcnJ1cHRlZCAvXHJcbiAgICAgICAgICogcmVzdGFydGVkIGJlZm9yZSB0aGV5J3JlIGFja25vd2xlZGdlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFdyaXRlIHJlc3BvbnNlcyBmcm9tIHRoZSBiYWNrZW5kIGFyZSBsaW5rZWQgdG8gdGhlaXIgb3JpZ2luYXRpbmcgcmVxdWVzdFxyXG4gICAgICAgICAqIHB1cmVseSBiYXNlZCBvbiBvcmRlciwgYW5kIHNvIHdlIGNhbiBqdXN0IHNoaWZ0KCkgd3JpdGVzIGZyb20gdGhlIGZyb250IG9mXHJcbiAgICAgICAgICogdGhlIHdyaXRlUGlwZWxpbmUgYXMgd2UgcmVjZWl2ZSByZXNwb25zZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53cml0ZVBpcGVsaW5lID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBtYXBwaW5nIG9mIHdhdGNoZWQgdGFyZ2V0cyB0aGF0IHRoZSBjbGllbnQgY2FyZXMgYWJvdXQgdHJhY2tpbmcgYW5kIHRoZVxyXG4gICAgICAgICAqIHVzZXIgaGFzIGV4cGxpY2l0bHkgY2FsbGVkIGEgJ2xpc3RlbicgZm9yIHRoaXMgdGFyZ2V0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhlc2UgdGFyZ2V0cyBtYXkgb3IgbWF5IG5vdCBoYXZlIGJlZW4gc2VudCB0byBvciBhY2tub3dsZWRnZWQgYnkgdGhlXHJcbiAgICAgICAgICogc2VydmVyLiBPbiByZS1lc3RhYmxpc2hpbmcgdGhlIGxpc3RlbiBzdHJlYW0sIHRoZXNlIHRhcmdldHMgc2hvdWxkIGJlIHNlbnRcclxuICAgICAgICAgKiB0byB0aGUgc2VydmVyLiBUaGUgdGFyZ2V0cyByZW1vdmVkIHdpdGggdW5saXN0ZW5zIGFyZSByZW1vdmVkIGVhZ2VybHlcclxuICAgICAgICAgKiB3aXRob3V0IHdhaXRpbmcgZm9yIGNvbmZpcm1hdGlvbiBmcm9tIHRoZSBsaXN0ZW4gc3RyZWFtLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGlzdGVuVGFyZ2V0cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHNldCBvZiByZWFzb25zIGZvciB3aHkgdGhlIFJlbW90ZVN0b3JlIG1heSBiZSBvZmZsaW5lLiBJZiBlbXB0eSwgdGhlXHJcbiAgICAgICAgICogUmVtb3RlU3RvcmUgbWF5IHN0YXJ0IGl0cyBuZXR3b3JrIGNvbm5lY3Rpb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2ZmbGluZUNhdXNlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFdmVudCBoYW5kbGVycyB0aGF0IGdldCBjYWxsZWQgd2hlbiB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCBvciBlbmFibGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogUE9SVElORyBOT1RFOiBUaGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgb24gdGhlIFdlYiBjbGllbnQgdG8gY3JlYXRlIHRoZVxyXG4gICAgICAgICAqIHVuZGVybHlpbmcgc3RyZWFtcyAodG8gc3VwcG9ydCB0cmVlLXNoYWtlYWJsZSBzdHJlYW1zKS4gT24gQW5kcm9pZCBhbmQgaU9TLFxyXG4gICAgICAgICAqIHRoZSBzdHJlYW1zIGFyZSBjcmVhdGVkIGR1cmluZyBjb25zdHJ1Y3Rpb24gb2YgUmVtb3RlU3RvcmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eU1vbml0b3IgPSBjb25uZWN0aXZpdHlNb25pdG9yO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5TW9uaXRvci5hZGRDYWxsYmFjaygoXykgPT4ge1xyXG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gUG9ydGluZyBOb3RlOiBVbmxpa2UgaU9TLCBgcmVzdGFydE5ldHdvcmsoKWAgaXMgY2FsbGVkIGV2ZW4gd2hlbiB0aGVcclxuICAgICAgICAgICAgICAgIC8vIG5ldHdvcmsgYmVjb21lcyB1bnJlYWNoYWJsZSBhcyB3ZSBkb24ndCBoYXZlIGFueSBvdGhlciB3YXkgdG8gdGVhclxyXG4gICAgICAgICAgICAgICAgLy8gZG93biBvdXIgc3RyZWFtcy5cclxuICAgICAgICAgICAgICAgIGlmIChjYW5Vc2VOZXR3b3JrKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQ1LCAnUmVzdGFydGluZyBzdHJlYW1zIGZvciBuZXR3b3JrIHJlYWNoYWJpbGl0eSBjaGFuZ2UuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVzdGFydE5ldHdvcmsodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGVUcmFja2VyID0gbmV3IE9ubGluZVN0YXRlVHJhY2tlcihhc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZUhhbmRsZXIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1JlbW90ZVN0b3JlKGxvY2FsU3RvcmUsIGRhdGFzdG9yZSwgYXN5bmNRdWV1ZSwgb25saW5lU3RhdGVIYW5kbGVyLCBjb25uZWN0aXZpdHlNb25pdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlbW90ZVN0b3JlSW1wbChsb2NhbFN0b3JlLCBkYXRhc3RvcmUsIGFzeW5jUXVldWUsIG9ubGluZVN0YXRlSGFuZGxlciwgY29ubmVjdGl2aXR5TW9uaXRvcik7XHJcbn1cclxuLyoqIFJlLWVuYWJsZXMgdGhlIG5ldHdvcmsuIElkZW1wb3RlbnQuICovXHJcbmZ1bmN0aW9uIHJlbW90ZVN0b3JlRW5hYmxlTmV0d29yayhyZW1vdGVTdG9yZSkge1xyXG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgwIC8qIFVzZXJEaXNhYmxlZCAqLyk7XHJcbiAgICByZXR1cm4gZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgaWYgKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbmV0d29ya1N0YXR1c0hhbmRsZXIgb2YgcmVtb3RlU3RvcmVJbXBsLm9uTmV0d29ya1N0YXR1c0NoYW5nZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRlbXBvcmFyaWx5IGRpc2FibGVzIHRoZSBuZXR3b3JrLiBUaGUgbmV0d29yayBjYW4gYmUgcmUtZW5hYmxlZCB1c2luZ1xyXG4gKiBlbmFibGVOZXR3b3JrKCkuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiByZW1vdGVTdG9yZURpc2FibGVOZXR3b3JrKHJlbW90ZVN0b3JlKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuYWRkKDAgLyogVXNlckRpc2FibGVkICovKTtcclxuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIC8vIFNldCB0aGUgT25saW5lU3RhdGUgdG8gT2ZmbGluZSBzbyBnZXQoKXMgcmV0dXJuIGZyb20gY2FjaGUsIGV0Yy5cclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiT2ZmbGluZVwiIC8qIE9mZmxpbmUgKi8pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBmb3IgKGNvbnN0IG5ldHdvcmtTdGF0dXNIYW5kbGVyIG9mIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UpIHtcclxuICAgICAgICBhd2FpdCBuZXR3b3JrU3RhdHVzSGFuZGxlcigvKiBlbmFibGVkPSAqLyBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVTaHV0ZG93bihyZW1vdGVTdG9yZSkge1xyXG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcclxuICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ1JlbW90ZVN0b3JlIHNodXR0aW5nIGRvd24uJyk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoNSAvKiBTaHV0ZG93biAqLyk7XHJcbiAgICBhd2FpdCBkaXNhYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwuY29ubmVjdGl2aXR5TW9uaXRvci5zaHV0ZG93bigpO1xyXG4gICAgLy8gU2V0IHRoZSBPbmxpbmVTdGF0ZSB0byBVbmtub3duIChyYXRoZXIgdGhhbiBPZmZsaW5lKSB0byBhdm9pZCBwb3RlbnRpYWxseVxyXG4gICAgLy8gdHJpZ2dlcmluZyBzcHVyaW91cyBsaXN0ZW5lciBldmVudHMgd2l0aCBjYWNoZWQgZGF0YSwgZXRjLlxyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogVW5rbm93biAqLyk7XHJcbn1cclxuLyoqXHJcbiAqIFN0YXJ0cyBuZXcgbGlzdGVuIGZvciB0aGUgZ2l2ZW4gdGFyZ2V0LiBVc2VzIHJlc3VtZSB0b2tlbiBpZiBwcm92aWRlZC4gSXRcclxuICogaXMgYSBuby1vcCBpZiB0aGUgdGFyZ2V0IG9mIGdpdmVuIGBUYXJnZXREYXRhYCBpcyBhbHJlYWR5IGJlaW5nIGxpc3RlbmVkIHRvLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3RlU3RvcmVMaXN0ZW4ocmVtb3RlU3RvcmUsIHRhcmdldERhdGEpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICBpZiAocmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuaGFzKHRhcmdldERhdGEudGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gTWFyayB0aGlzIGFzIHNvbWV0aGluZyB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSBsaXN0ZW5pbmcgZm9yLlxyXG4gICAgcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuc2V0KHRhcmdldERhdGEudGFyZ2V0SWQsIHRhcmdldERhdGEpO1xyXG4gICAgaWYgKHNob3VsZFN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgIC8vIFRoZSBsaXN0ZW4gd2lsbCBiZSBzZW50IGluIG9uV2F0Y2hTdHJlYW1PcGVuXHJcbiAgICAgICAgc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZW5zdXJlV2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5pc09wZW4oKSkge1xyXG4gICAgICAgIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCB0YXJnZXREYXRhKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVtb3ZlcyB0aGUgbGlzdGVuIGZyb20gc2VydmVyLiBJdCBpcyBhIG5vLW9wIGlmIHRoZSBnaXZlbiB0YXJnZXQgaWQgaXNcclxuICogbm90IGJlaW5nIGxpc3RlbmVkIHRvLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3RlU3RvcmVVbmxpc3RlbihyZW1vdGVTdG9yZSwgdGFyZ2V0SWQpIHtcclxuICAgIGNvbnN0IHJlbW90ZVN0b3JlSW1wbCA9IGRlYnVnQ2FzdChyZW1vdGVTdG9yZSk7XHJcbiAgICBjb25zdCB3YXRjaFN0cmVhbSA9IGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5kZWxldGUodGFyZ2V0SWQpO1xyXG4gICAgaWYgKHdhdGNoU3RyZWFtLmlzT3BlbigpKSB7XHJcbiAgICAgICAgc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLnNpemUgPT09IDApIHtcclxuICAgICAgICBpZiAod2F0Y2hTdHJlYW0uaXNPcGVuKCkpIHtcclxuICAgICAgICAgICAgd2F0Y2hTdHJlYW0ubWFya0lkbGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpKSB7XHJcbiAgICAgICAgICAgIC8vIFJldmVydCB0byBPbmxpbmVTdGF0ZS5Vbmtub3duIGlmIHRoZSB3YXRjaCBzdHJlYW0gaXMgbm90IG9wZW4gYW5kIHdlXHJcbiAgICAgICAgICAgIC8vIGhhdmUgbm8gbGlzdGVuZXJzLCBzaW5jZSB3aXRob3V0IGFueSBsaXN0ZW5zIHRvIHNlbmQgd2UgY2Fubm90XHJcbiAgICAgICAgICAgIC8vIGNvbmZpcm0gaWYgdGhlIHN0cmVhbSBpcyBoZWFsdGh5IGFuZCB1cGdyYWRlIHRvIE9ubGluZVN0YXRlLk9ubGluZS5cclxuICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogVW5rbm93biAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXZSBuZWVkIHRvIGluY3JlbWVudCB0aGUgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBwZW5kaW5nIHJlc3BvbnNlcyB3ZSdyZSBkdWVcclxuICogZnJvbSB3YXRjaCBzbyB3ZSB3YWl0IGZvciB0aGUgYWNrIHRvIHByb2Nlc3MgYW55IG1lc3NhZ2VzIGZyb20gdGhpcyB0YXJnZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZW5kV2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0RGF0YSkge1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvci5yZWNvcmRQZW5kaW5nVGFyZ2V0UmVxdWVzdCh0YXJnZXREYXRhLnRhcmdldElkKTtcclxuICAgIGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkud2F0Y2godGFyZ2V0RGF0YSk7XHJcbn1cclxuLyoqXHJcbiAqIFdlIG5lZWQgdG8gaW5jcmVtZW50IHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcGVuZGluZyByZXNwb25zZXMgd2UncmUgZHVlXHJcbiAqIGZyb20gd2F0Y2ggc28gd2Ugd2FpdCBmb3IgdGhlIHJlbW92YWwgb24gdGhlIHNlcnZlciBiZWZvcmUgd2UgcHJvY2VzcyBhbnlcclxuICogbWVzc2FnZXMgZnJvbSB0aGlzIHRhcmdldC5cclxuICovXHJcbmZ1bmN0aW9uIHNlbmRVbndhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldElkKSB7XHJcbiAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLnJlY29yZFBlbmRpbmdUYXJnZXRSZXF1ZXN0KHRhcmdldElkKTtcclxuICAgIGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkudW53YXRjaCh0YXJnZXRJZCk7XHJcbn1cclxuZnVuY3Rpb24gc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IgPSBuZXcgV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yKHtcclxuICAgICAgICBnZXRSZW1vdGVLZXlzRm9yVGFyZ2V0OiB0YXJnZXRJZCA9PiByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQodGFyZ2V0SWQpLFxyXG4gICAgICAgIGdldFRhcmdldERhdGFGb3JUYXJnZXQ6IHRhcmdldElkID0+IHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmdldCh0YXJnZXRJZCkgfHwgbnVsbFxyXG4gICAgfSk7XHJcbiAgICBlbnN1cmVXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpLnN0YXJ0KCk7XHJcbiAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLmhhbmRsZVdhdGNoU3RyZWFtU3RhcnQoKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIHRoZSB3YXRjaCBzdHJlYW0gc2hvdWxkIGJlIHN0YXJ0ZWQgYmVjYXVzZSBpdCdzIG5lY2Vzc2FyeVxyXG4gKiBhbmQgaGFzIG5vdCB5ZXQgYmVlbiBzdGFydGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hvdWxkU3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIHJldHVybiAoY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZUltcGwpICYmXHJcbiAgICAgICAgIWVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkuaXNTdGFydGVkKCkgJiZcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zaXplID4gMCk7XHJcbn1cclxuZnVuY3Rpb24gY2FuVXNlTmV0d29yayhyZW1vdGVTdG9yZSkge1xyXG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcclxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5zaXplID09PSAwO1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFuVXBXYXRjaFN0cmVhbVN0YXRlKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoQ2hhbmdlQWdncmVnYXRvciA9IHVuZGVmaW5lZDtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBvbldhdGNoU3RyZWFtT3BlbihyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC5saXN0ZW5UYXJnZXRzLmZvckVhY2goKHRhcmdldERhdGEsIHRhcmdldElkKSA9PiB7XHJcbiAgICAgICAgc2VuZFdhdGNoUmVxdWVzdChyZW1vdGVTdG9yZUltcGwsIHRhcmdldERhdGEpO1xyXG4gICAgfSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gb25XYXRjaFN0cmVhbUNsb3NlKHJlbW90ZVN0b3JlSW1wbCwgZXJyb3IpIHtcclxuICAgIGNsZWFuVXBXYXRjaFN0cmVhbVN0YXRlKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAvLyBJZiB3ZSBzdGlsbCBuZWVkIHRoZSB3YXRjaCBzdHJlYW0sIHJldHJ5IHRoZSBjb25uZWN0aW9uLlxyXG4gICAgaWYgKHNob3VsZFN0YXJ0V2F0Y2hTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuaGFuZGxlV2F0Y2hTdHJlYW1GYWlsdXJlKGVycm9yKTtcclxuICAgICAgICBzdGFydFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBObyBuZWVkIHRvIHJlc3RhcnQgd2F0Y2ggc3RyZWFtIGJlY2F1c2UgdGhlcmUgYXJlIG5vIGFjdGl2ZSB0YXJnZXRzLlxyXG4gICAgICAgIC8vIFRoZSBvbmxpbmUgc3RhdGUgaXMgc2V0IHRvIHVua25vd24gYmVjYXVzZSB0aGVyZSBpcyBubyBhY3RpdmUgYXR0ZW1wdFxyXG4gICAgICAgIC8vIGF0IGVzdGFibGlzaGluZyBhIGNvbm5lY3Rpb25cclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIlVua25vd25cIiAvKiBVbmtub3duICovKTtcclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiBvbldhdGNoU3RyZWFtQ2hhbmdlKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UsIHNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgLy8gTWFyayB0aGUgY2xpZW50IGFzIG9ubGluZSBzaW5jZSB3ZSBnb3QgYSBtZXNzYWdlIGZyb20gdGhlIHNlcnZlclxyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJPbmxpbmVcIiAvKiBPbmxpbmUgKi8pO1xyXG4gICAgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgV2F0Y2hUYXJnZXRDaGFuZ2UgJiZcclxuICAgICAgICB3YXRjaENoYW5nZS5zdGF0ZSA9PT0gMiAvKiBSZW1vdmVkICovICYmXHJcbiAgICAgICAgd2F0Y2hDaGFuZ2UuY2F1c2UpIHtcclxuICAgICAgICAvLyBUaGVyZSB3YXMgYW4gZXJyb3Igb24gYSB0YXJnZXQsIGRvbid0IHdhaXQgZm9yIGEgY29uc2lzdGVudCBzbmFwc2hvdFxyXG4gICAgICAgIC8vIHRvIHJhaXNlIGV2ZW50c1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZVRhcmdldEVycm9yKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdGYWlsZWQgdG8gcmVtb3ZlIHRhcmdldHMgJXM6ICVzICcsIHdhdGNoQ2hhbmdlLnRhcmdldElkcy5qb2luKCcsJyksIGUpO1xyXG4gICAgICAgICAgICBhd2FpdCBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHdhdGNoQ2hhbmdlIGluc3RhbmNlb2YgRG9jdW1lbnRXYXRjaENoYW5nZSkge1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53YXRjaENoYW5nZUFnZ3JlZ2F0b3IuaGFuZGxlRG9jdW1lbnRDaGFuZ2Uod2F0Y2hDaGFuZ2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAod2F0Y2hDaGFuZ2UgaW5zdGFuY2VvZiBFeGlzdGVuY2VGaWx0ZXJDaGFuZ2UpIHtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLmhhbmRsZUV4aXN0ZW5jZUZpbHRlcih3YXRjaENoYW5nZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLmhhbmRsZVRhcmdldENoYW5nZSh3YXRjaENoYW5nZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXNuYXBzaG90VmVyc2lvbi5pc0VxdWFsKFNuYXBzaG90VmVyc2lvbi5taW4oKSkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uID0gYXdhaXQgbG9jYWxTdG9yZUdldExhc3RSZW1vdGVTbmFwc2hvdFZlcnNpb24ocmVtb3RlU3RvcmVJbXBsLmxvY2FsU3RvcmUpO1xyXG4gICAgICAgICAgICBpZiAoc25hcHNob3RWZXJzaW9uLmNvbXBhcmVUbyhsYXN0UmVtb3RlU25hcHNob3RWZXJzaW9uKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHJlY2VpdmVkIGEgdGFyZ2V0IGNoYW5nZSB3aXRoIGEgZ2xvYmFsIHNuYXBzaG90IGlmIHRoZSBzbmFwc2hvdFxyXG4gICAgICAgICAgICAgICAgLy8gdmVyc2lvbiBpcyBub3QgZXF1YWwgdG8gU25hcHNob3RWZXJzaW9uLm1pbigpLlxyXG4gICAgICAgICAgICAgICAgYXdhaXQgcmFpc2VXYXRjaFNuYXBzaG90KHJlbW90ZVN0b3JlSW1wbCwgc25hcHNob3RWZXJzaW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDUsICdGYWlsZWQgdG8gcmFpc2Ugc25hcHNob3Q6JywgZSk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrVW50aWxSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVjb3ZlcnkgbG9naWMgZm9yIEluZGV4ZWREQiBlcnJvcnMgdGhhdCB0YWtlcyB0aGUgbmV0d29yayBvZmZsaW5lIHVudGlsXHJcbiAqIGBvcGAgc3VjY2VlZHMuIFJldHJpZXMgYXJlIHNjaGVkdWxlZCB3aXRoIGJhY2tvZmYgdXNpbmdcclxuICogYGVucXVldWVSZXRyeWFibGUoKWAuIElmIGBvcCgpYCBpcyBub3QgcHJvdmlkZWQsIEluZGV4ZWREQiBhY2Nlc3MgaXNcclxuICogdmFsaWRhdGVkIHZpYSBhIGdlbmVyaWMgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuZWQgUHJvbWlzZSBpcyByZXNvbHZlZCBvbmNlIHRoZSBuZXR3b3JrIGlzIGRpc2FibGVkIGFuZCBiZWZvcmVcclxuICogYW55IHJldHJ5IGF0dGVtcHQuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkaXNhYmxlTmV0d29ya1VudGlsUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCBlLCBvcCkge1xyXG4gICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmFkZCgxIC8qIEluZGV4ZWREYkZhaWxlZCAqLyk7XHJcbiAgICAgICAgLy8gRGlzYWJsZSBuZXR3b3JrIGFuZCByYWlzZSBvZmZsaW5lIHNuYXBzaG90c1xyXG4gICAgICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIk9mZmxpbmVcIiAvKiBPZmZsaW5lICovKTtcclxuICAgICAgICBpZiAoIW9wKSB7XHJcbiAgICAgICAgICAgIC8vIFVzZSBhIHNpbXBsZSByZWFkIG9wZXJhdGlvbiB0byBkZXRlcm1pbmUgaWYgSW5kZXhlZERCIHJlY292ZXJlZC5cclxuICAgICAgICAgICAgLy8gSWRlYWxseSwgd2Ugd291bGQgZXhwb3NlIGEgaGVhbHRoIGNoZWNrIGRpcmVjdGx5IG9uIFNpbXBsZURiLCBidXRcclxuICAgICAgICAgICAgLy8gUmVtb3RlU3RvcmUgb25seSBoYXMgYWNjZXNzIHRvIHBlcnNpc3RlbmNlIHRocm91Z2ggTG9jYWxTdG9yZS5cclxuICAgICAgICAgICAgb3AgPSAoKSA9PiBsb2NhbFN0b3JlR2V0TGFzdFJlbW90ZVNuYXBzaG90VmVyc2lvbihyZW1vdGVTdG9yZUltcGwubG9jYWxTdG9yZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb2JlIEluZGV4ZWREQiBwZXJpb2RpY2FsbHkgYW5kIHJlLWVuYWJsZSBuZXR3b3JrXHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLmFzeW5jUXVldWUuZW5xdWV1ZVJldHJ5YWJsZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ1JldHJ5aW5nIEluZGV4ZWREQiBhY2Nlc3MnKTtcclxuICAgICAgICAgICAgYXdhaXQgb3AoKTtcclxuICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDEgLyogSW5kZXhlZERiRmFpbGVkICovKTtcclxuICAgICAgICAgICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlcyBgb3BgLiBJZiBgb3BgIGZhaWxzLCB0YWtlcyB0aGUgbmV0d29yayBvZmZsaW5lIHVudGlsIGBvcGBcclxuICogc3VjY2VlZHMuIFJldHVybnMgYWZ0ZXIgdGhlIGZpcnN0IGF0dGVtcHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBleGVjdXRlV2l0aFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgb3ApIHtcclxuICAgIHJldHVybiBvcCgpLmNhdGNoKGUgPT4gZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSwgb3ApKTtcclxufVxyXG4vKipcclxuICogVGFrZXMgYSBiYXRjaCBvZiBjaGFuZ2VzIGZyb20gdGhlIERhdGFzdG9yZSwgcmVwYWNrYWdlcyB0aGVtIGFzIGFcclxuICogUmVtb3RlRXZlbnQsIGFuZCBwYXNzZXMgdGhhdCBvbiB0byB0aGUgbGlzdGVuZXIsIHdoaWNoIGlzIHR5cGljYWxseSB0aGVcclxuICogU3luY0VuZ2luZS5cclxuICovXHJcbmZ1bmN0aW9uIHJhaXNlV2F0Y2hTbmFwc2hvdChyZW1vdGVTdG9yZUltcGwsIHNuYXBzaG90VmVyc2lvbikge1xyXG4gICAgY29uc3QgcmVtb3RlRXZlbnQgPSByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLmNyZWF0ZVJlbW90ZUV2ZW50KHNuYXBzaG90VmVyc2lvbik7XHJcbiAgICAvLyBVcGRhdGUgaW4tbWVtb3J5IHJlc3VtZSB0b2tlbnMuIExvY2FsU3RvcmUgd2lsbCB1cGRhdGUgdGhlXHJcbiAgICAvLyBwZXJzaXN0ZW50IHZpZXcgb2YgdGhlc2Ugd2hlbiBhcHBseWluZyB0aGUgY29tcGxldGVkIFJlbW90ZUV2ZW50LlxyXG4gICAgcmVtb3RlRXZlbnQudGFyZ2V0Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UsIHRhcmdldElkKSA9PiB7XHJcbiAgICAgICAgaWYgKGNoYW5nZS5yZXN1bWVUb2tlbi5hcHByb3hpbWF0ZUJ5dGVTaXplKCkgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5nZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAvLyBBIHdhdGNoZWQgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkIGFscmVhZHkuXHJcbiAgICAgICAgICAgIGlmICh0YXJnZXREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zZXQodGFyZ2V0SWQsIHRhcmdldERhdGEud2l0aFJlc3VtZVRva2VuKGNoYW5nZS5yZXN1bWVUb2tlbiwgc25hcHNob3RWZXJzaW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIFJlLWVzdGFibGlzaCBsaXN0ZW5zIGZvciB0aGUgdGFyZ2V0cyB0aGF0IGhhdmUgYmVlbiBpbnZhbGlkYXRlZCBieVxyXG4gICAgLy8gZXhpc3RlbmNlIGZpbHRlciBtaXNtYXRjaGVzLlxyXG4gICAgcmVtb3RlRXZlbnQudGFyZ2V0TWlzbWF0Y2hlcy5mb3JFYWNoKHRhcmdldElkID0+IHtcclxuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gcmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuZ2V0KHRhcmdldElkKTtcclxuICAgICAgICBpZiAoIXRhcmdldERhdGEpIHtcclxuICAgICAgICAgICAgLy8gQSB3YXRjaGVkIHRhcmdldCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5LlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFyIHRoZSByZXN1bWUgdG9rZW4gZm9yIHRoZSB0YXJnZXQsIHNpbmNlIHdlJ3JlIGluIGEga25vd24gbWlzbWF0Y2hcclxuICAgICAgICAvLyBzdGF0ZS5cclxuICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5zZXQodGFyZ2V0SWQsIHRhcmdldERhdGEud2l0aFJlc3VtZVRva2VuKEJ5dGVTdHJpbmcuRU1QVFlfQllURV9TVFJJTkcsIHRhcmdldERhdGEuc25hcHNob3RWZXJzaW9uKSk7XHJcbiAgICAgICAgLy8gQ2F1c2UgYSBoYXJkIHJlc2V0IGJ5IHVud2F0Y2hpbmcgYW5kIHJld2F0Y2hpbmcgaW1tZWRpYXRlbHksIGJ1dFxyXG4gICAgICAgIC8vIGRlbGliZXJhdGVseSBkb24ndCBzZW5kIGEgcmVzdW1lIHRva2VuIHNvIHRoYXQgd2UgZ2V0IGEgZnVsbCB1cGRhdGUuXHJcbiAgICAgICAgc2VuZFVud2F0Y2hSZXF1ZXN0KHJlbW90ZVN0b3JlSW1wbCwgdGFyZ2V0SWQpO1xyXG4gICAgICAgIC8vIE1hcmsgdGhlIHRhcmdldCB3ZSBzZW5kIGFzIGJlaW5nIG9uIGJlaGFsZiBvZiBhbiBleGlzdGVuY2UgZmlsdGVyXHJcbiAgICAgICAgLy8gbWlzbWF0Y2gsIGJ1dCBkb24ndCBhY3R1YWxseSByZXRhaW4gdGhhdCBpbiBsaXN0ZW5UYXJnZXRzLiBUaGlzIGVuc3VyZXNcclxuICAgICAgICAvLyB0aGF0IHdlIGZsYWcgdGhlIGZpcnN0IHJlLWxpc3RlbiB0aGlzIHdheSB3aXRob3V0IGltcGFjdGluZyBmdXR1cmVcclxuICAgICAgICAvLyBsaXN0ZW5zIG9mIHRoaXMgdGFyZ2V0ICh0aGF0IG1pZ2h0IGhhcHBlbiBlLmcuIG9uIHJlY29ubmVjdCkuXHJcbiAgICAgICAgY29uc3QgcmVxdWVzdFRhcmdldERhdGEgPSBuZXcgVGFyZ2V0RGF0YSh0YXJnZXREYXRhLnRhcmdldCwgdGFyZ2V0SWQsIDEgLyogRXhpc3RlbmNlRmlsdGVyTWlzbWF0Y2ggKi8sIHRhcmdldERhdGEuc2VxdWVuY2VOdW1iZXIpO1xyXG4gICAgICAgIHNlbmRXYXRjaFJlcXVlc3QocmVtb3RlU3RvcmVJbXBsLCByZXF1ZXN0VGFyZ2V0RGF0YSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmFwcGx5UmVtb3RlRXZlbnQocmVtb3RlRXZlbnQpO1xyXG59XHJcbi8qKiBIYW5kbGVzIGFuIGVycm9yIG9uIGEgdGFyZ2V0ICovXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVRhcmdldEVycm9yKHJlbW90ZVN0b3JlSW1wbCwgd2F0Y2hDaGFuZ2UpIHtcclxuICAgIGNvbnN0IGVycm9yID0gd2F0Y2hDaGFuZ2UuY2F1c2U7XHJcbiAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIHdhdGNoQ2hhbmdlLnRhcmdldElkcykge1xyXG4gICAgICAgIC8vIEEgd2F0Y2hlZCB0YXJnZXQgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWQgYWxyZWFkeS5cclxuICAgICAgICBpZiAocmVtb3RlU3RvcmVJbXBsLmxpc3RlblRhcmdldHMuaGFzKHRhcmdldElkKSkge1xyXG4gICAgICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLnJlamVjdExpc3Rlbih0YXJnZXRJZCwgZXJyb3IpO1xyXG4gICAgICAgICAgICByZW1vdGVTdG9yZUltcGwubGlzdGVuVGFyZ2V0cy5kZWxldGUodGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICByZW1vdGVTdG9yZUltcGwud2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yLnJlbW92ZVRhcmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBmaWxsIG91ciB3cml0ZSBwaXBlbGluZSB3aXRoIHdyaXRlcyBmcm9tIHRoZSBMb2NhbFN0b3JlLlxyXG4gKlxyXG4gKiBDYWxsZWQgaW50ZXJuYWxseSB0byBib290c3RyYXAgb3IgcmVmaWxsIHRoZSB3cml0ZSBwaXBlbGluZSBhbmQgYnlcclxuICogU3luY0VuZ2luZSB3aGVuZXZlciB0aGVyZSBhcmUgbmV3IG11dGF0aW9ucyB0byBwcm9jZXNzLlxyXG4gKlxyXG4gKiBTdGFydHMgdGhlIHdyaXRlIHN0cmVhbSBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBmaWxsV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZSkge1xyXG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcclxuICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIGxldCBsYXN0QmF0Y2hJZFJldHJpZXZlZCA9IHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA+IDBcclxuICAgICAgICA/IHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lW3JlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCAtIDFdXHJcbiAgICAgICAgICAgIC5iYXRjaElkXHJcbiAgICAgICAgOiBCQVRDSElEX1VOS05PV047XHJcbiAgICB3aGlsZSAoY2FuQWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IGF3YWl0IGxvY2FsU3RvcmVHZXROZXh0TXV0YXRpb25CYXRjaChyZW1vdGVTdG9yZUltcGwubG9jYWxTdG9yZSwgbGFzdEJhdGNoSWRSZXRyaWV2ZWQpO1xyXG4gICAgICAgICAgICBpZiAoYmF0Y2ggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVN0cmVhbS5tYXJrSWRsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0QmF0Y2hJZFJldHJpZXZlZCA9IGJhdGNoLmJhdGNoSWQ7XHJcbiAgICAgICAgICAgICAgICBhZGRUb1dyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsLCBiYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtVbnRpbFJlY292ZXJ5KHJlbW90ZVN0b3JlSW1wbCwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNob3VsZFN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSkge1xyXG4gICAgICAgIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHdlIGNhbiBhZGQgdG8gdGhlIHdyaXRlIHBpcGVsaW5lIChpLmUuIHRoZSBuZXR3b3JrIGlzXHJcbiAqIGVuYWJsZWQgYW5kIHRoZSB3cml0ZSBwaXBlbGluZSBpcyBub3QgZnVsbCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBjYW5BZGRUb1dyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICByZXR1cm4gKGNhblVzZU5ldHdvcmsocmVtb3RlU3RvcmVJbXBsKSAmJlxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA8IE1BWF9QRU5ESU5HX1dSSVRFUyk7XHJcbn1cclxuLyoqXHJcbiAqIFF1ZXVlcyBhZGRpdGlvbmFsIHdyaXRlcyB0byBiZSBzZW50IHRvIHRoZSB3cml0ZSBzdHJlYW0sIHNlbmRpbmcgdGhlbVxyXG4gKiBpbW1lZGlhdGVseSBpZiB0aGUgd3JpdGUgc3RyZWFtIGlzIGVzdGFibGlzaGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkVG9Xcml0ZVBpcGVsaW5lKHJlbW90ZVN0b3JlSW1wbCwgYmF0Y2gpIHtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLnB1c2goYmF0Y2gpO1xyXG4gICAgY29uc3Qgd3JpdGVTdHJlYW0gPSBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgaWYgKHdyaXRlU3RyZWFtLmlzT3BlbigpICYmIHdyaXRlU3RyZWFtLmhhbmRzaGFrZUNvbXBsZXRlKSB7XHJcbiAgICAgICAgd3JpdGVTdHJlYW0ud3JpdGVNdXRhdGlvbnMoYmF0Y2gubXV0YXRpb25zKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzaG91bGRTdGFydFdyaXRlU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgcmV0dXJuIChjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCkgJiZcclxuICAgICAgICAhZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5pc1N0YXJ0ZWQoKSAmJlxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLmxlbmd0aCA+IDApO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0V3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpLnN0YXJ0KCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZVN0cmVhbU9wZW4ocmVtb3RlU3RvcmVJbXBsKSB7XHJcbiAgICBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpLndyaXRlSGFuZHNoYWtlKCk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gb25Xcml0ZUhhbmRzaGFrZUNvbXBsZXRlKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgY29uc3Qgd3JpdGVTdHJlYW0gPSBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgLy8gU2VuZCB0aGUgd3JpdGUgcGlwZWxpbmUgbm93IHRoYXQgdGhlIHN0cmVhbSBpcyBlc3RhYmxpc2hlZC5cclxuICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUpIHtcclxuICAgICAgICB3cml0ZVN0cmVhbS53cml0ZU11dGF0aW9ucyhiYXRjaC5tdXRhdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIG9uTXV0YXRpb25SZXN1bHQocmVtb3RlU3RvcmVJbXBsLCBjb21taXRWZXJzaW9uLCByZXN1bHRzKSB7XHJcbiAgICBjb25zdCBiYXRjaCA9IHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lLnNoaWZ0KCk7XHJcbiAgICBjb25zdCBzdWNjZXNzID0gTXV0YXRpb25CYXRjaFJlc3VsdC5mcm9tKGJhdGNoLCBjb21taXRWZXJzaW9uLCByZXN1bHRzKTtcclxuICAgIGF3YWl0IGV4ZWN1dGVXaXRoUmVjb3ZlcnkocmVtb3RlU3RvcmVJbXBsLCAoKSA9PiByZW1vdGVTdG9yZUltcGwucmVtb3RlU3luY2VyLmFwcGx5U3VjY2Vzc2Z1bFdyaXRlKHN1Y2Nlc3MpKTtcclxuICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB3aXRoIHRoZSBjb21wbGV0aW9uIG9mIHRoaXMgbXV0YXRpb24gYW5vdGhlclxyXG4gICAgLy8gc2xvdCBoYXMgZnJlZWQgdXAuXHJcbiAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIG9uV3JpdGVTdHJlYW1DbG9zZShyZW1vdGVTdG9yZUltcGwsIGVycm9yKSB7XHJcbiAgICAvLyBJZiB0aGUgd3JpdGUgc3RyZWFtIGNsb3NlZCBhZnRlciB0aGUgd3JpdGUgaGFuZHNoYWtlIGNvbXBsZXRlcywgYSB3cml0ZVxyXG4gICAgLy8gb3BlcmF0aW9uIGZhaWxlZCBhbmQgd2UgZmFpbCB0aGUgcGVuZGluZyBvcGVyYXRpb24uXHJcbiAgICBpZiAoZXJyb3IgJiYgZW5zdXJlV3JpdGVTdHJlYW0ocmVtb3RlU3RvcmVJbXBsKS5oYW5kc2hha2VDb21wbGV0ZSkge1xyXG4gICAgICAgIC8vIFRoaXMgZXJyb3IgYWZmZWN0cyB0aGUgYWN0dWFsIHdyaXRlLlxyXG4gICAgICAgIGF3YWl0IGhhbmRsZVdyaXRlRXJyb3IocmVtb3RlU3RvcmVJbXBsLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgd3JpdGUgc3RyZWFtIG1pZ2h0IGhhdmUgYmVlbiBzdGFydGVkIGJ5IHJlZmlsbGluZyB0aGUgd3JpdGVcclxuICAgIC8vIHBpcGVsaW5lIGZvciBmYWlsZWQgd3JpdGVzXHJcbiAgICBpZiAoc2hvdWxkU3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XHJcbiAgICAgICAgc3RhcnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdyaXRlRXJyb3IocmVtb3RlU3RvcmVJbXBsLCBlcnJvcikge1xyXG4gICAgLy8gT25seSBoYW5kbGUgcGVybWFuZW50IGVycm9ycyBoZXJlLiBJZiBpdCdzIHRyYW5zaWVudCwganVzdCBsZXQgdGhlIHJldHJ5XHJcbiAgICAvLyBsb2dpYyBraWNrIGluLlxyXG4gICAgaWYgKGlzUGVybWFuZW50V3JpdGVFcnJvcihlcnJvci5jb2RlKSkge1xyXG4gICAgICAgIC8vIFRoaXMgd2FzIGEgcGVybWFuZW50IGVycm9yLCB0aGUgcmVxdWVzdCBpdHNlbGYgd2FzIHRoZSBwcm9ibGVtXHJcbiAgICAgICAgLy8gc28gaXQncyBub3QgZ29pbmcgdG8gc3VjY2VlZCBpZiB3ZSByZXNlbmQgaXQuXHJcbiAgICAgICAgY29uc3QgYmF0Y2ggPSByZW1vdGVTdG9yZUltcGwud3JpdGVQaXBlbGluZS5zaGlmdCgpO1xyXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSBpdCdzIGFsc28gdW5saWtlbHkgdGhhdCB0aGUgc2VydmVyIGl0c2VsZiBpcyBtZWx0aW5nXHJcbiAgICAgICAgLy8gZG93biAtLSB0aGlzIHdhcyBqdXN0IGEgYmFkIHJlcXVlc3Qgc28gaW5oaWJpdCBiYWNrb2ZmIG9uIHRoZSBuZXh0XHJcbiAgICAgICAgLy8gcmVzdGFydC5cclxuICAgICAgICBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpLmluaGliaXRCYWNrb2ZmKCk7XHJcbiAgICAgICAgYXdhaXQgZXhlY3V0ZVdpdGhSZWNvdmVyeShyZW1vdGVTdG9yZUltcGwsICgpID0+IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIucmVqZWN0RmFpbGVkV3JpdGUoYmF0Y2guYmF0Y2hJZCwgZXJyb3IpKTtcclxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgd2l0aCB0aGUgY29tcGxldGlvbiBvZiB0aGlzIG11dGF0aW9uXHJcbiAgICAgICAgLy8gYW5vdGhlciBzbG90IGhhcyBmcmVlZCB1cC5cclxuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlc3RhcnROZXR3b3JrKHJlbW90ZVN0b3JlKSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuYWRkKDQgLyogQ29ubmVjdGl2aXR5Q2hhbmdlICovKTtcclxuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIFVua25vd24gKi8pO1xyXG4gICAgcmVtb3RlU3RvcmVJbXBsLm9mZmxpbmVDYXVzZXMuZGVsZXRlKDQgLyogQ29ubmVjdGl2aXR5Q2hhbmdlICovKTtcclxuICAgIGF3YWl0IGVuYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlbW90ZVN0b3JlSGFuZGxlQ3JlZGVudGlhbENoYW5nZShyZW1vdGVTdG9yZSwgdXNlcikge1xyXG4gICAgY29uc3QgcmVtb3RlU3RvcmVJbXBsID0gZGVidWdDYXN0KHJlbW90ZVN0b3JlKTtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC5hc3luY1F1ZXVlLnZlcmlmeU9wZXJhdGlvbkluUHJvZ3Jlc3MoKTtcclxuICAgIGxvZ0RlYnVnKExPR19UQUckNSwgJ1JlbW90ZVN0b3JlIHJlY2VpdmVkIG5ldyBjcmVkZW50aWFscycpO1xyXG4gICAgY29uc3QgdXNlc05ldHdvcmsgPSBjYW5Vc2VOZXR3b3JrKHJlbW90ZVN0b3JlSW1wbCk7XHJcbiAgICAvLyBUZWFyIGRvd24gYW5kIHJlLWNyZWF0ZSBvdXIgbmV0d29yayBzdHJlYW1zLiBUaGlzIHdpbGwgZW5zdXJlIHdlIGdldCBhXHJcbiAgICAvLyBmcmVzaCBhdXRoIHRva2VuIGZvciB0aGUgbmV3IHVzZXIgYW5kIHJlLWZpbGwgdGhlIHdyaXRlIHBpcGVsaW5lIHdpdGhcclxuICAgIC8vIG5ldyBtdXRhdGlvbnMgZnJvbSB0aGUgTG9jYWxTdG9yZSAoc2luY2UgbXV0YXRpb25zIGFyZSBwZXItdXNlcikuXHJcbiAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMyAvKiBDcmVkZW50aWFsQ2hhbmdlICovKTtcclxuICAgIGF3YWl0IGRpc2FibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIGlmICh1c2VzTmV0d29yaykge1xyXG4gICAgICAgIC8vIERvbid0IHNldCB0aGUgbmV0d29yayBzdGF0dXMgdG8gVW5rbm93biBpZiB3ZSBhcmUgb2ZmbGluZS5cclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25saW5lU3RhdGVUcmFja2VyLnNldChcIlVua25vd25cIiAvKiBVbmtub3duICovKTtcclxuICAgIH1cclxuICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC5yZW1vdGVTeW5jZXIuaGFuZGxlQ3JlZGVudGlhbENoYW5nZSh1c2VyKTtcclxuICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgzIC8qIENyZWRlbnRpYWxDaGFuZ2UgKi8pO1xyXG4gICAgYXdhaXQgZW5hYmxlTmV0d29ya0ludGVybmFsKHJlbW90ZVN0b3JlSW1wbCk7XHJcbn1cclxuLyoqXHJcbiAqIFRvZ2dsZXMgdGhlIG5ldHdvcmsgc3RhdGUgd2hlbiB0aGUgY2xpZW50IGdhaW5zIG9yIGxvc2VzIGl0cyBwcmltYXJ5IGxlYXNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVtb3RlU3RvcmVBcHBseVByaW1hcnlTdGF0ZShyZW1vdGVTdG9yZSwgaXNQcmltYXJ5KSB7XHJcbiAgICBjb25zdCByZW1vdGVTdG9yZUltcGwgPSBkZWJ1Z0Nhc3QocmVtb3RlU3RvcmUpO1xyXG4gICAgaWYgKGlzUHJpbWFyeSkge1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vZmZsaW5lQ2F1c2VzLmRlbGV0ZSgyIC8qIElzU2Vjb25kYXJ5ICovKTtcclxuICAgICAgICBhd2FpdCBlbmFibGVOZXR3b3JrSW50ZXJuYWwocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFpc1ByaW1hcnkpIHtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub2ZmbGluZUNhdXNlcy5hZGQoMiAvKiBJc1NlY29uZGFyeSAqLyk7XHJcbiAgICAgICAgYXdhaXQgZGlzYWJsZU5ldHdvcmtJbnRlcm5hbChyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbmxpbmVTdGF0ZVRyYWNrZXIuc2V0KFwiVW5rbm93blwiIC8qIFVua25vd24gKi8pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJZiBub3QgeWV0IGluaXRpYWxpemVkLCByZWdpc3RlcnMgdGhlIFdhdGNoU3RyZWFtIGFuZCBpdHMgbmV0d29yayBzdGF0ZVxyXG4gKiBjYWxsYmFjayB3aXRoIGByZW1vdGVTdG9yZUltcGxgLiBSZXR1cm5zIHRoZSBleGlzdGluZyBzdHJlYW0gaWYgb25lIGlzXHJcbiAqIGFscmVhZHkgYXZhaWxhYmxlLlxyXG4gKlxyXG4gKiBQT1JUSU5HIE5PVEU6IE9uIGlPUyBhbmQgQW5kcm9pZCwgdGhlIFdhdGNoU3RyZWFtIGdldHMgcmVnaXN0ZXJlZCBvbiBzdGFydHVwLlxyXG4gKiBUaGlzIGlzIG5vdCBkb25lIG9uIFdlYiB0byBhbGxvdyBpdCB0byBiZSB0cmVlLXNoYWtlbi5cclxuICovXHJcbmZ1bmN0aW9uIGVuc3VyZVdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbCkge1xyXG4gICAgaWYgKCFyZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0pIHtcclxuICAgICAgICAvLyBDcmVhdGUgc3RyZWFtIChidXQgbm90ZSB0aGF0IGl0IGlzIG5vdCBzdGFydGVkIHlldCkuXHJcbiAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoU3RyZWFtID0gbmV3UGVyc2lzdGVudFdhdGNoU3RyZWFtKHJlbW90ZVN0b3JlSW1wbC5kYXRhc3RvcmUsIHJlbW90ZVN0b3JlSW1wbC5hc3luY1F1ZXVlLCB7XHJcbiAgICAgICAgICAgIG9uT3Blbjogb25XYXRjaFN0cmVhbU9wZW4uYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxyXG4gICAgICAgICAgICBvbkNsb3NlOiBvbldhdGNoU3RyZWFtQ2xvc2UuYmluZChudWxsLCByZW1vdGVTdG9yZUltcGwpLFxyXG4gICAgICAgICAgICBvbldhdGNoQ2hhbmdlOiBvbldhdGNoU3RyZWFtQ2hhbmdlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC5vbk5ldHdvcmtTdGF0dXNDaGFuZ2UucHVzaChhc3luYyAoZW5hYmxlZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLndhdGNoU3RyZWFtLmluaGliaXRCYWNrb2ZmKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRXYXRjaFN0cmVhbShyZW1vdGVTdG9yZUltcGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU3RvcmVJbXBsLm9ubGluZVN0YXRlVHJhY2tlci5zZXQoXCJVbmtub3duXCIgLyogVW5rbm93biAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUltcGwud2F0Y2hTdHJlYW0uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgY2xlYW5VcFdhdGNoU3RyZWFtU3RhdGUocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW90ZVN0b3JlSW1wbC53YXRjaFN0cmVhbTtcclxufVxyXG4vKipcclxuICogSWYgbm90IHlldCBpbml0aWFsaXplZCwgcmVnaXN0ZXJzIHRoZSBXcml0ZVN0cmVhbSBhbmQgaXRzIG5ldHdvcmsgc3RhdGVcclxuICogY2FsbGJhY2sgd2l0aCBgcmVtb3RlU3RvcmVJbXBsYC4gUmV0dXJucyB0aGUgZXhpc3Rpbmcgc3RyZWFtIGlmIG9uZSBpc1xyXG4gKiBhbHJlYWR5IGF2YWlsYWJsZS5cclxuICpcclxuICogUE9SVElORyBOT1RFOiBPbiBpT1MgYW5kIEFuZHJvaWQsIHRoZSBXcml0ZVN0cmVhbSBnZXRzIHJlZ2lzdGVyZWQgb24gc3RhcnR1cC5cclxuICogVGhpcyBpcyBub3QgZG9uZSBvbiBXZWIgdG8gYWxsb3cgaXQgdG8gYmUgdHJlZS1zaGFrZW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBlbnN1cmVXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwpIHtcclxuICAgIGlmICghcmVtb3RlU3RvcmVJbXBsLndyaXRlU3RyZWFtKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIHN0cmVhbSAoYnV0IG5vdGUgdGhhdCBpdCBpcyBub3Qgc3RhcnRlZCB5ZXQpLlxyXG4gICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbSA9IG5ld1BlcnNpc3RlbnRXcml0ZVN0cmVhbShyZW1vdGVTdG9yZUltcGwuZGF0YXN0b3JlLCByZW1vdGVTdG9yZUltcGwuYXN5bmNRdWV1ZSwge1xyXG4gICAgICAgICAgICBvbk9wZW46IG9uV3JpdGVTdHJlYW1PcGVuLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25DbG9zZTogb25Xcml0ZVN0cmVhbUNsb3NlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25IYW5kc2hha2VDb21wbGV0ZTogb25Xcml0ZUhhbmRzaGFrZUNvbXBsZXRlLmJpbmQobnVsbCwgcmVtb3RlU3RvcmVJbXBsKSxcclxuICAgICAgICAgICAgb25NdXRhdGlvblJlc3VsdDogb25NdXRhdGlvblJlc3VsdC5iaW5kKG51bGwsIHJlbW90ZVN0b3JlSW1wbClcclxuICAgICAgICB9KTtcclxuICAgICAgICByZW1vdGVTdG9yZUltcGwub25OZXR3b3JrU3RhdHVzQ2hhbmdlLnB1c2goYXN5bmMgKGVuYWJsZWQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbS5pbmhpYml0QmFja29mZigpO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHN0YXJ0IHRoZSB3cml0ZSBzdHJlYW0gaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUocmVtb3RlU3RvcmVJbXBsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlSW1wbC53cml0ZVN0cmVhbS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckNSwgYFN0b3BwaW5nIHdyaXRlIHN0cmVhbSB3aXRoICR7cmVtb3RlU3RvcmVJbXBsLndyaXRlUGlwZWxpbmUubGVuZ3RofSBwZW5kaW5nIHdyaXRlc2ApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlSW1wbC53cml0ZVBpcGVsaW5lID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZW1vdGVTdG9yZUltcGwud3JpdGVTdHJlYW07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9HX1RBRyQ0ID0gJ0FzeW5jUXVldWUnO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBvcGVyYXRpb24gc2NoZWR1bGVkIHRvIGJlIHJ1biBpbiB0aGUgZnV0dXJlIG9uIGFuIEFzeW5jUXVldWUuXHJcbiAqXHJcbiAqIEl0IGlzIGNyZWF0ZWQgdmlhIERlbGF5ZWRPcGVyYXRpb24uY3JlYXRlQW5kU2NoZWR1bGUoKS5cclxuICpcclxuICogU3VwcG9ydHMgY2FuY2VsbGF0aW9uICh2aWEgY2FuY2VsKCkpIGFuZCBlYXJseSBleGVjdXRpb24gKHZpYSBza2lwRGVsYXkoKSkuXHJcbiAqXHJcbiAqIE5vdGU6IFdlIGltcGxlbWVudCBgUHJvbWlzZUxpa2VgIGluc3RlYWQgb2YgYFByb21pc2VgLCBhcyB0aGUgYFByb21pc2VgIHR5cGVcclxuICogaW4gbmV3ZXIgdmVyc2lvbnMgb2YgVHlwZVNjcmlwdCBkZWZpbmVzIGBmaW5hbGx5YCwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpblxyXG4gKiBJRS5cclxuICovXHJcbmNsYXNzIERlbGF5ZWRPcGVyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoYXN5bmNRdWV1ZSwgdGltZXJJZCwgdGFyZ2V0VGltZU1zLCBvcCwgcmVtb3ZhbENhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcclxuICAgICAgICB0aGlzLnRpbWVySWQgPSB0aW1lcklkO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0VGltZU1zID0gdGFyZ2V0VGltZU1zO1xyXG4gICAgICAgIHRoaXMub3AgPSBvcDtcclxuICAgICAgICB0aGlzLnJlbW92YWxDYWxsYmFjayA9IHJlbW92YWxDYWxsYmFjaztcclxuICAgICAgICB0aGlzLmRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy50aGVuID0gdGhpcy5kZWZlcnJlZC5wcm9taXNlLnRoZW4uYmluZCh0aGlzLmRlZmVycmVkLnByb21pc2UpO1xyXG4gICAgICAgIC8vIEl0J3Mgbm9ybWFsIGZvciB0aGUgZGVmZXJyZWQgcHJvbWlzZSB0byBiZSBjYW5jZWxlZCAoZHVlIHRvIGNhbmNlbGxhdGlvbilcclxuICAgICAgICAvLyBhbmQgc28gd2UgYXR0YWNoIGEgZHVtbXkgY2F0Y2ggY2FsbGJhY2sgdG8gYXZvaWRcclxuICAgICAgICAvLyAnVW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbldhcm5pbmcnIGxvZyBzcGFtLlxyXG4gICAgICAgIHRoaXMuZGVmZXJyZWQucHJvbWlzZS5jYXRjaChlcnIgPT4geyB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIERlbGF5ZWRPcGVyYXRpb24gdGhhdCBoYXMgYmVlbiBzY2hlZHVsZWQgdG8gYmVcclxuICAgICAqIGV4ZWN1dGVkIG9uIHRoZSBwcm92aWRlZCBhc3luY1F1ZXVlIGFmdGVyIHRoZSBwcm92aWRlZCBkZWxheU1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhc3luY1F1ZXVlIC0gVGhlIHF1ZXVlIHRvIHNjaGVkdWxlIHRoZSBvcGVyYXRpb24gb24uXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBBIFRpbWVyIElEIGlkZW50aWZ5aW5nIHRoZSB0eXBlIG9mIG9wZXJhdGlvbiB0aGlzIGlzLlxyXG4gICAgICogQHBhcmFtIGRlbGF5TXMgLSBUaGUgZGVsYXkgKG1zKSBiZWZvcmUgdGhlIG9wZXJhdGlvbiBzaG91bGQgYmUgc2NoZWR1bGVkLlxyXG4gICAgICogQHBhcmFtIG9wIC0gVGhlIG9wZXJhdGlvbiB0byBydW4uXHJcbiAgICAgKiBAcGFyYW0gcmVtb3ZhbENhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBvbmNlIHRoZVxyXG4gICAgICogICBvcGVyYXRpb24gaXMgZXhlY3V0ZWQgb3IgY2FuY2VsZWQsIG5vdGlmeWluZyB0aGUgQXN5bmNRdWV1ZSB0byByZW1vdmUgaXRcclxuICAgICAqICAgZnJvbSBpdHMgZGVsYXllZE9wZXJhdGlvbnMgbGlzdC5cclxuICAgICAqICAgUE9SVElORyBOT1RFOiBUaGlzIGV4aXN0cyB0byBwcmV2ZW50IG1ha2luZyByZW1vdmVEZWxheWVkT3BlcmF0aW9uKCkgYW5kXHJcbiAgICAgKiAgIHRoZSBEZWxheWVkT3BlcmF0aW9uIGNsYXNzIHB1YmxpYy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUFuZFNjaGVkdWxlKGFzeW5jUXVldWUsIHRpbWVySWQsIGRlbGF5TXMsIG9wLCByZW1vdmFsQ2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRUaW1lID0gRGF0ZS5ub3coKSArIGRlbGF5TXM7XHJcbiAgICAgICAgY29uc3QgZGVsYXllZE9wID0gbmV3IERlbGF5ZWRPcGVyYXRpb24oYXN5bmNRdWV1ZSwgdGltZXJJZCwgdGFyZ2V0VGltZSwgb3AsIHJlbW92YWxDYWxsYmFjayk7XHJcbiAgICAgICAgZGVsYXllZE9wLnN0YXJ0KGRlbGF5TXMpO1xyXG4gICAgICAgIHJldHVybiBkZWxheWVkT3A7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgdGltZXIuIFRoaXMgaXMgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGNvbnN0cnVjdGlvbiBieVxyXG4gICAgICogY3JlYXRlQW5kU2NoZWR1bGUoKS5cclxuICAgICAqL1xyXG4gICAgc3RhcnQoZGVsYXlNcykge1xyXG4gICAgICAgIHRoaXMudGltZXJIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGFuZGxlRGVsYXlFbGFwc2VkKCksIGRlbGF5TXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBRdWV1ZXMgdGhlIG9wZXJhdGlvbiB0byBydW4gaW1tZWRpYXRlbHkgKGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gcnVuIG9yXHJcbiAgICAgKiBjYW5jZWxlZCkuXHJcbiAgICAgKi9cclxuICAgIHNraXBEZWxheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEZWxheUVsYXBzZWQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyB0aGUgb3BlcmF0aW9uIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQgb3IgY2FuY2VsZWQuIFRoZVxyXG4gICAgICogcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkLlxyXG4gICAgICpcclxuICAgICAqIEFzIGxvbmcgYXMgdGhlIG9wZXJhdGlvbiBoYXMgbm90IHlldCBiZWVuIHJ1biwgY2FsbGluZyBjYW5jZWwoKSBwcm92aWRlcyBhXHJcbiAgICAgKiBndWFyYW50ZWUgdGhhdCB0aGUgb3BlcmF0aW9uIHdpbGwgbm90IGJlIHJ1bi5cclxuICAgICAqL1xyXG4gICAgY2FuY2VsKHJlYXNvbikge1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVySGFuZGxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkNBTkNFTExFRCwgJ09wZXJhdGlvbiBjYW5jZWxsZWQnICsgKHJlYXNvbiA/ICc6ICcgKyByZWFzb24gOiAnJykpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVEZWxheUVsYXBzZWQoKSB7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lckhhbmRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wKCkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbGVhclRpbWVvdXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZXJIYW5kbGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmFsQ2FsbGJhY2sodGhpcyk7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy50aW1lckhhbmRsZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgRmlyZXN0b3JlRXJyb3IgdGhhdCBjYW4gYmUgc3VyZmFjZWQgdG8gdGhlIHVzZXIgaWYgdGhlIHByb3ZpZGVkXHJcbiAqIGVycm9yIGlzIGFuIEluZGV4ZWREYlRyYW5zYWN0aW9uRXJyb3IuIFJlLXRocm93cyB0aGUgZXJyb3Igb3RoZXJ3aXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBtc2cpIHtcclxuICAgIGxvZ0Vycm9yKExPR19UQUckNCwgYCR7bXNnfTogJHtlfWApO1xyXG4gICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTkFWQUlMQUJMRSwgYCR7bXNnfTogJHtlfWApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG9jdW1lbnRTZXQgaXMgYW4gaW1tdXRhYmxlIChjb3B5LW9uLXdyaXRlKSBjb2xsZWN0aW9uIHRoYXQgaG9sZHMgZG9jdW1lbnRzXHJcbiAqIGluIG9yZGVyIHNwZWNpZmllZCBieSB0aGUgcHJvdmlkZWQgY29tcGFyYXRvci4gV2UgYWx3YXlzIGFkZCBhIGRvY3VtZW50IGtleVxyXG4gKiBjb21wYXJhdG9yIG9uIHRvcCBvZiB3aGF0IGlzIHByb3ZpZGVkIHRvIGd1YXJhbnRlZSBkb2N1bWVudCBlcXVhbGl0eSBiYXNlZCBvblxyXG4gKiB0aGUga2V5LlxyXG4gKi9cclxuY2xhc3MgRG9jdW1lbnRTZXQge1xyXG4gICAgLyoqIFRoZSBkZWZhdWx0IG9yZGVyaW5nIGlzIGJ5IGtleSBpZiB0aGUgY29tcGFyYXRvciBpcyBvbWl0dGVkICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wKSB7XHJcbiAgICAgICAgLy8gV2UgYXJlIGFkZGluZyBkb2N1bWVudCBrZXkgY29tcGFyYXRvciB0byB0aGUgZW5kIGFzIGl0J3MgdGhlIG9ubHlcclxuICAgICAgICAvLyBndWFyYW50ZWVkIHVuaXF1ZSBwcm9wZXJ0eSBvZiBhIGRvY3VtZW50LlxyXG4gICAgICAgIGlmIChjb21wKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGFyYXRvciA9IChkMSwgZDIpID0+IGNvbXAoZDEsIGQyKSB8fCBEb2N1bWVudEtleS5jb21wYXJhdG9yKGQxLmtleSwgZDIua2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGFyYXRvciA9IChkMSwgZDIpID0+IERvY3VtZW50S2V5LmNvbXBhcmF0b3IoZDEua2V5LCBkMi5rZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmtleWVkTWFwID0gZG9jdW1lbnRNYXAoKTtcclxuICAgICAgICB0aGlzLnNvcnRlZFNldCA9IG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSBjb3B5IG9mIHRoZSBleGlzdGluZyBEb2N1bWVudFNldCwgdXNpbmcgdGhlIHNhbWVcclxuICAgICAqIGNvbXBhcmF0b3IuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBlbXB0eVNldChvbGRTZXQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50U2V0KG9sZFNldC5jb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIGhhcyhrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXllZE1hcC5nZXQoa2V5KSAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmtleWVkTWFwLmdldChrZXkpO1xyXG4gICAgfVxyXG4gICAgZmlyc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydGVkU2V0Lm1pbktleSgpO1xyXG4gICAgfVxyXG4gICAgbGFzdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZWRTZXQubWF4S2V5KCk7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlZFNldC5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBwcm92aWRlZCBrZXkgaW4gdGhlIGRvY3VtZW50IHNldCwgb3IgLTEgaWYgdGhlXHJcbiAgICAgKiBkb2N1bWVudCBrZXkgaXMgbm90IHByZXNlbnQgaW4gdGhlIHNldDtcclxuICAgICAqL1xyXG4gICAgaW5kZXhPZihrZXkpIHtcclxuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmtleWVkTWFwLmdldChrZXkpO1xyXG4gICAgICAgIHJldHVybiBkb2MgPyB0aGlzLnNvcnRlZFNldC5pbmRleE9mKGRvYykgOiAtMTtcclxuICAgIH1cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRlZFNldC5zaXplO1xyXG4gICAgfVxyXG4gICAgLyoqIEl0ZXJhdGVzIGRvY3VtZW50cyBpbiBvcmRlciBkZWZpbmVkIGJ5IFwiY29tcGFyYXRvclwiICovXHJcbiAgICBmb3JFYWNoKGNiKSB7XHJcbiAgICAgICAgdGhpcy5zb3J0ZWRTZXQuaW5vcmRlclRyYXZlcnNhbCgoaywgdikgPT4ge1xyXG4gICAgICAgICAgICBjYihrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEluc2VydHMgb3IgdXBkYXRlcyBhIGRvY3VtZW50IHdpdGggdGhlIHNhbWUga2V5ICovXHJcbiAgICBhZGQoZG9jKSB7XHJcbiAgICAgICAgLy8gRmlyc3QgcmVtb3ZlIHRoZSBlbGVtZW50IGlmIHdlIGhhdmUgaXQuXHJcbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5kZWxldGUoZG9jLmtleSk7XHJcbiAgICAgICAgcmV0dXJuIHNldC5jb3B5KHNldC5rZXllZE1hcC5pbnNlcnQoZG9jLmtleSwgZG9jKSwgc2V0LnNvcnRlZFNldC5pbnNlcnQoZG9jLCBudWxsKSk7XHJcbiAgICB9XHJcbiAgICAvKiogRGVsZXRlcyBhIGRvY3VtZW50IHdpdGggYSBnaXZlbiBrZXkgKi9cclxuICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICBjb25zdCBkb2MgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghZG9jKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMua2V5ZWRNYXAucmVtb3ZlKGtleSksIHRoaXMuc29ydGVkU2V0LnJlbW92ZShkb2MpKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIERvY3VtZW50U2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNpemUgIT09IG90aGVyLnNpemUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aGlzSXQgPSB0aGlzLnNvcnRlZFNldC5nZXRJdGVyYXRvcigpO1xyXG4gICAgICAgIGNvbnN0IG90aGVySXQgPSBvdGhlci5zb3J0ZWRTZXQuZ2V0SXRlcmF0b3IoKTtcclxuICAgICAgICB3aGlsZSAodGhpc0l0Lmhhc05leHQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0aGlzRG9jID0gdGhpc0l0LmdldE5leHQoKS5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IG90aGVyRG9jID0gb3RoZXJJdC5nZXROZXh0KCkua2V5O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXNEb2MuaXNFcXVhbChvdGhlckRvYykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IGRvY1N0cmluZ3MgPSBbXTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgZG9jU3RyaW5ncy5wdXNoKGRvYy50b1N0cmluZygpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZG9jU3RyaW5ncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICdEb2N1bWVudFNldCAoKSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0RvY3VtZW50U2V0IChcXG4gICcgKyBkb2NTdHJpbmdzLmpvaW4oJyAgXFxuJykgKyAnXFxuKSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29weShrZXllZE1hcCwgc29ydGVkU2V0KSB7XHJcbiAgICAgICAgY29uc3QgbmV3U2V0ID0gbmV3IERvY3VtZW50U2V0KCk7XHJcbiAgICAgICAgbmV3U2V0LmNvbXBhcmF0b3IgPSB0aGlzLmNvbXBhcmF0b3I7XHJcbiAgICAgICAgbmV3U2V0LmtleWVkTWFwID0ga2V5ZWRNYXA7XHJcbiAgICAgICAgbmV3U2V0LnNvcnRlZFNldCA9IHNvcnRlZFNldDtcclxuICAgICAgICByZXR1cm4gbmV3U2V0O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEb2N1bWVudENoYW5nZVNldCBrZWVwcyB0cmFjayBvZiBhIHNldCBvZiBjaGFuZ2VzIHRvIGRvY3MgaW4gYSBxdWVyeSwgbWVyZ2luZ1xyXG4gKiBkdXBsaWNhdGUgZXZlbnRzIGZvciB0aGUgc2FtZSBkb2MuXHJcbiAqL1xyXG5jbGFzcyBEb2N1bWVudENoYW5nZVNldCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICB0cmFjayhjaGFuZ2UpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBjaGFuZ2UuZG9jLmtleTtcclxuICAgICAgICBjb25zdCBvbGRDaGFuZ2UgPSB0aGlzLmNoYW5nZU1hcC5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIW9sZENoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIGNoYW5nZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWVyZ2UgdGhlIG5ldyBjaGFuZ2Ugd2l0aCB0aGUgZXhpc3RpbmcgY2hhbmdlLlxyXG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSAhPT0gMCAvKiBBZGRlZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMyAvKiBNZXRhZGF0YSAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIGNoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAzIC8qIE1ldGFkYXRhICovICYmXHJcbiAgICAgICAgICAgIG9sZENoYW5nZS50eXBlICE9PSAxIC8qIFJlbW92ZWQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBvbGRDaGFuZ2UudHlwZSxcclxuICAgICAgICAgICAgICAgIGRvYzogY2hhbmdlLmRvY1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDIgLyogTW9kaWZpZWQgKi8gJiZcclxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDIgLyogTW9kaWZpZWQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5pbnNlcnQoa2V5LCB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAyIC8qIE1vZGlmaWVkICovLFxyXG4gICAgICAgICAgICAgICAgZG9jOiBjaGFuZ2UuZG9jXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PT0gMiAvKiBNb2RpZmllZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMCAvKiBBZGRlZCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDAgLyogQWRkZWQgKi8sXHJcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAxIC8qIFJlbW92ZWQgKi8gJiZcclxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDAgLyogQWRkZWQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSB0aGlzLmNoYW5nZU1hcC5yZW1vdmUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDEgLyogUmVtb3ZlZCAqLyAmJlxyXG4gICAgICAgICAgICBvbGRDaGFuZ2UudHlwZSA9PT0gMiAvKiBNb2RpZmllZCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDEgLyogUmVtb3ZlZCAqLyxcclxuICAgICAgICAgICAgICAgIGRvYzogb2xkQ2hhbmdlLmRvY1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09IDAgLyogQWRkZWQgKi8gJiZcclxuICAgICAgICAgICAgb2xkQ2hhbmdlLnR5cGUgPT09IDEgLyogUmVtb3ZlZCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcCA9IHRoaXMuY2hhbmdlTWFwLmluc2VydChrZXksIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogTW9kaWZpZWQgKi8sXHJcbiAgICAgICAgICAgICAgICBkb2M6IGNoYW5nZS5kb2NcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIHRoZXNlIGNhc2VzLCB3aGljaCBkb24ndCBtYWtlIHNlbnNlOlxyXG4gICAgICAgICAgICAvLyBBZGRlZC0+QWRkZWRcclxuICAgICAgICAgICAgLy8gUmVtb3ZlZC0+UmVtb3ZlZFxyXG4gICAgICAgICAgICAvLyBNb2RpZmllZC0+QWRkZWRcclxuICAgICAgICAgICAgLy8gUmVtb3ZlZC0+TW9kaWZpZWRcclxuICAgICAgICAgICAgLy8gTWV0YWRhdGEtPkFkZGVkXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZWQtPk1ldGFkYXRhXHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGFuZ2VzKCkge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNoYW5nZU1hcC5pbm9yZGVyVHJhdmVyc2FsKChrZXksIGNoYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2hhbmdlcztcclxuICAgIH1cclxufVxyXG5jbGFzcyBWaWV3U25hcHNob3Qge1xyXG4gICAgY29uc3RydWN0b3IocXVlcnksIGRvY3MsIG9sZERvY3MsIGRvY0NoYW5nZXMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIHN5bmNTdGF0ZUNoYW5nZWQsIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3M7XHJcbiAgICAgICAgdGhpcy5vbGREb2NzID0gb2xkRG9jcztcclxuICAgICAgICB0aGlzLmRvY0NoYW5nZXMgPSBkb2NDaGFuZ2VzO1xyXG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBtdXRhdGVkS2V5cztcclxuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcclxuICAgICAgICB0aGlzLnN5bmNTdGF0ZUNoYW5nZWQgPSBzeW5jU3RhdGVDaGFuZ2VkO1xyXG4gICAgICAgIHRoaXMuZXhjbHVkZXNNZXRhZGF0YUNoYW5nZXMgPSBleGNsdWRlc01ldGFkYXRhQ2hhbmdlcztcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgdmlldyBzbmFwc2hvdCBhcyBpZiBhbGwgZG9jdW1lbnRzIGluIHRoZSBzbmFwc2hvdCB3ZXJlIGFkZGVkLiAqL1xyXG4gICAgc3RhdGljIGZyb21Jbml0aWFsRG9jdW1lbnRzKHF1ZXJ5LCBkb2N1bWVudHMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUpIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XHJcbiAgICAgICAgZG9jdW1lbnRzLmZvckVhY2goZG9jID0+IHtcclxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgdHlwZTogMCAvKiBBZGRlZCAqLywgZG9jIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmlld1NuYXBzaG90KHF1ZXJ5LCBkb2N1bWVudHMsIERvY3VtZW50U2V0LmVtcHR5U2V0KGRvY3VtZW50cyksIGNoYW5nZXMsIG11dGF0ZWRLZXlzLCBmcm9tQ2FjaGUsIFxyXG4gICAgICAgIC8qIHN5bmNTdGF0ZUNoYW5nZWQ9ICovIHRydWUsIFxyXG4gICAgICAgIC8qIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzPSAqLyBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzUGVuZGluZ1dyaXRlcygpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMubXV0YXRlZEtleXMuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmZyb21DYWNoZSAhPT0gb3RoZXIuZnJvbUNhY2hlIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc3luY1N0YXRlQ2hhbmdlZCAhPT0gb3RoZXIuc3luY1N0YXRlQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICAhdGhpcy5tdXRhdGVkS2V5cy5pc0VxdWFsKG90aGVyLm11dGF0ZWRLZXlzKSB8fFxyXG4gICAgICAgICAgICAhcXVlcnlFcXVhbHModGhpcy5xdWVyeSwgb3RoZXIucXVlcnkpIHx8XHJcbiAgICAgICAgICAgICF0aGlzLmRvY3MuaXNFcXVhbChvdGhlci5kb2NzKSB8fFxyXG4gICAgICAgICAgICAhdGhpcy5vbGREb2NzLmlzRXF1YWwob3RoZXIub2xkRG9jcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5kb2NDaGFuZ2VzO1xyXG4gICAgICAgIGNvbnN0IG90aGVyQ2hhbmdlcyA9IG90aGVyLmRvY0NoYW5nZXM7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoICE9PSBvdGhlckNoYW5nZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzW2ldLnR5cGUgIT09IG90aGVyQ2hhbmdlc1tpXS50eXBlIHx8XHJcbiAgICAgICAgICAgICAgICAhY2hhbmdlc1tpXS5kb2MuaXNFcXVhbChvdGhlckNoYW5nZXNbaV0uZG9jKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBIb2xkcyB0aGUgbGlzdGVuZXJzIGFuZCB0aGUgbGFzdCByZWNlaXZlZCBWaWV3U25hcHNob3QgZm9yIGEgcXVlcnkgYmVpbmdcclxuICogdHJhY2tlZCBieSBFdmVudE1hbmFnZXIuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUxpc3RlbmVyc0luZm8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3U25hcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld0V2ZW50TWFuYWdlcigpIHtcclxuICAgIHJldHVybiBuZXcgRXZlbnRNYW5hZ2VySW1wbCgpO1xyXG59XHJcbmNsYXNzIEV2ZW50TWFuYWdlckltcGwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gbmV3IE9iamVjdE1hcChxID0+IGNhbm9uaWZ5UXVlcnkocSksIHF1ZXJ5RXF1YWxzKTtcclxuICAgICAgICB0aGlzLm9ubGluZVN0YXRlID0gXCJVbmtub3duXCIgLyogVW5rbm93biAqLztcclxuICAgICAgICB0aGlzLnNuYXBzaG90c0luU3luY0xpc3RlbmVycyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiBldmVudE1hbmFnZXJMaXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikge1xyXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xyXG4gICAgY29uc3QgcXVlcnkgPSBsaXN0ZW5lci5xdWVyeTtcclxuICAgIGxldCBmaXJzdExpc3RlbiA9IGZhbHNlO1xyXG4gICAgbGV0IHF1ZXJ5SW5mbyA9IGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5nZXQocXVlcnkpO1xyXG4gICAgaWYgKCFxdWVyeUluZm8pIHtcclxuICAgICAgICBmaXJzdExpc3RlbiA9IHRydWU7XHJcbiAgICAgICAgcXVlcnlJbmZvID0gbmV3IFF1ZXJ5TGlzdGVuZXJzSW5mbygpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZpcnN0TGlzdGVuKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcXVlcnlJbmZvLnZpZXdTbmFwID0gYXdhaXQgZXZlbnRNYW5hZ2VySW1wbC5vbkxpc3RlbihxdWVyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgSW5pdGlhbGl6YXRpb24gb2YgcXVlcnkgJyR7c3RyaW5naWZ5UXVlcnkobGlzdGVuZXIucXVlcnkpfScgZmFpbGVkYCk7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyLm9uRXJyb3IoZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLnNldChxdWVyeSwgcXVlcnlJbmZvKTtcclxuICAgIHF1ZXJ5SW5mby5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICAvLyBSdW4gZ2xvYmFsIHNuYXBzaG90IGxpc3RlbmVycyBpZiBhIGNvbnNpc3RlbnQgc25hcHNob3QgaGFzIGJlZW4gZW1pdHRlZC5cclxuICAgIGxpc3RlbmVyLmFwcGx5T25saW5lU3RhdGVDaGFuZ2UoZXZlbnRNYW5hZ2VySW1wbC5vbmxpbmVTdGF0ZSk7XHJcbiAgICBpZiAocXVlcnlJbmZvLnZpZXdTbmFwKSB7XHJcbiAgICAgICAgY29uc3QgcmFpc2VkRXZlbnQgPSBsaXN0ZW5lci5vblZpZXdTbmFwc2hvdChxdWVyeUluZm8udmlld1NuYXApO1xyXG4gICAgICAgIGlmIChyYWlzZWRFdmVudCkge1xyXG4gICAgICAgICAgICByYWlzZVNuYXBzaG90c0luU3luY0V2ZW50KGV2ZW50TWFuYWdlckltcGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiBldmVudE1hbmFnZXJVbmxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKSB7XHJcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XHJcbiAgICBjb25zdCBxdWVyeSA9IGxpc3RlbmVyLnF1ZXJ5O1xyXG4gICAgbGV0IGxhc3RMaXN0ZW4gPSBmYWxzZTtcclxuICAgIGNvbnN0IHF1ZXJ5SW5mbyA9IGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5nZXQocXVlcnkpO1xyXG4gICAgaWYgKHF1ZXJ5SW5mbykge1xyXG4gICAgICAgIGNvbnN0IGkgPSBxdWVyeUluZm8ubGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgICAgcXVlcnlJbmZvLmxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIGxhc3RMaXN0ZW4gPSBxdWVyeUluZm8ubGlzdGVuZXJzLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGFzdExpc3Rlbikge1xyXG4gICAgICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5kZWxldGUocXVlcnkpO1xyXG4gICAgICAgIHJldHVybiBldmVudE1hbmFnZXJJbXBsLm9uVW5saXN0ZW4ocXVlcnkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGV2ZW50TWFuYWdlck9uV2F0Y2hDaGFuZ2UoZXZlbnRNYW5hZ2VyLCB2aWV3U25hcHMpIHtcclxuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcclxuICAgIGxldCByYWlzZWRFdmVudCA9IGZhbHNlO1xyXG4gICAgZm9yIChjb25zdCB2aWV3U25hcCBvZiB2aWV3U25hcHMpIHtcclxuICAgICAgICBjb25zdCBxdWVyeSA9IHZpZXdTbmFwLnF1ZXJ5O1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5SW5mbyA9IGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5nZXQocXVlcnkpO1xyXG4gICAgICAgIGlmIChxdWVyeUluZm8pIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBxdWVyeUluZm8ubGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIub25WaWV3U25hcHNob3Qodmlld1NuYXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHF1ZXJ5SW5mby52aWV3U25hcCA9IHZpZXdTbmFwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyYWlzZWRFdmVudCkge1xyXG4gICAgICAgIHJhaXNlU25hcHNob3RzSW5TeW5jRXZlbnQoZXZlbnRNYW5hZ2VySW1wbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25XYXRjaEVycm9yKGV2ZW50TWFuYWdlciwgcXVlcnksIGVycm9yKSB7XHJcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XHJcbiAgICBjb25zdCBxdWVyeUluZm8gPSBldmVudE1hbmFnZXJJbXBsLnF1ZXJpZXMuZ2V0KHF1ZXJ5KTtcclxuICAgIGlmIChxdWVyeUluZm8pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIub25FcnJvcihlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMuIE5PVEU6IFdlIGRvbid0IG5lZWQgdG8gY2FsbCBzeW5jRW5naW5lLnVubGlzdGVuKClcclxuICAgIC8vIGFmdGVyIGFuIGVycm9yLlxyXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5xdWVyaWVzLmRlbGV0ZShxdWVyeSk7XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRNYW5hZ2VyT25PbmxpbmVTdGF0ZUNoYW5nZShldmVudE1hbmFnZXIsIG9ubGluZVN0YXRlKSB7XHJcbiAgICBjb25zdCBldmVudE1hbmFnZXJJbXBsID0gZGVidWdDYXN0KGV2ZW50TWFuYWdlcik7XHJcbiAgICBldmVudE1hbmFnZXJJbXBsLm9ubGluZVN0YXRlID0gb25saW5lU3RhdGU7XHJcbiAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcclxuICAgIGV2ZW50TWFuYWdlckltcGwucXVlcmllcy5mb3JFYWNoKChfLCBxdWVyeUluZm8pID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHF1ZXJ5SW5mby5saXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgLy8gUnVuIGdsb2JhbCBzbmFwc2hvdCBsaXN0ZW5lcnMgaWYgYSBjb25zaXN0ZW50IHNuYXBzaG90IGhhcyBiZWVuIGVtaXR0ZWQuXHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lci5hcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAocmFpc2VkRXZlbnQpIHtcclxuICAgICAgICByYWlzZVNuYXBzaG90c0luU3luY0V2ZW50KGV2ZW50TWFuYWdlckltcGwpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgb2JzZXJ2ZXIpIHtcclxuICAgIGNvbnN0IGV2ZW50TWFuYWdlckltcGwgPSBkZWJ1Z0Nhc3QoZXZlbnRNYW5hZ2VyKTtcclxuICAgIGV2ZW50TWFuYWdlckltcGwuc25hcHNob3RzSW5TeW5jTGlzdGVuZXJzLmFkZChvYnNlcnZlcik7XHJcbiAgICAvLyBJbW1lZGlhdGVseSBmaXJlIGFuIGluaXRpYWwgZXZlbnQsIGluZGljYXRpbmcgYWxsIGV4aXN0aW5nIGxpc3RlbmVyc1xyXG4gICAgLy8gYXJlIGluLXN5bmMuXHJcbiAgICBvYnNlcnZlci5uZXh0KCk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBvYnNlcnZlcikge1xyXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VySW1wbCA9IGRlYnVnQ2FzdChldmVudE1hbmFnZXIpO1xyXG4gICAgZXZlbnRNYW5hZ2VySW1wbC5zbmFwc2hvdHNJblN5bmNMaXN0ZW5lcnMuZGVsZXRlKG9ic2VydmVyKTtcclxufVxyXG4vLyBDYWxsIGFsbCBnbG9iYWwgc25hcHNob3QgbGlzdGVuZXJzIHRoYXQgaGF2ZSBiZWVuIHNldC5cclxuZnVuY3Rpb24gcmFpc2VTbmFwc2hvdHNJblN5bmNFdmVudChldmVudE1hbmFnZXJJbXBsKSB7XHJcbiAgICBldmVudE1hbmFnZXJJbXBsLnNuYXBzaG90c0luU3luY0xpc3RlbmVycy5mb3JFYWNoKG9ic2VydmVyID0+IHtcclxuICAgICAgICBvYnNlcnZlci5uZXh0KCk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUXVlcnlMaXN0ZW5lciB0YWtlcyBhIHNlcmllcyBvZiBpbnRlcm5hbCB2aWV3IHNuYXBzaG90cyBhbmQgZGV0ZXJtaW5lc1xyXG4gKiB3aGVuIHRvIHJhaXNlIHRoZSBldmVudC5cclxuICpcclxuICogSXQgdXNlcyBhbiBPYnNlcnZlciB0byBkaXNwYXRjaCBldmVudHMuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUxpc3RlbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBxdWVyeU9ic2VydmVyLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgIHRoaXMucXVlcnlPYnNlcnZlciA9IHF1ZXJ5T2JzZXJ2ZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbCBzbmFwc2hvdHMgKGUuZy4gZnJvbSBjYWNoZSkgbWF5IG5vdCBiZSBwcm9wYWdhdGVkIHRvIHRoZSB3cmFwcGVkXHJcbiAgICAgICAgICogb2JzZXJ2ZXIuIFRoaXMgZmxhZyBpcyBzZXQgdG8gdHJ1ZSBvbmNlIHdlJ3ZlIGFjdHVhbGx5IHJhaXNlZCBhbiBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJhaXNlZEluaXRpYWxFdmVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc25hcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZSA9IFwiVW5rbm93blwiIC8qIFVua25vd24gKi87XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgbmV3IFZpZXdTbmFwc2hvdCB0byB0aGlzIGxpc3RlbmVyLCByYWlzaW5nIGEgdXNlci1mYWNpbmcgZXZlbnRcclxuICAgICAqIGlmIGFwcGxpY2FibGUgKGRlcGVuZGluZyBvbiB3aGF0IGNoYW5nZWQsIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGludG9cclxuICAgICAqIG1ldGFkYXRhLW9ubHkgY2hhbmdlcywgZXRjLikuIFJldHVybnMgdHJ1ZSBpZiBhIHVzZXItZmFjaW5nIGV2ZW50IHdhc1xyXG4gICAgICogaW5kZWVkIHJhaXNlZC5cclxuICAgICAqL1xyXG4gICAgb25WaWV3U25hcHNob3Qoc25hcCkge1xyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmluY2x1ZGVNZXRhZGF0YUNoYW5nZXMpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBtZXRhZGF0YSBvbmx5IGNoYW5nZXMuXHJcbiAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBkb2NDaGFuZ2Ugb2Ygc25hcC5kb2NDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jQ2hhbmdlLnR5cGUgIT09IDMgLyogTWV0YWRhdGEgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2NDaGFuZ2VzLnB1c2goZG9jQ2hhbmdlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzbmFwID0gbmV3IFZpZXdTbmFwc2hvdChzbmFwLnF1ZXJ5LCBzbmFwLmRvY3MsIHNuYXAub2xkRG9jcywgZG9jQ2hhbmdlcywgc25hcC5tdXRhdGVkS2V5cywgc25hcC5mcm9tQ2FjaGUsIHNuYXAuc3luY1N0YXRlQ2hhbmdlZCwgXHJcbiAgICAgICAgICAgIC8qIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzPSAqLyB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJhaXNlZEV2ZW50ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJhaXNlZEluaXRpYWxFdmVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG91bGRSYWlzZUluaXRpYWxFdmVudChzbmFwLCB0aGlzLm9ubGluZVN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWlzZUluaXRpYWxFdmVudChzbmFwKTtcclxuICAgICAgICAgICAgICAgIHJhaXNlZEV2ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNob3VsZFJhaXNlRXZlbnQoc25hcCkpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyLm5leHQoc25hcCk7XHJcbiAgICAgICAgICAgIHJhaXNlZEV2ZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zbmFwID0gc25hcDtcclxuICAgICAgICByZXR1cm4gcmFpc2VkRXZlbnQ7XHJcbiAgICB9XHJcbiAgICBvbkVycm9yKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeU9ic2VydmVyLmVycm9yKGVycm9yKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHdoZXRoZXIgYSBzbmFwc2hvdCB3YXMgcmFpc2VkLiAqL1xyXG4gICAgYXBwbHlPbmxpbmVTdGF0ZUNoYW5nZShvbmxpbmVTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMub25saW5lU3RhdGUgPSBvbmxpbmVTdGF0ZTtcclxuICAgICAgICBsZXQgcmFpc2VkRXZlbnQgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5zbmFwICYmXHJcbiAgICAgICAgICAgICF0aGlzLnJhaXNlZEluaXRpYWxFdmVudCAmJlxyXG4gICAgICAgICAgICB0aGlzLnNob3VsZFJhaXNlSW5pdGlhbEV2ZW50KHRoaXMuc25hcCwgb25saW5lU3RhdGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFpc2VJbml0aWFsRXZlbnQodGhpcy5zbmFwKTtcclxuICAgICAgICAgICAgcmFpc2VkRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmFpc2VkRXZlbnQ7XHJcbiAgICB9XHJcbiAgICBzaG91bGRSYWlzZUluaXRpYWxFdmVudChzbmFwLCBvbmxpbmVTdGF0ZSkge1xyXG4gICAgICAgIC8vIEFsd2F5cyByYWlzZSB0aGUgZmlyc3QgZXZlbnQgd2hlbiB3ZSdyZSBzeW5jZWRcclxuICAgICAgICBpZiAoIXNuYXAuZnJvbUNhY2hlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOT1RFOiBXZSBjb25zaWRlciBPbmxpbmVTdGF0ZS5Vbmtub3duIGFzIG9ubGluZSAoaXQgc2hvdWxkIGJlY29tZSBPZmZsaW5lXHJcbiAgICAgICAgLy8gb3IgT25saW5lIGlmIHdlIHdhaXQgbG9uZyBlbm91Z2gpLlxyXG4gICAgICAgIGNvbnN0IG1heWJlT25saW5lID0gb25saW5lU3RhdGUgIT09IFwiT2ZmbGluZVwiIC8qIE9mZmxpbmUgKi87XHJcbiAgICAgICAgLy8gRG9uJ3QgcmFpc2UgdGhlIGV2ZW50IGlmIHdlJ3JlIG9ubGluZSwgYXJlbid0IHN5bmNlZCB5ZXQgKGNoZWNrZWRcclxuICAgICAgICAvLyBhYm92ZSkgYW5kIGFyZSB3YWl0aW5nIGZvciBhIHN5bmMuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53YWl0Rm9yU3luY1doZW5PbmxpbmUgJiYgbWF5YmVPbmxpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSYWlzZSBkYXRhIGZyb20gY2FjaGUgaWYgd2UgaGF2ZSBhbnkgZG9jdW1lbnRzIG9yIHdlIGFyZSBvZmZsaW5lXHJcbiAgICAgICAgcmV0dXJuICFzbmFwLmRvY3MuaXNFbXB0eSgpIHx8IG9ubGluZVN0YXRlID09PSBcIk9mZmxpbmVcIiAvKiBPZmZsaW5lICovO1xyXG4gICAgfVxyXG4gICAgc2hvdWxkUmFpc2VFdmVudChzbmFwKSB7XHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBoYW5kbGUgaW5jbHVkZURvY3VtZW50TWV0YWRhdGFDaGFuZ2VzIGhlcmUgYmVjYXVzZVxyXG4gICAgICAgIC8vIHRoZSBNZXRhZGF0YSBvbmx5IGNoYW5nZXMgaGF2ZSBhbHJlYWR5IGJlZW4gc3RyaXBwZWQgb3V0IGlmIG5lZWRlZC5cclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBvbmx5IGNoYW5nZXMgd2Ugd2lsbCBzZWUgYXJlIHRoZSBvbmVzIHdlIHNob3VsZFxyXG4gICAgICAgIC8vIHByb3BhZ2F0ZS5cclxuICAgICAgICBpZiAoc25hcC5kb2NDaGFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhc1BlbmRpbmdXcml0ZXNDaGFuZ2VkID0gdGhpcy5zbmFwICYmIHRoaXMuc25hcC5oYXNQZW5kaW5nV3JpdGVzICE9PSBzbmFwLmhhc1BlbmRpbmdXcml0ZXM7XHJcbiAgICAgICAgaWYgKHNuYXAuc3luY1N0YXRlQ2hhbmdlZCB8fCBoYXNQZW5kaW5nV3JpdGVzQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluY2x1ZGVNZXRhZGF0YUNoYW5nZXMgPT09IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdlbmVyYWxseSB3ZSBzaG91bGQgaGF2ZSBoaXQgb25lIG9mIHRoZSBjYXNlcyBhYm92ZSwgYnV0IGl0J3MgcG9zc2libGVcclxuICAgICAgICAvLyB0byBnZXQgaGVyZSBpZiB0aGVyZSB3ZXJlIG9ubHkgbWV0YWRhdGEgZG9jQ2hhbmdlcyBhbmQgdGhleSBnb3RcclxuICAgICAgICAvLyBzdHJpcHBlZCBvdXQuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmFpc2VJbml0aWFsRXZlbnQoc25hcCkge1xyXG4gICAgICAgIHNuYXAgPSBWaWV3U25hcHNob3QuZnJvbUluaXRpYWxEb2N1bWVudHMoc25hcC5xdWVyeSwgc25hcC5kb2NzLCBzbmFwLm11dGF0ZWRLZXlzLCBzbmFwLmZyb21DYWNoZSk7XHJcbiAgICAgICAgdGhpcy5yYWlzZWRJbml0aWFsRXZlbnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucXVlcnlPYnNlcnZlci5uZXh0KHNuYXApO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHNldCBvZiBjaGFuZ2VzIHRvIHdoYXQgZG9jdW1lbnRzIGFyZSBjdXJyZW50bHkgaW4gdmlldyBhbmQgb3V0IG9mIHZpZXcgZm9yXHJcbiAqIGEgZ2l2ZW4gcXVlcnkuIFRoZXNlIGNoYW5nZXMgYXJlIHNlbnQgdG8gdGhlIExvY2FsU3RvcmUgYnkgdGhlIFZpZXcgKHZpYVxyXG4gKiB0aGUgU3luY0VuZ2luZSkgYW5kIGFyZSB1c2VkIHRvIHBpbiAvIHVucGluIGRvY3VtZW50cyBhcyBhcHByb3ByaWF0ZS5cclxuICovXHJcbmNsYXNzIExvY2FsVmlld0NoYW5nZXMge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0SWQsIGZyb21DYWNoZSwgYWRkZWRLZXlzLCByZW1vdmVkS2V5cykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0SWQgPSB0YXJnZXRJZDtcclxuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcclxuICAgICAgICB0aGlzLmFkZGVkS2V5cyA9IGFkZGVkS2V5cztcclxuICAgICAgICB0aGlzLnJlbW92ZWRLZXlzID0gcmVtb3ZlZEtleXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVNuYXBzaG90KHRhcmdldElkLCB2aWV3U25hcHNob3QpIHtcclxuICAgICAgICBsZXQgYWRkZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICBsZXQgcmVtb3ZlZEtleXMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZG9jQ2hhbmdlIG9mIHZpZXdTbmFwc2hvdC5kb2NDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZG9jQ2hhbmdlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBBZGRlZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICBhZGRlZEtleXMgPSBhZGRlZEtleXMuYWRkKGRvY0NoYW5nZS5kb2Mua2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBSZW1vdmVkICovOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzID0gcmVtb3ZlZEtleXMuYWRkKGRvY0NoYW5nZS5kb2Mua2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IExvY2FsVmlld0NoYW5nZXModGFyZ2V0SWQsIHZpZXdTbmFwc2hvdC5mcm9tQ2FjaGUsIGFkZGVkS2V5cywgcmVtb3ZlZEtleXMpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEJ1bmRsZUxvYWRSZXN1bHQge1xyXG4gICAgY29uc3RydWN0b3IocHJvZ3Jlc3MsIGNoYW5nZWREb2NzKSB7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzcyA9IHByb2dyZXNzO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlZERvY3MgPSBjaGFuZ2VkRG9jcztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSGVscGVyIHRvIGNvbnZlcnQgb2JqZWN0cyBmcm9tIGJ1bmRsZXMgdG8gbW9kZWwgb2JqZWN0cyBpbiB0aGUgU0RLLlxyXG4gKi9cclxuY2xhc3MgQnVuZGxlQ29udmVydGVySW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemVyKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gc2VyaWFsaXplcjtcclxuICAgIH1cclxuICAgIHRvRG9jdW1lbnRLZXkobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tTmFtZSh0aGlzLnNlcmlhbGl6ZXIsIG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIEJ1bmRsZURvY3VtZW50IHRvIGEgTXV0YWJsZURvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICB0b011dGFibGVEb2N1bWVudChidW5kbGVkRG9jKSB7XHJcbiAgICAgICAgaWYgKGJ1bmRsZWREb2MubWV0YWRhdGEuZXhpc3RzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tRG9jdW1lbnQodGhpcy5zZXJpYWxpemVyLCBidW5kbGVkRG9jLmRvY3VtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQodGhpcy50b0RvY3VtZW50S2V5KGJ1bmRsZWREb2MubWV0YWRhdGEubmFtZSksIHRoaXMudG9TbmFwc2hvdFZlcnNpb24oYnVuZGxlZERvYy5tZXRhZGF0YS5yZWFkVGltZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU25hcHNob3RWZXJzaW9uKHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gZnJvbVZlcnNpb24odGltZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgY2xhc3MgdG8gcHJvY2VzcyB0aGUgZWxlbWVudHMgZnJvbSBhIGJ1bmRsZSwgbG9hZCB0aGVtIGludG8gbG9jYWxcclxuICogc3RvcmFnZSBhbmQgcHJvdmlkZSBwcm9ncmVzcyB1cGRhdGUgd2hpbGUgbG9hZGluZy5cclxuICovXHJcbmNsYXNzIEJ1bmRsZUxvYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihidW5kbGVNZXRhZGF0YSwgbG9jYWxTdG9yZSwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHRoaXMuYnVuZGxlTWV0YWRhdGEgPSBidW5kbGVNZXRhZGF0YTtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSBsb2NhbFN0b3JlO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgLyoqIEJhdGNoZWQgcXVlcmllcyB0byBiZSBzYXZlZCBpbnRvIHN0b3JhZ2UgKi9cclxuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBbXTtcclxuICAgICAgICAvKiogQmF0Y2hlZCBkb2N1bWVudHMgdG8gYmUgc2F2ZWQgaW50byBzdG9yYWdlICovXHJcbiAgICAgICAgdGhpcy5kb2N1bWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLnByb2dyZXNzID0gYnVuZGxlSW5pdGlhbFByb2dyZXNzKGJ1bmRsZU1ldGFkYXRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBlbGVtZW50IGZyb20gdGhlIGJ1bmRsZSB0byB0aGUgbG9hZGVyLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYSBuZXcgcHJvZ3Jlc3MgaWYgYWRkaW5nIHRoZSBlbGVtZW50IGxlYWRzIHRvIGEgbmV3IHByb2dyZXNzLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cclxuICAgICAqL1xyXG4gICAgYWRkU2l6ZWRFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLnByb2dyZXNzLmJ5dGVzTG9hZGVkICs9IGVsZW1lbnQuYnl0ZUxlbmd0aDtcclxuICAgICAgICBsZXQgZG9jdW1lbnRzTG9hZGVkID0gdGhpcy5wcm9ncmVzcy5kb2N1bWVudHNMb2FkZWQ7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQucGF5bG9hZC5uYW1lZFF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5wdXNoKGVsZW1lbnQucGF5bG9hZC5uYW1lZFF1ZXJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5wYXlsb2FkLmRvY3VtZW50TWV0YWRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHMucHVzaCh7IG1ldGFkYXRhOiBlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YSB9KTtcclxuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBheWxvYWQuZG9jdW1lbnRNZXRhZGF0YS5leGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICsrZG9jdW1lbnRzTG9hZGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQucGF5bG9hZC5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50c1t0aGlzLmRvY3VtZW50cy5sZW5ndGggLSAxXS5kb2N1bWVudCA9XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBheWxvYWQuZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgICsrZG9jdW1lbnRzTG9hZGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZG9jdW1lbnRzTG9hZGVkICE9PSB0aGlzLnByb2dyZXNzLmRvY3VtZW50c0xvYWRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzLmRvY3VtZW50c0xvYWRlZCA9IGRvY3VtZW50c0xvYWRlZDtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvZ3Jlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGdldFF1ZXJ5RG9jdW1lbnRNYXBwaW5nKGRvY3VtZW50cykge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5RG9jdW1lbnRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgY29uc3QgYnVuZGxlQ29udmVydGVyID0gbmV3IEJ1bmRsZUNvbnZlcnRlckltcGwodGhpcy5zZXJpYWxpemVyKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGJ1bmRsZURvYyBvZiBkb2N1bWVudHMpIHtcclxuICAgICAgICAgICAgaWYgKGJ1bmRsZURvYy5tZXRhZGF0YS5xdWVyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudEtleSA9IGJ1bmRsZUNvbnZlcnRlci50b0RvY3VtZW50S2V5KGJ1bmRsZURvYy5tZXRhZGF0YS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcXVlcnlOYW1lIG9mIGJ1bmRsZURvYy5tZXRhZGF0YS5xdWVyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRLZXlzID0gKHF1ZXJ5RG9jdW1lbnRNYXAuZ2V0KHF1ZXJ5TmFtZSkgfHwgZG9jdW1lbnRLZXlTZXQoKSkuYWRkKGRvY3VtZW50S2V5KTtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeURvY3VtZW50TWFwLnNldChxdWVyeU5hbWUsIGRvY3VtZW50S2V5cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5RG9jdW1lbnRNYXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgdG8gJ1N1Y2Nlc3MnIGFuZCByZXR1cm4gdGhlIHVwZGF0ZWQgcHJvZ3Jlc3MuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGNvbXBsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZWREb2N1bWVudHMgPSBhd2FpdCBsb2NhbFN0b3JlQXBwbHlCdW5kbGVkRG9jdW1lbnRzKHRoaXMubG9jYWxTdG9yZSwgbmV3IEJ1bmRsZUNvbnZlcnRlckltcGwodGhpcy5zZXJpYWxpemVyKSwgdGhpcy5kb2N1bWVudHMsIHRoaXMuYnVuZGxlTWV0YWRhdGEuaWQpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5RG9jdW1lbnRNYXAgPSB0aGlzLmdldFF1ZXJ5RG9jdW1lbnRNYXBwaW5nKHRoaXMuZG9jdW1lbnRzKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHEgb2YgdGhpcy5xdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGxvY2FsU3RvcmVTYXZlTmFtZWRRdWVyeSh0aGlzLmxvY2FsU3RvcmUsIHEsIHF1ZXJ5RG9jdW1lbnRNYXAuZ2V0KHEubmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb2dyZXNzLnRhc2tTdGF0ZSA9ICdTdWNjZXNzJztcclxuICAgICAgICByZXR1cm4gbmV3IEJ1bmRsZUxvYWRSZXN1bHQoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9ncmVzcyksIGNoYW5nZWREb2N1bWVudHMpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHJlcHJlc2VudGluZyB0aGUgaW5pdGlhbCBwcm9ncmVzcyBvZlxyXG4gKiBsb2FkaW5nIGEgYnVuZGxlLlxyXG4gKi9cclxuZnVuY3Rpb24gYnVuZGxlSW5pdGlhbFByb2dyZXNzKG1ldGFkYXRhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxyXG4gICAgICAgIGRvY3VtZW50c0xvYWRlZDogMCxcclxuICAgICAgICBieXRlc0xvYWRlZDogMCxcclxuICAgICAgICB0b3RhbERvY3VtZW50czogbWV0YWRhdGEudG90YWxEb2N1bWVudHMsXHJcbiAgICAgICAgdG90YWxCeXRlczogbWV0YWRhdGEudG90YWxCeXRlc1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRoYXQgdGhlIGxvYWRpbmdcclxuICogaGFzIHN1Y2NlZWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGJ1bmRsZVN1Y2Nlc3NQcm9ncmVzcyhtZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0YXNrU3RhdGU6ICdTdWNjZXNzJyxcclxuICAgICAgICBkb2N1bWVudHNMb2FkZWQ6IG1ldGFkYXRhLnRvdGFsRG9jdW1lbnRzLFxyXG4gICAgICAgIGJ5dGVzTG9hZGVkOiBtZXRhZGF0YS50b3RhbEJ5dGVzLFxyXG4gICAgICAgIHRvdGFsRG9jdW1lbnRzOiBtZXRhZGF0YS50b3RhbERvY3VtZW50cyxcclxuICAgICAgICB0b3RhbEJ5dGVzOiBtZXRhZGF0YS50b3RhbEJ5dGVzXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEFkZGVkTGltYm9Eb2N1bWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBSZW1vdmVkTGltYm9Eb2N1bWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmlldyBpcyByZXNwb25zaWJsZSBmb3IgY29tcHV0aW5nIHRoZSBmaW5hbCBtZXJnZWQgdHJ1dGggb2Ygd2hhdCBkb2NzIGFyZSBpblxyXG4gKiBhIHF1ZXJ5LiBJdCBnZXRzIG5vdGlmaWVkIG9mIGxvY2FsIGFuZCByZW1vdGUgY2hhbmdlcyB0byBkb2NzLCBhbmQgYXBwbGllc1xyXG4gKiB0aGUgcXVlcnkgZmlsdGVycyBhbmQgbGltaXRzIHRvIGRldGVybWluZSB0aGUgbW9zdCBjb3JyZWN0IHBvc3NpYmxlIHJlc3VsdHMuXHJcbiAqL1xyXG5jbGFzcyBWaWV3IHtcclxuICAgIGNvbnN0cnVjdG9yKHF1ZXJ5LCBcclxuICAgIC8qKiBEb2N1bWVudHMgaW5jbHVkZWQgaW4gdGhlIHJlbW90ZSB0YXJnZXQgKi9cclxuICAgIF9zeW5jZWREb2N1bWVudHMpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICAgICAgdGhpcy5fc3luY2VkRG9jdW1lbnRzID0gX3N5bmNlZERvY3VtZW50cztcclxuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmbGFnIHdoZXRoZXIgdGhlIHZpZXcgaXMgY3VycmVudCB3aXRoIHRoZSBiYWNrZW5kLiBBIHZpZXcgaXMgY29uc2lkZXJlZFxyXG4gICAgICAgICAqIGN1cnJlbnQgYWZ0ZXIgaXQgaGFzIHNlZW4gdGhlIGN1cnJlbnQgZmxhZyBmcm9tIHRoZSBiYWNrZW5kIGFuZCBkaWQgbm90XHJcbiAgICAgICAgICogbG9zZSBjb25zaXN0ZW5jeSB3aXRoaW4gdGhlIHdhdGNoIHN0cmVhbSAoZS5nLiBiZWNhdXNlIG9mIGFuIGV4aXN0ZW5jZVxyXG4gICAgICAgICAqIGZpbHRlciBtaXNtYXRjaCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIERvY3VtZW50cyBpbiB0aGUgdmlldyBidXQgbm90IGluIHRoZSByZW1vdGUgdGFyZ2V0ICovXHJcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgLyoqIERvY3VtZW50IEtleXMgdGhhdCBoYXZlIGxvY2FsIGNoYW5nZXMgKi9cclxuICAgICAgICB0aGlzLm11dGF0ZWRLZXlzID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IgPSBuZXdRdWVyeUNvbXBhcmF0b3IocXVlcnkpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQgPSBuZXcgRG9jdW1lbnRTZXQodGhpcy5kb2NDb21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNldCBvZiByZW1vdGUgZG9jdW1lbnRzIHRoYXQgdGhlIHNlcnZlciBoYXMgdG9sZCB1cyBiZWxvbmdzIHRvIHRoZSB0YXJnZXQgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgKiB0aGlzIHZpZXcuXHJcbiAgICAgKi9cclxuICAgIGdldCBzeW5jZWREb2N1bWVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N5bmNlZERvY3VtZW50cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhIHNldCBvZiBkb2MgY2hhbmdlcywgYXBwbGllcyB0aGUgcXVlcnkgbGltaXQsIGFuZCBjb21wdXRlc1xyXG4gICAgICogd2hhdCB0aGUgbmV3IHJlc3VsdHMgc2hvdWxkIGJlLCB3aGF0IHRoZSBjaGFuZ2VzIHdlcmUsIGFuZCB3aGV0aGVyIHdlIG1heVxyXG4gICAgICogbmVlZCB0byBnbyBiYWNrIHRvIHRoZSBsb2NhbCBjYWNoZSBmb3IgbW9yZSByZXN1bHRzLiBEb2VzIG5vdCBtYWtlIGFueVxyXG4gICAgICogY2hhbmdlcyB0byB0aGUgdmlldy5cclxuICAgICAqIEBwYXJhbSBkb2NDaGFuZ2VzIC0gVGhlIGRvYyBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoaXMgdmlldy5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0NoYW5nZXMgLSBJZiB0aGlzIGlzIGJlaW5nIGNhbGxlZCB3aXRoIGEgcmVmaWxsLCB0aGVuIHN0YXJ0XHJcbiAgICAgKiAgICAgICAgd2l0aCB0aGlzIHNldCBvZiBkb2NzIGFuZCBjaGFuZ2VzIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgdmlldy5cclxuICAgICAqIEByZXR1cm5zIGEgbmV3IHNldCBvZiBkb2NzLCBjaGFuZ2VzLCBhbmQgcmVmaWxsIGZsYWcuXHJcbiAgICAgKi9cclxuICAgIGNvbXB1dGVEb2NDaGFuZ2VzKGRvY0NoYW5nZXMsIHByZXZpb3VzQ2hhbmdlcykge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZVNldCA9IHByZXZpb3VzQ2hhbmdlc1xyXG4gICAgICAgICAgICA/IHByZXZpb3VzQ2hhbmdlcy5jaGFuZ2VTZXRcclxuICAgICAgICAgICAgOiBuZXcgRG9jdW1lbnRDaGFuZ2VTZXQoKTtcclxuICAgICAgICBjb25zdCBvbGREb2N1bWVudFNldCA9IHByZXZpb3VzQ2hhbmdlc1xyXG4gICAgICAgICAgICA/IHByZXZpb3VzQ2hhbmdlcy5kb2N1bWVudFNldFxyXG4gICAgICAgICAgICA6IHRoaXMuZG9jdW1lbnRTZXQ7XHJcbiAgICAgICAgbGV0IG5ld011dGF0ZWRLZXlzID0gcHJldmlvdXNDaGFuZ2VzXHJcbiAgICAgICAgICAgID8gcHJldmlvdXNDaGFuZ2VzLm11dGF0ZWRLZXlzXHJcbiAgICAgICAgICAgIDogdGhpcy5tdXRhdGVkS2V5cztcclxuICAgICAgICBsZXQgbmV3RG9jdW1lbnRTZXQgPSBvbGREb2N1bWVudFNldDtcclxuICAgICAgICBsZXQgbmVlZHNSZWZpbGwgPSBmYWxzZTtcclxuICAgICAgICAvLyBUcmFjayB0aGUgbGFzdCBkb2MgaW4gYSAoZnVsbCkgbGltaXQuIFRoaXMgaXMgbmVjZXNzYXJ5LCBiZWNhdXNlIHNvbWVcclxuICAgICAgICAvLyB1cGRhdGUgKGEgZGVsZXRlLCBvciBhbiB1cGRhdGUgbW92aW5nIGEgZG9jIHBhc3QgdGhlIG9sZCBsaW1pdCkgbWlnaHRcclxuICAgICAgICAvLyBtZWFuIHRoZXJlIGlzIHNvbWUgb3RoZXIgZG9jdW1lbnQgaW4gdGhlIGxvY2FsIGNhY2hlIHRoYXQgZWl0aGVyIHNob3VsZFxyXG4gICAgICAgIC8vIGNvbWUgKDEpIGJldHdlZW4gdGhlIG9sZCBsYXN0IGxpbWl0IGRvYyBhbmQgdGhlIG5ldyBsYXN0IGRvY3VtZW50LCBpbiB0aGVcclxuICAgICAgICAvLyBjYXNlIG9mIHVwZGF0ZXMsIG9yICgyKSBhZnRlciB0aGUgbmV3IGxhc3QgZG9jdW1lbnQsIGluIHRoZSBjYXNlIG9mXHJcbiAgICAgICAgLy8gZGVsZXRlcy4gU28gd2Uga2VlcCB0aGlzIGRvYyBhdCB0aGUgb2xkIGxpbWl0IHRvIGNvbXBhcmUgdGhlIHVwZGF0ZXMgdG8uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGQgbmV2ZXIgZ2V0IHVzZWQgaW4gYSByZWZpbGwgKHdoZW4gcHJldmlvdXNDaGFuZ2VzIGlzXHJcbiAgICAgICAgLy8gc2V0KSwgYmVjYXVzZSB0aGVyZSB3aWxsIG9ubHkgYmUgYWRkcyAtLSBubyBkZWxldGVzIG9yIHVwZGF0ZXMuXHJcbiAgICAgICAgY29uc3QgbGFzdERvY0luTGltaXQgPSBoYXNMaW1pdFRvRmlyc3QodGhpcy5xdWVyeSkgJiYgb2xkRG9jdW1lbnRTZXQuc2l6ZSA9PT0gdGhpcy5xdWVyeS5saW1pdFxyXG4gICAgICAgICAgICA/IG9sZERvY3VtZW50U2V0Lmxhc3QoKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgZmlyc3REb2NJbkxpbWl0ID0gaGFzTGltaXRUb0xhc3QodGhpcy5xdWVyeSkgJiYgb2xkRG9jdW1lbnRTZXQuc2l6ZSA9PT0gdGhpcy5xdWVyeS5saW1pdFxyXG4gICAgICAgICAgICA/IG9sZERvY3VtZW50U2V0LmZpcnN0KClcclxuICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIGRvY0NoYW5nZXMuaW5vcmRlclRyYXZlcnNhbCgoa2V5LCBlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvbGREb2MgPSBvbGREb2N1bWVudFNldC5nZXQoa2V5KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3RG9jID0gcXVlcnlNYXRjaGVzKHRoaXMucXVlcnksIGVudHJ5KSA/IGVudHJ5IDogbnVsbDtcclxuICAgICAgICAgICAgY29uc3Qgb2xkRG9jSGFkUGVuZGluZ011dGF0aW9ucyA9IG9sZERvY1xyXG4gICAgICAgICAgICAgICAgPyB0aGlzLm11dGF0ZWRLZXlzLmhhcyhvbGREb2Mua2V5KVxyXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgbmV3RG9jSGFzUGVuZGluZ011dGF0aW9ucyA9IG5ld0RvY1xyXG4gICAgICAgICAgICAgICAgPyBuZXdEb2MuaGFzTG9jYWxNdXRhdGlvbnMgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGNvbnNpZGVyIGNvbW1pdHRlZCBtdXRhdGlvbnMgZm9yIGRvY3VtZW50cyB0aGF0IHdlcmVcclxuICAgICAgICAgICAgICAgICAgICAvLyBtdXRhdGVkIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgdGhlIHZpZXcuXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMubXV0YXRlZEtleXMuaGFzKG5ld0RvYy5rZXkpICYmIG5ld0RvYy5oYXNDb21taXR0ZWRNdXRhdGlvbnMpXHJcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgY2hhbmdlQXBwbGllZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgY2hhbmdlXHJcbiAgICAgICAgICAgIGlmIChvbGREb2MgJiYgbmV3RG9jKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkb2NzRXF1YWwgPSBvbGREb2MuZGF0YS5pc0VxdWFsKG5ld0RvYy5kYXRhKTtcclxuICAgICAgICAgICAgICAgIGlmICghZG9jc0VxdWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZFdhaXRGb3JTeW5jZWREb2N1bWVudChvbGREb2MsIG5ld0RvYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDIgLyogTW9kaWZpZWQgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2M6IG5ld0RvY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobGFzdERvY0luTGltaXQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jQ29tcGFyYXRvcihuZXdEb2MsIGxhc3REb2NJbkxpbWl0KSA+IDApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlyc3REb2NJbkxpbWl0ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NDb21wYXJhdG9yKG5ld0RvYywgZmlyc3REb2NJbkxpbWl0KSA8IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGRvYyBtb3ZlZCBmcm9tIGluc2lkZSB0aGUgbGltaXQgdG8gb3V0c2lkZSB0aGUgbGltaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0IG1lYW5zIHRoZXJlIG1heSBiZSBzb21lIG90aGVyIGRvYyBpbiB0aGUgbG9jYWwgY2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluc3RlYWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1JlZmlsbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGREb2NIYWRQZW5kaW5nTXV0YXRpb25zICE9PSBuZXdEb2NIYXNQZW5kaW5nTXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlU2V0LnRyYWNrKHsgdHlwZTogMyAvKiBNZXRhZGF0YSAqLywgZG9jOiBuZXdEb2MgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIW9sZERvYyAmJiBuZXdEb2MpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDAgLyogQWRkZWQgKi8sIGRvYzogbmV3RG9jIH0pO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlQXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2xkRG9jICYmICFuZXdEb2MpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZVNldC50cmFjayh7IHR5cGU6IDEgLyogUmVtb3ZlZCAqLywgZG9jOiBvbGREb2MgfSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VBcHBsaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0RG9jSW5MaW1pdCB8fCBmaXJzdERvY0luTGltaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBIGRvYyB3YXMgcmVtb3ZlZCBmcm9tIGEgZnVsbCBsaW1pdCBxdWVyeS4gV2UnbGwgbmVlZCB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlcnkgZnJvbSB0aGUgbG9jYWwgY2FjaGUgdG8gc2VlIGlmIHdlIGtub3cgYWJvdXQgc29tZSBvdGhlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvYyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgcmVzdWx0cy5cclxuICAgICAgICAgICAgICAgICAgICBuZWVkc1JlZmlsbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYW5nZUFwcGxpZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdEb2MpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdEb2N1bWVudFNldCA9IG5ld0RvY3VtZW50U2V0LmFkZChuZXdEb2MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdEb2NIYXNQZW5kaW5nTXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld011dGF0ZWRLZXlzID0gbmV3TXV0YXRlZEtleXMuYWRkKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdNdXRhdGVkS2V5cyA9IG5ld011dGF0ZWRLZXlzLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0RvY3VtZW50U2V0ID0gbmV3RG9jdW1lbnRTZXQuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5kZWxldGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIERyb3AgZG9jdW1lbnRzIG91dCB0byBtZWV0IGxpbWl0L2xpbWl0VG9MYXN0IHJlcXVpcmVtZW50LlxyXG4gICAgICAgIGlmIChoYXNMaW1pdFRvRmlyc3QodGhpcy5xdWVyeSkgfHwgaGFzTGltaXRUb0xhc3QodGhpcy5xdWVyeSkpIHtcclxuICAgICAgICAgICAgd2hpbGUgKG5ld0RvY3VtZW50U2V0LnNpemUgPiB0aGlzLnF1ZXJ5LmxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGREb2MgPSBoYXNMaW1pdFRvRmlyc3QodGhpcy5xdWVyeSlcclxuICAgICAgICAgICAgICAgICAgICA/IG5ld0RvY3VtZW50U2V0Lmxhc3QoKVxyXG4gICAgICAgICAgICAgICAgICAgIDogbmV3RG9jdW1lbnRTZXQuZmlyc3QoKTtcclxuICAgICAgICAgICAgICAgIG5ld0RvY3VtZW50U2V0ID0gbmV3RG9jdW1lbnRTZXQuZGVsZXRlKG9sZERvYy5rZXkpO1xyXG4gICAgICAgICAgICAgICAgbmV3TXV0YXRlZEtleXMgPSBuZXdNdXRhdGVkS2V5cy5kZWxldGUob2xkRG9jLmtleSk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VTZXQudHJhY2soeyB0eXBlOiAxIC8qIFJlbW92ZWQgKi8sIGRvYzogb2xkRG9jIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50U2V0OiBuZXdEb2N1bWVudFNldCxcclxuICAgICAgICAgICAgY2hhbmdlU2V0LFxyXG4gICAgICAgICAgICBuZWVkc1JlZmlsbCxcclxuICAgICAgICAgICAgbXV0YXRlZEtleXM6IG5ld011dGF0ZWRLZXlzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHNob3VsZFdhaXRGb3JTeW5jZWREb2N1bWVudChvbGREb2MsIG5ld0RvYykge1xyXG4gICAgICAgIC8vIFdlIHN1cHByZXNzIHRoZSBpbml0aWFsIGNoYW5nZSBldmVudCBmb3IgZG9jdW1lbnRzIHRoYXQgd2VyZSBtb2RpZmllZCBhc1xyXG4gICAgICAgIC8vIHBhcnQgb2YgYSB3cml0ZSBhY2tub3dsZWRnbWVudCAoZS5nLiB3aGVuIHRoZSB2YWx1ZSBvZiBhIHNlcnZlciB0cmFuc2Zvcm1cclxuICAgICAgICAvLyBpcyBhcHBsaWVkKSBhcyBXYXRjaCB3aWxsIHNlbmQgdXMgdGhlIHNhbWUgZG9jdW1lbnQgYWdhaW4uXHJcbiAgICAgICAgLy8gQnkgc3VwcHJlc3NpbmcgdGhlIGV2ZW50LCB3ZSBvbmx5IHJhaXNlIHR3byB1c2VyIHZpc2libGUgZXZlbnRzIChvbmUgd2l0aFxyXG4gICAgICAgIC8vIGBoYXNQZW5kaW5nV3JpdGVzYCBhbmQgdGhlIGZpbmFsIHN0YXRlIG9mIHRoZSBkb2N1bWVudCkgaW5zdGVhZCBvZiB0aHJlZVxyXG4gICAgICAgIC8vIChvbmUgd2l0aCBgaGFzUGVuZGluZ1dyaXRlc2AsIHRoZSBtb2RpZmllZCBkb2N1bWVudCB3aXRoXHJcbiAgICAgICAgLy8gYGhhc1BlbmRpbmdXcml0ZXNgIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgdGhlIGRvY3VtZW50KS5cclxuICAgICAgICByZXR1cm4gKG9sZERvYy5oYXNMb2NhbE11dGF0aW9ucyAmJlxyXG4gICAgICAgICAgICBuZXdEb2MuaGFzQ29tbWl0dGVkTXV0YXRpb25zICYmXHJcbiAgICAgICAgICAgICFuZXdEb2MuaGFzTG9jYWxNdXRhdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB2aWV3IHdpdGggdGhlIGdpdmVuIFZpZXdEb2N1bWVudENoYW5nZXMgYW5kIG9wdGlvbmFsbHkgdXBkYXRlc1xyXG4gICAgICogbGltYm8gZG9jcyBhbmQgc3luYyBzdGF0ZSBmcm9tIHRoZSBwcm92aWRlZCB0YXJnZXQgY2hhbmdlLlxyXG4gICAgICogQHBhcmFtIGRvY0NoYW5nZXMgLSBUaGUgc2V0IG9mIGNoYW5nZXMgdG8gbWFrZSB0byB0aGUgdmlldydzIGRvY3MuXHJcbiAgICAgKiBAcGFyYW0gdXBkYXRlTGltYm9Eb2N1bWVudHMgLSBXaGV0aGVyIHRvIHVwZGF0ZSBsaW1ibyBkb2N1bWVudHMgYmFzZWQgb25cclxuICAgICAqICAgICAgICB0aGlzIGNoYW5nZS5cclxuICAgICAqIEBwYXJhbSB0YXJnZXRDaGFuZ2UgLSBBIHRhcmdldCBjaGFuZ2UgdG8gYXBwbHkgZm9yIGNvbXB1dGluZyBsaW1ibyBkb2NzIGFuZFxyXG4gICAgICogICAgICAgIHN5bmMgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBWaWV3Q2hhbmdlIHdpdGggdGhlIGdpdmVuIGRvY3MsIGNoYW5nZXMsIGFuZCBzeW5jIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICAvLyBQT1JUSU5HIE5PVEU6IFRoZSBpT1MvQW5kcm9pZCBjbGllbnRzIGFsd2F5cyBjb21wdXRlIGxpbWJvIGRvY3VtZW50IGNoYW5nZXMuXHJcbiAgICBhcHBseUNoYW5nZXMoZG9jQ2hhbmdlcywgdXBkYXRlTGltYm9Eb2N1bWVudHMsIHRhcmdldENoYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IG9sZERvY3MgPSB0aGlzLmRvY3VtZW50U2V0O1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXQgPSBkb2NDaGFuZ2VzLmRvY3VtZW50U2V0O1xyXG4gICAgICAgIHRoaXMubXV0YXRlZEtleXMgPSBkb2NDaGFuZ2VzLm11dGF0ZWRLZXlzO1xyXG4gICAgICAgIC8vIFNvcnQgY2hhbmdlcyBiYXNlZCBvbiB0eXBlIGFuZCBxdWVyeSBjb21wYXJhdG9yXHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGRvY0NoYW5nZXMuY2hhbmdlU2V0LmdldENoYW5nZXMoKTtcclxuICAgICAgICBjaGFuZ2VzLnNvcnQoKGMxLCBjMikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gKGNvbXBhcmVDaGFuZ2VUeXBlKGMxLnR5cGUsIGMyLnR5cGUpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvY0NvbXBhcmF0b3IoYzEuZG9jLCBjMi5kb2MpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmFwcGx5VGFyZ2V0Q2hhbmdlKHRhcmdldENoYW5nZSk7XHJcbiAgICAgICAgY29uc3QgbGltYm9DaGFuZ2VzID0gdXBkYXRlTGltYm9Eb2N1bWVudHNcclxuICAgICAgICAgICAgPyB0aGlzLnVwZGF0ZUxpbWJvRG9jdW1lbnRzKClcclxuICAgICAgICAgICAgOiBbXTtcclxuICAgICAgICBjb25zdCBzeW5jZWQgPSB0aGlzLmxpbWJvRG9jdW1lbnRzLnNpemUgPT09IDAgJiYgdGhpcy5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IG5ld1N5bmNTdGF0ZSA9IHN5bmNlZCA/IDEgLyogU3luY2VkICovIDogMCAvKiBMb2NhbCAqLztcclxuICAgICAgICBjb25zdCBzeW5jU3RhdGVDaGFuZ2VkID0gbmV3U3luY1N0YXRlICE9PSB0aGlzLnN5bmNTdGF0ZTtcclxuICAgICAgICB0aGlzLnN5bmNTdGF0ZSA9IG5ld1N5bmNTdGF0ZTtcclxuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPT09IDAgJiYgIXN5bmNTdGF0ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgLy8gbm8gY2hhbmdlc1xyXG4gICAgICAgICAgICByZXR1cm4geyBsaW1ib0NoYW5nZXMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNuYXAgPSBuZXcgVmlld1NuYXBzaG90KHRoaXMucXVlcnksIGRvY0NoYW5nZXMuZG9jdW1lbnRTZXQsIG9sZERvY3MsIGNoYW5nZXMsIGRvY0NoYW5nZXMubXV0YXRlZEtleXMsIG5ld1N5bmNTdGF0ZSA9PT0gMCAvKiBMb2NhbCAqLywgc3luY1N0YXRlQ2hhbmdlZCwgXHJcbiAgICAgICAgICAgIC8qIGV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzPSAqLyBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzbmFwc2hvdDogc25hcCxcclxuICAgICAgICAgICAgICAgIGxpbWJvQ2hhbmdlc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhbiBPbmxpbmVTdGF0ZSBjaGFuZ2UgdG8gdGhlIHZpZXcsIHBvdGVudGlhbGx5IGdlbmVyYXRpbmcgYVxyXG4gICAgICogVmlld0NoYW5nZSBpZiB0aGUgdmlldydzIHN5bmNTdGF0ZSBjaGFuZ2VzIGFzIGEgcmVzdWx0LlxyXG4gICAgICovXHJcbiAgICBhcHBseU9ubGluZVN0YXRlQ2hhbmdlKG9ubGluZVN0YXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCAmJiBvbmxpbmVTdGF0ZSA9PT0gXCJPZmZsaW5lXCIgLyogT2ZmbGluZSAqLykge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBvZmZsaW5lLCBzZXQgYGN1cnJlbnRgIHRvIGZhbHNlIGFuZCB0aGVuIGNhbGwgYXBwbHlDaGFuZ2VzKClcclxuICAgICAgICAgICAgLy8gdG8gcmVmcmVzaCBvdXIgc3luY1N0YXRlIGFuZCBnZW5lcmF0ZSBhIFZpZXdDaGFuZ2UgYXMgYXBwcm9wcmlhdGUuIFdlXHJcbiAgICAgICAgICAgIC8vIGFyZSBndWFyYW50ZWVkIHRvIGdldCBhIG5ldyBUYXJnZXRDaGFuZ2UgdGhhdCBzZXRzIGBjdXJyZW50YCBiYWNrIHRvXHJcbiAgICAgICAgICAgIC8vIHRydWUgb25jZSB0aGUgY2xpZW50IGlzIGJhY2sgb25saW5lLlxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlDaGFuZ2VzKHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50U2V0OiB0aGlzLmRvY3VtZW50U2V0LFxyXG4gICAgICAgICAgICAgICAgY2hhbmdlU2V0OiBuZXcgRG9jdW1lbnRDaGFuZ2VTZXQoKSxcclxuICAgICAgICAgICAgICAgIG11dGF0ZWRLZXlzOiB0aGlzLm11dGF0ZWRLZXlzLFxyXG4gICAgICAgICAgICAgICAgbmVlZHNSZWZpbGw6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICAvKiB1cGRhdGVMaW1ib0RvY3VtZW50cz0gKi8gZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gZWZmZWN0LCBqdXN0IHJldHVybiBhIG5vLW9wIFZpZXdDaGFuZ2UuXHJcbiAgICAgICAgICAgIHJldHVybiB7IGxpbWJvQ2hhbmdlczogW10gfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZG9jIGZvciB0aGUgZ2l2ZW4ga2V5IHNob3VsZCBiZSBpbiBsaW1iby5cclxuICAgICAqL1xyXG4gICAgc2hvdWxkQmVJbkxpbWJvKGtleSkge1xyXG4gICAgICAgIC8vIElmIHRoZSByZW1vdGUgZW5kIHNheXMgaXQncyBwYXJ0IG9mIHRoaXMgcXVlcnksIGl0J3Mgbm90IGluIGxpbWJvLlxyXG4gICAgICAgIGlmICh0aGlzLl9zeW5jZWREb2N1bWVudHMuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGUgbG9jYWwgc3RvcmUgZG9lc24ndCB0aGluayBpdCdzIGEgcmVzdWx0LCBzbyBpdCBzaG91bGRuJ3QgYmUgaW4gbGltYm8uXHJcbiAgICAgICAgaWYgKCF0aGlzLmRvY3VtZW50U2V0LmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGxvY2FsIGNoYW5nZXMgdG8gdGhlIGRvYywgdGhleSBtaWdodCBleHBsYWluIHdoeSB0aGUgc2VydmVyXHJcbiAgICAgICAgLy8gZG9lc24ndCBrbm93IHRoYXQgaXQncyBwYXJ0IG9mIHRoZSBxdWVyeS4gU28gZG9uJ3QgcHV0IGl0IGluIGxpbWJvLlxyXG4gICAgICAgIC8vIFRPRE8oa2xpbXQpOiBJZGVhbGx5LCB3ZSB3b3VsZCBvbmx5IGNvbnNpZGVyIGNoYW5nZXMgdGhhdCBtaWdodCBhY3R1YWxseVxyXG4gICAgICAgIC8vIGFmZmVjdCB0aGlzIHNwZWNpZmljIHF1ZXJ5LlxyXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50U2V0LmdldChrZXkpLmhhc0xvY2FsTXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIGluIGxpbWJvLlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHN5bmNlZERvY3VtZW50cywgY3VycmVudCwgYW5kIGxpbWJvIGRvY3MgYmFzZWQgb24gdGhlIGdpdmVuIGNoYW5nZS5cclxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgY2hhbmdlcyB0byB3aGljaCBkb2NzIGFyZSBpbiBsaW1iby5cclxuICAgICAqL1xyXG4gICAgYXBwbHlUYXJnZXRDaGFuZ2UodGFyZ2V0Q2hhbmdlKSB7XHJcbiAgICAgICAgaWYgKHRhcmdldENoYW5nZSkge1xyXG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UuYWRkZWREb2N1bWVudHMuZm9yRWFjaChrZXkgPT4gKHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHRoaXMuX3N5bmNlZERvY3VtZW50cy5hZGQoa2V5KSkpO1xyXG4gICAgICAgICAgICB0YXJnZXRDaGFuZ2UubW9kaWZpZWREb2N1bWVudHMuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGFyZ2V0Q2hhbmdlLnJlbW92ZWREb2N1bWVudHMuZm9yRWFjaChrZXkgPT4gKHRoaXMuX3N5bmNlZERvY3VtZW50cyA9IHRoaXMuX3N5bmNlZERvY3VtZW50cy5kZWxldGUoa2V5KSkpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB0YXJnZXRDaGFuZ2UuY3VycmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVMaW1ib0RvY3VtZW50cygpIHtcclxuICAgICAgICAvLyBXZSBjYW4gb25seSBkZXRlcm1pbmUgbGltYm8gZG9jdW1lbnRzIHdoZW4gd2UncmUgaW4tc3luYyB3aXRoIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPKGtsaW10KTogRG8gdGhpcyBpbmNyZW1lbnRhbGx5IHNvIHRoYXQgaXQncyBub3QgcXVhZHJhdGljIHdoZW5cclxuICAgICAgICAvLyB1cGRhdGluZyBtYW55IGRvY3VtZW50cy5cclxuICAgICAgICBjb25zdCBvbGRMaW1ib0RvY3VtZW50cyA9IHRoaXMubGltYm9Eb2N1bWVudHM7XHJcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IGRvY3VtZW50S2V5U2V0KCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudFNldC5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZEJlSW5MaW1ibyhkb2Mua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cyA9IHRoaXMubGltYm9Eb2N1bWVudHMuYWRkKGRvYy5rZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRGlmZiB0aGUgbmV3IGxpbWJvIGRvY3Mgd2l0aCB0aGUgb2xkIGxpbWJvIGRvY3MuXHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xyXG4gICAgICAgIG9sZExpbWJvRG9jdW1lbnRzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmxpbWJvRG9jdW1lbnRzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2gobmV3IFJlbW92ZWRMaW1ib0RvY3VtZW50KGtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghb2xkTGltYm9Eb2N1bWVudHMuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChuZXcgQWRkZWRMaW1ib0RvY3VtZW50KGtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgaW4tbWVtb3J5IHN0YXRlIG9mIHRoZSBjdXJyZW50IHZpZXcgd2l0aCB0aGUgc3RhdGUgcmVhZCBmcm9tXHJcbiAgICAgKiBwZXJzaXN0ZW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBXZSB1cGRhdGUgdGhlIHF1ZXJ5IHZpZXcgd2hlbmV2ZXIgYSBjbGllbnQncyBwcmltYXJ5IHN0YXR1cyBjaGFuZ2VzOlxyXG4gICAgICogLSBXaGVuIGEgY2xpZW50IHRyYW5zaXRpb25zIGZyb20gcHJpbWFyeSB0byBzZWNvbmRhcnksIGl0IGNhbiBtaXNzXHJcbiAgICAgKiAgIExvY2FsU3RvcmFnZSB1cGRhdGVzIGFuZCBpdHMgcXVlcnkgdmlld3MgbWF5IHRlbXBvcmFyaWx5IG5vdCBiZVxyXG4gICAgICogICBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgc3RhdGUgb24gZGlzay5cclxuICAgICAqIC0gRm9yIHNlY29uZGFyeSB0byBwcmltYXJ5IHRyYW5zaXRpb25zLCB0aGUgY2xpZW50IG5lZWRzIHRvIHVwZGF0ZSB0aGUgbGlzdFxyXG4gICAgICogICBvZiBgc3luY2VkRG9jdW1lbnRzYCBzaW5jZSBzZWNvbmRhcnkgY2xpZW50cyB1cGRhdGUgdGhlaXIgcXVlcnkgdmlld3NcclxuICAgICAqICAgYmFzZWQgcHVyZWx5IG9uIHN5bnRoZXNpemVkIFJlbW90ZUV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcXVlcnlSZXN1bHQuZG9jdW1lbnRzIC0gVGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoZSBxdWVyeSBhY2NvcmRpbmdcclxuICAgICAqIHRvIHRoZSBMb2NhbFN0b3JlLlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXMgLSBUaGUga2V5cyBvZiB0aGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggdGhlXHJcbiAgICAgKiBxdWVyeSBhY2NvcmRpbmcgdG8gdGhlIGJhY2tlbmQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIFZpZXdDaGFuZ2UgdGhhdCByZXN1bHRlZCBmcm9tIHRoaXMgc3luY2hyb25pemF0aW9uLlxyXG4gICAgICovXHJcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE11bHRpLXRhYiBvbmx5LlxyXG4gICAgc3luY2hyb25pemVXaXRoUGVyc2lzdGVkU3RhdGUocXVlcnlSZXN1bHQpIHtcclxuICAgICAgICB0aGlzLl9zeW5jZWREb2N1bWVudHMgPSBxdWVyeVJlc3VsdC5yZW1vdGVLZXlzO1xyXG4gICAgICAgIHRoaXMubGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpO1xyXG4gICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0aGlzLmNvbXB1dGVEb2NDaGFuZ2VzKHF1ZXJ5UmVzdWx0LmRvY3VtZW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlDaGFuZ2VzKGRvY0NoYW5nZXMsIC8qdXBkYXRlTGltYm9Eb2N1bWVudHM9Ki8gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB2aWV3IHNuYXBzaG90IGFzIGlmIHRoaXMgcXVlcnkgd2FzIGp1c3QgbGlzdGVuZWQgdG8uIENvbnRhaW5zXHJcbiAgICAgKiBhIGRvY3VtZW50IGFkZCBmb3IgZXZlcnkgZXhpc3RpbmcgZG9jdW1lbnQgYW5kIHRoZSBgZnJvbUNhY2hlYCBhbmRcclxuICAgICAqIGBoYXNQZW5kaW5nV3JpdGVzYCBzdGF0dXMgb2YgdGhlIGFscmVhZHkgZXN0YWJsaXNoZWQgdmlldy5cclxuICAgICAqL1xyXG4gICAgLy8gUE9SVElORyBOT1RFOiBNdWx0aS10YWIgb25seS5cclxuICAgIGNvbXB1dGVJbml0aWFsU25hcHNob3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIFZpZXdTbmFwc2hvdC5mcm9tSW5pdGlhbERvY3VtZW50cyh0aGlzLnF1ZXJ5LCB0aGlzLmRvY3VtZW50U2V0LCB0aGlzLm11dGF0ZWRLZXlzLCB0aGlzLnN5bmNTdGF0ZSA9PT0gMCAvKiBMb2NhbCAqLyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcGFyZUNoYW5nZVR5cGUoYzEsIGMyKSB7XHJcbiAgICBjb25zdCBvcmRlciA9IChjaGFuZ2UpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKGNoYW5nZSkge1xyXG4gICAgICAgICAgICBjYXNlIDAgLyogQWRkZWQgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgY2FzZSAyIC8qIE1vZGlmaWVkICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgICAgIGNhc2UgMyAvKiBNZXRhZGF0YSAqLzpcclxuICAgICAgICAgICAgICAgIC8vIEEgbWV0YWRhdGEgY2hhbmdlIGlzIGNvbnZlcnRlZCB0byBhIG1vZGlmaWVkIGNoYW5nZSBhdCB0aGUgcHVibGljXHJcbiAgICAgICAgICAgICAgICAvLyBhcGkgbGF5ZXIuICBTaW5jZSB3ZSBzb3J0IGJ5IGRvY3VtZW50IGtleSBhbmQgdGhlbiBjaGFuZ2UgdHlwZSxcclxuICAgICAgICAgICAgICAgIC8vIG1ldGFkYXRhIGFuZCBtb2RpZmllZCBjaGFuZ2VzIG11c3QgYmUgc29ydGVkIGVxdWl2YWxlbnRseS5cclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogUmVtb3ZlZCAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG9yZGVyKGMxKSAtIG9yZGVyKGMyKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJDMgPSAnU3luY0VuZ2luZSc7XHJcbi8qKlxyXG4gKiBRdWVyeVZpZXcgY29udGFpbnMgYWxsIG9mIHRoZSBkYXRhIHRoYXQgU3luY0VuZ2luZSBuZWVkcyB0byBrZWVwIHRyYWNrIG9mIGZvclxyXG4gKiBhIHBhcnRpY3VsYXIgcXVlcnkuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeVZpZXcge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBxdWVyeSBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHF1ZXJ5LCBcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRhcmdldCBudW1iZXIgY3JlYXRlZCBieSB0aGUgY2xpZW50IHRoYXQgaXMgdXNlZCBpbiB0aGUgd2F0Y2hcclxuICAgICAqIHN0cmVhbSB0byBpZGVudGlmeSB0aGlzIHF1ZXJ5LlxyXG4gICAgICovXHJcbiAgICB0YXJnZXRJZCwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB2aWV3IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRpbmcgdGhlIGZpbmFsIG1lcmdlZCB0cnV0aCBvZiB3aGF0XHJcbiAgICAgKiBkb2NzIGFyZSBpbiB0aGUgcXVlcnkuIEl0IGdldHMgbm90aWZpZWQgb2YgbG9jYWwgYW5kIHJlbW90ZSBjaGFuZ2VzLFxyXG4gICAgICogYW5kIGFwcGxpZXMgdGhlIHF1ZXJ5IGZpbHRlcnMgYW5kIGxpbWl0cyB0byBkZXRlcm1pbmUgdGhlIG1vc3QgY29ycmVjdFxyXG4gICAgICogcG9zc2libGUgcmVzdWx0cy5cclxuICAgICAqL1xyXG4gICAgdmlldykge1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgIH1cclxufVxyXG4vKiogVHJhY2tzIGEgbGltYm8gcmVzb2x1dGlvbi4gKi9cclxuY2xhc3MgTGltYm9SZXNvbHV0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIG9uY2Ugd2UndmUgcmVjZWl2ZWQgYSBkb2N1bWVudC4gVGhpcyBpcyB1c2VkIGluXHJcbiAgICAgICAgICogZ2V0UmVtb3RlS2V5c0ZvclRhcmdldCgpIGFuZCB1bHRpbWF0ZWx5IHVzZWQgYnkgV2F0Y2hDaGFuZ2VBZ2dyZWdhdG9yIHRvXHJcbiAgICAgICAgICogZGVjaWRlIHdoZXRoZXIgaXQgbmVlZHMgdG8gbWFudWZhY3R1cmUgYSBkZWxldGUgZXZlbnQgZm9yIHRoZSB0YXJnZXQgb25jZVxyXG4gICAgICAgICAqIHRoZSB0YXJnZXQgaXMgQ1VSUkVOVC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlY2VpdmVkRG9jdW1lbnQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgYFN5bmNFbmdpbmVgIGNvb3JkaW5hdGluZyB3aXRoIG90aGVyIHBhcnRzIG9mIFNESy5cclxuICpcclxuICogVGhlIHBhcnRzIG9mIFN5bmNFbmdpbmUgdGhhdCBhY3QgYXMgYSBjYWxsYmFjayB0byBSZW1vdGVTdG9yZSBuZWVkIHRvIGJlXHJcbiAqIHJlZ2lzdGVyZWQgaW5kaXZpZHVhbGx5LiBUaGlzIGlzIGRvbmUgaW4gYHN5bmNFbmdpbmVXcml0ZSgpYCBhbmRcclxuICogYHN5bmNFbmdpbmVMaXN0ZW4oKWAgKGFzIHdlbGwgYXMgYGFwcGx5UHJpbWFyeVN0YXRlKClgKSBhcyB0aGVzZSBtZXRob2RzXHJcbiAqIHNlcnZlIGFzIGVudHJ5IHBvaW50cyB0byBSZW1vdGVTdG9yZSdzIGZ1bmN0aW9uYWxpdHkuXHJcbiAqXHJcbiAqIE5vdGU6IHNvbWUgZmllbGQgZGVmaW5lZCBpbiB0aGlzIGNsYXNzIG1pZ2h0IGhhdmUgcHVibGljIGFjY2VzcyBsZXZlbCwgYnV0XHJcbiAqIHRoZSBjbGFzcyBpcyBub3QgZXhwb3J0ZWQgc28gdGhleSBhcmUgb25seSBhY2Nlc3NpYmxlIGZyb20gdGhpcyBtb2R1bGUuXHJcbiAqIFRoaXMgaXMgdXNlZnVsIHRvIGltcGxlbWVudCBvcHRpb25hbCBmZWF0dXJlcyAobGlrZSBidW5kbGVzKSBpbiBmcmVlXHJcbiAqIGZ1bmN0aW9ucywgc3VjaCB0aGF0IHRoZXkgYXJlIHRyZWUtc2hha2VhYmxlLlxyXG4gKi9cclxuY2xhc3MgU3luY0VuZ2luZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IobG9jYWxTdG9yZSwgcmVtb3RlU3RvcmUsIGV2ZW50TWFuYWdlciwgXHJcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE1hbmFnZXMgc3RhdGUgc3luY2hyb25pemF0aW9uIGluIG11bHRpLXRhYiBlbnZpcm9ubWVudHMuXHJcbiAgICBzaGFyZWRDbGllbnRTdGF0ZSwgY3VycmVudFVzZXIsIG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gbG9jYWxTdG9yZTtcclxuICAgICAgICB0aGlzLnJlbW90ZVN0b3JlID0gcmVtb3RlU3RvcmU7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSA9IHNoYXJlZENsaWVudFN0YXRlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSBjdXJyZW50VXNlcjtcclxuICAgICAgICB0aGlzLm1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zID0gbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnM7XHJcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lTGlzdGVuZXIgPSB7fTtcclxuICAgICAgICB0aGlzLnF1ZXJ5Vmlld3NCeVF1ZXJ5ID0gbmV3IE9iamVjdE1hcChxID0+IGNhbm9uaWZ5UXVlcnkocSksIHF1ZXJ5RXF1YWxzKTtcclxuICAgICAgICB0aGlzLnF1ZXJpZXNCeVRhcmdldCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUga2V5cyBvZiBkb2N1bWVudHMgdGhhdCBhcmUgaW4gbGltYm8gZm9yIHdoaWNoIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYVxyXG4gICAgICAgICAqIGxpbWJvIHJlc29sdXRpb24gcXVlcnkuIFRoZSBzdHJpbmdzIGluIHRoaXMgc2V0IGFyZSB0aGUgcmVzdWx0IG9mIGNhbGxpbmdcclxuICAgICAgICAgKiBga2V5LnBhdGguY2Fub25pY2FsU3RyaW5nKClgIHdoZXJlIGBrZXlgIGlzIGEgYERvY3VtZW50S2V5YCBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGUgYFNldGAgdHlwZSB3YXMgY2hvc2VuIGJlY2F1c2UgaXQgcHJvdmlkZXMgZWZmaWNpZW50IGxvb2t1cCBhbmQgcmVtb3ZhbFxyXG4gICAgICAgICAqIG9mIGFyYml0cmFyeSBlbGVtZW50cyBhbmQgaXQgYWxzbyBtYWludGFpbnMgaW5zZXJ0aW9uIG9yZGVyLCBwcm92aWRpbmcgdGhlXHJcbiAgICAgICAgICogZGVzaXJlZCBxdWV1ZS1saWtlIEZJRk8gc2VtYW50aWNzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSB0YXJnZXQgSUQgZm9yIGVhY2ggZG9jdW1lbnQgdGhhdCBpcyBpbiBsaW1ibyB3aXRoIGFuXHJcbiAgICAgICAgICogYWN0aXZlIHRhcmdldC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5ID0gbmV3IFNvcnRlZE1hcChEb2N1bWVudEtleS5jb21wYXJhdG9yKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYW4gYWN0aXZlIGxpbWJvIHJlc29sdXRpb24gZm9yIGVhY2hcclxuICAgICAgICAgKiBhY3RpdmUgdGFyZ2V0IElEIHRoYXQgd2FzIHN0YXJ0ZWQgZm9yIHRoZSBwdXJwb3NlIG9mIGxpbWJvIHJlc29sdXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5saW1ib0RvY3VtZW50UmVmcyA9IG5ldyBSZWZlcmVuY2VTZXQoKTtcclxuICAgICAgICAvKiogU3RvcmVzIHVzZXIgY29tcGxldGlvbiBoYW5kbGVycywgaW5kZXhlZCBieSBVc2VyIGFuZCBCYXRjaElkLiAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25Vc2VyQ2FsbGJhY2tzID0ge307XHJcbiAgICAgICAgLyoqIFN0b3JlcyB1c2VyIGNhbGxiYWNrcyB3YWl0aW5nIGZvciBhbGwgcGVuZGluZyB3cml0ZXMgdG8gYmUgYWNrbm93bGVkZ2VkLiAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlc0NhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmxpbWJvVGFyZ2V0SWRHZW5lcmF0b3IgPSBUYXJnZXRJZEdlbmVyYXRvci5mb3JTeW5jRW5naW5lKCk7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVTdGF0ZSA9IFwiVW5rbm93blwiIC8qIFVua25vd24gKi87XHJcbiAgICAgICAgLy8gVGhlIHByaW1hcnkgc3RhdGUgaXMgc2V0IHRvIGB0cnVlYCBvciBgZmFsc2VgIGltbWVkaWF0ZWx5IGFmdGVyIEZpcmVzdG9yZVxyXG4gICAgICAgIC8vIHN0YXJ0dXAuIEluIHRoZSBpbnRlcmltLCBhIGNsaWVudCBzaG91bGQgb25seSBiZSBjb25zaWRlcmVkIHByaW1hcnkgaWZcclxuICAgICAgICAvLyBgaXNQcmltYXJ5YCBpcyB0cnVlLlxyXG4gICAgICAgIHRoaXMuX2lzUHJpbWFyeUNsaWVudCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGdldCBpc1ByaW1hcnlDbGllbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUHJpbWFyeUNsaWVudCA9PT0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdTeW5jRW5naW5lKGxvY2FsU3RvcmUsIHJlbW90ZVN0b3JlLCBldmVudE1hbmFnZXIsIFxyXG4vLyBQT1JUSU5HIE5PVEU6IE1hbmFnZXMgc3RhdGUgc3luY2hyb25pemF0aW9uIGluIG11bHRpLXRhYiBlbnZpcm9ubWVudHMuXHJcbnNoYXJlZENsaWVudFN0YXRlLCBjdXJyZW50VXNlciwgbWF4Q29uY3VycmVudExpbWJvUmVzb2x1dGlvbnMsIGlzUHJpbWFyeSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZSA9IG5ldyBTeW5jRW5naW5lSW1wbChsb2NhbFN0b3JlLCByZW1vdGVTdG9yZSwgZXZlbnRNYW5hZ2VyLCBzaGFyZWRDbGllbnRTdGF0ZSwgY3VycmVudFVzZXIsIG1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zKTtcclxuICAgIGlmIChpc1ByaW1hcnkpIHtcclxuICAgICAgICBzeW5jRW5naW5lLl9pc1ByaW1hcnlDbGllbnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN5bmNFbmdpbmU7XHJcbn1cclxuLyoqXHJcbiAqIEluaXRpYXRlcyB0aGUgbmV3IGxpc3RlbiwgcmVzb2x2ZXMgcHJvbWlzZSB3aGVuIGxpc3RlbiBlbnF1ZXVlZCB0byB0aGVcclxuICogc2VydmVyLiBBbGwgdGhlIHN1YnNlcXVlbnQgdmlldyBzbmFwc2hvdHMgb3IgZXJyb3JzIGFyZSBzZW50IHRvIHRoZVxyXG4gKiBzdWJzY3JpYmVkIGhhbmRsZXJzLiBSZXR1cm5zIHRoZSBpbml0aWFsIHNuYXBzaG90LlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUxpc3RlbihzeW5jRW5naW5lLCBxdWVyeSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lKTtcclxuICAgIGxldCB0YXJnZXRJZDtcclxuICAgIGxldCB2aWV3U25hcHNob3Q7XHJcbiAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xyXG4gICAgaWYgKHF1ZXJ5Vmlldykge1xyXG4gICAgICAgIC8vIFBPUlRJTkcgTk9URTogV2l0aCBNdWx0aS1UYWIgV2ViLCBpdCBpcyBwb3NzaWJsZSB0aGF0IGEgcXVlcnkgdmlld1xyXG4gICAgICAgIC8vIGFscmVhZHkgZXhpc3RzIHdoZW4gRXZlbnRNYW5hZ2VyIGNhbGxzIHVzIGZvciB0aGUgZmlyc3QgdGltZS4gVGhpc1xyXG4gICAgICAgIC8vIGhhcHBlbnMgd2hlbiB0aGUgcHJpbWFyeSB0YWIgaXMgYWxyZWFkeSBsaXN0ZW5pbmcgdG8gdGhpcyBxdWVyeSBvblxyXG4gICAgICAgIC8vIGJlaGFsZiBvZiBhbm90aGVyIHRhYiBhbmQgdGhlIHVzZXIgb2YgdGhlIHByaW1hcnkgYWxzbyBzdGFydHMgbGlzdGVuaW5nXHJcbiAgICAgICAgLy8gdG8gdGhlIHF1ZXJ5LiBFdmVudE1hbmFnZXIgd2lsbCBub3QgaGF2ZSBhbiBhc3NpZ25lZCB0YXJnZXQgSUQgaW4gdGhpc1xyXG4gICAgICAgIC8vIGNhc2UgYW5kIGNhbGxzIGBsaXN0ZW5gIHRvIG9idGFpbiB0aGlzIElELlxyXG4gICAgICAgIHRhcmdldElkID0gcXVlcnlWaWV3LnRhcmdldElkO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmFkZExvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgICAgIHZpZXdTbmFwc2hvdCA9IHF1ZXJ5Vmlldy52aWV3LmNvbXB1dGVJbml0aWFsU25hcHNob3QoKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSBhd2FpdCBsb2NhbFN0b3JlQWxsb2NhdGVUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlUb1RhcmdldChxdWVyeSkpO1xyXG4gICAgICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcclxuICAgICAgICAgICAgcmVtb3RlU3RvcmVMaXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdGF0dXMgPSBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5hZGRMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldERhdGEudGFyZ2V0SWQpO1xyXG4gICAgICAgIHRhcmdldElkID0gdGFyZ2V0RGF0YS50YXJnZXRJZDtcclxuICAgICAgICB2aWV3U25hcHNob3QgPSBhd2FpdCBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBzdGF0dXMgPT09ICdjdXJyZW50Jyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlld1NuYXBzaG90O1xyXG59XHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSB2aWV3IGZvciBhIHByZXZpb3VzbHkgdW5rbm93biBxdWVyeSBhbmQgY29tcHV0ZXMgaXRzIGluaXRpYWxcclxuICogc25hcHNob3QuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplVmlld0FuZENvbXB1dGVTbmFwc2hvdChzeW5jRW5naW5lSW1wbCwgcXVlcnksIHRhcmdldElkLCBjdXJyZW50KSB7XHJcbiAgICAvLyBQT1JUSU5HIE5PVEU6IE9uIFdlYiBvbmx5LCB3ZSBpbmplY3QgdGhlIGNvZGUgdGhhdCByZWdpc3RlcnMgbmV3IExpbWJvXHJcbiAgICAvLyB0YXJnZXRzIGJhc2VkIG9uIHZpZXcgY2hhbmdlcy4gVGhpcyBhbGxvd3MgdXMgdG8gb25seSBkZXBlbmQgb24gTGltYm9cclxuICAgIC8vIGNoYW5nZXMgd2hlbiB1c2VyIGNvZGUgaW5jbHVkZXMgcXVlcmllcy5cclxuICAgIHN5bmNFbmdpbmVJbXBsLmFwcGx5RG9jQ2hhbmdlcyA9IChxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KSA9PiBhcHBseURvY0NoYW5nZXMoc3luY0VuZ2luZUltcGwsIHF1ZXJ5VmlldywgY2hhbmdlcywgcmVtb3RlRXZlbnQpO1xyXG4gICAgY29uc3QgcXVlcnlSZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5LCBcclxuICAgIC8qIHVzZVByZXZpb3VzUmVzdWx0cz0gKi8gdHJ1ZSk7XHJcbiAgICBjb25zdCB2aWV3ID0gbmV3IFZpZXcocXVlcnksIHF1ZXJ5UmVzdWx0LnJlbW90ZUtleXMpO1xyXG4gICAgY29uc3Qgdmlld0RvY0NoYW5nZXMgPSB2aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKHF1ZXJ5UmVzdWx0LmRvY3VtZW50cyk7XHJcbiAgICBjb25zdCBzeW50aGVzaXplZFRhcmdldENoYW5nZSA9IFRhcmdldENoYW5nZS5jcmVhdGVTeW50aGVzaXplZFRhcmdldENoYW5nZUZvckN1cnJlbnRDaGFuZ2UodGFyZ2V0SWQsIGN1cnJlbnQgJiYgc3luY0VuZ2luZUltcGwub25saW5lU3RhdGUgIT09IFwiT2ZmbGluZVwiIC8qIE9mZmxpbmUgKi8pO1xyXG4gICAgY29uc3Qgdmlld0NoYW5nZSA9IHZpZXcuYXBwbHlDaGFuZ2VzKHZpZXdEb2NDaGFuZ2VzLCBcclxuICAgIC8qIHVwZGF0ZUxpbWJvRG9jdW1lbnRzPSAqLyBzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQsIHN5bnRoZXNpemVkVGFyZ2V0Q2hhbmdlKTtcclxuICAgIHVwZGF0ZVRyYWNrZWRMaW1ib3Moc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCB2aWV3Q2hhbmdlLmxpbWJvQ2hhbmdlcyk7XHJcbiAgICBjb25zdCBkYXRhID0gbmV3IFF1ZXJ5VmlldyhxdWVyeSwgdGFyZ2V0SWQsIHZpZXcpO1xyXG4gICAgc3luY0VuZ2luZUltcGwucXVlcnlWaWV3c0J5UXVlcnkuc2V0KHF1ZXJ5LCBkYXRhKTtcclxuICAgIGlmIChzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuaGFzKHRhcmdldElkKSkge1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5nZXQodGFyZ2V0SWQpLnB1c2gocXVlcnkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LnNldCh0YXJnZXRJZCwgW3F1ZXJ5XSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlld0NoYW5nZS5zbmFwc2hvdDtcclxufVxyXG4vKiogU3RvcHMgbGlzdGVuaW5nIHRvIHRoZSBxdWVyeS4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVVubGlzdGVuKHN5bmNFbmdpbmUsIHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGNvbnN0IHF1ZXJ5VmlldyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmdldChxdWVyeSk7XHJcbiAgICAvLyBPbmx5IGNsZWFuIHVwIHRoZSBxdWVyeSB2aWV3IGFuZCB0YXJnZXQgaWYgdGhpcyBpcyB0aGUgb25seSBxdWVyeSBtYXBwZWRcclxuICAgIC8vIHRvIHRoZSB0YXJnZXQuXHJcbiAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgaWYgKHF1ZXJpZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5zZXQocXVlcnlWaWV3LnRhcmdldElkLCBxdWVyaWVzLmZpbHRlcihxID0+ICFxdWVyeUVxdWFscyhxLCBxdWVyeSkpKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5kZWxldGUocXVlcnkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIE5vIG90aGVyIHF1ZXJpZXMgYXJlIG1hcHBlZCB0byB0aGUgdGFyZ2V0LCBjbGVhbiB1cCB0aGUgcXVlcnkgYW5kIHRoZSB0YXJnZXQuXHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGxvY2FsIHF1ZXJ5IHRhcmdldCBmaXJzdCB0byBhbGxvdyB1cyB0byB2ZXJpZnlcclxuICAgICAgICAvLyB3aGV0aGVyIGFueSBvdGhlciBjbGllbnQgaXMgc3RpbGwgaW50ZXJlc3RlZCBpbiB0aGlzIHRhcmdldC5cclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5yZW1vdmVMb2NhbFF1ZXJ5VGFyZ2V0KHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0UmVtYWluc0FjdGl2ZSA9IHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmlzQWN0aXZlUXVlcnlUYXJnZXQocXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgICAgICBpZiAoIXRhcmdldFJlbWFpbnNBY3RpdmUpIHtcclxuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnRhcmdldElkLCBcclxuICAgICAgICAgICAgLyprZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YT0qLyBmYWxzZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmNsZWFyUXVlcnlTdGF0ZShxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgcXVlcnlWaWV3LnRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHF1ZXJ5Vmlldy50YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVSZWxlYXNlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy50YXJnZXRJZCwgXHJcbiAgICAgICAgLyprZWVwUGVyc2lzdGVkVGFyZ2V0RGF0YT0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW5pdGlhdGVzIHRoZSB3cml0ZSBvZiBsb2NhbCBtdXRhdGlvbiBiYXRjaCB3aGljaCBpbnZvbHZlcyBhZGRpbmcgdGhlXHJcbiAqIHdyaXRlcyB0byB0aGUgbXV0YXRpb24gcXVldWUsIG5vdGlmeWluZyB0aGUgcmVtb3RlIHN0b3JlIGFib3V0IG5ld1xyXG4gKiBtdXRhdGlvbnMgYW5kIHJhaXNpbmcgZXZlbnRzIGZvciBhbnkgY2hhbmdlcyB0aGlzIHdyaXRlIGNhdXNlZC5cclxuICpcclxuICogVGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhpcyBjYWxsIGlzIHJlc29sdmVkIHdoZW4gdGhlIGFib3ZlIHN0ZXBzXHJcbiAqIGhhdmUgY29tcGxldGVkLCAqbm90KiB3aGVuIHRoZSB3cml0ZSB3YXMgYWNrZWQgYnkgdGhlIGJhY2tlbmQuIFRoZVxyXG4gKiB1c2VyQ2FsbGJhY2sgaXMgcmVzb2x2ZWQgb25jZSB0aGUgd3JpdGUgd2FzIGFja2VkL3JlamVjdGVkIGJ5IHRoZVxyXG4gKiBiYWNrZW5kIChvciBmYWlsZWQgbG9jYWxseSBmb3IgYW55IG90aGVyIHJlYXNvbikuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lV3JpdGUoc3luY0VuZ2luZSwgYmF0Y2gsIHVzZXJDYWxsYmFjaykge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3Moc3luY0VuZ2luZSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVXcml0ZUxvY2FsbHkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2gpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLmFkZFBlbmRpbmdNdXRhdGlvbihyZXN1bHQuYmF0Y2hJZCk7XHJcbiAgICAgICAgYWRkTXV0YXRpb25DYWxsYmFjayhzeW5jRW5naW5lSW1wbCwgcmVzdWx0LmJhdGNoSWQsIHVzZXJDYWxsYmFjayk7XHJcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVtaXROZXdTbmFwc0FuZE5vdGlmeUxvY2FsU3RvcmUoc3luY0VuZ2luZUltcGwsIHJlc3VsdC5jaGFuZ2VzKTtcclxuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZShzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIElmIHdlIGNhbid0IHBlcnNpc3QgdGhlIG11dGF0aW9uLCB3ZSByZWplY3QgdGhlIHVzZXIgY2FsbGJhY2sgYW5kXHJcbiAgICAgICAgLy8gZG9uJ3Qgc2VuZCB0aGUgbXV0YXRpb24uIFRoZSB1c2VyIGNhbiB0aGVuIHJldHJ5IHRoZSB3cml0ZS5cclxuICAgICAgICBjb25zdCBlcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBwZXJzaXN0IHdyaXRlYCk7XHJcbiAgICAgICAgdXNlckNhbGxiYWNrLnJlamVjdChlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgb25lIHJlbW90ZSBldmVudCB0byB0aGUgc3luYyBlbmdpbmUsIG5vdGlmeWluZyBhbnkgdmlld3Mgb2YgdGhlXHJcbiAqIGNoYW5nZXMsIGFuZCByZWxlYXNpbmcgYW55IHBlbmRpbmcgbXV0YXRpb24gYmF0Y2hlcyB0aGF0IHdvdWxkIGJlY29tZVxyXG4gKiB2aXNpYmxlIGJlY2F1c2Ugb2YgdGhlIHNuYXBzaG90IHZlcnNpb24gdGhlIHJlbW90ZSBldmVudCBjb250YWlucy5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVJlbW90ZUV2ZW50KHN5bmNFbmdpbmUsIHJlbW90ZUV2ZW50KSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGF3YWl0IGxvY2FsU3RvcmVBcHBseVJlbW90ZUV2ZW50VG9Mb2NhbENhY2hlKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHJlbW90ZUV2ZW50KTtcclxuICAgICAgICAvLyBVcGRhdGUgYHJlY2VpdmVkRG9jdW1lbnRgIGFzIGFwcHJvcHJpYXRlIGZvciBhbnkgbGltYm8gdGFyZ2V0cy5cclxuICAgICAgICByZW1vdGVFdmVudC50YXJnZXRDaGFuZ2VzLmZvckVhY2goKHRhcmdldENoYW5nZSwgdGFyZ2V0SWQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgICAgIGlmIChsaW1ib1Jlc29sdXRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBsaW1ibyByZXNvbHV0aW9uIGxvb2t1cCwgaXQncyBmb3IgYSBzaW5nbGUgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBpdCBjb3VsZCBiZSBhZGRlZCwgbW9kaWZpZWQsIG9yIHJlbW92ZWQsIGJ1dCBub3QgYSBjb21iaW5hdGlvbi5cclxuICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQodGFyZ2V0Q2hhbmdlLmFkZGVkRG9jdW1lbnRzLnNpemUgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENoYW5nZS5tb2RpZmllZERvY3VtZW50cy5zaXplICtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5zaXplIDw9XHJcbiAgICAgICAgICAgICAgICAgICAgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Q2hhbmdlLmFkZGVkRG9jdW1lbnRzLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0Q2hhbmdlLm1vZGlmaWVkRG9jdW1lbnRzLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFyZEFzc2VydChsaW1ib1Jlc29sdXRpb24ucmVjZWl2ZWREb2N1bWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRDaGFuZ2UucmVtb3ZlZERvY3VtZW50cy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhcmRBc3NlcnQobGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbWJvUmVzb2x1dGlvbi5yZWNlaXZlZERvY3VtZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdhcyBwcm9iYWJseSBqdXN0IGEgQ1VSUkVOVCB0YXJnZXRDaGFuZ2Ugb3Igc2ltaWxhci5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzLCByZW1vdGVFdmVudCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGFuIE9ubGluZVN0YXRlIGNoYW5nZSB0byB0aGUgc3luYyBlbmdpbmUgYW5kIG5vdGlmaWVzIGFueSB2aWV3cyBvZlxyXG4gKiB0aGUgY2hhbmdlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2Uoc3luY0VuZ2luZSwgb25saW5lU3RhdGUsIHNvdXJjZSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICAvLyBJZiB3ZSBhcmUgdGhlIHNlY29uZGFyeSBjbGllbnQsIHdlIGV4cGxpY2l0bHkgaWdub3JlIHRoZSByZW1vdGUgc3RvcmUnc1xyXG4gICAgLy8gb25saW5lIHN0YXRlICh0aGUgbG9jYWwgY2xpZW50IG1heSBnbyBvZmZsaW5lLCBldmVuIHRob3VnaCB0aGUgcHJpbWFyeVxyXG4gICAgLy8gdGFiIHJlbWFpbnMgb25saW5lKSBhbmQgb25seSBhcHBseSB0aGUgcHJpbWFyeSB0YWIncyBvbmxpbmUgc3RhdGUgZnJvbVxyXG4gICAgLy8gU2hhcmVkQ2xpZW50U3RhdGUuXHJcbiAgICBpZiAoKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCAmJlxyXG4gICAgICAgIHNvdXJjZSA9PT0gMCAvKiBSZW1vdGVTdG9yZSAqLykgfHxcclxuICAgICAgICAoIXN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCAmJlxyXG4gICAgICAgICAgICBzb3VyY2UgPT09IDEgLyogU2hhcmVkQ2xpZW50U3RhdGUgKi8pKSB7XHJcbiAgICAgICAgY29uc3QgbmV3Vmlld1NuYXBzaG90cyA9IFtdO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmZvckVhY2goKHF1ZXJ5LCBxdWVyeVZpZXcpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgdmlld0NoYW5nZSA9IHF1ZXJ5Vmlldy52aWV3LmFwcGx5T25saW5lU3RhdGVDaGFuZ2Uob25saW5lU3RhdGUpO1xyXG4gICAgICAgICAgICBpZiAodmlld0NoYW5nZS5zbmFwc2hvdCkge1xyXG4gICAgICAgICAgICAgICAgbmV3Vmlld1NuYXBzaG90cy5wdXNoKHZpZXdDaGFuZ2Uuc25hcHNob3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyT25PbmxpbmVTdGF0ZUNoYW5nZShzeW5jRW5naW5lSW1wbC5ldmVudE1hbmFnZXIsIG9ubGluZVN0YXRlKTtcclxuICAgICAgICBpZiAobmV3Vmlld1NuYXBzaG90cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc3luY0VuZ2luZUxpc3RlbmVyLm9uV2F0Y2hDaGFuZ2UobmV3Vmlld1NuYXBzaG90cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLm9ubGluZVN0YXRlID0gb25saW5lU3RhdGU7XHJcbiAgICAgICAgaWYgKHN5bmNFbmdpbmVJbXBsLmlzUHJpbWFyeUNsaWVudCkge1xyXG4gICAgICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5zZXRPbmxpbmVTdGF0ZShvbmxpbmVTdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWplY3RzIHRoZSBsaXN0ZW4gZm9yIHRoZSBnaXZlbiB0YXJnZXRJRC4gVGhpcyBjYW4gYmUgdHJpZ2dlcmVkIGJ5IHRoZVxyXG4gKiBiYWNrZW5kIGZvciBhbnkgYWN0aXZlIHRhcmdldC5cclxuICpcclxuICogQHBhcmFtIHN5bmNFbmdpbmUgLSBUaGUgc3luYyBlbmdpbmUgaW1wbGVtZW50YXRpb24uXHJcbiAqIEBwYXJhbSB0YXJnZXRJZCAtIFRoZSB0YXJnZXRJRCBjb3JyZXNwb25kcyB0byBvbmUgcHJldmlvdXNseSBpbml0aWF0ZWQgYnkgdGhlXHJcbiAqIHVzZXIgYXMgcGFydCBvZiBUYXJnZXREYXRhIHBhc3NlZCB0byBsaXN0ZW4oKSBvbiBSZW1vdGVTdG9yZS5cclxuICogQHBhcmFtIGVyciAtIEEgZGVzY3JpcHRpb24gb2YgdGhlIGNvbmRpdGlvbiB0aGF0IGhhcyBmb3JjZWQgdGhlIHJlamVjdGlvbi5cclxuICogTmVhcmx5IGFsd2F5cyB0aGlzIHdpbGwgYmUgYW4gaW5kaWNhdGlvbiB0aGF0IHRoZSB1c2VyIGlzIG5vIGxvbmdlclxyXG4gKiBhdXRob3JpemVkIHRvIHNlZSB0aGUgZGF0YSBtYXRjaGluZyB0aGUgdGFyZ2V0LlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZVJlamVjdExpc3RlbihzeW5jRW5naW5lLCB0YXJnZXRJZCwgZXJyKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIC8vIFBPUlRJTkcgTk9URTogTXVsdGktdGFiIG9ubHkuXHJcbiAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVRdWVyeVN0YXRlKHRhcmdldElkLCAncmVqZWN0ZWQnLCBlcnIpO1xyXG4gICAgY29uc3QgbGltYm9SZXNvbHV0aW9uID0gc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICBjb25zdCBsaW1ib0tleSA9IGxpbWJvUmVzb2x1dGlvbiAmJiBsaW1ib1Jlc29sdXRpb24ua2V5O1xyXG4gICAgaWYgKGxpbWJvS2V5KSB7XHJcbiAgICAgICAgLy8gVE9ETyhrbGltdCk6IFdlIHJlYWxseSBvbmx5IHNob3VsZCBkbyB0aGUgZm9sbG93aW5nIG9uIHBlcm1pc3Npb25cclxuICAgICAgICAvLyBkZW5pZWQgZXJyb3JzLCBidXQgd2UgZG9uJ3QgaGF2ZSB0aGUgY2F1c2UgY29kZSBoZXJlLlxyXG4gICAgICAgIC8vIEl0J3MgYSBsaW1ibyBkb2MuIENyZWF0ZSBhIHN5bnRoZXRpYyBldmVudCBzYXlpbmcgaXQgd2FzIGRlbGV0ZWQuXHJcbiAgICAgICAgLy8gVGhpcyBpcyBraW5kIG9mIGEgaGFjay4gSWRlYWxseSwgd2Ugd291bGQgaGF2ZSBhIG1ldGhvZCBpbiB0aGUgbG9jYWxcclxuICAgICAgICAvLyBzdG9yZSB0byBwdXJnZSBhIGRvY3VtZW50LiBIb3dldmVyLCBpdCB3b3VsZCBiZSB0cmlja3kgdG8ga2VlcCBhbGwgb2ZcclxuICAgICAgICAvLyB0aGUgbG9jYWwgc3RvcmUncyBpbnZhcmlhbnRzIHdpdGggYW5vdGhlciBtZXRob2QuXHJcbiAgICAgICAgbGV0IGRvY3VtZW50VXBkYXRlcyA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbiAgICAgICAgLy8gVE9ETyhiLzIxNzE4OTIxNik6IFRoaXMgbGltYm8gZG9jdW1lbnQgc2hvdWxkIGlkZWFsbHkgaGF2ZSBhIHJlYWQgdGltZSxcclxuICAgICAgICAvLyBzbyB0aGF0IGl0IGlzIHBpY2tlZCB1cCBieSBhbnkgcmVhZC10aW1lIGJhc2VkIHNjYW5zLiBUaGUgYmFja2VuZCxcclxuICAgICAgICAvLyBob3dldmVyLCBkb2VzIG5vdCBzZW5kIGEgcmVhZCB0aW1lIGZvciB0YXJnZXQgcmVtb3ZhbHMuXHJcbiAgICAgICAgZG9jdW1lbnRVcGRhdGVzID0gZG9jdW1lbnRVcGRhdGVzLmluc2VydChsaW1ib0tleSwgTXV0YWJsZURvY3VtZW50Lm5ld05vRG9jdW1lbnQobGltYm9LZXksIFNuYXBzaG90VmVyc2lvbi5taW4oKSkpO1xyXG4gICAgICAgIGNvbnN0IHJlc29sdmVkTGltYm9Eb2N1bWVudHMgPSBkb2N1bWVudEtleVNldCgpLmFkZChsaW1ib0tleSk7XHJcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUmVtb3RlRXZlbnQoU25hcHNob3RWZXJzaW9uLm1pbigpLCBcclxuICAgICAgICAvKiB0YXJnZXRDaGFuZ2VzPSAqLyBuZXcgTWFwKCksIFxyXG4gICAgICAgIC8qIHRhcmdldE1pc21hdGNoZXM9ICovIG5ldyBTb3J0ZWRTZXQocHJpbWl0aXZlQ29tcGFyYXRvciksIGRvY3VtZW50VXBkYXRlcywgcmVzb2x2ZWRMaW1ib0RvY3VtZW50cyk7XHJcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUFwcGx5UmVtb3RlRXZlbnQoc3luY0VuZ2luZUltcGwsIGV2ZW50KTtcclxuICAgICAgICAvLyBTaW5jZSB0aGlzIHF1ZXJ5IGZhaWxlZCwgd2Ugd29uJ3Qgd2FudCB0byBtYW51YWxseSB1bmxpc3RlbiB0byBpdC5cclxuICAgICAgICAvLyBXZSBvbmx5IHJlbW92ZSBpdCBmcm9tIGJvb2trZWVwaW5nIGFmdGVyIHdlIHN1Y2Nlc3NmdWxseSBhcHBsaWVkIHRoZVxyXG4gICAgICAgIC8vIFJlbW90ZUV2ZW50LiBJZiBgYXBwbHlSZW1vdGVFdmVudCgpYCB0aHJvd3MsIHdlIHdhbnQgdG8gcmUtbGlzdGVuIHRvXHJcbiAgICAgICAgLy8gdGhpcyBxdWVyeSB3aGVuIHRoZSBSZW1vdGVTdG9yZSByZXN0YXJ0cyB0aGUgV2F0Y2ggc3RyZWFtLCB3aGljaCBzaG91bGRcclxuICAgICAgICAvLyByZS10cmlnZ2VyIHRoZSB0YXJnZXQgZmFpbHVyZS5cclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LnJlbW92ZShsaW1ib0tleSk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmRlbGV0ZSh0YXJnZXRJZCk7XHJcbiAgICAgICAgcHVtcEVucXVldWVkTGltYm9SZXNvbHV0aW9ucyhzeW5jRW5naW5lSW1wbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlUmVsZWFzZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCwgXHJcbiAgICAgICAgLyoga2VlcFBlcnNpc3RlZFRhcmdldERhdGEgKi8gZmFsc2UpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCBlcnIpKVxyXG4gICAgICAgICAgICAuY2F0Y2goaWdub3JlSWZQcmltYXJ5TGVhc2VMb3NzKTtcclxuICAgIH1cclxufVxyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlTdWNjZXNzZnVsV3JpdGUoc3luY0VuZ2luZSwgbXV0YXRpb25CYXRjaFJlc3VsdCkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCBiYXRjaElkID0gbXV0YXRpb25CYXRjaFJlc3VsdC5iYXRjaC5iYXRjaElkO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gYXdhaXQgbG9jYWxTdG9yZUFja25vd2xlZGdlQmF0Y2goc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgbXV0YXRpb25CYXRjaFJlc3VsdCk7XHJcbiAgICAgICAgLy8gVGhlIGxvY2FsIHN0b3JlIG1heSBvciBtYXkgbm90IGJlIGFibGUgdG8gYXBwbHkgdGhlIHdyaXRlIHJlc3VsdCBhbmRcclxuICAgICAgICAvLyByYWlzZSBldmVudHMgaW1tZWRpYXRlbHkgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSB3YXRjaGVyIGlzIGNhdWdodFxyXG4gICAgICAgIC8vIHVwKSwgc28gd2UgcmFpc2UgdXNlciBjYWxsYmFja3MgZmlyc3Qgc28gdGhhdCB0aGV5IGNvbnNpc3RlbnRseSBoYXBwZW5cclxuICAgICAgICAvLyBiZWZvcmUgbGlzdGVuIGV2ZW50cy5cclxuICAgICAgICBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCAvKmVycm9yPSovIG51bGwpO1xyXG4gICAgICAgIHRyaWdnZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS51cGRhdGVNdXRhdGlvblN0YXRlKGJhdGNoSWQsICdhY2tub3dsZWRnZWQnKTtcclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgY2hhbmdlcyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBhd2FpdCBpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MoZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVSZWplY3RGYWlsZWRXcml0ZShzeW5jRW5naW5lLCBiYXRjaElkLCBlcnJvcikge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlUmVqZWN0QmF0Y2goc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgYmF0Y2hJZCk7XHJcbiAgICAgICAgLy8gVGhlIGxvY2FsIHN0b3JlIG1heSBvciBtYXkgbm90IGJlIGFibGUgdG8gYXBwbHkgdGhlIHdyaXRlIHJlc3VsdCBhbmRcclxuICAgICAgICAvLyByYWlzZSBldmVudHMgaW1tZWRpYXRlbHkgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSB3YXRjaGVyIGlzIGNhdWdodCB1cCksXHJcbiAgICAgICAgLy8gc28gd2UgcmFpc2UgdXNlciBjYWxsYmFja3MgZmlyc3Qgc28gdGhhdCB0aGV5IGNvbnNpc3RlbnRseSBoYXBwZW4gYmVmb3JlXHJcbiAgICAgICAgLy8gbGlzdGVuIGV2ZW50cy5cclxuICAgICAgICBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmVJbXBsLCBiYXRjaElkLCBlcnJvcik7XHJcbiAgICAgICAgdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnVwZGF0ZU11dGF0aW9uU3RhdGUoYmF0Y2hJZCwgJ3JlamVjdGVkJywgZXJyb3IpO1xyXG4gICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGF3YWl0IGlnbm9yZUlmUHJpbWFyeUxlYXNlTG9zcyhlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIHVzZXIgY2FsbGJhY2sgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBwZW5kaW5nIG11dGF0aW9ucyBhdCB0aGUgbW9tZW50IG9mIGNhbGxpbmdcclxuICogYXJlIGFja25vd2xlZGdlZCAuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lUmVnaXN0ZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2soc3luY0VuZ2luZSwgY2FsbGJhY2spIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgaWYgKCFjYW5Vc2VOZXR3b3JrKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlKSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ1RoZSBuZXR3b3JrIGlzIGRpc2FibGVkLiBUaGUgdGFzayByZXR1cm5lZCBieSAnICtcclxuICAgICAgICAgICAgXCInYXdhaXRQZW5kaW5nV3JpdGVzKCknIHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoZSBuZXR3b3JrIGlzIGVuYWJsZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBoaWdoZXN0QmF0Y2hJZCA9IGF3YWl0IGxvY2FsU3RvcmVHZXRIaWdoZXN0VW5hY2tub3dsZWRnZWRCYXRjaElkKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUpO1xyXG4gICAgICAgIGlmIChoaWdoZXN0QmF0Y2hJZCA9PT0gQkFUQ0hJRF9VTktOT1dOKSB7XHJcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkgaWYgdGhlcmUgaXMgbm8gcGVuZGluZyB3cml0ZXMgYXQgdGhlIG1vbWVudC5cclxuICAgICAgICAgICAgY2FsbGJhY2sucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHN5bmNFbmdpbmVJbXBsLnBlbmRpbmdXcml0ZXNDYWxsYmFja3MuZ2V0KGhpZ2hlc3RCYXRjaElkKSB8fCBbXTtcclxuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwucGVuZGluZ1dyaXRlc0NhbGxiYWNrcy5zZXQoaGlnaGVzdEJhdGNoSWQsIGNhbGxiYWNrcyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCAnSW5pdGlhbGl6YXRpb24gb2Ygd2FpdEZvclBlbmRpbmdXcml0ZXMoKSBvcGVyYXRpb24gZmFpbGVkJyk7XHJcbiAgICAgICAgY2FsbGJhY2sucmVqZWN0KGZpcmVzdG9yZUVycm9yKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVHJpZ2dlcnMgdGhlIGNhbGxiYWNrcyB0aGF0IGFyZSB3YWl0aW5nIGZvciB0aGlzIGJhdGNoIGlkIHRvIGdldCBhY2tub3dsZWRnZWQgYnkgc2VydmVyLFxyXG4gKiBpZiB0aGVyZSBhcmUgYW55LlxyXG4gKi9cclxuZnVuY3Rpb24gdHJpZ2dlclBlbmRpbmdXcml0ZXNDYWxsYmFja3Moc3luY0VuZ2luZUltcGwsIGJhdGNoSWQpIHtcclxuICAgIChzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmdldChiYXRjaElkKSB8fCBbXSkuZm9yRWFjaChjYWxsYmFjayA9PiB7XHJcbiAgICAgICAgY2FsbGJhY2sucmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmRlbGV0ZShiYXRjaElkKTtcclxufVxyXG4vKiogUmVqZWN0IGFsbCBvdXRzdGFuZGluZyBjYWxsYmFja3Mgd2FpdGluZyBmb3IgcGVuZGluZyB3cml0ZXMgdG8gY29tcGxldGUuICovXHJcbmZ1bmN0aW9uIHJlamVjdE91dHN0YW5kaW5nUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgZXJyb3JNZXNzYWdlKSB7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2tzID0+IHtcclxuICAgICAgICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5DQU5DRUxMRUQsIGVycm9yTWVzc2FnZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5wZW5kaW5nV3JpdGVzQ2FsbGJhY2tzLmNsZWFyKCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkTXV0YXRpb25DYWxsYmFjayhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCwgY2FsbGJhY2spIHtcclxuICAgIGxldCBuZXdDYWxsYmFja3MgPSBzeW5jRW5naW5lSW1wbC5tdXRhdGlvblVzZXJDYWxsYmFja3Nbc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIudG9LZXkoKV07XHJcbiAgICBpZiAoIW5ld0NhbGxiYWNrcykge1xyXG4gICAgICAgIG5ld0NhbGxiYWNrcyA9IG5ldyBTb3J0ZWRNYXAocHJpbWl0aXZlQ29tcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICBuZXdDYWxsYmFja3MgPSBuZXdDYWxsYmFja3MuaW5zZXJ0KGJhdGNoSWQsIGNhbGxiYWNrKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLm11dGF0aW9uVXNlckNhbGxiYWNrc1tzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlci50b0tleSgpXSA9XHJcbiAgICAgICAgbmV3Q2FsbGJhY2tzO1xyXG59XHJcbi8qKlxyXG4gKiBSZXNvbHZlcyBvciByZWplY3RzIHRoZSB1c2VyIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gYmF0Y2ggYW5kIHRoZW4gZGlzY2FyZHNcclxuICogaXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9jZXNzVXNlckNhbGxiYWNrKHN5bmNFbmdpbmUsIGJhdGNoSWQsIGVycm9yKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGxldCBuZXdDYWxsYmFja3MgPSBzeW5jRW5naW5lSW1wbC5tdXRhdGlvblVzZXJDYWxsYmFja3Nbc3luY0VuZ2luZUltcGwuY3VycmVudFVzZXIudG9LZXkoKV07XHJcbiAgICAvLyBOT1RFOiBNdXRhdGlvbnMgcmVzdG9yZWQgZnJvbSBwZXJzaXN0ZW5jZSB3b24ndCBoYXZlIGNhbGxiYWNrcywgc28gaXQnc1xyXG4gICAgLy8gb2theSBmb3IgdGhlcmUgdG8gYmUgbm8gY2FsbGJhY2sgZm9yIHRoaXMgSUQuXHJcbiAgICBpZiAobmV3Q2FsbGJhY2tzKSB7XHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBuZXdDYWxsYmFja3MuZ2V0KGJhdGNoSWQpO1xyXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3Q2FsbGJhY2tzID0gbmV3Q2FsbGJhY2tzLnJlbW92ZShiYXRjaElkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwubXV0YXRpb25Vc2VyQ2FsbGJhY2tzW3N5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLnRvS2V5KCldID1cclxuICAgICAgICAgICAgbmV3Q2FsbGJhY2tzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCBlcnJvciA9IG51bGwpIHtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnNoYXJlZENsaWVudFN0YXRlLnJlbW92ZUxvY2FsUXVlcnlUYXJnZXQodGFyZ2V0SWQpO1xyXG4gICAgZm9yIChjb25zdCBxdWVyeSBvZiBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZ2V0KHRhcmdldElkKSkge1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmRlbGV0ZShxdWVyeSk7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoRXJyb3IocXVlcnksIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzeW5jRW5naW5lSW1wbC5xdWVyaWVzQnlUYXJnZXQuZGVsZXRlKHRhcmdldElkKTtcclxuICAgIGlmIChzeW5jRW5naW5lSW1wbC5pc1ByaW1hcnlDbGllbnQpIHtcclxuICAgICAgICBjb25zdCBsaW1ib0tleXMgPSBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5yZW1vdmVSZWZlcmVuY2VzRm9ySWQodGFyZ2V0SWQpO1xyXG4gICAgICAgIGxpbWJvS2V5cy5mb3JFYWNoKGxpbWJvS2V5ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaXNSZWZlcmVuY2VkID0gc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMuY29udGFpbnNLZXkobGltYm9LZXkpO1xyXG4gICAgICAgICAgICBpZiAoIWlzUmVmZXJlbmNlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgcmVtb3ZlZCB0aGUgbGFzdCByZWZlcmVuY2UgZm9yIHRoaXMga2V5XHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaW1ib1RhcmdldChzeW5jRW5naW5lSW1wbCwgbGltYm9LZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlTGltYm9UYXJnZXQoc3luY0VuZ2luZUltcGwsIGtleSkge1xyXG4gICAgc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLmRlbGV0ZShrZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKSk7XHJcbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHRhcmdldCBhbHJlYWR5IGdvdCByZW1vdmVkIGJlY2F1c2UgdGhlIHF1ZXJ5IGZhaWxlZC4gSW4gdGhhdCBjYXNlLFxyXG4gICAgLy8gdGhlIGtleSB3b24ndCBleGlzdCBpbiBgbGltYm9UYXJnZXRzQnlLZXlgLiBPbmx5IGRvIHRoZSBjbGVhbnVwIGlmIHdlIHN0aWxsIGhhdmUgdGhlIHRhcmdldC5cclxuICAgIGNvbnN0IGxpbWJvVGFyZ2V0SWQgPSBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5nZXQoa2V5KTtcclxuICAgIGlmIChsaW1ib1RhcmdldElkID09PSBudWxsKSB7XHJcbiAgICAgICAgLy8gVGhpcyB0YXJnZXQgYWxyZWFkeSBnb3QgcmVtb3ZlZCwgYmVjYXVzZSB0aGUgcXVlcnkgZmFpbGVkLlxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIGxpbWJvVGFyZ2V0SWQpO1xyXG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkgPVxyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5LnJlbW92ZShrZXkpO1xyXG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmRlbGV0ZShsaW1ib1RhcmdldElkKTtcclxuICAgIHB1bXBFbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMoc3luY0VuZ2luZUltcGwpO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZVRyYWNrZWRMaW1ib3Moc3luY0VuZ2luZUltcGwsIHRhcmdldElkLCBsaW1ib0NoYW5nZXMpIHtcclxuICAgIGZvciAoY29uc3QgbGltYm9DaGFuZ2Ugb2YgbGltYm9DaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGxpbWJvQ2hhbmdlIGluc3RhbmNlb2YgQWRkZWRMaW1ib0RvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLmFkZFJlZmVyZW5jZShsaW1ib0NoYW5nZS5rZXksIHRhcmdldElkKTtcclxuICAgICAgICAgICAgdHJhY2tMaW1ib0NoYW5nZShzeW5jRW5naW5lSW1wbCwgbGltYm9DaGFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsaW1ib0NoYW5nZSBpbnN0YW5jZW9mIFJlbW92ZWRMaW1ib0RvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGxvZ0RlYnVnKExPR19UQUckMywgJ0RvY3VtZW50IG5vIGxvbmdlciBpbiBsaW1ibzogJyArIGxpbWJvQ2hhbmdlLmtleSk7XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLmxpbWJvRG9jdW1lbnRSZWZzLnJlbW92ZVJlZmVyZW5jZShsaW1ib0NoYW5nZS5rZXksIHRhcmdldElkKTtcclxuICAgICAgICAgICAgY29uc3QgaXNSZWZlcmVuY2VkID0gc3luY0VuZ2luZUltcGwubGltYm9Eb2N1bWVudFJlZnMuY29udGFpbnNLZXkobGltYm9DaGFuZ2Uua2V5KTtcclxuICAgICAgICAgICAgaWYgKCFpc1JlZmVyZW5jZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHJlbW92ZWQgdGhlIGxhc3QgcmVmZXJlbmNlIGZvciB0aGlzIGtleVxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlTGltYm9UYXJnZXQoc3luY0VuZ2luZUltcGwsIGxpbWJvQ2hhbmdlLmtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhY2tMaW1ib0NoYW5nZShzeW5jRW5naW5lSW1wbCwgbGltYm9DaGFuZ2UpIHtcclxuICAgIGNvbnN0IGtleSA9IGxpbWJvQ2hhbmdlLmtleTtcclxuICAgIGNvbnN0IGtleVN0cmluZyA9IGtleS5wYXRoLmNhbm9uaWNhbFN0cmluZygpO1xyXG4gICAgaWYgKCFzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleS5nZXQoa2V5KSAmJlxyXG4gICAgICAgICFzeW5jRW5naW5lSW1wbC5lbnF1ZXVlZExpbWJvUmVzb2x1dGlvbnMuaGFzKGtleVN0cmluZykpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdOZXcgZG9jdW1lbnQgaW4gbGltYm86ICcgKyBrZXkpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5hZGQoa2V5U3RyaW5nKTtcclxuICAgICAgICBwdW1wRW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zKHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3RhcnRzIGxpc3RlbnMgZm9yIGRvY3VtZW50cyBpbiBsaW1ibyB0aGF0IGFyZSBlbnF1ZXVlZCBmb3IgcmVzb2x1dGlvbixcclxuICogc3ViamVjdCB0byBhIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVzb2x1dGlvbnMuXHJcbiAqXHJcbiAqIFdpdGhvdXQgYm91bmRpbmcgdGhlIG51bWJlciBvZiBjb25jdXJyZW50IHJlc29sdXRpb25zLCB0aGUgc2VydmVyIGNhbiBmYWlsXHJcbiAqIHdpdGggXCJyZXNvdXJjZSBleGhhdXN0ZWRcIiBlcnJvcnMgd2hpY2ggY2FuIGxlYWQgdG8gcGF0aG9sb2dpY2FsIGNsaWVudFxyXG4gKiBiZWhhdmlvciBhcyBzZWVuIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzI2ODMuXHJcbiAqL1xyXG5mdW5jdGlvbiBwdW1wRW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zKHN5bmNFbmdpbmVJbXBsKSB7XHJcbiAgICB3aGlsZSAoc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zLnNpemUgPiAwICYmXHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9UYXJnZXRzQnlLZXkuc2l6ZSA8XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLm1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zKSB7XHJcbiAgICAgICAgY29uc3Qga2V5U3RyaW5nID0gc3luY0VuZ2luZUltcGwuZW5xdWV1ZWRMaW1ib1Jlc29sdXRpb25zXHJcbiAgICAgICAgICAgIC52YWx1ZXMoKVxyXG4gICAgICAgICAgICAubmV4dCgpLnZhbHVlO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmVucXVldWVkTGltYm9SZXNvbHV0aW9ucy5kZWxldGUoa2V5U3RyaW5nKTtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcoa2V5U3RyaW5nKSk7XHJcbiAgICAgICAgY29uc3QgbGltYm9UYXJnZXRJZCA9IHN5bmNFbmdpbmVJbXBsLmxpbWJvVGFyZ2V0SWRHZW5lcmF0b3IubmV4dCgpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvUmVzb2x1dGlvbnNCeVRhcmdldC5zZXQobGltYm9UYXJnZXRJZCwgbmV3IExpbWJvUmVzb2x1dGlvbihrZXkpKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVJbXBsLmFjdGl2ZUxpbWJvVGFyZ2V0c0J5S2V5Lmluc2VydChrZXksIGxpbWJvVGFyZ2V0SWQpO1xyXG4gICAgICAgIHJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCBuZXcgVGFyZ2V0RGF0YShxdWVyeVRvVGFyZ2V0KG5ld1F1ZXJ5Rm9yUGF0aChrZXkucGF0aCkpLCBsaW1ib1RhcmdldElkLCAyIC8qIExpbWJvUmVzb2x1dGlvbiAqLywgTGlzdGVuU2VxdWVuY2UuSU5WQUxJRCkpO1xyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmUsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGNvbnN0IG5ld1NuYXBzID0gW107XHJcbiAgICBjb25zdCBkb2NDaGFuZ2VzSW5BbGxWaWV3cyA9IFtdO1xyXG4gICAgY29uc3QgcXVlcmllc1Byb2Nlc3NlZCA9IFtdO1xyXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmlzRW1wdHkoKSkge1xyXG4gICAgICAgIC8vIFJldHVybiBlYXJseSBzaW5jZSBgb25XYXRjaENoYW5nZSgpYCBtaWdodCBub3QgaGF2ZSBiZWVuIGFzc2lnbmVkIHlldC5cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5mb3JFYWNoKChfLCBxdWVyeVZpZXcpID0+IHtcclxuICAgICAgICBxdWVyaWVzUHJvY2Vzc2VkLnB1c2goc3luY0VuZ2luZUltcGxcclxuICAgICAgICAgICAgLmFwcGx5RG9jQ2hhbmdlcyhxdWVyeVZpZXcsIGNoYW5nZXMsIHJlbW90ZUV2ZW50KVxyXG4gICAgICAgICAgICAudGhlbih2aWV3U25hcHNob3QgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmlld1NuYXBzaG90KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUudXBkYXRlUXVlcnlTdGF0ZShxdWVyeVZpZXcudGFyZ2V0SWQsIHZpZXdTbmFwc2hvdC5mcm9tQ2FjaGUgPyAnbm90LWN1cnJlbnQnIDogJ2N1cnJlbnQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ld1NuYXBzLnB1c2godmlld1NuYXBzaG90KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSBMb2NhbFZpZXdDaGFuZ2VzLmZyb21TbmFwc2hvdChxdWVyeVZpZXcudGFyZ2V0SWQsIHZpZXdTbmFwc2hvdCk7XHJcbiAgICAgICAgICAgICAgICBkb2NDaGFuZ2VzSW5BbGxWaWV3cy5wdXNoKGRvY0NoYW5nZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfSk7XHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChxdWVyaWVzUHJvY2Vzc2VkKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoQ2hhbmdlKG5ld1NuYXBzKTtcclxuICAgIGF3YWl0IGxvY2FsU3RvcmVOb3RpZnlMb2NhbFZpZXdDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIGRvY0NoYW5nZXNJbkFsbFZpZXdzKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBhcHBseURvY0NoYW5nZXMoc3luY0VuZ2luZUltcGwsIHF1ZXJ5VmlldywgY2hhbmdlcywgcmVtb3RlRXZlbnQpIHtcclxuICAgIGxldCB2aWV3RG9jQ2hhbmdlcyA9IHF1ZXJ5Vmlldy52aWV3LmNvbXB1dGVEb2NDaGFuZ2VzKGNoYW5nZXMpO1xyXG4gICAgaWYgKHZpZXdEb2NDaGFuZ2VzLm5lZWRzUmVmaWxsKSB7XHJcbiAgICAgICAgLy8gVGhlIHF1ZXJ5IGhhcyBhIGxpbWl0IGFuZCBzb21lIGRvY3Mgd2VyZSByZW1vdmVkLCBzbyB3ZSBuZWVkXHJcbiAgICAgICAgLy8gdG8gcmUtcnVuIHRoZSBxdWVyeSBhZ2FpbnN0IHRoZSBsb2NhbCBzdG9yZSB0byBtYWtlIHN1cmUgd2VcclxuICAgICAgICAvLyBkaWRuJ3QgbG9zZSBhbnkgZ29vZCBkb2NzIHRoYXQgaGFkIGJlZW4gcGFzdCB0aGUgbGltaXQuXHJcbiAgICAgICAgdmlld0RvY0NoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlRXhlY3V0ZVF1ZXJ5KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5Vmlldy5xdWVyeSwgXHJcbiAgICAgICAgLyogdXNlUHJldmlvdXNSZXN1bHRzPSAqLyBmYWxzZSkudGhlbigoeyBkb2N1bWVudHMgfSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gcXVlcnlWaWV3LnZpZXcuY29tcHV0ZURvY0NoYW5nZXMoZG9jdW1lbnRzLCB2aWV3RG9jQ2hhbmdlcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YXJnZXRDaGFuZ2UgPSByZW1vdGVFdmVudCAmJiByZW1vdGVFdmVudC50YXJnZXRDaGFuZ2VzLmdldChxdWVyeVZpZXcudGFyZ2V0SWQpO1xyXG4gICAgY29uc3Qgdmlld0NoYW5nZSA9IHF1ZXJ5Vmlldy52aWV3LmFwcGx5Q2hhbmdlcyh2aWV3RG9jQ2hhbmdlcywgXHJcbiAgICAvKiB1cGRhdGVMaW1ib0RvY3VtZW50cz0gKi8gc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50LCB0YXJnZXRDaGFuZ2UpO1xyXG4gICAgdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkLCB2aWV3Q2hhbmdlLmxpbWJvQ2hhbmdlcyk7XHJcbiAgICByZXR1cm4gdmlld0NoYW5nZS5zbmFwc2hvdDtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lSGFuZGxlQ3JlZGVudGlhbENoYW5nZShzeW5jRW5naW5lLCB1c2VyKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGNvbnN0IHVzZXJDaGFuZ2VkID0gIXN5bmNFbmdpbmVJbXBsLmN1cnJlbnRVc2VyLmlzRXF1YWwodXNlcik7XHJcbiAgICBpZiAodXNlckNoYW5nZWQpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdVc2VyIGNoYW5nZS4gTmV3IHVzZXI6JywgdXNlci50b0tleSgpKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2NhbFN0b3JlSGFuZGxlVXNlckNoYW5nZShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB1c2VyKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5jdXJyZW50VXNlciA9IHVzZXI7XHJcbiAgICAgICAgLy8gRmFpbHMgdGFza3Mgd2FpdGluZyBmb3IgcGVuZGluZyB3cml0ZXMgcmVxdWVzdGVkIGJ5IHByZXZpb3VzIHVzZXIuXHJcbiAgICAgICAgcmVqZWN0T3V0c3RhbmRpbmdQZW5kaW5nV3JpdGVzQ2FsbGJhY2tzKHN5bmNFbmdpbmVJbXBsLCBcIid3YWl0Rm9yUGVuZGluZ1dyaXRlcycgcHJvbWlzZSBpcyByZWplY3RlZCBkdWUgdG8gYSB1c2VyIGNoYW5nZS5cIik7XHJcbiAgICAgICAgLy8gVE9ETyhiLzExNDIyNjQxNyk6IENvbnNpZGVyIGNhbGxpbmcgdGhpcyBvbmx5IGluIHRoZSBwcmltYXJ5IHRhYi5cclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5oYW5kbGVVc2VyQ2hhbmdlKHVzZXIsIHJlc3VsdC5yZW1vdmVkQmF0Y2hJZHMsIHJlc3VsdC5hZGRlZEJhdGNoSWRzKTtcclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgcmVzdWx0LmFmZmVjdGVkRG9jdW1lbnRzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jRW5naW5lR2V0UmVtb3RlS2V5c0ZvclRhcmdldChzeW5jRW5naW5lLCB0YXJnZXRJZCkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCBsaW1ib1Jlc29sdXRpb24gPSBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQuZ2V0KHRhcmdldElkKTtcclxuICAgIGlmIChsaW1ib1Jlc29sdXRpb24gJiYgbGltYm9SZXNvbHV0aW9uLnJlY2VpdmVkRG9jdW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnRLZXlTZXQoKS5hZGQobGltYm9SZXNvbHV0aW9uLmtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQga2V5U2V0ID0gZG9jdW1lbnRLZXlTZXQoKTtcclxuICAgICAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgaWYgKCFxdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXlTZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xyXG4gICAgICAgICAgICBjb25zdCBxdWVyeVZpZXcgPSBzeW5jRW5naW5lSW1wbC5xdWVyeVZpZXdzQnlRdWVyeS5nZXQocXVlcnkpO1xyXG4gICAgICAgICAgICBrZXlTZXQgPSBrZXlTZXQudW5pb25XaXRoKHF1ZXJ5Vmlldy52aWV3LnN5bmNlZERvY3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXlTZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlY29uY2lsZSB0aGUgbGlzdCBvZiBzeW5jZWQgZG9jdW1lbnRzIGluIGFuIGV4aXN0aW5nIHZpZXcgd2l0aCB0aG9zZVxyXG4gKiBmcm9tIHBlcnNpc3RlbmNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3luY2hyb25pemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmUsIHF1ZXJ5Vmlldykge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCBxdWVyeVJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgcXVlcnlWaWV3LnF1ZXJ5LCBcclxuICAgIC8qIHVzZVByZXZpb3VzUmVzdWx0cz0gKi8gdHJ1ZSk7XHJcbiAgICBjb25zdCB2aWV3U25hcHNob3QgPSBxdWVyeVZpZXcudmlldy5zeW5jaHJvbml6ZVdpdGhQZXJzaXN0ZWRTdGF0ZShxdWVyeVJlc3VsdCk7XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwuaXNQcmltYXJ5Q2xpZW50KSB7XHJcbiAgICAgICAgdXBkYXRlVHJhY2tlZExpbWJvcyhzeW5jRW5naW5lSW1wbCwgcXVlcnlWaWV3LnRhcmdldElkLCB2aWV3U25hcHNob3QubGltYm9DaGFuZ2VzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2aWV3U25hcHNob3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBuZXdseSBjaGFuZ2VkIGRvY3VtZW50cyBmcm9tIHJlbW90ZSBkb2N1bWVudCBjYWNoZSBhbmQgcmFpc2VzXHJcbiAqIHNuYXBzaG90cyBpZiBuZWVkZWQuXHJcbiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lU3luY2hyb25pemVXaXRoQ2hhbmdlZERvY3VtZW50cyhzeW5jRW5naW5lKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlR2V0TmV3RG9jdW1lbnRDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUpLnRoZW4oY2hhbmdlcyA9PiBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lSW1wbCwgY2hhbmdlcykpO1xyXG59XHJcbi8qKiBBcHBsaWVzIGEgbXV0YXRpb24gc3RhdGUgdG8gYW4gZXhpc3RpbmcgYmF0Y2guICAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5hc3luYyBmdW5jdGlvbiBzeW5jRW5naW5lQXBwbHlCYXRjaFN0YXRlKHN5bmNFbmdpbmUsIGJhdGNoSWQsIGJhdGNoU3RhdGUsIGVycm9yKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIGNvbnN0IGRvY3VtZW50cyA9IGF3YWl0IGxvY2FsU3RvcmVMb29rdXBNdXRhdGlvbkRvY3VtZW50cyhzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBiYXRjaElkKTtcclxuICAgIGlmIChkb2N1bWVudHMgPT09IG51bGwpIHtcclxuICAgICAgICAvLyBBIHRocm90dGxlZCB0YWIgbWF5IG5vdCBoYXZlIHNlZW4gdGhlIG11dGF0aW9uIGJlZm9yZSBpdCB3YXMgY29tcGxldGVkXHJcbiAgICAgICAgLy8gYW5kIHJlbW92ZWQgZnJvbSB0aGUgbXV0YXRpb24gcXVldWUsIGluIHdoaWNoIGNhc2Ugd2Ugd29uJ3QgaGF2ZSBjYWNoZWRcclxuICAgICAgICAvLyB0aGUgYWZmZWN0ZWQgZG9jdW1lbnRzLiBJbiB0aGlzIGNhc2Ugd2UgY2FuIHNhZmVseSBpZ25vcmUgdGhlIHVwZGF0ZVxyXG4gICAgICAgIC8vIHNpbmNlIHRoYXQgbWVhbnMgd2UgZGlkbid0IGFwcGx5IHRoZSBtdXRhdGlvbiBsb2NhbGx5IGF0IGFsbCAoaWYgd2VcclxuICAgICAgICAvLyBoYWQsIHdlIHdvdWxkIGhhdmUgY2FjaGVkIHRoZSBhZmZlY3RlZCBkb2N1bWVudHMpLCBhbmQgc28gd2Ugd2lsbCBqdXN0XHJcbiAgICAgICAgLy8gc2VlIGFueSByZXN1bHRpbmcgZG9jdW1lbnQgY2hhbmdlcyB2aWEgbm9ybWFsIHJlbW90ZSBkb2N1bWVudCB1cGRhdGVzXHJcbiAgICAgICAgLy8gYXMgYXBwbGljYWJsZS5cclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdDYW5ub3QgYXBwbHkgbXV0YXRpb24gYmF0Y2ggd2l0aCBpZDogJyArIGJhdGNoSWQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChiYXRjaFN0YXRlID09PSAncGVuZGluZycpIHtcclxuICAgICAgICAvLyBJZiB3ZSBhcmUgdGhlIHByaW1hcnkgY2xpZW50LCB3ZSBuZWVkIHRvIHNlbmQgdGhpcyB3cml0ZSB0byB0aGVcclxuICAgICAgICAvLyBiYWNrZW5kLiBTZWNvbmRhcnkgY2xpZW50cyB3aWxsIGlnbm9yZSB0aGVzZSB3cml0ZXMgc2luY2UgdGhlaXIgcmVtb3RlXHJcbiAgICAgICAgLy8gY29ubmVjdGlvbiBpcyBkaXNhYmxlZC5cclxuICAgICAgICBhd2FpdCBmaWxsV3JpdGVQaXBlbGluZShzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiYXRjaFN0YXRlID09PSAnYWNrbm93bGVkZ2VkJyB8fCBiYXRjaFN0YXRlID09PSAncmVqZWN0ZWQnKSB7XHJcbiAgICAgICAgLy8gTk9URTogQm90aCB0aGVzZSBtZXRob2RzIGFyZSBuby1vcHMgZm9yIGJhdGNoZXMgdGhhdCBvcmlnaW5hdGVkIGZyb21cclxuICAgICAgICAvLyBvdGhlciBjbGllbnRzLlxyXG4gICAgICAgIHByb2Nlc3NVc2VyQ2FsbGJhY2soc3luY0VuZ2luZUltcGwsIGJhdGNoSWQsIGVycm9yID8gZXJyb3IgOiBudWxsKTtcclxuICAgICAgICB0cmlnZ2VyUGVuZGluZ1dyaXRlc0NhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCwgYmF0Y2hJZCk7XHJcbiAgICAgICAgbG9jYWxTdG9yZVJlbW92ZUNhY2hlZE11dGF0aW9uQmF0Y2hNZXRhZGF0YShzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCBiYXRjaElkKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhaWwoKTtcclxuICAgIH1cclxuICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBkb2N1bWVudHMpO1xyXG59XHJcbi8qKiBBcHBsaWVzIGEgcXVlcnkgdGFyZ2V0IGNoYW5nZSBmcm9tIGEgZGlmZmVyZW50IHRhYi4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuYXN5bmMgZnVuY3Rpb24gc3luY0VuZ2luZUFwcGx5UHJpbWFyeVN0YXRlKHN5bmNFbmdpbmUsIGlzUHJpbWFyeSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBlbnN1cmVXYXRjaENhbGxiYWNrcyhzeW5jRW5naW5lSW1wbCk7XHJcbiAgICBzeW5jRW5naW5lRW5zdXJlV3JpdGVDYWxsYmFja3Moc3luY0VuZ2luZUltcGwpO1xyXG4gICAgaWYgKGlzUHJpbWFyeSA9PT0gdHJ1ZSAmJiBzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgLy8gU2Vjb25kYXJ5IHRhYnMgb25seSBtYWludGFpbiBWaWV3cyBmb3IgdGhlaXIgbG9jYWwgbGlzdGVuZXJzIGFuZCB0aGVcclxuICAgICAgICAvLyBWaWV3cyBpbnRlcm5hbCBzdGF0ZSBtYXkgbm90IGJlIDEwMCUgcG9wdWxhdGVkIChpbiBwYXJ0aWN1bGFyXHJcbiAgICAgICAgLy8gc2Vjb25kYXJ5IHRhYnMgZG9uJ3QgdHJhY2sgc3luY2VkRG9jdW1lbnRzLCB0aGUgc2V0IG9mIGRvY3VtZW50cyB0aGVcclxuICAgICAgICAvLyBzZXJ2ZXIgY29uc2lkZXJzIHRvIGJlIGluIHRoZSB0YXJnZXQpLiBTbyB3aGVuIGEgc2Vjb25kYXJ5IGJlY29tZXNcclxuICAgICAgICAvLyBwcmltYXJ5LCB3ZSBuZWVkIHRvIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHZpZXdzIGZvciBhbGwgdGFyZ2V0c1xyXG4gICAgICAgIC8vIG1hdGNoIHRoZSBzdGF0ZSBvbiBkaXNrLlxyXG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhcmdldHMgPSBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5nZXRBbGxBY3RpdmVRdWVyeVRhcmdldHMoKTtcclxuICAgICAgICBjb25zdCBhY3RpdmVRdWVyaWVzID0gYXdhaXQgc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZUltcGwsIGFjdGl2ZVRhcmdldHMudG9BcnJheSgpKTtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50ID0gdHJ1ZTtcclxuICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUFwcGx5UHJpbWFyeVN0YXRlKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0cnVlKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldERhdGEgb2YgYWN0aXZlUXVlcmllcykge1xyXG4gICAgICAgICAgICByZW1vdGVTdG9yZUxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdGFyZ2V0RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQcmltYXJ5ID09PSBmYWxzZSAmJiBzeW5jRW5naW5lSW1wbC5faXNQcmltYXJ5Q2xpZW50ICE9PSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IGFjdGl2ZVRhcmdldHMgPSBbXTtcclxuICAgICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5mb3JFYWNoKChfLCB0YXJnZXRJZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3luY0VuZ2luZUltcGwuc2hhcmVkQ2xpZW50U3RhdGUuaXNMb2NhbFF1ZXJ5VGFyZ2V0KHRhcmdldElkKSkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlVGFyZ2V0cy5wdXNoKHRhcmdldElkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHAgPSBwLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFuZENsZWFudXBUYXJnZXQoc3luY0VuZ2luZUltcGwsIHRhcmdldElkKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8qa2VlcFBlcnNpc3RlZFRhcmdldERhdGE9Ki8gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZW1vdGVTdG9yZVVubGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXdhaXQgcDtcclxuICAgICAgICBhd2FpdCBzeW5jaHJvbml6ZVF1ZXJ5Vmlld3NBbmRSYWlzZVNuYXBzaG90cyhzeW5jRW5naW5lSW1wbCwgYWN0aXZlVGFyZ2V0cyk7XHJcbiAgICAgICAgcmVzZXRMaW1ib0RvY3VtZW50cyhzeW5jRW5naW5lSW1wbCk7XHJcbiAgICAgICAgc3luY0VuZ2luZUltcGwuX2lzUHJpbWFyeUNsaWVudCA9IGZhbHNlO1xyXG4gICAgICAgIGF3YWl0IHJlbW90ZVN0b3JlQXBwbHlQcmltYXJ5U3RhdGUoc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIGZhbHNlKTtcclxuICAgIH1cclxufVxyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5mdW5jdGlvbiByZXNldExpbWJvRG9jdW1lbnRzKHN5bmNFbmdpbmUpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgc3luY0VuZ2luZUltcGwuYWN0aXZlTGltYm9SZXNvbHV0aW9uc0J5VGFyZ2V0LmZvckVhY2goKF8sIHRhcmdldElkKSA9PiB7XHJcbiAgICAgICAgcmVtb3RlU3RvcmVVbmxpc3RlbihzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZSwgdGFyZ2V0SWQpO1xyXG4gICAgfSk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5saW1ib0RvY3VtZW50UmVmcy5yZW1vdmVBbGxSZWZlcmVuY2VzKCk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1Jlc29sdXRpb25zQnlUYXJnZXQgPSBuZXcgTWFwKCk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5hY3RpdmVMaW1ib1RhcmdldHNCeUtleSA9IG5ldyBTb3J0ZWRNYXAoRG9jdW1lbnRLZXkuY29tcGFyYXRvcik7XHJcbn1cclxuLyoqXHJcbiAqIFJlY29uY2lsZSB0aGUgcXVlcnkgdmlld3Mgb2YgdGhlIHByb3ZpZGVkIHF1ZXJ5IHRhcmdldHMgd2l0aCB0aGUgc3RhdGUgZnJvbVxyXG4gKiBwZXJzaXN0ZW5jZS4gUmFpc2VzIHNuYXBzaG90cyBmb3IgYW55IGNoYW5nZXMgdGhhdCBhZmZlY3QgdGhlIGxvY2FsXHJcbiAqIGNsaWVudCBhbmQgcmV0dXJucyB0aGUgdXBkYXRlZCBzdGF0ZSBvZiBhbGwgdGFyZ2V0J3MgcXVlcnkgZGF0YS5cclxuICpcclxuICogQHBhcmFtIHN5bmNFbmdpbmUgLSBUaGUgc3luYyBlbmdpbmUgaW1wbGVtZW50YXRpb25cclxuICogQHBhcmFtIHRhcmdldHMgLSB0aGUgbGlzdCBvZiB0YXJnZXRzIHdpdGggdmlld3MgdGhhdCBuZWVkIHRvIGJlIHJlY29tcHV0ZWRcclxuICogQHBhcmFtIHRyYW5zaXRpb25Ub1ByaW1hcnkgLSBgdHJ1ZWAgaWZmIHRoZSB0YWIgdHJhbnNpdGlvbnMgZnJvbSBhIHNlY29uZGFyeVxyXG4gKiB0YWIgdG8gYSBwcmltYXJ5IHRhYlxyXG4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuYXN5bmMgZnVuY3Rpb24gc3luY2hyb25pemVRdWVyeVZpZXdzQW5kUmFpc2VTbmFwc2hvdHMoc3luY0VuZ2luZSwgdGFyZ2V0cywgdHJhbnNpdGlvblRvUHJpbWFyeSkge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICBjb25zdCBhY3RpdmVRdWVyaWVzID0gW107XHJcbiAgICBjb25zdCBuZXdWaWV3U25hcHNob3RzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIHRhcmdldHMpIHtcclxuICAgICAgICBsZXQgdGFyZ2V0RGF0YTtcclxuICAgICAgICBjb25zdCBxdWVyaWVzID0gc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0LmdldCh0YXJnZXRJZCk7XHJcbiAgICAgICAgaWYgKHF1ZXJpZXMgJiYgcXVlcmllcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgLy8gRm9yIHF1ZXJpZXMgdGhhdCBoYXZlIGEgbG9jYWwgVmlldywgd2UgZmV0Y2ggdGhlaXIgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgICAgICAvLyBmcm9tIExvY2FsU3RvcmUgKGFzIHRoZSByZXN1bWUgdG9rZW4gYW5kIHRoZSBzbmFwc2hvdCB2ZXJzaW9uXHJcbiAgICAgICAgICAgIC8vIG1pZ2h0IGhhdmUgY2hhbmdlZCkgYW5kIHJlY29uY2lsZSB0aGVpciB2aWV3cyB3aXRoIHRoZSBwZXJzaXN0ZWRcclxuICAgICAgICAgICAgLy8gc3RhdGUgKHRoZSBsaXN0IG9mIHN5bmNlZERvY3VtZW50cyBtYXkgaGF2ZSBnb3R0ZW4gb3V0IG9mIHN5bmMpLlxyXG4gICAgICAgICAgICB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHF1ZXJ5VG9UYXJnZXQocXVlcmllc1swXSkpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5IG9mIHF1ZXJpZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VmlldyA9IHN5bmNFbmdpbmVJbXBsLnF1ZXJ5Vmlld3NCeVF1ZXJ5LmdldChxdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gYXdhaXQgc3luY2hyb25pemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBxdWVyeVZpZXcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZXdDaGFuZ2Uuc25hcHNob3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWaWV3U25hcHNob3RzLnB1c2godmlld0NoYW5nZS5zbmFwc2hvdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBxdWVyaWVzIHRoYXQgbmV2ZXIgZXhlY3V0ZWQgb24gdGhpcyBjbGllbnQsIHdlIG5lZWQgdG9cclxuICAgICAgICAgICAgLy8gYWxsb2NhdGUgdGhlIHRhcmdldCBpbiBMb2NhbFN0b3JlIGFuZCBpbml0aWFsaXplIGEgbmV3IFZpZXcuXHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IGxvY2FsU3RvcmVHZXRDYWNoZWRUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICB0YXJnZXREYXRhID0gYXdhaXQgbG9jYWxTdG9yZUFsbG9jYXRlVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUsIHRhcmdldCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGluaXRpYWxpemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBzeW50aGVzaXplVGFyZ2V0VG9RdWVyeSh0YXJnZXQpLCB0YXJnZXRJZCwgXHJcbiAgICAgICAgICAgIC8qY3VycmVudD0qLyBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVF1ZXJpZXMucHVzaCh0YXJnZXREYXRhKTtcclxuICAgIH1cclxuICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoQ2hhbmdlKG5ld1ZpZXdTbmFwc2hvdHMpO1xyXG4gICAgcmV0dXJuIGFjdGl2ZVF1ZXJpZXM7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBgUXVlcnlgIG9iamVjdCBmcm9tIHRoZSBzcGVjaWZpZWQgYFRhcmdldGAuIFRoZXJlIGlzIG5vIHdheSB0b1xyXG4gKiBvYnRhaW4gdGhlIG9yaWdpbmFsIGBRdWVyeWAsIHNvIHdlIHN5bnRoZXNpemUgYSBgUXVlcnlgIGZyb20gdGhlIGBUYXJnZXRgXHJcbiAqIG9iamVjdC5cclxuICpcclxuICogVGhlIHN5bnRoZXNpemVkIHJlc3VsdCBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWwgYFF1ZXJ5YCwgYnV0XHJcbiAqIHNpbmNlIHRoZSBzeW50aGVzaXplZCBgUXVlcnlgIHNob3VsZCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0cyBhcyB0aGVcclxuICogb3JpZ2luYWwgb25lIChvbmx5IHRoZSBwcmVzZW50YXRpb24gb2YgcmVzdWx0cyBtaWdodCBkaWZmZXIpLCB0aGUgcG90ZW50aWFsXHJcbiAqIGRpZmZlcmVuY2Ugd2lsbCBub3QgY2F1c2UgaXNzdWVzLlxyXG4gKi9cclxuLy8gUE9SVElORyBOT1RFOiBNdWx0aS1UYWIgb25seS5cclxuZnVuY3Rpb24gc3ludGhlc2l6ZVRhcmdldFRvUXVlcnkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gbmV3UXVlcnkodGFyZ2V0LnBhdGgsIHRhcmdldC5jb2xsZWN0aW9uR3JvdXAsIHRhcmdldC5vcmRlckJ5LCB0YXJnZXQuZmlsdGVycywgdGFyZ2V0LmxpbWl0LCBcIkZcIiAvKiBGaXJzdCAqLywgdGFyZ2V0LnN0YXJ0QXQsIHRhcmdldC5lbmRBdCk7XHJcbn1cclxuLyoqIFJldHVybnMgdGhlIElEcyBvZiB0aGUgY2xpZW50cyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLiAqL1xyXG4vLyBQT1JUSU5HIE5PVEU6IE11bHRpLVRhYiBvbmx5LlxyXG5mdW5jdGlvbiBzeW5jRW5naW5lR2V0QWN0aXZlQ2xpZW50cyhzeW5jRW5naW5lKSB7XHJcbiAgICBjb25zdCBzeW5jRW5naW5lSW1wbCA9IGRlYnVnQ2FzdChzeW5jRW5naW5lKTtcclxuICAgIHJldHVybiBsb2NhbFN0b3JlR2V0QWN0aXZlQ2xpZW50cyhzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlKTtcclxufVxyXG4vKiogQXBwbGllcyBhIHF1ZXJ5IHRhcmdldCBjaGFuZ2UgZnJvbSBhIGRpZmZlcmVudCB0YWIuICovXHJcbi8vIFBPUlRJTkcgTk9URTogTXVsdGktVGFiIG9ubHkuXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseVRhcmdldFN0YXRlKHN5bmNFbmdpbmUsIHRhcmdldElkLCBzdGF0ZSwgZXJyb3IpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgaWYgKHN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQpIHtcclxuICAgICAgICAvLyBJZiB3ZSByZWNlaXZlIGEgdGFyZ2V0IHN0YXRlIG5vdGlmaWNhdGlvbiB2aWEgV2ViU3RvcmFnZSwgd2UgYXJlXHJcbiAgICAgICAgLy8gZWl0aGVyIGFscmVhZHkgc2Vjb25kYXJ5IG9yIGFub3RoZXIgdGFiIGhhcyB0YWtlbiB0aGUgcHJpbWFyeSBsZWFzZS5cclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDMsICdJZ25vcmluZyB1bmV4cGVjdGVkIHF1ZXJ5IHN0YXRlIG5vdGlmaWNhdGlvbi4nKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2N1cnJlbnQnOlxyXG4gICAgICAgICAgICBjYXNlICdub3QtY3VycmVudCc6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBhd2FpdCBsb2NhbFN0b3JlR2V0TmV3RG9jdW1lbnRDaGFuZ2VzKHN5bmNFbmdpbmVJbXBsLmxvY2FsU3RvcmUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ludGhlc2l6ZWRSZW1vdGVFdmVudCA9IFJlbW90ZUV2ZW50LmNyZWF0ZVN5bnRoZXNpemVkUmVtb3RlRXZlbnRGb3JDdXJyZW50Q2hhbmdlKHRhcmdldElkLCBzdGF0ZSA9PT0gJ2N1cnJlbnQnKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHN5bmNFbmdpbmVFbWl0TmV3U25hcHNBbmROb3RpZnlMb2NhbFN0b3JlKHN5bmNFbmdpbmVJbXBsLCBjaGFuZ2VzLCBzeW50aGVzaXplZFJlbW90ZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzoge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxyXG4gICAgICAgICAgICAgICAgLyoga2VlcFBlcnNpc3RlZFRhcmdldERhdGEgKi8gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVBbmRDbGVhbnVwVGFyZ2V0KHN5bmNFbmdpbmVJbXBsLCB0YXJnZXRJZCwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqIEFkZHMgb3IgcmVtb3ZlcyBXYXRjaCB0YXJnZXRzIGZvciBxdWVyaWVzIGZyb20gZGlmZmVyZW50IHRhYnMuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNFbmdpbmVBcHBseUFjdGl2ZVRhcmdldHNDaGFuZ2Uoc3luY0VuZ2luZSwgYWRkZWQsIHJlbW92ZWQpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZW5zdXJlV2F0Y2hDYWxsYmFja3Moc3luY0VuZ2luZSk7XHJcbiAgICBpZiAoIXN5bmNFbmdpbmVJbXBsLl9pc1ByaW1hcnlDbGllbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHRhcmdldElkIG9mIGFkZGVkKSB7XHJcbiAgICAgICAgaWYgKHN5bmNFbmdpbmVJbXBsLnF1ZXJpZXNCeVRhcmdldC5oYXModGFyZ2V0SWQpKSB7XHJcbiAgICAgICAgICAgIC8vIEEgdGFyZ2V0IG1pZ2h0IGhhdmUgYmVlbiBhZGRlZCBpbiBhIHByZXZpb3VzIGF0dGVtcHRcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQzLCAnQWRkaW5nIGFuIGFscmVhZHkgYWN0aXZlIHRhcmdldCAnICsgdGFyZ2V0SWQpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gYXdhaXQgbG9jYWxTdG9yZUdldENhY2hlZFRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXRJZCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGF3YWl0IGxvY2FsU3RvcmVBbGxvY2F0ZVRhcmdldChzeW5jRW5naW5lSW1wbC5sb2NhbFN0b3JlLCB0YXJnZXQpO1xyXG4gICAgICAgIGF3YWl0IGluaXRpYWxpemVWaWV3QW5kQ29tcHV0ZVNuYXBzaG90KHN5bmNFbmdpbmVJbXBsLCBzeW50aGVzaXplVGFyZ2V0VG9RdWVyeSh0YXJnZXQpLCB0YXJnZXREYXRhLnRhcmdldElkLCBcclxuICAgICAgICAvKmN1cnJlbnQ9Ki8gZmFsc2UpO1xyXG4gICAgICAgIHJlbW90ZVN0b3JlTGlzdGVuKHN5bmNFbmdpbmVJbXBsLnJlbW90ZVN0b3JlLCB0YXJnZXREYXRhKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgdGFyZ2V0SWQgb2YgcmVtb3ZlZCkge1xyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHRhcmdldCBpcyBzdGlsbCBhY3RpdmUgc2luY2UgdGhlIHRhcmdldCBtaWdodCBoYXZlIGJlZW5cclxuICAgICAgICAvLyByZW1vdmVkIGlmIGl0IGhhcyBiZWVuIHJlamVjdGVkIGJ5IHRoZSBiYWNrZW5kLlxyXG4gICAgICAgIGlmICghc3luY0VuZ2luZUltcGwucXVlcmllc0J5VGFyZ2V0Lmhhcyh0YXJnZXRJZCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbGVhc2UgcXVlcmllcyB0aGF0IGFyZSBzdGlsbCBhY3RpdmUuXHJcbiAgICAgICAgYXdhaXQgbG9jYWxTdG9yZVJlbGVhc2VUYXJnZXQoc3luY0VuZ2luZUltcGwubG9jYWxTdG9yZSwgdGFyZ2V0SWQsIFxyXG4gICAgICAgIC8qIGtlZXBQZXJzaXN0ZWRUYXJnZXREYXRhICovIGZhbHNlKVxyXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlVW5saXN0ZW4oc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUsIHRhcmdldElkKTtcclxuICAgICAgICAgICAgcmVtb3ZlQW5kQ2xlYW51cFRhcmdldChzeW5jRW5naW5lSW1wbCwgdGFyZ2V0SWQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChpZ25vcmVJZlByaW1hcnlMZWFzZUxvc3MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVuc3VyZVdhdGNoQ2FsbGJhY2tzKHN5bmNFbmdpbmUpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLmFwcGx5UmVtb3RlRXZlbnQgPVxyXG4gICAgICAgIHN5bmNFbmdpbmVBcHBseVJlbW90ZUV2ZW50LmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xyXG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLmdldFJlbW90ZUtleXNGb3JUYXJnZXQgPVxyXG4gICAgICAgIHN5bmNFbmdpbmVHZXRSZW1vdGVLZXlzRm9yVGFyZ2V0LmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwpO1xyXG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLnJlamVjdExpc3RlbiA9XHJcbiAgICAgICAgc3luY0VuZ2luZVJlamVjdExpc3Rlbi5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoQ2hhbmdlID1cclxuICAgICAgICBldmVudE1hbmFnZXJPbldhdGNoQ2hhbmdlLmJpbmQobnVsbCwgc3luY0VuZ2luZUltcGwuZXZlbnRNYW5hZ2VyKTtcclxuICAgIHN5bmNFbmdpbmVJbXBsLnN5bmNFbmdpbmVMaXN0ZW5lci5vbldhdGNoRXJyb3IgPVxyXG4gICAgICAgIGV2ZW50TWFuYWdlck9uV2F0Y2hFcnJvci5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsLmV2ZW50TWFuYWdlcik7XHJcbiAgICByZXR1cm4gc3luY0VuZ2luZUltcGw7XHJcbn1cclxuZnVuY3Rpb24gc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHN5bmNFbmdpbmUpIHtcclxuICAgIGNvbnN0IHN5bmNFbmdpbmVJbXBsID0gZGVidWdDYXN0KHN5bmNFbmdpbmUpO1xyXG4gICAgc3luY0VuZ2luZUltcGwucmVtb3RlU3RvcmUucmVtb3RlU3luY2VyLmFwcGx5U3VjY2Vzc2Z1bFdyaXRlID1cclxuICAgICAgICBzeW5jRW5naW5lQXBwbHlTdWNjZXNzZnVsV3JpdGUuYmluZChudWxsLCBzeW5jRW5naW5lSW1wbCk7XHJcbiAgICBzeW5jRW5naW5lSW1wbC5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIucmVqZWN0RmFpbGVkV3JpdGUgPVxyXG4gICAgICAgIHN5bmNFbmdpbmVSZWplY3RGYWlsZWRXcml0ZS5iaW5kKG51bGwsIHN5bmNFbmdpbmVJbXBsKTtcclxuICAgIHJldHVybiBzeW5jRW5naW5lSW1wbDtcclxufVxyXG4vKipcclxuICogTG9hZHMgYSBGaXJlc3RvcmUgYnVuZGxlIGludG8gdGhlIFNESy4gVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgd2hlblxyXG4gKiB0aGUgYnVuZGxlIGZpbmlzaGVkIGxvYWRpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBzeW5jRW5naW5lIC0gU3luY0VuZ2luZSB0byB1c2UuXHJcbiAqIEBwYXJhbSBidW5kbGVSZWFkZXIgLSBCdW5kbGUgdG8gbG9hZCBpbnRvIHRoZSBTREsuXHJcbiAqIEBwYXJhbSB0YXNrIC0gTG9hZEJ1bmRsZVRhc2sgdXNlZCB0byB1cGRhdGUgdGhlIGxvYWRpbmcgcHJvZ3Jlc3MgdG8gcHVibGljIEFQSS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNFbmdpbmVMb2FkQnVuZGxlKHN5bmNFbmdpbmUsIGJ1bmRsZVJlYWRlciwgdGFzaykge1xyXG4gICAgY29uc3Qgc3luY0VuZ2luZUltcGwgPSBkZWJ1Z0Nhc3Qoc3luY0VuZ2luZSk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICBsb2FkQnVuZGxlSW1wbChzeW5jRW5naW5lSW1wbCwgYnVuZGxlUmVhZGVyLCB0YXNrKS50aGVuKCgpID0+IHtcclxuICAgICAgICBzeW5jRW5naW5lSW1wbC5zaGFyZWRDbGllbnRTdGF0ZS5ub3RpZnlCdW5kbGVMb2FkZWQoKTtcclxuICAgIH0pO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGxvYWRCdW5kbGVJbXBsKHN5bmNFbmdpbmUsIHJlYWRlciwgdGFzaykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHJlYWRlci5nZXRNZXRhZGF0YSgpO1xyXG4gICAgICAgIGNvbnN0IHNraXAgPSBhd2FpdCBsb2NhbFN0b3JlSGFzTmV3ZXJCdW5kbGUoc3luY0VuZ2luZS5sb2NhbFN0b3JlLCBtZXRhZGF0YSk7XHJcbiAgICAgICAgaWYgKHNraXApIHtcclxuICAgICAgICAgICAgYXdhaXQgcmVhZGVyLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRhc2suX2NvbXBsZXRlV2l0aChidW5kbGVTdWNjZXNzUHJvZ3Jlc3MobWV0YWRhdGEpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXNrLl91cGRhdGVQcm9ncmVzcyhidW5kbGVJbml0aWFsUHJvZ3Jlc3MobWV0YWRhdGEpKTtcclxuICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgQnVuZGxlTG9hZGVyKG1ldGFkYXRhLCBzeW5jRW5naW5lLmxvY2FsU3RvcmUsIHJlYWRlci5zZXJpYWxpemVyKTtcclxuICAgICAgICBsZXQgZWxlbWVudCA9IGF3YWl0IHJlYWRlci5uZXh0RWxlbWVudCgpO1xyXG4gICAgICAgIHdoaWxlIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBhd2FpdCBsb2FkZXIuYWRkU2l6ZWRFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgICAgIHRhc2suX3VwZGF0ZVByb2dyZXNzKHByb2dyZXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbGVtZW50ID0gYXdhaXQgcmVhZGVyLm5leHRFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgIC8vIFRPRE8oYi8xNjA4NzY0NDMpOiBUaGlzIGN1cnJlbnRseSByYWlzZXMgc25hcHNob3RzIHdpdGhcclxuICAgICAgICAvLyBgZnJvbUNhY2hlPWZhbHNlYCBpZiB1c2VycyBhbHJlYWR5IGxpc3RlbiB0byBzb21lIHF1ZXJpZXMgYW5kIGJ1bmRsZXNcclxuICAgICAgICAvLyBoYXMgbmV3ZXIgdmVyc2lvbi5cclxuICAgICAgICBhd2FpdCBzeW5jRW5naW5lRW1pdE5ld1NuYXBzQW5kTm90aWZ5TG9jYWxTdG9yZShzeW5jRW5naW5lLCByZXN1bHQuY2hhbmdlZERvY3MsIFxyXG4gICAgICAgIC8qIHJlbW90ZUV2ZW50ICovIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgLy8gU2F2ZSBtZXRhZGF0YSwgc28gbG9hZGluZyB0aGUgc2FtZSBidW5kbGUgd2lsbCBza2lwLlxyXG4gICAgICAgIGF3YWl0IGxvY2FsU3RvcmVTYXZlQnVuZGxlKHN5bmNFbmdpbmUubG9jYWxTdG9yZSwgbWV0YWRhdGEpO1xyXG4gICAgICAgIHRhc2suX2NvbXBsZXRlV2l0aChyZXN1bHQucHJvZ3Jlc3MpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dXYXJuKExPR19UQUckMywgYExvYWRpbmcgYnVuZGxlIGZhaWxlZCB3aXRoICR7ZX1gKTtcclxuICAgICAgICB0YXNrLl9mYWlsV2l0aChlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUHJvdmlkZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciBGaXJlc3RvcmUgd2l0aCBpbi1tZW1vcnkgcGVyc2lzdGVuY2UuXHJcbiAqIFVzZXMgRWFnZXJHQyBnYXJiYWdlIGNvbGxlY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVRhYnMgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGFzeW5jIGluaXRpYWxpemUoY2ZnKSB7XHJcbiAgICAgICAgdGhpcy5zZXJpYWxpemVyID0gbmV3U2VyaWFsaXplcihjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQpO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUgPSB0aGlzLmNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZyk7XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZSA9IHRoaXMuY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLnN0YXJ0KCk7XHJcbiAgICAgICAgdGhpcy5nY1NjaGVkdWxlciA9IHRoaXMuY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnKTtcclxuICAgICAgICB0aGlzLmxvY2FsU3RvcmUgPSB0aGlzLmNyZWF0ZUxvY2FsU3RvcmUoY2ZnKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUdhcmJhZ2VDb2xsZWN0aW9uU2NoZWR1bGVyKGNmZykge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlTG9jYWxTdG9yZShjZmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3TG9jYWxTdG9yZSh0aGlzLnBlcnNpc3RlbmNlLCBuZXcgUXVlcnlFbmdpbmUoKSwgY2ZnLmluaXRpYWxVc2VyLCB0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUGVyc2lzdGVuY2UoY2ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZW1vcnlQZXJzaXN0ZW5jZShNZW1vcnlFYWdlckRlbGVnYXRlLmZhY3RvcnksIHRoaXMuc2VyaWFsaXplcik7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVTaGFyZWRDbGllbnRTdGF0ZShjZmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVNoYXJlZENsaWVudFN0YXRlKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyB0ZXJtaW5hdGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2NTY2hlZHVsZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUuc2h1dGRvd24oKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLnNodXRkb3duKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgRmlyZXN0b3JlIHdpdGggSW5kZXhlZERCIHBlcnNpc3RlbmNlLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhlZERiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIGV4dGVuZHMgTWVtb3J5T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBjYWNoZVNpemVCeXRlcywgZm9yY2VPd25lcnNoaXApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMub25saW5lQ29tcG9uZW50UHJvdmlkZXIgPSBvbmxpbmVDb21wb25lbnRQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gY2FjaGVTaXplQnl0ZXM7XHJcbiAgICAgICAgdGhpcy5mb3JjZU93bmVyc2hpcCA9IGZvcmNlT3duZXJzaGlwO1xyXG4gICAgICAgIHRoaXMuc3luY2hyb25pemVUYWJzID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpbml0aWFsaXplKGNmZykge1xyXG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRpYWxpemUoY2ZnKTtcclxuICAgICAgICBhd2FpdCBsb2NhbFN0b3JlU3luY2hyb25pemVMYXN0RG9jdW1lbnRDaGFuZ2VSZWFkVGltZSh0aGlzLmxvY2FsU3RvcmUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMub25saW5lQ29tcG9uZW50UHJvdmlkZXIuaW5pdGlhbGl6ZSh0aGlzLCBjZmcpO1xyXG4gICAgICAgIC8vIEVucXVldWUgd3JpdGVzIGZyb20gYSBwcmV2aW91cyBzZXNzaW9uXHJcbiAgICAgICAgYXdhaXQgc3luY0VuZ2luZUVuc3VyZVdyaXRlQ2FsbGJhY2tzKHRoaXMub25saW5lQ29tcG9uZW50UHJvdmlkZXIuc3luY0VuZ2luZSk7XHJcbiAgICAgICAgYXdhaXQgZmlsbFdyaXRlUGlwZWxpbmUodGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5yZW1vdGVTdG9yZSk7XHJcbiAgICAgICAgLy8gTk9URTogVGhpcyB3aWxsIGltbWVkaWF0ZWx5IGNhbGwgdGhlIGxpc3RlbmVyLCBzbyB3ZSBtYWtlIHN1cmUgdG9cclxuICAgICAgICAvLyBzZXQgaXQgYWZ0ZXIgbG9jYWxTdG9yZSAvIHJlbW90ZVN0b3JlIGFyZSBzdGFydGVkLlxyXG4gICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdGVuY2Uuc2V0UHJpbWFyeVN0YXRlTGlzdGVuZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nY1NjaGVkdWxlciAmJiAhdGhpcy5nY1NjaGVkdWxlci5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdjU2NoZWR1bGVyLnN0YXJ0KHRoaXMubG9jYWxTdG9yZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlTG9jYWxTdG9yZShjZmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3TG9jYWxTdG9yZSh0aGlzLnBlcnNpc3RlbmNlLCBuZXcgUXVlcnlFbmdpbmUoKSwgY2ZnLmluaXRpYWxVc2VyLCB0aGlzLnNlcmlhbGl6ZXIpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlR2FyYmFnZUNvbGxlY3Rpb25TY2hlZHVsZXIoY2ZnKSB7XHJcbiAgICAgICAgY29uc3QgZ2FyYmFnZUNvbGxlY3RvciA9IHRoaXMucGVyc2lzdGVuY2UucmVmZXJlbmNlRGVsZWdhdGUuZ2FyYmFnZUNvbGxlY3RvcjtcclxuICAgICAgICByZXR1cm4gbmV3IExydVNjaGVkdWxlcihnYXJiYWdlQ29sbGVjdG9yLCBjZmcuYXN5bmNRdWV1ZSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVQZXJzaXN0ZW5jZShjZmcpIHtcclxuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZUtleSA9IGluZGV4ZWREYlN0b3JhZ2VQcmVmaXgoY2ZnLmRhdGFiYXNlSW5mby5kYXRhYmFzZUlkLCBjZmcuZGF0YWJhc2VJbmZvLnBlcnNpc3RlbmNlS2V5KTtcclxuICAgICAgICBjb25zdCBscnVQYXJhbXMgPSB0aGlzLmNhY2hlU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgPyBMcnVQYXJhbXMud2l0aENhY2hlU2l6ZSh0aGlzLmNhY2hlU2l6ZUJ5dGVzKVxyXG4gICAgICAgICAgICA6IExydVBhcmFtcy5ERUZBVUxUO1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhlZERiUGVyc2lzdGVuY2UodGhpcy5zeW5jaHJvbml6ZVRhYnMsIHBlcnNpc3RlbmNlS2V5LCBjZmcuY2xpZW50SWQsIGxydVBhcmFtcywgY2ZnLmFzeW5jUXVldWUsIGdldFdpbmRvdygpLCBnZXREb2N1bWVudCgpLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUsICEhdGhpcy5mb3JjZU93bmVyc2hpcCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVTaGFyZWRDbGllbnRTdGF0ZShjZmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lbW9yeVNoYXJlZENsaWVudFN0YXRlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgRmlyZXN0b3JlIHdpdGggbXVsdGktdGFiIEluZGV4ZWREQlxyXG4gKiBwZXJzaXN0ZW5jZS5cclxuICpcclxuICogSW4gdGhlIGxlZ2FjeSBjbGllbnQsIHRoaXMgcHJvdmlkZXIgaXMgdXNlZCB0byBwcm92aWRlIGJvdGggbXVsdGktdGFiIGFuZFxyXG4gKiBub24tbXVsdGktdGFiIHBlcnNpc3RlbmNlIHNpbmNlIHdlIGNhbm5vdCB0ZWxsIGF0IGJ1aWxkIHRpbWUgd2hldGhlclxyXG4gKiBgc3luY2hyb25pemVUYWJzYCB3aWxsIGJlIGVuYWJsZWQuXHJcbiAqL1xyXG5jbGFzcyBNdWx0aVRhYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciBleHRlbmRzIEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgY2FjaGVTaXplQnl0ZXMpIHtcclxuICAgICAgICBzdXBlcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgY2FjaGVTaXplQnl0ZXMsIC8qIGZvcmNlT3duZXJzaGlwPSAqLyBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlciA9IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuY2FjaGVTaXplQnl0ZXMgPSBjYWNoZVNpemVCeXRlcztcclxuICAgICAgICB0aGlzLnN5bmNocm9uaXplVGFicyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBhc3luYyBpbml0aWFsaXplKGNmZykge1xyXG4gICAgICAgIGF3YWl0IHN1cGVyLmluaXRpYWxpemUoY2ZnKTtcclxuICAgICAgICBjb25zdCBzeW5jRW5naW5lID0gdGhpcy5vbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lO1xyXG4gICAgICAgIGlmICh0aGlzLnNoYXJlZENsaWVudFN0YXRlIGluc3RhbmNlb2YgV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUuc3luY0VuZ2luZSA9IHtcclxuICAgICAgICAgICAgICAgIGFwcGx5QmF0Y2hTdGF0ZTogc3luY0VuZ2luZUFwcGx5QmF0Y2hTdGF0ZS5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxyXG4gICAgICAgICAgICAgICAgYXBwbHlUYXJnZXRTdGF0ZTogc3luY0VuZ2luZUFwcGx5VGFyZ2V0U3RhdGUuYmluZChudWxsLCBzeW5jRW5naW5lKSxcclxuICAgICAgICAgICAgICAgIGFwcGx5QWN0aXZlVGFyZ2V0c0NoYW5nZTogc3luY0VuZ2luZUFwcGx5QWN0aXZlVGFyZ2V0c0NoYW5nZS5iaW5kKG51bGwsIHN5bmNFbmdpbmUpLFxyXG4gICAgICAgICAgICAgICAgZ2V0QWN0aXZlQ2xpZW50czogc3luY0VuZ2luZUdldEFjdGl2ZUNsaWVudHMuYmluZChudWxsLCBzeW5jRW5naW5lKSxcclxuICAgICAgICAgICAgICAgIHN5bmNocm9uaXplV2l0aENoYW5nZWREb2N1bWVudHM6IHN5bmNFbmdpbmVTeW5jaHJvbml6ZVdpdGhDaGFuZ2VkRG9jdW1lbnRzLmJpbmQobnVsbCwgc3luY0VuZ2luZSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZS5zdGFydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOT1RFOiBUaGlzIHdpbGwgaW1tZWRpYXRlbHkgY2FsbCB0aGUgbGlzdGVuZXIsIHNvIHdlIG1ha2Ugc3VyZSB0b1xyXG4gICAgICAgIC8vIHNldCBpdCBhZnRlciBsb2NhbFN0b3JlIC8gcmVtb3RlU3RvcmUgYXJlIHN0YXJ0ZWQuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5zZXRQcmltYXJ5U3RhdGVMaXN0ZW5lcihhc3luYyAoaXNQcmltYXJ5KSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHN5bmNFbmdpbmVBcHBseVByaW1hcnlTdGF0ZSh0aGlzLm9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUsIGlzUHJpbWFyeSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdjU2NoZWR1bGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltYXJ5ICYmICF0aGlzLmdjU2NoZWR1bGVyLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdjU2NoZWR1bGVyLnN0YXJ0KHRoaXMubG9jYWxTdG9yZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNQcmltYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nY1NjaGVkdWxlci5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVNoYXJlZENsaWVudFN0YXRlKGNmZykge1xyXG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xyXG4gICAgICAgIGlmICghV2ViU3RvcmFnZVNoYXJlZENsaWVudFN0YXRlLmlzQXZhaWxhYmxlKHdpbmRvdykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5JTVBMRU1FTlRFRCwgJ0luZGV4ZWREQiBwZXJzaXN0ZW5jZSBpcyBvbmx5IGF2YWlsYWJsZSBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0IExvY2FsU3RvcmFnZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGVyc2lzdGVuY2VLZXkgPSBpbmRleGVkRGJTdG9yYWdlUHJlZml4KGNmZy5kYXRhYmFzZUluZm8uZGF0YWJhc2VJZCwgY2ZnLmRhdGFiYXNlSW5mby5wZXJzaXN0ZW5jZUtleSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJTdG9yYWdlU2hhcmVkQ2xpZW50U3RhdGUod2luZG93LCBjZmcuYXN5bmNRdWV1ZSwgcGVyc2lzdGVuY2VLZXksIGNmZy5jbGllbnRJZCwgY2ZnLmluaXRpYWxVc2VyKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgYW5kIHdpcmVzIHRoZSBjb21wb25lbnRzIHRoYXQgYXJlIG5lZWRlZCB0byBpbnRlcmZhY2Ugd2l0aCB0aGVcclxuICogbmV0d29yay5cclxuICovXHJcbmNsYXNzIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIHtcclxuICAgIGFzeW5jIGluaXRpYWxpemUob2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLCBjZmcpIHtcclxuICAgICAgICBpZiAodGhpcy5sb2NhbFN0b3JlKSB7XHJcbiAgICAgICAgICAgIC8vIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyIG1heSBnZXQgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMgaWZcclxuICAgICAgICAgICAgLy8gbXVsdGktdGFiIHBlcnNpc3RlbmNlIGlzIHVzZWQuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0b3JlID0gb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLmxvY2FsU3RvcmU7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRDbGllbnRTdGF0ZSA9IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5zaGFyZWRDbGllbnRTdGF0ZTtcclxuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IHRoaXMuY3JlYXRlRGF0YXN0b3JlKGNmZyk7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTdG9yZSA9IHRoaXMuY3JlYXRlUmVtb3RlU3RvcmUoY2ZnKTtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IHRoaXMuY3JlYXRlRXZlbnRNYW5hZ2VyKGNmZyk7XHJcbiAgICAgICAgdGhpcy5zeW5jRW5naW5lID0gdGhpcy5jcmVhdGVTeW5jRW5naW5lKGNmZywgXHJcbiAgICAgICAgLyogc3RhcnRBc1ByaW1hcnk9Ki8gIW9mZmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jaHJvbml6ZVRhYnMpO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUub25saW5lU3RhdGVIYW5kbGVyID0gb25saW5lU3RhdGUgPT4gc3luY0VuZ2luZUFwcGx5T25saW5lU3RhdGVDaGFuZ2UodGhpcy5zeW5jRW5naW5lLCBvbmxpbmVTdGF0ZSwgMSAvKiBTaGFyZWRDbGllbnRTdGF0ZSAqLyk7XHJcbiAgICAgICAgdGhpcy5yZW1vdGVTdG9yZS5yZW1vdGVTeW5jZXIuaGFuZGxlQ3JlZGVudGlhbENoYW5nZSA9XHJcbiAgICAgICAgICAgIHN5bmNFbmdpbmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlLmJpbmQobnVsbCwgdGhpcy5zeW5jRW5naW5lKTtcclxuICAgICAgICBhd2FpdCByZW1vdGVTdG9yZUFwcGx5UHJpbWFyeVN0YXRlKHRoaXMucmVtb3RlU3RvcmUsIHRoaXMuc3luY0VuZ2luZS5pc1ByaW1hcnlDbGllbnQpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlRXZlbnRNYW5hZ2VyKGNmZykge1xyXG4gICAgICAgIHJldHVybiBuZXdFdmVudE1hbmFnZXIoKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZURhdGFzdG9yZShjZmcpIHtcclxuICAgICAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3U2VyaWFsaXplcihjZmcuZGF0YWJhc2VJbmZvLmRhdGFiYXNlSWQpO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXdDb25uZWN0aW9uKGNmZy5kYXRhYmFzZUluZm8pO1xyXG4gICAgICAgIHJldHVybiBuZXdEYXRhc3RvcmUoY2ZnLmF1dGhDcmVkZW50aWFscywgY2ZnLmFwcENoZWNrQ3JlZGVudGlhbHMsIGNvbm5lY3Rpb24sIHNlcmlhbGl6ZXIpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlUmVtb3RlU3RvcmUoY2ZnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld1JlbW90ZVN0b3JlKHRoaXMubG9jYWxTdG9yZSwgdGhpcy5kYXRhc3RvcmUsIGNmZy5hc3luY1F1ZXVlLCBvbmxpbmVTdGF0ZSA9PiBzeW5jRW5naW5lQXBwbHlPbmxpbmVTdGF0ZUNoYW5nZSh0aGlzLnN5bmNFbmdpbmUsIG9ubGluZVN0YXRlLCAwIC8qIFJlbW90ZVN0b3JlICovKSwgbmV3Q29ubmVjdGl2aXR5TW9uaXRvcigpKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVN5bmNFbmdpbmUoY2ZnLCBzdGFydEFzUHJpbWFyeSkge1xyXG4gICAgICAgIHJldHVybiBuZXdTeW5jRW5naW5lKHRoaXMubG9jYWxTdG9yZSwgdGhpcy5yZW1vdGVTdG9yZSwgdGhpcy5ldmVudE1hbmFnZXIsIHRoaXMuc2hhcmVkQ2xpZW50U3RhdGUsIGNmZy5pbml0aWFsVXNlciwgY2ZnLm1heENvbmN1cnJlbnRMaW1ib1Jlc29sdXRpb25zLCBzdGFydEFzUHJpbWFyeSk7XHJcbiAgICB9XHJcbiAgICB0ZXJtaW5hdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZVN0b3JlU2h1dGRvd24odGhpcy5yZW1vdGVTdG9yZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEhvdyBtYW55IGJ5dGVzIHRvIHJlYWQgZWFjaCB0aW1lIHdoZW4gYFJlYWRhYmxlU3RyZWFtUmVhZGVyLnJlYWQoKWAgaXNcclxuICogY2FsbGVkLiBPbmx5IGFwcGxpY2FibGUgZm9yIGJ5dGUgc3RyZWFtcyB0aGF0IHdlIGNvbnRyb2wgKGUuZy4gdGhvc2UgYmFja2VkXHJcbiAqIGJ5IGFuIFVJbnQ4QXJyYXkpLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9CWVRFU19QRVJfUkVBRCA9IDEwMjQwO1xyXG4vKipcclxuICogQnVpbGRzIGEgYEJ5dGVTdHJlYW1SZWFkZXJgIGZyb20gYSBVSW50OEFycmF5LlxyXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIGRhdGEgc291cmNlIHRvIHVzZS5cclxuICogQHBhcmFtIGJ5dGVzUGVyUmVhZCAtIEhvdyBtYW55IGJ5dGVzIGVhY2ggYHJlYWQoKWAgZnJvbSB0aGUgcmV0dXJuZWQgcmVhZGVyXHJcbiAqICAgICAgICB3aWxsIHJlYWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0J5dGVTdHJlYW1SZWFkZXJIZWxwZXIoc291cmNlLCBieXRlc1BlclJlYWQgPSBERUZBVUxUX0JZVEVTX1BFUl9SRUFEKSB7XHJcbiAgICBsZXQgcmVhZEZyb20gPSAwO1xyXG4gICAgLy8gVGhlIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXIgY2hhbmdlZC4gV2UgdXNlXHJcbiAgICAvLyBgYW55YCBoZXJlIHRvIGFsbG93IHRoaXMgY29kZSB0byBjb21waWxlIHdpdGggZGlmZmVyZW50IHZlcnNpb25zLlxyXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDI5NzBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBjb25zdCByZWFkZXIgPSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICBhc3luYyByZWFkKCkge1xyXG4gICAgICAgICAgICBpZiAocmVhZEZyb20gPCBzb3VyY2UuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2Uuc2xpY2UocmVhZEZyb20sIHJlYWRGcm9tICsgYnl0ZXNQZXJSZWFkKSxcclxuICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJlYWRGcm9tICs9IGJ5dGVzUGVyUmVhZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXN5bmMgY2FuY2VsKCkgeyB9LFxyXG4gICAgICAgIHJlbGVhc2VMb2NrKCkgeyB9LFxyXG4gICAgICAgIGNsb3NlZDogUHJvbWlzZS5yZWplY3QoJ3VuaW1wbGVtZW50ZWQnKVxyXG4gICAgfTtcclxuICAgIHJldHVybiByZWFkZXI7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KGZ1bmN0aW9uTmFtZSwgYXJndW1lbnROYW1lLCBhcmd1bWVudCkge1xyXG4gICAgaWYgKCFhcmd1bWVudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBGdW5jdGlvbiAke2Z1bmN0aW9uTmFtZX0oKSBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgJHthcmd1bWVudE5hbWV9LmApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCB0d28gYm9vbGVhbiBvcHRpb25zIGFyZSBub3Qgc2V0IGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVJc05vdFVzZWRUb2dldGhlcihvcHRpb25OYW1lMSwgYXJndW1lbnQxLCBvcHRpb25OYW1lMiwgYXJndW1lbnQyKSB7XHJcbiAgICBpZiAoYXJndW1lbnQxID09PSB0cnVlICYmIGFyZ3VtZW50MiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGAke29wdGlvbk5hbWUxfSBhbmQgJHtvcHRpb25OYW1lMn0gY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIuYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IGBwYXRoYCByZWZlcnMgdG8gYSBkb2N1bWVudCAoaW5kaWNhdGVkIGJ5IHRoZSBmYWN0IGl0IGNvbnRhaW5zXHJcbiAqIGFuIGV2ZW4gbnVtYmVycyBvZiBzZWdtZW50cykuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZURvY3VtZW50UGF0aChwYXRoKSB7XHJcbiAgICBpZiAoIURvY3VtZW50S2V5LmlzRG9jdW1lbnRLZXkocGF0aCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBkb2N1bWVudCByZWZlcmVuY2UuIERvY3VtZW50IHJlZmVyZW5jZXMgbXVzdCBoYXZlIGFuIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzLCBidXQgJHtwYXRofSBoYXMgJHtwYXRoLmxlbmd0aH0uYCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IGBwYXRoYCByZWZlcnMgdG8gYSBjb2xsZWN0aW9uIChpbmRpY2F0ZWQgYnkgdGhlIGZhY3QgaXRcclxuICogY29udGFpbnMgYW4gb2RkIG51bWJlcnMgb2Ygc2VnbWVudHMpLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVDb2xsZWN0aW9uUGF0aChwYXRoKSB7XHJcbiAgICBpZiAoRG9jdW1lbnRLZXkuaXNEb2N1bWVudEtleShwYXRoKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIGNvbGxlY3Rpb24gcmVmZXJlbmNlLiBDb2xsZWN0aW9uIHJlZmVyZW5jZXMgbXVzdCBoYXZlIGFuIG9kZCBudW1iZXIgb2Ygc2VnbWVudHMsIGJ1dCAke3BhdGh9IGhhcyAke3BhdGgubGVuZ3RofS5gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGl0J3MgYSBub24tbnVsbCBvYmplY3Qgd2l0aG91dCBhIGN1c3RvbSBwcm90b3R5cGVcclxuICogKGkuZS4gZXhjbHVkZXMgQXJyYXksIERhdGUsIGV0Yy4pLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChpbnB1dCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgaW5wdXQgIT09IG51bGwgJiZcclxuICAgICAgICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxyXG4gICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpID09PSBudWxsKSk7XHJcbn1cclxuLyoqIFJldHVybnMgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHlwZSAvIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBpbnB1dC4gKi9cclxuZnVuY3Rpb24gdmFsdWVEZXNjcmlwdGlvbihpbnB1dCkge1xyXG4gICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpbnB1dCA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAnbnVsbCc7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDIwKSB7XHJcbiAgICAgICAgICAgIGlucHV0ID0gYCR7aW5wdXQuc3Vic3RyaW5nKDAsIDIwKX0uLi5gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgaW5wdXQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIHJldHVybiAnJyArIGlucHV0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnYW4gYXJyYXknO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY3VzdG9tT2JqZWN0TmFtZSA9IHRyeUdldEN1c3RvbU9iamVjdFR5cGUoaW5wdXQpO1xyXG4gICAgICAgICAgICBpZiAoY3VzdG9tT2JqZWN0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBhIGN1c3RvbSAke2N1c3RvbU9iamVjdE5hbWV9IG9iamVjdGA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FuIG9iamVjdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gJ2EgZnVuY3Rpb24nO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhaWwoKTtcclxuICAgIH1cclxufVxyXG4vKiogdHJ5IHRvIGdldCB0aGUgY29uc3RydWN0b3IgbmFtZSBmb3IgYW4gb2JqZWN0LiAqL1xyXG5mdW5jdGlvbiB0cnlHZXRDdXN0b21PYmplY3RUeXBlKGlucHV0KSB7XHJcbiAgICBpZiAoaW5wdXQuY29uc3RydWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gaW5wdXQuY29uc3RydWN0b3IubmFtZTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBDYXN0cyBgb2JqYCB0byBgVGAsIG9wdGlvbmFsbHkgdW53cmFwcGluZyBDb21wYXQgdHlwZXMgdG8gZXhwb3NlIHRoZVxyXG4gKiB1bmRlcmx5aW5nIGluc3RhbmNlLiBUaHJvd3MgaWYgIGBvYmpgIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBgVGAuXHJcbiAqXHJcbiAqIFRoaXMgY2FzdCBpcyB1c2VkIGluIHRoZSBMaXRlIGFuZCBGdWxsIFNESyB0byB2ZXJpZnkgaW5zdGFuY2UgdHlwZXMgZm9yXHJcbiAqIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHB1YmxpYyBBUEkuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gY2FzdChvYmosIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdHJ1Y3Rvcikge1xyXG4gICAgaWYgKCdfZGVsZWdhdGUnIGluIG9iaikge1xyXG4gICAgICAgIC8vIFVud3JhcCBDb21wYXQgdHlwZXNcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIG9iaiA9IG9iai5fZGVsZWdhdGU7XHJcbiAgICB9XHJcbiAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcclxuICAgICAgICBpZiAoY29uc3RydWN0b3IubmFtZSA9PT0gb2JqLmNvbnN0cnVjdG9yLm5hbWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1R5cGUgZG9lcyBub3QgbWF0Y2ggdGhlIGV4cGVjdGVkIGluc3RhbmNlLiBEaWQgeW91IHBhc3MgYSAnICtcclxuICAgICAgICAgICAgICAgIGByZWZlcmVuY2UgZnJvbSBhIGRpZmZlcmVudCBGaXJlc3RvcmUgU0RLP2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZURlc2NyaXB0aW9uKG9iaik7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBFeHBlY3RlZCB0eXBlICcke2NvbnN0cnVjdG9yLm5hbWV9JywgYnV0IGl0IHdhczogJHtkZXNjcmlwdGlvbn1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVOdW1iZXIoZnVuY3Rpb25OYW1lLCBuKSB7XHJcbiAgICBpZiAobiA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfSgpIHJlcXVpcmVzIGEgcG9zaXRpdmUgbnVtYmVyLCBidXQgaXQgd2FzOiAke259LmApO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBPbiBOb2RlLCBvbmx5IHN1cHBvcnRlZCBkYXRhIHNvdXJjZSBpcyBhIGBVaW50OEFycmF5YCBmb3Igbm93LlxyXG4gKi9cclxuZnVuY3Rpb24gdG9CeXRlU3RyZWFtUmVhZGVyKHNvdXJjZSwgYnl0ZXNQZXJSZWFkKSB7XHJcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBOb2RlUGxhdGZvcm0udG9CeXRlU3RyZWFtUmVhZGVyIGV4cGVjdHMgc291cmNlIHRvIGJlIFVpbnQ4QXJyYXksIGdvdCAke3ZhbHVlRGVzY3JpcHRpb24oc291cmNlKX1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0b0J5dGVTdHJlYW1SZWFkZXJIZWxwZXIoc291cmNlLCBieXRlc1BlclJlYWQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qXHJcbiAqIEEgd3JhcHBlciBpbXBsZW1lbnRhdGlvbiBvZiBPYnNlcnZlcjxUPiB0aGF0IHdpbGwgZGlzcGF0Y2ggZXZlbnRzXHJcbiAqIGFzeW5jaHJvbm91c2x5LiBUbyBhbGxvdyBpbW1lZGlhdGUgc2lsZW5jaW5nLCBhIG11dGUgY2FsbCBpcyBhZGRlZCB3aGljaFxyXG4gKiBjYXVzZXMgZXZlbnRzIHNjaGVkdWxlZCB0byBubyBsb25nZXIgYmUgcmFpc2VkLlxyXG4gKi9cclxuY2xhc3MgQXN5bmNPYnNlcnZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvYnNlcnZlcikge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHNldCB0byB0cnVlLCB3aWxsIG5vdCByYWlzZSBmdXR1cmUgZXZlbnRzLiBOZWNlc3NhcnkgdG8gZGVhbCB3aXRoXHJcbiAgICAgICAgICogYXN5bmMgZGV0YWNobWVudCBvZiBsaXN0ZW5lci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11dGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBuZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIubmV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlRXZlbnQodGhpcy5vYnNlcnZlci5uZXh0LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXJyb3IoZXJyb3IpIHtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5lcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlRXZlbnQodGhpcy5vYnNlcnZlci5lcnJvciwgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5jYXVnaHQgRXJyb3IgaW4gc25hcHNob3QgbGlzdGVuZXI6JywgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG11dGUoKSB7XHJcbiAgICAgICAgdGhpcy5tdXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzY2hlZHVsZUV2ZW50KGV2ZW50SGFuZGxlciwgZXZlbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMubXV0ZWQpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubXV0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgY29tcGxldGUgZWxlbWVudCBpbiB0aGUgYnVuZGxlIHN0cmVhbSwgdG9nZXRoZXIgd2l0aCB0aGUgYnl0ZSBsZW5ndGggaXRcclxuICogb2NjdXBpZXMgaW4gdGhlIHN0cmVhbS5cclxuICovXHJcbmNsYXNzIFNpemVkQnVuZGxlRWxlbWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBcclxuICAgIC8vIEhvdyBtYW55IGJ5dGVzIHRoaXMgZWxlbWVudCB0YWtlcyB0byBzdG9yZSBpbiB0aGUgYnVuZGxlLlxyXG4gICAgYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XHJcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIGlzQnVuZGxlTWV0YWRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuICdtZXRhZGF0YScgaW4gdGhpcy5wYXlsb2FkO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGJ1bmRsZS5cclxuICpcclxuICogVGFrZXMgYSBidW5kbGUgc3RyZWFtIG9yIGJ1ZmZlciwgYW5kIHByZXNlbnRzIGFic3RyYWN0aW9ucyB0byByZWFkIGJ1bmRsZWRcclxuICogZWxlbWVudHMgb3V0IG9mIHRoZSB1bmRlcmx5aW5nIGNvbnRlbnQuXHJcbiAqL1xyXG5jbGFzcyBCdW5kbGVSZWFkZXJJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIFRoZSByZWFkZXIgdG8gcmVhZCBmcm9tIHVuZGVybHlpbmcgYmluYXJ5IGJ1bmRsZSBkYXRhIHNvdXJjZS4gKi9cclxuICAgIHJlYWRlciwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XHJcbiAgICAgICAgLyoqIENhY2hlZCBidW5kbGUgbWV0YWRhdGEuICovXHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludGVybmFsIGJ1ZmZlciB0byBob2xkIGJ1bmRsZSBjb250ZW50LCBhY2N1bXVsYXRpbmcgaW5jb21wbGV0ZSBlbGVtZW50XHJcbiAgICAgICAgICogY29udGVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy50ZXh0RGVjb2RlciA9IG5ld1RleHREZWNvZGVyKCk7XHJcbiAgICAgICAgLy8gUmVhZCB0aGUgbWV0YWRhdGEgKHdoaWNoIGlzIHRoZSBmaXJzdCBlbGVtZW50KS5cclxuICAgICAgICB0aGlzLm5leHRFbGVtZW50SW1wbCgpLnRoZW4oZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuaXNCdW5kbGVNZXRhZGF0YSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGFkYXRhLnJlc29sdmUoZWxlbWVudC5wYXlsb2FkLm1ldGFkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWV0YWRhdGEucmVqZWN0KG5ldyBFcnJvcihgVGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGJ1bmRsZSBpcyBub3QgYSBtZXRhZGF0YSwgaXQgaXNcbiAgICAgICAgICAgICAke0pTT04uc3RyaW5naWZ5KGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5wYXlsb2FkKX1gKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBlcnJvciA9PiB0aGlzLm1ldGFkYXRhLnJlamVjdChlcnJvcikpO1xyXG4gICAgfVxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZGVyLmNhbmNlbCgpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0TWV0YWRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGEucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGFzeW5jIG5leHRFbGVtZW50KCkge1xyXG4gICAgICAgIC8vIE1ha2VzIHN1cmUgbWV0YWRhdGEgaXMgcmVhZCBiZWZvcmUgcHJvY2VlZGluZy5cclxuICAgICAgICBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEVsZW1lbnRJbXBsKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGZyb20gdGhlIGhlYWQgb2YgaW50ZXJuYWwgYnVmZmVyLCBhbmQgcHVsbGluZyBtb3JlIGRhdGEgZnJvbVxyXG4gICAgICogdW5kZXJseWluZyBzdHJlYW0gaWYgYSBjb21wbGV0ZSBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZCwgdW50aWwgYW5cclxuICAgICAqIGVsZW1lbnQoaW5jbHVkaW5nIHRoZSBwcmVmaXhlZCBsZW5ndGggYW5kIHRoZSBKU09OIHN0cmluZykgaXMgZm91bmQuXHJcbiAgICAgKlxyXG4gICAgICogT25jZSBhIGNvbXBsZXRlIGVsZW1lbnQgaXMgcmVhZCwgaXQgaXMgZHJvcHBlZCBmcm9tIGludGVybmFsIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGVpdGhlciB0aGUgYnVuZGxlZCBlbGVtZW50LCBvciBudWxsIGlmIHdlIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mXHJcbiAgICAgKiB0aGUgc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBuZXh0RWxlbWVudEltcGwoKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoQnVmZmVyID0gYXdhaXQgdGhpcy5yZWFkTGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGxlbmd0aEJ1ZmZlciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoU3RyaW5nID0gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUobGVuZ3RoQnVmZmVyKTtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSBOdW1iZXIobGVuZ3RoU3RyaW5nKTtcclxuICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoYGxlbmd0aCBzdHJpbmcgKCR7bGVuZ3RoU3RyaW5nfSkgaXMgbm90IHZhbGlkIG51bWJlcmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBqc29uU3RyaW5nID0gYXdhaXQgdGhpcy5yZWFkSnNvblN0cmluZyhsZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2l6ZWRCdW5kbGVFbGVtZW50KEpTT04ucGFyc2UoanNvblN0cmluZyksIGxlbmd0aEJ1ZmZlci5sZW5ndGggKyBsZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgLyoqIEZpcnN0IGluZGV4IG9mICd7JyBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci4gKi9cclxuICAgIGluZGV4T2ZPcGVuQnJhY2tldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuZmluZEluZGV4KHYgPT4gdiA9PT0gJ3snLmNoYXJDb2RlQXQoMCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGludGVybmFsIGJ1ZmZlciwgdW50aWwgdGhlIGZpcnN0ICd7JywgYW5kXHJcbiAgICAgKiByZXR1cm4gdGhlIGNvbnRlbnQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgcmVhY2hlZCBlbmQgb2YgdGhlIHN0cmVhbSwgcmV0dXJucyBhIG51bGwuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWRMZW5ndGgoKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXhPZk9wZW5CcmFja2V0KCkgPCAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBhd2FpdCB0aGlzLnB1bGxNb3JlRGF0YVRvQnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCcm9rZSBvdXQgb2YgdGhlIGxvb3AgYmVjYXVzZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWQsIGFuZCB0aGVyZVxyXG4gICAgICAgIC8vIGhhcHBlbnMgdG8gYmUgbm8gbW9yZSBkYXRhIHRvIHByb2Nlc3MuXHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmluZGV4T2ZPcGVuQnJhY2tldCgpO1xyXG4gICAgICAgIC8vIEJyb2tlIG91dCBvZiB0aGUgbG9vcCBiZWNhdXNlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZCwgYnV0IHN0aWxsXHJcbiAgICAgICAgLy8gY2Fubm90IGZpbmQgYW4gb3BlbiBicmFja2V0LlxyXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5yYWlzZUVycm9yKCdSZWFjaGVkIHRoZSBlbmQgb2YgYnVuZGxlIHdoZW4gYSBsZW5ndGggc3RyaW5nIGlzIGV4cGVjdGVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1ZmZlci5zbGljZSgwLCBwb3NpdGlvbik7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBidWZmZXIgdG8gZHJvcCB0aGUgcmVhZCBsZW5ndGguXHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zbGljZShwb3NpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgZnJvbSBhIHNwZWNpZmllZCBwb3NpdGlvbiBmcm9tIHRoZSBpbnRlcm5hbCBidWZmZXIsIGZvciBhIHNwZWNpZmllZFxyXG4gICAgICogbnVtYmVyIG9mIGJ5dGVzLCBwdWxsaW5nIG1vcmUgZGF0YSBmcm9tIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBpZiBuZWVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBkZWNvZGVkIGZyb20gdGhlIHJlYWQgYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWRKc29uU3RyaW5nKGxlbmd0aCkge1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlci5sZW5ndGggPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgZG9uZSA9IGF3YWl0IHRoaXMucHVsbE1vcmVEYXRhVG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmFpc2VFcnJvcignUmVhY2hlZCB0aGUgZW5kIG9mIGJ1bmRsZSB3aGVuIG1vcmUgaXMgZXhwZWN0ZWQuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy5idWZmZXIuc2xpY2UoMCwgbGVuZ3RoKSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnRlcm5hbCBidWZmZXIgdG8gZHJvcCB0aGUgcmVhZCBqc29uIHN0cmluZy5cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnNsaWNlKGxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJhaXNlRXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLnJlYWRlci5jYW5jZWwoKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVuZGxlIGZvcm1hdDogJHttZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQdWxscyBtb3JlIGRhdGEgZnJvbSB1bmRlcmx5aW5nIHN0cmVhbSB0byBpbnRlcm5hbCBidWZmZXIuXHJcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN0cmVhbSBpcyBmaW5pc2hlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgcHVsbE1vcmVEYXRhVG9CdWZmZXIoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO1xyXG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIubGVuZ3RoICsgcmVzdWx0LnZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIG5ld0J1ZmZlci5zZXQodGhpcy5idWZmZXIpO1xyXG4gICAgICAgICAgICBuZXdCdWZmZXIuc2V0KHJlc3VsdC52YWx1ZSwgdGhpcy5idWZmZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQuZG9uZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdCdW5kbGVSZWFkZXIocmVhZGVyLCBzZXJpYWxpemVyKSB7XHJcbiAgICByZXR1cm4gbmV3IEJ1bmRsZVJlYWRlckltcGwocmVhZGVyLCBzZXJpYWxpemVyKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSW50ZXJuYWwgdHJhbnNhY3Rpb24gb2JqZWN0IHJlc3BvbnNpYmxlIGZvciBhY2N1bXVsYXRpbmcgdGhlIG11dGF0aW9ucyB0b1xyXG4gKiBwZXJmb3JtIGFuZCB0aGUgYmFzZSB2ZXJzaW9ucyBmb3IgYW55IGRvY3VtZW50cyByZWFkLlxyXG4gKi9cclxuY2xhc3MgVHJhbnNhY3Rpb24kMiB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhc3RvcmUpIHtcclxuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcclxuICAgICAgICAvLyBUaGUgdmVyc2lvbiBvZiBlYWNoIGRvY3VtZW50IHRoYXQgd2FzIHJlYWQgZHVyaW5nIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgdGhpcy5yZWFkVmVyc2lvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZGVmZXJyZWQgdXNhZ2UgZXJyb3IgdGhhdCBvY2N1cnJlZCBwcmV2aW91c2x5IGluIHRoaXMgdHJhbnNhY3Rpb24gdGhhdFxyXG4gICAgICAgICAqIHdpbGwgY2F1c2UgdGhlIHRyYW5zYWN0aW9uIHRvIGZhaWwgb25jZSBpdCBhY3R1YWxseSBjb21taXRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFzdFdyaXRlRXJyb3IgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBvZiBkb2N1bWVudHMgdGhhdCBoYXZlIGJlZW4gd3JpdHRlbiBpbiB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBXaGVuIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSB3cml0ZSB0byB0aGUgc2FtZSBrZXkgaW4gYSB0cmFuc2FjdGlvbiwgYW55XHJcbiAgICAgICAgICogd3JpdGVzIGFmdGVyIHRoZSBmaXJzdCBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgbG9va3VwKGtleXMpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUNvbW1pdE5vdENhbGxlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdGaXJlc3RvcmUgdHJhbnNhY3Rpb25zIHJlcXVpcmUgYWxsIHJlYWRzIHRvIGJlIGV4ZWN1dGVkIGJlZm9yZSBhbGwgd3JpdGVzLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkb2NzID0gYXdhaXQgaW52b2tlQmF0Y2hHZXREb2N1bWVudHNScGModGhpcy5kYXRhc3RvcmUsIGtleXMpO1xyXG4gICAgICAgIGRvY3MuZm9yRWFjaChkb2MgPT4gdGhpcy5yZWNvcmRWZXJzaW9uKGRvYykpO1xyXG4gICAgICAgIHJldHVybiBkb2NzO1xyXG4gICAgfVxyXG4gICAgc2V0KGtleSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMud3JpdGUoZGF0YS50b011dGF0aW9uKGtleSwgdGhpcy5wcmVjb25kaXRpb24oa2V5KSkpO1xyXG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShrZXksIGRhdGEpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlKGRhdGEudG9NdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uRm9yVXBkYXRlKGtleSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0V3JpdGVFcnJvciA9IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud3JpdHRlbkRvY3MuYWRkKGtleS50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICB0aGlzLndyaXRlKG5ldyBEZWxldGVNdXRhdGlvbihrZXksIHRoaXMucHJlY29uZGl0aW9uKGtleSkpKTtcclxuICAgICAgICB0aGlzLndyaXR0ZW5Eb2NzLmFkZChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBjb21taXQoKSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVDb21taXROb3RDYWxsZWQoKTtcclxuICAgICAgICBpZiAodGhpcy5sYXN0V3JpdGVFcnJvcikge1xyXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmxhc3RXcml0ZUVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bndyaXR0ZW4gPSB0aGlzLnJlYWRWZXJzaW9ucztcclxuICAgICAgICAvLyBGb3IgZWFjaCBtdXRhdGlvbiwgbm90ZSB0aGF0IHRoZSBkb2Mgd2FzIHdyaXR0ZW4uXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbnMuZm9yRWFjaChtdXRhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIHVud3JpdHRlbi5kZWxldGUobXV0YXRpb24ua2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEZvciBlYWNoIGRvY3VtZW50IHRoYXQgd2FzIHJlYWQgYnV0IG5vdCB3cml0dGVuIHRvLCB3ZSB3YW50IHRvIHBlcmZvcm1cclxuICAgICAgICAvLyBhIGB2ZXJpZnlgIG9wZXJhdGlvbi5cclxuICAgICAgICB1bndyaXR0ZW4uZm9yRWFjaCgoXywgcGF0aCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBEb2N1bWVudEtleS5mcm9tUGF0aChwYXRoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnMucHVzaChuZXcgVmVyaWZ5TXV0YXRpb24oa2V5LCB0aGlzLnByZWNvbmRpdGlvbihrZXkpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXdhaXQgaW52b2tlQ29tbWl0UnBjKHRoaXMuZGF0YXN0b3JlLCB0aGlzLm11dGF0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVjb3JkVmVyc2lvbihkb2MpIHtcclxuICAgICAgICBsZXQgZG9jVmVyc2lvbjtcclxuICAgICAgICBpZiAoZG9jLmlzRm91bmREb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgIGRvY1ZlcnNpb24gPSBkb2MudmVyc2lvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZG9jLmlzTm9Eb2N1bWVudCgpKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBkZWxldGVkIGRvY3MsIHdlIG11c3QgdXNlIGJhc2VWZXJzaW9uIDAgd2hlbiB3ZSBvdmVyd3JpdGUgdGhlbS5cclxuICAgICAgICAgICAgZG9jVmVyc2lvbiA9IFNuYXBzaG90VmVyc2lvbi5taW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbnMuZ2V0KGRvYy5rZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nVmVyc2lvbikge1xyXG4gICAgICAgICAgICBpZiAoIWRvY1ZlcnNpb24uaXNFcXVhbChleGlzdGluZ1ZlcnNpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHRyYW5zYWN0aW9uIHdpbGwgZmFpbCBubyBtYXR0ZXIgd2hhdC5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkFCT1JURUQsICdEb2N1bWVudCB2ZXJzaW9uIGNoYW5nZWQgYmV0d2VlbiB0d28gcmVhZHMuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZFZlcnNpb25zLnNldChkb2Mua2V5LnRvU3RyaW5nKCksIGRvY1ZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmVyc2lvbiBvZiB0aGlzIGRvY3VtZW50IHdoZW4gaXQgd2FzIHJlYWQgaW4gdGhpcyB0cmFuc2FjdGlvbixcclxuICAgICAqIGFzIGEgcHJlY29uZGl0aW9uLCBvciBubyBwcmVjb25kaXRpb24gaWYgaXQgd2FzIG5vdCByZWFkLlxyXG4gICAgICovXHJcbiAgICBwcmVjb25kaXRpb24oa2V5KSB7XHJcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb25zLmdldChrZXkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLndyaXR0ZW5Eb2NzLmhhcyhrZXkudG9TdHJpbmcoKSkgJiYgdmVyc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUodmVyc2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLm5vbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByZWNvbmRpdGlvbiBmb3IgYSBkb2N1bWVudCBpZiB0aGUgb3BlcmF0aW9uIGlzIGFuIHVwZGF0ZS5cclxuICAgICAqL1xyXG4gICAgcHJlY29uZGl0aW9uRm9yVXBkYXRlKGtleSkge1xyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnJlYWRWZXJzaW9ucy5nZXQoa2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIGEgZG9jdW1lbnQgaXMgd3JpdHRlbiwgd2Ugd2FudCB0byB0YWtlIGludG8gYWNjb3VudCB0aGVcclxuICAgICAgICAvLyByZWFkIHRpbWUgYW5kIGV4aXN0ZW5jZVxyXG4gICAgICAgIGlmICghdGhpcy53cml0dGVuRG9jcy5oYXMoa2V5LnRvU3RyaW5nKCkpICYmIHZlcnNpb24pIHtcclxuICAgICAgICAgICAgaWYgKHZlcnNpb24uaXNFcXVhbChTbmFwc2hvdFZlcnNpb24ubWluKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdCwgc28gZmFpbCB0aGUgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhcyB0byBiZSB2YWxpZGF0ZWQgbG9jYWxseSBiZWNhdXNlIHlvdSBjYW4ndCBzZW5kIGFcclxuICAgICAgICAgICAgICAgIC8vIHByZWNvbmRpdGlvbiB0aGF0IGEgZG9jdW1lbnQgZG9lcyBub3QgZXhpc3Qgd2l0aG91dCBjaGFuZ2luZyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgYmFja2VuZCB3cml0ZSB0byBiZSBhbiBpbnNlcnQuIFRoaXMgaXMgdGhlIHJldmVyc2VcclxuICAgICAgICAgICAgICAgIC8vIG9mIHdoYXQgd2Ugd2FudCwgc2luY2Ugd2Ugd2FudCB0byBhc3NlcnQgdGhhdCB0aGUgZG9jdW1lbnQgZG9lc24ndFxyXG4gICAgICAgICAgICAgICAgLy8gZXhpc3QgYnV0IHRoZW4gc2VuZCB0aGUgdXBkYXRlIGFuZCBoYXZlIGl0IGZhaWwuIFNpbmNlIHdlIGNhbid0XHJcbiAgICAgICAgICAgICAgICAvLyBleHByZXNzIHRoYXQgdG8gdGhlIGJhY2tlbmQsIHdlIGhhdmUgdG8gdmFsaWRhdGUgbG9jYWxseS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoaXMgY2FuIGNoYW5nZSBvbmNlIHdlIGNhbiBzZW5kIHNlcGFyYXRlIHZlcmlmeSB3cml0ZXMgaW4gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbi5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIFwiQ2FuJ3QgdXBkYXRlIGEgZG9jdW1lbnQgdGhhdCBkb2Vzbid0IGV4aXN0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEb2N1bWVudCBleGlzdHMsIGJhc2UgcHJlY29uZGl0aW9uIG9uIGRvY3VtZW50IHVwZGF0ZSB0aW1lLlxyXG4gICAgICAgICAgICByZXR1cm4gUHJlY29uZGl0aW9uLnVwZGF0ZVRpbWUodmVyc2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEb2N1bWVudCB3YXMgbm90IHJlYWQsIHNvIHdlIGp1c3QgdXNlIHRoZSBwcmVjb25kaXRpb25zIGZvciBhIGJsaW5kXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZS5cclxuICAgICAgICAgICAgcmV0dXJuIFByZWNvbmRpdGlvbi5leGlzdHModHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGUobXV0YXRpb24pIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUNvbW1pdE5vdENhbGxlZCgpO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zLnB1c2gobXV0YXRpb24pO1xyXG4gICAgfVxyXG4gICAgZW5zdXJlQ29tbWl0Tm90Q2FsbGVkKCkge1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfTUFYX0FUVEVNUFRTX0NPVU5UID0gNTtcclxuLyoqXHJcbiAqIFRyYW5zYWN0aW9uUnVubmVyIGVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgbmVlZGVkIHRvIHJ1biBhbmQgcmV0cnkgdHJhbnNhY3Rpb25zXHJcbiAqIHdpdGggYmFja29mZi5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uUnVubmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFzeW5jUXVldWUsIGRhdGFzdG9yZSwgdXBkYXRlRnVuY3Rpb24sIGRlZmVycmVkKSB7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlID0gYXN5bmNRdWV1ZTtcclxuICAgICAgICB0aGlzLmRhdGFzdG9yZSA9IGRhdGFzdG9yZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUZ1bmN0aW9uID0gdXBkYXRlRnVuY3Rpb247XHJcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IGRlZmVycmVkO1xyXG4gICAgICAgIHRoaXMuYXR0ZW1wdHNSZW1haW5pbmcgPSBERUZBVUxUX01BWF9BVFRFTVBUU19DT1VOVDtcclxuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgRXhwb25lbnRpYWxCYWNrb2ZmKHRoaXMuYXN5bmNRdWV1ZSwgXCJ0cmFuc2FjdGlvbl9yZXRyeVwiIC8qIFRyYW5zYWN0aW9uUmV0cnkgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqIFJ1bnMgdGhlIHRyYW5zYWN0aW9uIGFuZCBzZXRzIHRoZSByZXN1bHQgb24gZGVmZXJyZWQuICovXHJcbiAgICBydW4oKSB7XHJcbiAgICAgICAgdGhpcy5hdHRlbXB0c1JlbWFpbmluZyAtPSAxO1xyXG4gICAgICAgIHRoaXMucnVuV2l0aEJhY2tPZmYoKTtcclxuICAgIH1cclxuICAgIHJ1bldpdGhCYWNrT2ZmKCkge1xyXG4gICAgICAgIHRoaXMuYmFja29mZi5iYWNrb2ZmQW5kUnVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24kMih0aGlzLmRhdGFzdG9yZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9taXNlID0gdGhpcy50cnlSdW5VcGRhdGVGdW5jdGlvbih0cmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIGlmICh1c2VyUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgdXNlclByb21pc2VcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29tbWl0KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGNvbW1pdEVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNhY3Rpb25FcnJvcihjb21taXRFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2godXNlclByb21pc2VFcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc2FjdGlvbkVycm9yKHVzZXJQcm9taXNlRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHRyeVJ1blVwZGF0ZUZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgdXNlclByb21pc2UgPSB0aGlzLnVwZGF0ZUZ1bmN0aW9uKHRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHVzZXJQcm9taXNlKSB8fFxyXG4gICAgICAgICAgICAgICAgIXVzZXJQcm9taXNlLmNhdGNoIHx8XHJcbiAgICAgICAgICAgICAgICAhdXNlclByb21pc2UudGhlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoRXJyb3IoJ1RyYW5zYWN0aW9uIGNhbGxiYWNrIG11c3QgcmV0dXJuIGEgUHJvbWlzZScpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VyUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCByZXRyeSBlcnJvcnMgdGhyb3duIGJ5IHVzZXIgcHJvdmlkZWQgdXBkYXRlRnVuY3Rpb24uXHJcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikge1xyXG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzUmVtYWluaW5nID4gMCAmJiB0aGlzLmlzUmV0cnlhYmxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikpIHtcclxuICAgICAgICAgICAgdGhpcy5hdHRlbXB0c1JlbWFpbmluZyAtPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bldpdGhCYWNrT2ZmKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzUmV0cnlhYmxlVHJhbnNhY3Rpb25FcnJvcihlcnJvcikge1xyXG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnRmlyZWJhc2VFcnJvcicpIHtcclxuICAgICAgICAgICAgLy8gSW4gdHJhbnNhY3Rpb25zLCB0aGUgYmFja2VuZCB3aWxsIGZhaWwgb3V0ZGF0ZWQgcmVhZHMgd2l0aCBGQUlMRURfUFJFQ09ORElUSU9OIGFuZFxyXG4gICAgICAgICAgICAvLyBub24tbWF0Y2hpbmcgZG9jdW1lbnQgdmVyc2lvbnMgd2l0aCBBQk9SVEVELiBUaGVzZSBlcnJvcnMgc2hvdWxkIGJlIHJldHJpZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlcnJvci5jb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gKGNvZGUgPT09ICdhYm9ydGVkJyB8fFxyXG4gICAgICAgICAgICAgICAgY29kZSA9PT0gJ2ZhaWxlZC1wcmVjb25kaXRpb24nIHx8XHJcbiAgICAgICAgICAgICAgICAhaXNQZXJtYW5lbnRFcnJvcihjb2RlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJDIgPSAnRmlyZXN0b3JlQ2xpZW50JztcclxuY29uc3QgTUFYX0NPTkNVUlJFTlRfTElNQk9fUkVTT0xVVElPTlMgPSAxMDA7XHJcbi8qKlxyXG4gKiBGaXJlc3RvcmVDbGllbnQgaXMgYSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBjb25zdHJ1Y3RzIGFuZCBvd25zIGFsbCBvZiB0aGVcclxuICogcGllY2VzIG9mIHRoZSBjbGllbnQgU0RLIGFyY2hpdGVjdHVyZS4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZVxyXG4gKiBhc3luYyBxdWV1ZSB0aGF0IGlzIHNoYXJlZCBieSBhbGwgb2YgdGhlIG90aGVyIGNvbXBvbmVudHMgaW4gdGhlIHN5c3RlbS5cclxuICovXHJcbmNsYXNzIEZpcmVzdG9yZUNsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdXRoQ3JlZGVudGlhbHMsIGFwcENoZWNrQ3JlZGVudGlhbHMsIFxyXG4gICAgLyoqXHJcbiAgICAgKiBBc3luY2hyb25vdXMgcXVldWUgcmVzcG9uc2libGUgZm9yIGFsbCBvZiBvdXIgaW50ZXJuYWwgcHJvY2Vzc2luZy4gV2hlblxyXG4gICAgICogd2UgZ2V0IGluY29taW5nIHdvcmsgZnJvbSB0aGUgdXNlciAodmlhIHB1YmxpYyBBUEkpIG9yIHRoZSBuZXR3b3JrXHJcbiAgICAgKiAoaW5jb21pbmcgR1JQQyBtZXNzYWdlcyksIHdlIHNob3VsZCBhbHdheXMgc2NoZWR1bGUgb250byB0aGlzIHF1ZXVlLlxyXG4gICAgICogVGhpcyBlbnN1cmVzIGFsbCBvZiBvdXIgd29yayBpcyBwcm9wZXJseSBzZXJpYWxpemVkIChlLmcuIHdlIGRvbid0XHJcbiAgICAgKiBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IG9wZXJhdGlvbiB3aGlsZSB0aGUgcHJldmlvdXMgb25lIGlzIHdhaXRpbmcgZm9yXHJcbiAgICAgKiBhbiBhc3luYyBJL08gdG8gY29tcGxldGUpLlxyXG4gICAgICovXHJcbiAgICBhc3luY1F1ZXVlLCBkYXRhYmFzZUluZm8pIHtcclxuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscyA9IGF1dGhDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbHMgPSBhcHBDaGVja0NyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuYXN5bmNRdWV1ZSA9IGFzeW5jUXVldWU7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUluZm8gPSBkYXRhYmFzZUluZm87XHJcbiAgICAgICAgdGhpcy51c2VyID0gVXNlci5VTkFVVEhFTlRJQ0FURUQ7XHJcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IEF1dG9JZC5uZXdJZCgpO1xyXG4gICAgICAgIHRoaXMuYXV0aENyZWRlbnRpYWxMaXN0ZW5lciA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsTGlzdGVuZXIgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5zdGFydChhc3luY1F1ZXVlLCBhc3luYyAodXNlcikgPT4ge1xyXG4gICAgICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdSZWNlaXZlZCB1c2VyPScsIHVzZXIudWlkKTtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoQ3JlZGVudGlhbExpc3RlbmVyKHVzZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFscy5zdGFydChhc3luY1F1ZXVlLCBuZXdBcHBDaGVja1Rva2VuID0+IHtcclxuICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnUmVjZWl2ZWQgbmV3IGFwcCBjaGVjayB0b2tlbj0nLCBuZXdBcHBDaGVja1Rva2VuKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwQ2hlY2tDcmVkZW50aWFsTGlzdGVuZXIobmV3QXBwQ2hlY2tUb2tlbiwgdGhpcy51c2VyKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldENvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYXN5bmNRdWV1ZTogdGhpcy5hc3luY1F1ZXVlLFxyXG4gICAgICAgICAgICBkYXRhYmFzZUluZm86IHRoaXMuZGF0YWJhc2VJbmZvLFxyXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcclxuICAgICAgICAgICAgYXV0aENyZWRlbnRpYWxzOiB0aGlzLmF1dGhDcmVkZW50aWFscyxcclxuICAgICAgICAgICAgYXBwQ2hlY2tDcmVkZW50aWFsczogdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLFxyXG4gICAgICAgICAgICBpbml0aWFsVXNlcjogdGhpcy51c2VyLFxyXG4gICAgICAgICAgICBtYXhDb25jdXJyZW50TGltYm9SZXNvbHV0aW9uczogTUFYX0NPTkNVUlJFTlRfTElNQk9fUkVTT0xVVElPTlNcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoQ3JlZGVudGlhbExpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICB9XHJcbiAgICBzZXRBcHBDaGVja1Rva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLmFwcENoZWNrQ3JlZGVudGlhbExpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGF0IHRoZSBjbGllbnQgaGFzIG5vdCBiZWVuIHRlcm1pbmF0ZWQuIEVuc3VyZXMgdGhhdCBvdGhlciBtZXRob2RzIG9uXHJcbiAgICAgKiB0aGlzIGNsYXNzIGNhbm5vdCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGNsaWVudCBpcyB0ZXJtaW5hdGVkLlxyXG4gICAgICovXHJcbiAgICB2ZXJpZnlOb3RUZXJtaW5hdGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmFzeW5jUXVldWUuaXNTaHV0dGluZ0Rvd24pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ1RoZSBjbGllbnQgaGFzIGFscmVhZHkgYmVlbiB0ZXJtaW5hdGVkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRlcm1pbmF0ZSgpIHtcclxuICAgICAgICB0aGlzLmFzeW5jUXVldWUuZW50ZXJSZXN0cmljdGVkTW9kZSgpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXRFdmVuV2hpbGVSZXN0cmljdGVkKGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ubGluZUNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm9ubGluZUNvbXBvbmVudHMudGVybWluYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vZmZsaW5lQ29tcG9uZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMub2ZmbGluZUNvbXBvbmVudHMudGVybWluYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgY3JlZGVudGlhbHMgcHJvdmlkZXIgbXVzdCBiZSB0ZXJtaW5hdGVkIGFmdGVyIHNodXR0aW5nIGRvd24gdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdGVTdG9yZSBhcyBpdCB3aWxsIHByZXZlbnQgdGhlIFJlbW90ZVN0b3JlIGZyb20gcmV0cmlldmluZyBhdXRoXHJcbiAgICAgICAgICAgICAgICAvLyB0b2tlbnMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhDcmVkZW50aWFscy5zaHV0ZG93bigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja0NyZWRlbnRpYWxzLnNodXRkb3duKCk7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgRmFpbGVkIHRvIHNodXRkb3duIHBlcnNpc3RlbmNlYCk7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZmlyZXN0b3JlRXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKSB7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS52ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCk7XHJcbiAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdJbml0aWFsaXppbmcgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XHJcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gYXdhaXQgY2xpZW50LmdldENvbmZpZ3VyYXRpb24oKTtcclxuICAgIGF3YWl0IG9mZmxpbmVDb21wb25lbnRQcm92aWRlci5pbml0aWFsaXplKGNvbmZpZ3VyYXRpb24pO1xyXG4gICAgbGV0IGN1cnJlbnRVc2VyID0gY29uZmlndXJhdGlvbi5pbml0aWFsVXNlcjtcclxuICAgIGNsaWVudC5zZXRDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIoYXN5bmMgKHVzZXIpID0+IHtcclxuICAgICAgICBpZiAoIWN1cnJlbnRVc2VyLmlzRXF1YWwodXNlcikpIHtcclxuICAgICAgICAgICAgYXdhaXQgbG9jYWxTdG9yZUhhbmRsZVVzZXJDaGFuZ2Uob2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLmxvY2FsU3RvcmUsIHVzZXIpO1xyXG4gICAgICAgICAgICBjdXJyZW50VXNlciA9IHVzZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBXaGVuIGEgdXNlciBjYWxscyBjbGVhclBlcnNpc3RlbmNlKCkgaW4gb25lIGNsaWVudCwgYWxsIG90aGVyIGNsaWVudHNcclxuICAgIC8vIG5lZWQgdG8gYmUgdGVybWluYXRlZCB0byBhbGxvdyB0aGUgZGVsZXRlIHRvIHN1Y2NlZWQuXHJcbiAgICBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIucGVyc2lzdGVuY2Uuc2V0RGF0YWJhc2VEZWxldGVkTGlzdGVuZXIoKCkgPT4gY2xpZW50LnRlcm1pbmF0ZSgpKTtcclxuICAgIGNsaWVudC5vZmZsaW5lQ29tcG9uZW50cyA9IG9mZmxpbmVDb21wb25lbnRQcm92aWRlcjtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBzZXRPbmxpbmVDb21wb25lbnRQcm92aWRlcihjbGllbnQsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyKSB7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS52ZXJpZnlPcGVyYXRpb25JblByb2dyZXNzKCk7XHJcbiAgICBjb25zdCBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIgPSBhd2FpdCBlbnN1cmVPZmZsaW5lQ29tcG9uZW50cyhjbGllbnQpO1xyXG4gICAgbG9nRGVidWcoTE9HX1RBRyQyLCAnSW5pdGlhbGl6aW5nIE9ubGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XHJcbiAgICBjb25zdCBjb25maWd1cmF0aW9uID0gYXdhaXQgY2xpZW50LmdldENvbmZpZ3VyYXRpb24oKTtcclxuICAgIGF3YWl0IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLmluaXRpYWxpemUob2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyLCBjb25maWd1cmF0aW9uKTtcclxuICAgIC8vIFRoZSBDcmVkZW50aWFsQ2hhbmdlTGlzdGVuZXIgb2YgdGhlIG9ubGluZSBjb21wb25lbnQgcHJvdmlkZXIgdGFrZXNcclxuICAgIC8vIHByZWNlZGVuY2Ugb3ZlciB0aGUgb2ZmbGluZSBjb21wb25lbnQgcHJvdmlkZXIuXHJcbiAgICBjbGllbnQuc2V0Q3JlZGVudGlhbENoYW5nZUxpc3RlbmVyKHVzZXIgPT4gcmVtb3RlU3RvcmVIYW5kbGVDcmVkZW50aWFsQ2hhbmdlKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnJlbW90ZVN0b3JlLCB1c2VyKSk7XHJcbiAgICBjbGllbnQuc2V0QXBwQ2hlY2tUb2tlbkNoYW5nZUxpc3RlbmVyKChfLCB1c2VyKSA9PiByZW1vdGVTdG9yZUhhbmRsZUNyZWRlbnRpYWxDaGFuZ2Uob25saW5lQ29tcG9uZW50UHJvdmlkZXIucmVtb3RlU3RvcmUsIHVzZXIpKTtcclxuICAgIGNsaWVudC5vbmxpbmVDb21wb25lbnRzID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXI7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KSB7XHJcbiAgICBpZiAoIWNsaWVudC5vZmZsaW5lQ29tcG9uZW50cykge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMiwgJ1VzaW5nIGRlZmF1bHQgT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XHJcbiAgICAgICAgYXdhaXQgc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgbmV3IE1lbW9yeU9mZmxpbmVDb21wb25lbnRQcm92aWRlcigpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbGllbnQub2ZmbGluZUNvbXBvbmVudHM7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpIHtcclxuICAgIGlmICghY2xpZW50Lm9ubGluZUNvbXBvbmVudHMpIHtcclxuICAgICAgICBsb2dEZWJ1ZyhMT0dfVEFHJDIsICdVc2luZyBkZWZhdWx0IE9ubGluZUNvbXBvbmVudFByb3ZpZGVyJyk7XHJcbiAgICAgICAgYXdhaXQgc2V0T25saW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBuZXcgT25saW5lQ29tcG9uZW50UHJvdmlkZXIoKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xpZW50Lm9ubGluZUNvbXBvbmVudHM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGVyc2lzdGVuY2UoY2xpZW50KSB7XHJcbiAgICByZXR1cm4gZW5zdXJlT2ZmbGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5wZXJzaXN0ZW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TG9jYWxTdG9yZShjbGllbnQpIHtcclxuICAgIHJldHVybiBlbnN1cmVPZmZsaW5lQ29tcG9uZW50cyhjbGllbnQpLnRoZW4oYyA9PiBjLmxvY2FsU3RvcmUpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJlbW90ZVN0b3JlKGNsaWVudCkge1xyXG4gICAgcmV0dXJuIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5yZW1vdGVTdG9yZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0U3luY0VuZ2luZShjbGllbnQpIHtcclxuICAgIHJldHVybiBlbnN1cmVPbmxpbmVDb21wb25lbnRzKGNsaWVudCkudGhlbihjID0+IGMuc3luY0VuZ2luZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RGF0YXN0b3JlKGNsaWVudCkge1xyXG4gICAgcmV0dXJuIGVuc3VyZU9ubGluZUNvbXBvbmVudHMoY2xpZW50KS50aGVuKGMgPT4gYy5kYXRhc3RvcmUpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGdldEV2ZW50TWFuYWdlcihjbGllbnQpIHtcclxuICAgIGNvbnN0IG9ubGluZUNvbXBvbmVudFByb3ZpZGVyID0gYXdhaXQgZW5zdXJlT25saW5lQ29tcG9uZW50cyhjbGllbnQpO1xyXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gb25saW5lQ29tcG9uZW50UHJvdmlkZXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgZXZlbnRNYW5hZ2VyLm9uTGlzdGVuID0gc3luY0VuZ2luZUxpc3Rlbi5iaW5kKG51bGwsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLnN5bmNFbmdpbmUpO1xyXG4gICAgZXZlbnRNYW5hZ2VyLm9uVW5saXN0ZW4gPSBzeW5jRW5naW5lVW5saXN0ZW4uYmluZChudWxsLCBvbmxpbmVDb21wb25lbnRQcm92aWRlci5zeW5jRW5naW5lKTtcclxuICAgIHJldHVybiBldmVudE1hbmFnZXI7XHJcbn1cclxuLyoqIEVuYWJsZXMgdGhlIG5ldHdvcmsgY29ubmVjdGlvbiBhbmQgcmUtZW5xdWV1ZXMgYWxsIHBlbmRpbmcgb3BlcmF0aW9ucy4gKi9cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RW5hYmxlTmV0d29yayhjbGllbnQpIHtcclxuICAgIHJldHVybiBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBwZXJzaXN0ZW5jZSA9IGF3YWl0IGdldFBlcnNpc3RlbmNlKGNsaWVudCk7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlU3RvcmUgPSBhd2FpdCBnZXRSZW1vdGVTdG9yZShjbGllbnQpO1xyXG4gICAgICAgIHBlcnNpc3RlbmNlLnNldE5ldHdvcmtFbmFibGVkKHRydWUpO1xyXG4gICAgICAgIHJldHVybiByZW1vdGVTdG9yZUVuYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqIERpc2FibGVzIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24uIFBlbmRpbmcgb3BlcmF0aW9ucyB3aWxsIG5vdCBjb21wbGV0ZS4gKi9cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50RGlzYWJsZU5ldHdvcmsoY2xpZW50KSB7XHJcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGVyc2lzdGVuY2UgPSBhd2FpdCBnZXRQZXJzaXN0ZW5jZShjbGllbnQpO1xyXG4gICAgICAgIGNvbnN0IHJlbW90ZVN0b3JlID0gYXdhaXQgZ2V0UmVtb3RlU3RvcmUoY2xpZW50KTtcclxuICAgICAgICBwZXJzaXN0ZW5jZS5zZXROZXR3b3JrRW5hYmxlZChmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZVN0b3JlRGlzYWJsZU5ldHdvcmsocmVtb3RlU3RvcmUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgd3JpdGVzIHRoYXQgd2VyZSBwZW5kaW5nIGF0IHRoZSB0aW1lXHJcbiAqIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQgcmVjZWl2ZWQgc2VydmVyIGFja25vd2xlZGdlbWVudC4gQW4gYWNrbm93bGVkZ2VtZW50XHJcbiAqIGNhbiBiZSBlaXRoZXIgYWNjZXB0YW5jZSBvciByZWplY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRXYWl0Rm9yUGVuZGluZ1dyaXRlcyhjbGllbnQpIHtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBzeW5jRW5naW5lID0gYXdhaXQgZ2V0U3luY0VuZ2luZShjbGllbnQpO1xyXG4gICAgICAgIHJldHVybiBzeW5jRW5naW5lUmVnaXN0ZXJQZW5kaW5nV3JpdGVzQ2FsbGJhY2soc3luY0VuZ2luZSwgZGVmZXJyZWQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRMaXN0ZW4oY2xpZW50LCBxdWVyeSwgb3B0aW9ucywgb2JzZXJ2ZXIpIHtcclxuICAgIGNvbnN0IHdyYXBwZWRPYnNlcnZlciA9IG5ldyBBc3luY09ic2VydmVyKG9ic2VydmVyKTtcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFF1ZXJ5TGlzdGVuZXIocXVlcnksIHdyYXBwZWRPYnNlcnZlciwgb3B0aW9ucyk7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcclxuICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VyTGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHdyYXBwZWRPYnNlcnZlci5tdXRlKCk7XHJcbiAgICAgICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IGF3YWl0IGdldEV2ZW50TWFuYWdlcihjbGllbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50RnJvbUxvY2FsQ2FjaGUoY2xpZW50LCBkb2NLZXkpIHtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBsb2NhbFN0b3JlID0gYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpO1xyXG4gICAgICAgIHJldHVybiByZWFkRG9jdW1lbnRGcm9tQ2FjaGUobG9jYWxTdG9yZSwgZG9jS2V5LCBkZWZlcnJlZCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIGtleSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIHJlYWREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoZXZlbnRNYW5hZ2VyLCBjbGllbnQuYXN5bmNRdWV1ZSwga2V5LCBvcHRpb25zLCBkZWZlcnJlZCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudEdldERvY3VtZW50c0Zyb21Mb2NhbENhY2hlKGNsaWVudCwgcXVlcnkpIHtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBsb2NhbFN0b3JlID0gYXdhaXQgZ2V0TG9jYWxTdG9yZShjbGllbnQpO1xyXG4gICAgICAgIHJldHVybiBleGVjdXRlUXVlcnlGcm9tQ2FjaGUobG9jYWxTdG9yZSwgcXVlcnksIGRlZmVycmVkKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzVmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIHF1ZXJ5LCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcclxuICAgICAgICByZXR1cm4gZXhlY3V0ZVF1ZXJ5VmlhU25hcHNob3RMaXN0ZW5lcihldmVudE1hbmFnZXIsIGNsaWVudC5hc3luY1F1ZXVlLCBxdWVyeSwgb3B0aW9ucywgZGVmZXJyZWQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRXcml0ZShjbGllbnQsIG11dGF0aW9ucykge1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN5bmNFbmdpbmUgPSBhd2FpdCBnZXRTeW5jRW5naW5lKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIHN5bmNFbmdpbmVXcml0ZShzeW5jRW5naW5lLCBtdXRhdGlvbnMsIGRlZmVycmVkKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuZnVuY3Rpb24gZmlyZXN0b3JlQ2xpZW50QWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoY2xpZW50LCBvYnNlcnZlcikge1xyXG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gYXdhaXQgZ2V0RXZlbnRNYW5hZ2VyKGNsaWVudCk7XHJcbiAgICAgICAgcmV0dXJuIGFkZFNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgd3JhcHBlZE9ic2VydmVyKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB3cmFwcGVkT2JzZXJ2ZXIubXV0ZSgpO1xyXG4gICAgICAgIGNsaWVudC5hc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBldmVudE1hbmFnZXIgPSBhd2FpdCBnZXRFdmVudE1hbmFnZXIoY2xpZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNuYXBzaG90c0luU3luY0xpc3RlbmVyKGV2ZW50TWFuYWdlciwgd3JhcHBlZE9ic2VydmVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFRha2VzIGFuIHVwZGF0ZUZ1bmN0aW9uIGluIHdoaWNoIGEgc2V0IG9mIHJlYWRzIGFuZCB3cml0ZXMgY2FuIGJlIHBlcmZvcm1lZFxyXG4gKiBhdG9taWNhbGx5LiBJbiB0aGUgdXBkYXRlRnVuY3Rpb24sIHRoZSBjbGllbnQgY2FuIHJlYWQgYW5kIHdyaXRlIHZhbHVlc1xyXG4gKiB1c2luZyB0aGUgc3VwcGxpZWQgdHJhbnNhY3Rpb24gb2JqZWN0LiBBZnRlciB0aGUgdXBkYXRlRnVuY3Rpb24sIGFsbFxyXG4gKiBjaGFuZ2VzIHdpbGwgYmUgY29tbWl0dGVkLiBJZiBhIHJldHJ5YWJsZSBlcnJvciBvY2N1cnMgKGV4OiBzb21lIG90aGVyXHJcbiAqIGNsaWVudCBoYXMgY2hhbmdlZCBhbnkgb2YgdGhlIGRhdGEgcmVmZXJlbmNlZCksIHRoZW4gdGhlIHVwZGF0ZUZ1bmN0aW9uXHJcbiAqIHdpbGwgYmUgY2FsbGVkIGFnYWluIGFmdGVyIGEgYmFja29mZi4gSWYgdGhlIHVwZGF0ZUZ1bmN0aW9uIHN0aWxsIGZhaWxzXHJcbiAqIGFmdGVyIGFsbCByZXRyaWVzLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJlamVjdGVkLlxyXG4gKlxyXG4gKiBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHBhc3NlZCB0byB0aGUgdXBkYXRlRnVuY3Rpb24gY29udGFpbnMgbWV0aG9kcyBmb3JcclxuICogYWNjZXNzaW5nIGRvY3VtZW50cyBhbmQgY29sbGVjdGlvbnMuIFVubGlrZSBvdGhlciBkYXRhc3RvcmUgYWNjZXNzLCBkYXRhXHJcbiAqIGFjY2Vzc2VkIHdpdGggdGhlIHRyYW5zYWN0aW9uIHdpbGwgbm90IHJlZmxlY3QgbG9jYWwgY2hhbmdlcyB0aGF0IGhhdmUgbm90XHJcbiAqIGJlZW4gY29tbWl0dGVkLiBGb3IgdGhpcyByZWFzb24sIGl0IGlzIHJlcXVpcmVkIHRoYXQgYWxsIHJlYWRzIGFyZVxyXG4gKiBwZXJmb3JtZWQgYmVmb3JlIGFueSB3cml0ZXMuIFRyYW5zYWN0aW9ucyBtdXN0IGJlIHBlcmZvcm1lZCB3aGlsZSBvbmxpbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRUcmFuc2FjdGlvbihjbGllbnQsIHVwZGF0ZUZ1bmN0aW9uKSB7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZUFuZEZvcmdldChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF0YXN0b3JlID0gYXdhaXQgZ2V0RGF0YXN0b3JlKGNsaWVudCk7XHJcbiAgICAgICAgbmV3IFRyYW5zYWN0aW9uUnVubmVyKGNsaWVudC5hc3luY1F1ZXVlLCBkYXRhc3RvcmUsIHVwZGF0ZUZ1bmN0aW9uLCBkZWZlcnJlZCkucnVuKCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHJlYWREb2N1bWVudEZyb21DYWNoZShsb2NhbFN0b3JlLCBkb2NLZXksIHJlc3VsdCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IGxvY2FsU3RvcmVSZWFkRG9jdW1lbnQobG9jYWxTdG9yZSwgZG9jS2V5KTtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuaXNGb3VuZERvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoZG9jdW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5pc05vRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yZWplY3QobmV3IEZpcmVzdG9yZUVycm9yKENvZGUuVU5BVkFJTEFCTEUsICdGYWlsZWQgdG8gZ2V0IGRvY3VtZW50IGZyb20gY2FjaGUuIChIb3dldmVyLCB0aGlzIGRvY3VtZW50IG1heSAnICtcclxuICAgICAgICAgICAgICAgIFwiZXhpc3Qgb24gdGhlIHNlcnZlci4gUnVuIGFnYWluIHdpdGhvdXQgc2V0dGluZyAnc291cmNlJyBpbiBcIiArXHJcbiAgICAgICAgICAgICAgICAndGhlIEdldE9wdGlvbnMgdG8gYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgZG9jdW1lbnQgZnJvbSB0aGUgJyArXHJcbiAgICAgICAgICAgICAgICAnc2VydmVyLiknKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zdCBmaXJlc3RvcmVFcnJvciA9IHdyYXBJblVzZXJFcnJvcklmUmVjb3ZlcmFibGUoZSwgYEZhaWxlZCB0byBnZXQgZG9jdW1lbnQgJyR7ZG9jS2V5fSBmcm9tIGNhY2hlYCk7XHJcbiAgICAgICAgcmVzdWx0LnJlamVjdChmaXJlc3RvcmVFcnJvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlcyBhIGxhdGVuY3ktY29tcGVuc2F0ZWQgZG9jdW1lbnQgZnJvbSB0aGUgYmFja2VuZCB2aWEgYVxyXG4gKiBTbmFwc2hvdExpc3RlbmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVhZERvY3VtZW50VmlhU25hcHNob3RMaXN0ZW5lcihldmVudE1hbmFnZXIsIGFzeW5jUXVldWUsIGtleSwgb3B0aW9ucywgcmVzdWx0KSB7XHJcbiAgICBjb25zdCB3cmFwcGVkT2JzZXJ2ZXIgPSBuZXcgQXN5bmNPYnNlcnZlcih7XHJcbiAgICAgICAgbmV4dDogKHNuYXApID0+IHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHF1ZXJ5IGZpcnN0IGJlZm9yZSBwYXNzaW5nIGV2ZW50IHRvIHVzZXIgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gdXNlciBhY3Rpb25zIGFmZmVjdGluZyB0aGUgbm93IHN0YWxlIHF1ZXJ5LlxyXG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikpO1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdHMgPSBzbmFwLmRvY3MuaGFzKGtleSk7XHJcbiAgICAgICAgICAgIGlmICghZXhpc3RzICYmIHNuYXAuZnJvbUNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGRpbW9uZCk6IElmIHdlJ3JlIG9ubGluZSBhbmQgdGhlIGRvY3VtZW50IGRvZXNuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGV4aXN0IHRoZW4gd2UgcmVzb2x2ZSB3aXRoIGEgZG9jLmV4aXN0cyBzZXQgdG8gZmFsc2UuIElmXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBvZmZsaW5lIGhvd2V2ZXIsIHdlIHJlamVjdCB0aGUgUHJvbWlzZSBpbiB0aGlzXHJcbiAgICAgICAgICAgICAgICAvLyBjYXNlLiBUd28gb3B0aW9uczogMSkgQ2FjaGUgdGhlIG5lZ2F0aXZlIHJlc3BvbnNlIGZyb21cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgc28gd2UgY2FuIGRlbGl2ZXIgdGhhdCBldmVuIHdoZW4geW91J3JlXHJcbiAgICAgICAgICAgICAgICAvLyBvZmZsaW5lIDIpIEFjdHVhbGx5IHJlamVjdCB0aGUgUHJvbWlzZSBpbiB0aGUgb25saW5lIGNhc2VcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTkFWQUlMQUJMRSwgJ0ZhaWxlZCB0byBnZXQgZG9jdW1lbnQgYmVjYXVzZSB0aGUgY2xpZW50IGlzIG9mZmxpbmUuJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV4aXN0cyAmJlxyXG4gICAgICAgICAgICAgICAgc25hcC5mcm9tQ2FjaGUgJiZcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgJiZcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc291cmNlID09PSAnc2VydmVyJykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTkFWQUlMQUJMRSwgJ0ZhaWxlZCB0byBnZXQgZG9jdW1lbnQgZnJvbSBzZXJ2ZXIuIChIb3dldmVyLCB0aGlzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdkb2N1bWVudCBkb2VzIGV4aXN0IGluIHRoZSBsb2NhbCBjYWNoZS4gUnVuIGFnYWluICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd3aXRob3V0IHNldHRpbmcgc291cmNlIHRvIFwic2VydmVyXCIgdG8gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JldHJpZXZlIHRoZSBjYWNoZWQgZG9jdW1lbnQuKScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKHNuYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogZSA9PiByZXN1bHQucmVqZWN0KGUpXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFF1ZXJ5TGlzdGVuZXIobmV3UXVlcnlGb3JQYXRoKGtleS5wYXRoKSwgd3JhcHBlZE9ic2VydmVyLCB7XHJcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlczogdHJ1ZSxcclxuICAgICAgICB3YWl0Rm9yU3luY1doZW5PbmxpbmU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGV2ZW50TWFuYWdlckxpc3RlbihldmVudE1hbmFnZXIsIGxpc3RlbmVyKTtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUXVlcnlGcm9tQ2FjaGUobG9jYWxTdG9yZSwgcXVlcnksIHJlc3VsdCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBxdWVyeVJlc3VsdCA9IGF3YWl0IGxvY2FsU3RvcmVFeGVjdXRlUXVlcnkobG9jYWxTdG9yZSwgcXVlcnksIFxyXG4gICAgICAgIC8qIHVzZVByZXZpb3VzUmVzdWx0cz0gKi8gdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBWaWV3KHF1ZXJ5LCBxdWVyeVJlc3VsdC5yZW1vdGVLZXlzKTtcclxuICAgICAgICBjb25zdCB2aWV3RG9jQ2hhbmdlcyA9IHZpZXcuY29tcHV0ZURvY0NoYW5nZXMocXVlcnlSZXN1bHQuZG9jdW1lbnRzKTtcclxuICAgICAgICBjb25zdCB2aWV3Q2hhbmdlID0gdmlldy5hcHBseUNoYW5nZXModmlld0RvY0NoYW5nZXMsIFxyXG4gICAgICAgIC8qIHVwZGF0ZUxpbWJvRG9jdW1lbnRzPSAqLyBmYWxzZSk7XHJcbiAgICAgICAgcmVzdWx0LnJlc29sdmUodmlld0NoYW5nZS5zbmFwc2hvdCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUVycm9yID0gd3JhcEluVXNlckVycm9ySWZSZWNvdmVyYWJsZShlLCBgRmFpbGVkIHRvIGV4ZWN1dGUgcXVlcnkgJyR7cXVlcnl9IGFnYWluc3QgY2FjaGVgKTtcclxuICAgICAgICByZXN1bHQucmVqZWN0KGZpcmVzdG9yZUVycm9yKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGEgbGF0ZW5jeS1jb21wZW5zYXRlZCBxdWVyeSBzbmFwc2hvdCBmcm9tIHRoZSBiYWNrZW5kIHZpYSBhXHJcbiAqIFNuYXBzaG90TGlzdGVuZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBleGVjdXRlUXVlcnlWaWFTbmFwc2hvdExpc3RlbmVyKGV2ZW50TWFuYWdlciwgYXN5bmNRdWV1ZSwgcXVlcnksIG9wdGlvbnMsIHJlc3VsdCkge1xyXG4gICAgY29uc3Qgd3JhcHBlZE9ic2VydmVyID0gbmV3IEFzeW5jT2JzZXJ2ZXIoe1xyXG4gICAgICAgIG5leHQ6IHNuYXBzaG90ID0+IHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHF1ZXJ5IGZpcnN0IGJlZm9yZSBwYXNzaW5nIGV2ZW50IHRvIHVzZXIgdG8gYXZvaWRcclxuICAgICAgICAgICAgLy8gdXNlciBhY3Rpb25zIGFmZmVjdGluZyB0aGUgbm93IHN0YWxlIHF1ZXJ5LlxyXG4gICAgICAgICAgICBhc3luY1F1ZXVlLmVucXVldWVBbmRGb3JnZXQoKCkgPT4gZXZlbnRNYW5hZ2VyVW5saXN0ZW4oZXZlbnRNYW5hZ2VyLCBsaXN0ZW5lcikpO1xyXG4gICAgICAgICAgICBpZiAoc25hcHNob3QuZnJvbUNhY2hlICYmIG9wdGlvbnMuc291cmNlID09PSAnc2VydmVyJykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlamVjdChuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTkFWQUlMQUJMRSwgJ0ZhaWxlZCB0byBnZXQgZG9jdW1lbnRzIGZyb20gc2VydmVyLiAoSG93ZXZlciwgdGhlc2UgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50cyBtYXkgZXhpc3QgaW4gdGhlIGxvY2FsIGNhY2hlLiBSdW4gYWdhaW4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3dpdGhvdXQgc2V0dGluZyBzb3VyY2UgdG8gXCJzZXJ2ZXJcIiB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAncmV0cmlldmUgdGhlIGNhY2hlZCBkb2N1bWVudHMuKScpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKHNuYXBzaG90KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3I6IGUgPT4gcmVzdWx0LnJlamVjdChlKVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IG5ldyBRdWVyeUxpc3RlbmVyKHF1ZXJ5LCB3cmFwcGVkT2JzZXJ2ZXIsIHtcclxuICAgICAgICBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzOiB0cnVlLFxyXG4gICAgICAgIHdhaXRGb3JTeW5jV2hlbk9ubGluZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZXZlbnRNYW5hZ2VyTGlzdGVuKGV2ZW50TWFuYWdlciwgbGlzdGVuZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGZpcmVzdG9yZUNsaWVudExvYWRCdW5kbGUoY2xpZW50LCBkYXRhYmFzZUlkLCBkYXRhLCByZXN1bHRUYXNrKSB7XHJcbiAgICBjb25zdCByZWFkZXIgPSBjcmVhdGVCdW5kbGVSZWFkZXIoZGF0YSwgbmV3U2VyaWFsaXplcihkYXRhYmFzZUlkKSk7XHJcbiAgICBjbGllbnQuYXN5bmNRdWV1ZS5lbnF1ZXVlQW5kRm9yZ2V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICBzeW5jRW5naW5lTG9hZEJ1bmRsZShhd2FpdCBnZXRTeW5jRW5naW5lKGNsaWVudCksIHJlYWRlciwgcmVzdWx0VGFzayk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBmaXJlc3RvcmVDbGllbnRHZXROYW1lZFF1ZXJ5KGNsaWVudCwgcXVlcnlOYW1lKSB7XHJcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWUuZW5xdWV1ZShhc3luYyAoKSA9PiBsb2NhbFN0b3JlR2V0TmFtZWRRdWVyeShhd2FpdCBnZXRMb2NhbFN0b3JlKGNsaWVudCksIHF1ZXJ5TmFtZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUJ1bmRsZVJlYWRlcihkYXRhLCBzZXJpYWxpemVyKSB7XHJcbiAgICBsZXQgY29udGVudDtcclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb250ZW50ID0gbmV3VGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb250ZW50ID0gZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdCdW5kbGVSZWFkZXIodG9CeXRlU3RyZWFtUmVhZGVyKGNvbnRlbnQpLCBzZXJpYWxpemVyKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBMT0dfVEFHJDEgPSAnQ29tcG9uZW50UHJvdmlkZXInO1xyXG4vKipcclxuICogQW4gaW5zdGFuY2UgbWFwIHRoYXQgZW5zdXJlcyBvbmx5IG9uZSBEYXRhc3RvcmUgZXhpc3RzIHBlciBGaXJlc3RvcmVcclxuICogaW5zdGFuY2UuXHJcbiAqL1xyXG5jb25zdCBkYXRhc3RvcmVJbnN0YW5jZXMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgaW5zdGFuY2UuIE11c3QgYmUgY2FsbGVkXHJcbiAqIHdoZW4gdGhlIGBGaXJlc3RvcmVgIGluc3RhbmNlIGlzIHRlcm1pbmF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVDb21wb25lbnRzKGZpcmVzdG9yZSkge1xyXG4gICAgY29uc3QgZGF0YXN0b3JlID0gZGF0YXN0b3JlSW5zdGFuY2VzLmdldChmaXJlc3RvcmUpO1xyXG4gICAgaWYgKGRhdGFzdG9yZSkge1xyXG4gICAgICAgIGxvZ0RlYnVnKExPR19UQUckMSwgJ1JlbW92aW5nIERhdGFzdG9yZScpO1xyXG4gICAgICAgIGRhdGFzdG9yZUluc3RhbmNlcy5kZWxldGUoZmlyZXN0b3JlKTtcclxuICAgICAgICBkYXRhc3RvcmUudGVybWluYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWFrZURhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGFiYXNlSW5mbyhkYXRhYmFzZUlkLCBhcHBJZCwgcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzLmhvc3QsIHNldHRpbmdzLnNzbCwgc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZywgc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nLCBzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXMpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIHNldHRpbmdzKCkgZGVmYXVsdHM6XHJcbmNvbnN0IERFRkFVTFRfSE9TVCA9ICdmaXJlc3RvcmUuZ29vZ2xlYXBpcy5jb20nO1xyXG5jb25zdCBERUZBVUxUX1NTTCA9IHRydWU7XHJcbi8qKlxyXG4gKiBBIGNvbmNyZXRlIHR5cGUgZGVzY3JpYmluZyBhbGwgdGhlIHZhbHVlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHZpYSBhXHJcbiAqIHVzZXItc3VwcGxpZWQgYEZpcmVzdG9yZVNldHRpbmdzYCBvYmplY3QuIFRoaXMgaXMgYSBzZXBhcmF0ZSB0eXBlIHNvIHRoYXRcclxuICogZGVmYXVsdHMgY2FuIGJlIHN1cHBsaWVkIGFuZCB0aGUgdmFsdWUgY2FuIGJlIGNoZWNrZWQgZm9yIGVxdWFsaXR5LlxyXG4gKi9cclxuY2xhc3MgRmlyZXN0b3JlU2V0dGluZ3NJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5ob3N0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNzbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIkNhbid0IHByb3ZpZGUgc3NsIG9wdGlvbiBpZiBob3N0IG9wdGlvbiBpcyBub3Qgc2V0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IERFRkFVTFRfSE9TVDtcclxuICAgICAgICAgICAgdGhpcy5zc2wgPSBERUZBVUxUX1NTTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IHNldHRpbmdzLmhvc3Q7XHJcbiAgICAgICAgICAgIHRoaXMuc3NsID0gKF9hID0gc2V0dGluZ3Muc3NsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1NTTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHNldHRpbmdzLmNyZWRlbnRpYWxzO1xyXG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9ICEhc2V0dGluZ3MuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcclxuICAgICAgICBpZiAoc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlU2l6ZUJ5dGVzID0gTFJVX0RFRkFVTFRfQ0FDSEVfU0laRV9CWVRFUztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyAhPT0gTFJVX0NPTExFQ1RJT05fRElTQUJMRUQgJiZcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzIDwgTFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFUykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYGNhY2hlU2l6ZUJ5dGVzIG11c3QgYmUgYXQgbGVhc3QgJHtMUlVfTUlOSU1VTV9DQUNIRV9TSVpFX0JZVEVTfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVNpemVCeXRlcyA9IHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyA9ICEhc2V0dGluZ3MuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZztcclxuICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyA9XHJcbiAgICAgICAgICAgICEhc2V0dGluZ3MuZXhwZXJpbWVudGFsQXV0b0RldGVjdExvbmdQb2xsaW5nO1xyXG4gICAgICAgIHRoaXMudXNlRmV0Y2hTdHJlYW1zID0gISFzZXR0aW5ncy51c2VGZXRjaFN0cmVhbXM7XHJcbiAgICAgICAgdmFsaWRhdGVJc05vdFVzZWRUb2dldGhlcignZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZycsIHNldHRpbmdzLmV4cGVyaW1lbnRhbEZvcmNlTG9uZ1BvbGxpbmcsICdleHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcnLCBzZXR0aW5ncy5leHBlcmltZW50YWxBdXRvRGV0ZWN0TG9uZ1BvbGxpbmcpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5ob3N0ID09PSBvdGhlci5ob3N0ICYmXHJcbiAgICAgICAgICAgIHRoaXMuc3NsID09PSBvdGhlci5zc2wgJiZcclxuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9PT0gb3RoZXIuY3JlZGVudGlhbHMgJiZcclxuICAgICAgICAgICAgdGhpcy5jYWNoZVNpemVCeXRlcyA9PT0gb3RoZXIuY2FjaGVTaXplQnl0ZXMgJiZcclxuICAgICAgICAgICAgdGhpcy5leHBlcmltZW50YWxGb3JjZUxvbmdQb2xsaW5nID09PVxyXG4gICAgICAgICAgICAgICAgb3RoZXIuZXhwZXJpbWVudGFsRm9yY2VMb25nUG9sbGluZyAmJlxyXG4gICAgICAgICAgICB0aGlzLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyA9PT1cclxuICAgICAgICAgICAgICAgIG90aGVyLmV4cGVyaW1lbnRhbEF1dG9EZXRlY3RMb25nUG9sbGluZyAmJlxyXG4gICAgICAgICAgICB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgPT09IG90aGVyLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMgJiZcclxuICAgICAgICAgICAgdGhpcy51c2VGZXRjaFN0cmVhbXMgPT09IG90aGVyLnVzZUZldGNoU3RyZWFtcyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBDbG91ZCBGaXJlc3RvcmUgc2VydmljZSBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSB7QGxpbmsgZ2V0RmlyZXN0b3JlfS5cclxuICovXHJcbmNsYXNzIEZpcmVzdG9yZSQxIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkT3JBcHAsIF9hdXRoQ3JlZGVudGlhbHMsIF9hcHBDaGVja0NyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgdGhpcy5fYXV0aENyZWRlbnRpYWxzID0gX2F1dGhDcmVkZW50aWFscztcclxuICAgICAgICB0aGlzLl9hcHBDaGVja0NyZWRlbnRpYWxzID0gX2FwcENoZWNrQ3JlZGVudGlhbHM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBpdCdzIGEgRmlyZXN0b3JlIG9yIEZpcmVzdG9yZSBMaXRlIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdmaXJlc3RvcmUtbGl0ZSc7XHJcbiAgICAgICAgdGhpcy5fcGVyc2lzdGVuY2VLZXkgPSAnKGxpdGUpJztcclxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoe30pO1xyXG4gICAgICAgIHRoaXMuX3NldHRpbmdzRnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGRhdGFiYXNlSWRPckFwcCBpbnN0YW5jZW9mIERhdGFiYXNlSWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWRPckFwcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcCA9IGRhdGFiYXNlSWRPckFwcDtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWRGcm9tQXBwKGRhdGFiYXNlSWRPckFwcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGBGaXJlc3RvcmVgIHNlcnZpY2VcclxuICAgICAqIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXQgYXBwKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fYXBwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sIFwiRmlyZXN0b3JlIHdhcyBub3QgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIEZpcmViYXNlIFNESy4gJ2FwcCcgaXMgXCIgK1xyXG4gICAgICAgICAgICAgICAgJ25vdCBhdmFpbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcDtcclxuICAgIH1cclxuICAgIGdldCBfaW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzRnJvemVuO1xyXG4gICAgfVxyXG4gICAgZ2V0IF90ZXJtaW5hdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXJtaW5hdGVUYXNrICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBfc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3NGcm96ZW4pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0ZpcmVzdG9yZSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgYW5kIGl0cyBzZXR0aW5ncyBjYW4gbm8gbG9uZ2VyICcgK1xyXG4gICAgICAgICAgICAgICAgJ2JlIGNoYW5nZWQuIFlvdSBjYW4gb25seSBtb2RpZnkgc2V0dGluZ3MgYmVmb3JlIGNhbGxpbmcgYW55IG90aGVyICcgK1xyXG4gICAgICAgICAgICAgICAgJ21ldGhvZHMgb24gYSBGaXJlc3RvcmUgb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBGaXJlc3RvcmVTZXR0aW5nc0ltcGwoc2V0dGluZ3MpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5jcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1dGhDcmVkZW50aWFscyA9IG1ha2VBdXRoQ3JlZGVudGlhbHNQcm92aWRlcihzZXR0aW5ncy5jcmVkZW50aWFscyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFNldHRpbmdzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncztcclxuICAgIH1cclxuICAgIF9mcmVlemVTZXR0aW5ncygpIHtcclxuICAgICAgICB0aGlzLl9zZXR0aW5nc0Zyb3plbiA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xyXG4gICAgfVxyXG4gICAgX2RlbGV0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Rlcm1pbmF0ZVRhc2spIHtcclxuICAgICAgICAgICAgdGhpcy5fdGVybWluYXRlVGFzayA9IHRoaXMuX3Rlcm1pbmF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdGVybWluYXRlVGFzaztcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBgRmlyZXN0b3JlYCBpbnN0YW5jZS4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhcHA6IHRoaXMuX2FwcCxcclxuICAgICAgICAgICAgZGF0YWJhc2VJZDogdGhpcy5fZGF0YWJhc2VJZCxcclxuICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuX3NldHRpbmdzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVybWluYXRlcyBhbGwgY29tcG9uZW50cyB1c2VkIGJ5IHRoaXMgY2xpZW50LiBTdWJjbGFzc2VzIGNhbiBvdmVycmlkZVxyXG4gICAgICogdGhpcyBtZXRob2QgdG8gY2xlYW4gdXAgdGhlaXIgb3duIGRlcGVuZGVuY2llcywgYnV0IG11c3QgYWxzbyBjYWxsIHRoaXNcclxuICAgICAqIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBPbmx5IGV2ZXIgY2FsbGVkIG9uY2UuXHJcbiAgICAgKi9cclxuICAgIF90ZXJtaW5hdGUoKSB7XHJcbiAgICAgICAgcmVtb3ZlQ29tcG9uZW50cyh0aGlzKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGF0YWJhc2VJZEZyb21BcHAoYXBwKSB7XHJcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuYXBwbHkoYXBwLm9wdGlvbnMsIFsncHJvamVjdElkJ10pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1wicHJvamVjdElkXCIgbm90IHByb3ZpZGVkIGluIGZpcmViYXNlLmluaXRpYWxpemVBcHAuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IERhdGFiYXNlSWQoYXBwLm9wdGlvbnMucHJvamVjdElkKTtcclxufVxyXG4vKipcclxuICogTW9kaWZ5IHRoaXMgaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgQ2xvdWQgRmlyZXN0b3JlIGVtdWxhdG9yLlxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIGluc3RhbmNlIGhhcyBiZWVuIHVzZWQgdG8gZG8gYW55XHJcbiAqIG9wZXJhdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUgYEZpcmVzdG9yZWAgaW5zdGFuY2UgdG8gY29uZmlndXJlIHRvIGNvbm5lY3QgdG8gdGhlXHJcbiAqIGVtdWxhdG9yLlxyXG4gKiBAcGFyYW0gaG9zdCAtIHRoZSBlbXVsYXRvciBob3N0IChleDogbG9jYWxob3N0KS5cclxuICogQHBhcmFtIHBvcnQgLSB0aGUgZW11bGF0b3IgcG9ydCAoZXg6IDkwMDApLlxyXG4gKiBAcGFyYW0gb3B0aW9ucy5tb2NrVXNlclRva2VuIC0gdGhlIG1vY2sgYXV0aCB0b2tlbiB0byB1c2UgZm9yIHVuaXQgdGVzdGluZ1xyXG4gKiBTZWN1cml0eSBSdWxlcy5cclxuICovXHJcbmZ1bmN0aW9uIGNvbm5lY3RGaXJlc3RvcmVFbXVsYXRvcihmaXJlc3RvcmUsIGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSQxKTtcclxuICAgIGNvbnN0IHNldHRpbmdzID0gZmlyZXN0b3JlLl9nZXRTZXR0aW5ncygpO1xyXG4gICAgaWYgKHNldHRpbmdzLmhvc3QgIT09IERFRkFVTFRfSE9TVCAmJiBzZXR0aW5ncy5ob3N0ICE9PSBob3N0KSB7XHJcbiAgICAgICAgbG9nV2FybignSG9zdCBoYXMgYmVlbiBzZXQgaW4gYm90aCBzZXR0aW5ncygpIGFuZCB1c2VFbXVsYXRvcigpLCBlbXVsYXRvciBob3N0ICcgK1xyXG4gICAgICAgICAgICAnd2lsbCBiZSB1c2VkJyk7XHJcbiAgICB9XHJcbiAgICBmaXJlc3RvcmUuX3NldFNldHRpbmdzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZ3MpLCB7IGhvc3Q6IGAke2hvc3R9OiR7cG9ydH1gLCBzc2w6IGZhbHNlIH0pKTtcclxuICAgIGlmIChvcHRpb25zLm1vY2tVc2VyVG9rZW4pIHtcclxuICAgICAgICBsZXQgdG9rZW47XHJcbiAgICAgICAgbGV0IHVzZXI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1vY2tVc2VyVG9rZW4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRva2VuID0gb3B0aW9ucy5tb2NrVXNlclRva2VuO1xyXG4gICAgICAgICAgICB1c2VyID0gVXNlci5NT0NLX1VTRVI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBMZXQgY3JlYXRlTW9ja1VzZXJUb2tlbiB2YWxpZGF0ZSBmaXJzdCAoY2F0Y2hlcyBjb21tb24gbWlzdGFrZXMgbGlrZVxyXG4gICAgICAgICAgICAvLyBpbnZhbGlkIGZpZWxkIFwidWlkXCIgYW5kIG1pc3NpbmcgZmllbGQgXCJzdWJcIiAvIFwidXNlcl9pZFwiLilcclxuICAgICAgICAgICAgdG9rZW4gPSBjcmVhdGVNb2NrVXNlclRva2VuKG9wdGlvbnMubW9ja1VzZXJUb2tlbiwgKF9hID0gZmlyZXN0b3JlLl9hcHApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpb25zLnByb2plY3RJZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVpZCA9IG9wdGlvbnMubW9ja1VzZXJUb2tlbi5zdWIgfHwgb3B0aW9ucy5tb2NrVXNlclRva2VuLnVzZXJfaWQ7XHJcbiAgICAgICAgICAgIGlmICghdWlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBcIm1vY2tVc2VyVG9rZW4gbXVzdCBjb250YWluICdzdWInIG9yICd1c2VyX2lkJyBmaWVsZCFcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdXNlciA9IG5ldyBVc2VyKHVpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpcmVzdG9yZS5fYXV0aENyZWRlbnRpYWxzID0gbmV3IEVtdWxhdG9yQXV0aENyZWRlbnRpYWxzUHJvdmlkZXIobmV3IE9BdXRoVG9rZW4odG9rZW4sIHVzZXIpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBgRG9jdW1lbnRSZWZlcmVuY2VgIHJlZmVycyB0byBhIGRvY3VtZW50IGxvY2F0aW9uIGluIGEgRmlyZXN0b3JlIGRhdGFiYXNlXHJcbiAqIGFuZCBjYW4gYmUgdXNlZCB0byB3cml0ZSwgcmVhZCwgb3IgbGlzdGVuIHRvIHRoZSBsb2NhdGlvbi4gVGhlIGRvY3VtZW50IGF0XHJcbiAqIHRoZSByZWZlcmVuY2VkIGxvY2F0aW9uIG1heSBvciBtYXkgbm90IGV4aXN0LlxyXG4gKi9cclxuY2xhc3MgRG9jdW1lbnRSZWZlcmVuY2Uge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZpcmVzdG9yZSwgXHJcbiAgICAvKipcclxuICAgICAqIElmIHByb3ZpZGVkLCB0aGUgYEZpcmVzdG9yZURhdGFDb252ZXJ0ZXJgIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0ZXIsIF9rZXkpIHtcclxuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlcjtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIC8qKiBUaGUgdHlwZSBvZiB0aGlzIEZpcmVzdG9yZSByZWZlcmVuY2UuICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2RvY3VtZW50JztcclxuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcclxuICAgIH1cclxuICAgIGdldCBfcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5LnBhdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkb2N1bWVudCdzIGlkZW50aWZpZXIgd2l0aGluIGl0cyBjb2xsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXQgaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcGF0aCBvZiB0aGUgcmVmZXJlbmNlZCBkb2N1bWVudCAocmVsYXRpdmVcclxuICAgICAqIHRvIHRoZSByb290IG9mIHRoZSBkYXRhYmFzZSkuXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9rZXkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbGxlY3Rpb24gdGhpcyBgRG9jdW1lbnRSZWZlcmVuY2VgIGJlbG9uZ3MgdG8uXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uUmVmZXJlbmNlKHRoaXMuZmlyZXN0b3JlLCB0aGlzLmNvbnZlcnRlciwgdGhpcy5fa2V5LnBhdGgucG9wTGFzdCgpKTtcclxuICAgIH1cclxuICAgIHdpdGhDb252ZXJ0ZXIoY29udmVydGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZSh0aGlzLmZpcmVzdG9yZSwgY29udmVydGVyLCB0aGlzLl9rZXkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeWAgcmVmZXJzIHRvIGEgcXVlcnkgd2hpY2ggeW91IGNhbiByZWFkIG9yIGxpc3RlbiB0by4gWW91IGNhbiBhbHNvXHJcbiAqIGNvbnN0cnVjdCByZWZpbmVkIGBRdWVyeWAgb2JqZWN0cyBieSBhZGRpbmcgZmlsdGVycyBhbmQgb3JkZXJpbmcuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeSB7XHJcbiAgICAvLyBUaGlzIGlzIHRoZSBsaXRlIHZlcnNpb24gb2YgdGhlIFF1ZXJ5IGNsYXNzIGluIHRoZSBtYWluIFNESy5cclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xyXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBcclxuICAgIC8qKlxyXG4gICAgICogSWYgcHJvdmlkZWQsIHRoZSBgRmlyZXN0b3JlRGF0YUNvbnZlcnRlcmAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRlciwgX3F1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XHJcbiAgICAgICAgdGhpcy5fcXVlcnkgPSBfcXVlcnk7XHJcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoaXMgRmlyZXN0b3JlIHJlZmVyZW5jZS4gKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSAncXVlcnknO1xyXG4gICAgICAgIHRoaXMuZmlyZXN0b3JlID0gZmlyZXN0b3JlO1xyXG4gICAgfVxyXG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMuZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIHRoaXMuX3F1ZXJ5KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgQ29sbGVjdGlvblJlZmVyZW5jZWAgb2JqZWN0IGNhbiBiZSB1c2VkIGZvciBhZGRpbmcgZG9jdW1lbnRzLCBnZXR0aW5nXHJcbiAqIGRvY3VtZW50IHJlZmVyZW5jZXMsIGFuZCBxdWVyeWluZyBmb3IgZG9jdW1lbnRzICh1c2luZyB7QGxpbmsgcXVlcnl9KS5cclxuICovXHJcbmNsYXNzIENvbGxlY3Rpb25SZWZlcmVuY2UgZXh0ZW5kcyBRdWVyeSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIF9wYXRoKSB7XHJcbiAgICAgICAgc3VwZXIoZmlyZXN0b3JlLCBjb252ZXJ0ZXIsIG5ld1F1ZXJ5Rm9yUGF0aChfcGF0aCkpO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBGaXJlc3RvcmUgcmVmZXJlbmNlLiAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdjb2xsZWN0aW9uJztcclxuICAgIH1cclxuICAgIC8qKiBUaGUgY29sbGVjdGlvbidzIGlkZW50aWZpZXIuICovXHJcbiAgICBnZXQgaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5LnBhdGgubGFzdFNlZ21lbnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwYXRoIG9mIHRoZSByZWZlcmVuY2VkIGNvbGxlY3Rpb24gKHJlbGF0aXZlXHJcbiAgICAgKiB0byB0aGUgcm9vdCBvZiB0aGUgZGF0YWJhc2UpLlxyXG4gICAgICovXHJcbiAgICBnZXQgcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcXVlcnkucGF0aC5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNvbnRhaW5pbmcgYERvY3VtZW50UmVmZXJlbmNlYCBpZiB0aGlzIGlzIGFcclxuICAgICAqIHN1YmNvbGxlY3Rpb24uIElmIHRoaXMgaXNuJ3QgYSBzdWJjb2xsZWN0aW9uLCB0aGUgcmVmZXJlbmNlIGlzIG51bGwuXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHRoaXMuX3BhdGgucG9wTGFzdCgpO1xyXG4gICAgICAgIGlmIChwYXJlbnRQYXRoLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIFxyXG4gICAgICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIG5ldyBEb2N1bWVudEtleShwYXJlbnRQYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2l0aENvbnZlcnRlcihjb252ZXJ0ZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIGNvbnZlcnRlciwgdGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29sbGVjdGlvbihwYXJlbnQsIHBhdGgsIC4uLnBhdGhTZWdtZW50cykge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoJ2NvbGxlY3Rpb24nLCAncGF0aCcsIHBhdGgpO1xyXG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEZpcmVzdG9yZSQxKSB7XHJcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocGF0aCwgLi4ucGF0aFNlZ21lbnRzKTtcclxuICAgICAgICB2YWxpZGF0ZUNvbGxlY3Rpb25QYXRoKGFic29sdXRlUGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uUmVmZXJlbmNlKHBhcmVudCwgLyogY29udmVydGVyPSAqLyBudWxsLCBhYnNvbHV0ZVBhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXHJcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGNvbGxlY3Rpb24oKSB0byBiZSBhIENvbGxlY3Rpb25SZWZlcmVuY2UsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2EgRG9jdW1lbnRSZWZlcmVuY2Ugb3IgRmlyZWJhc2VGaXJlc3RvcmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gcGFyZW50Ll9wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHBhdGgsIC4uLnBhdGhTZWdtZW50cykpO1xyXG4gICAgICAgIHZhbGlkYXRlQ29sbGVjdGlvblBhdGgoYWJzb2x1dGVQYXRoKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWZlcmVuY2UocGFyZW50LmZpcmVzdG9yZSwgXHJcbiAgICAgICAgLyogY29udmVydGVyPSAqLyBudWxsLCBhYnNvbHV0ZVBhdGgpO1xyXG4gICAgfVxyXG59XHJcbi8vIFRPRE8oZmlyZXN0b3JlbGl0ZSk6IENvbnNpZGVyIHVzaW5nIEVycm9yRmFjdG9yeSAtXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvYmxvYi8wMTMxZTFmL3BhY2thZ2VzL3V0aWwvc3JjL2Vycm9ycy50cyNMMTA2XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3IGBRdWVyeWAgaW5zdGFuY2UgdGhhdCBpbmNsdWRlcyBhbGwgZG9jdW1lbnRzIGluIHRoZVxyXG4gKiBkYXRhYmFzZSB0aGF0IGFyZSBjb250YWluZWQgaW4gYSBjb2xsZWN0aW9uIG9yIHN1YmNvbGxlY3Rpb24gd2l0aCB0aGVcclxuICogZ2l2ZW4gYGNvbGxlY3Rpb25JZGAuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBBIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBgRmlyZXN0b3JlYCBpbnN0YW5jZS5cclxuICogQHBhcmFtIGNvbGxlY3Rpb25JZCAtIElkZW50aWZpZXMgdGhlIGNvbGxlY3Rpb25zIHRvIHF1ZXJ5IG92ZXIuIEV2ZXJ5XHJcbiAqIGNvbGxlY3Rpb24gb3Igc3ViY29sbGVjdGlvbiB3aXRoIHRoaXMgSUQgYXMgdGhlIGxhc3Qgc2VnbWVudCBvZiBpdHMgcGF0aFxyXG4gKiB3aWxsIGJlIGluY2x1ZGVkLiBDYW5ub3QgY29udGFpbiBhIHNsYXNoLlxyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBgUXVlcnlgLlxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGVjdGlvbkdyb3VwKGZpcmVzdG9yZSwgY29sbGVjdGlvbklkKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlJDEpO1xyXG4gICAgdmFsaWRhdGVOb25FbXB0eUFyZ3VtZW50KCdjb2xsZWN0aW9uR3JvdXAnLCAnY29sbGVjdGlvbiBpZCcsIGNvbGxlY3Rpb25JZCk7XHJcbiAgICBpZiAoY29sbGVjdGlvbklkLmluZGV4T2YoJy8nKSA+PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgY29sbGVjdGlvbiBJRCAnJHtjb2xsZWN0aW9uSWR9JyBwYXNzZWQgdG8gZnVuY3Rpb24gYCArXHJcbiAgICAgICAgICAgIGBjb2xsZWN0aW9uR3JvdXAoKS4gQ29sbGVjdGlvbiBJRHMgbXVzdCBub3QgY29udGFpbiAnLycuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5KGZpcmVzdG9yZSwgXHJcbiAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwsIG5ld1F1ZXJ5Rm9yQ29sbGVjdGlvbkdyb3VwKGNvbGxlY3Rpb25JZCkpO1xyXG59XHJcbmZ1bmN0aW9uIGRvYyhwYXJlbnQsIHBhdGgsIC4uLnBhdGhTZWdtZW50cykge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICAvLyBXZSBhbGxvdyBvbWlzc2lvbiBvZiAncGF0aFN0cmluZycgYnV0IGV4cGxpY2l0bHkgcHJvaGliaXQgcGFzc2luZyBpbiBib3RoXHJcbiAgICAvLyAndW5kZWZpbmVkJyBhbmQgJ251bGwnLlxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBwYXRoID0gQXV0b0lkLm5ld0lkKCk7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZU5vbkVtcHR5QXJndW1lbnQoJ2RvYycsICdwYXRoJywgcGF0aCk7XHJcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgRmlyZXN0b3JlJDEpIHtcclxuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBSZXNvdXJjZVBhdGguZnJvbVN0cmluZyhwYXRoLCAuLi5wYXRoU2VnbWVudHMpO1xyXG4gICAgICAgIHZhbGlkYXRlRG9jdW1lbnRQYXRoKGFic29sdXRlUGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZShwYXJlbnQsIFxyXG4gICAgICAgIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwgbmV3IERvY3VtZW50S2V5KGFic29sdXRlUGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpICYmXHJcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0V4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGNvbGxlY3Rpb24oKSB0byBiZSBhIENvbGxlY3Rpb25SZWZlcmVuY2UsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2EgRG9jdW1lbnRSZWZlcmVuY2Ugb3IgRmlyZWJhc2VGaXJlc3RvcmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gcGFyZW50Ll9wYXRoLmNoaWxkKFJlc291cmNlUGF0aC5mcm9tU3RyaW5nKHBhdGgsIC4uLnBhdGhTZWdtZW50cykpO1xyXG4gICAgICAgIHZhbGlkYXRlRG9jdW1lbnRQYXRoKGFic29sdXRlUGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFJlZmVyZW5jZShwYXJlbnQuZmlyZXN0b3JlLCBwYXJlbnQgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUmVmZXJlbmNlID8gcGFyZW50LmNvbnZlcnRlciA6IG51bGwsIG5ldyBEb2N1bWVudEtleShhYnNvbHV0ZVBhdGgpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCByZWZlcmVuY2VzIGFyZSBlcXVhbC5cclxuICpcclxuICogQHBhcmFtIGxlZnQgLSBBIHJlZmVyZW5jZSB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0gcmlnaHQgLSBBIHJlZmVyZW5jZSB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSByZWZlcmVuY2VzIHBvaW50IHRvIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBzYW1lXHJcbiAqIEZpcmVzdG9yZSBkYXRhYmFzZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZkVxdWFsKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBsZWZ0ID0gZ2V0TW9kdWxhckluc3RhbmNlKGxlZnQpO1xyXG4gICAgcmlnaHQgPSBnZXRNb2R1bGFySW5zdGFuY2UocmlnaHQpO1xyXG4gICAgaWYgKChsZWZ0IGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UgfHxcclxuICAgICAgICBsZWZ0IGluc3RhbmNlb2YgQ29sbGVjdGlvblJlZmVyZW5jZSkgJiZcclxuICAgICAgICAocmlnaHQgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSB8fCByaWdodCBpbnN0YW5jZW9mIENvbGxlY3Rpb25SZWZlcmVuY2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIChsZWZ0LmZpcmVzdG9yZSA9PT0gcmlnaHQuZmlyZXN0b3JlICYmXHJcbiAgICAgICAgICAgIGxlZnQucGF0aCA9PT0gcmlnaHQucGF0aCAmJlxyXG4gICAgICAgICAgICBsZWZ0LmNvbnZlcnRlciA9PT0gcmlnaHQuY29udmVydGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBxdWVyaWVzIHBvaW50IHRvIHRoZSBzYW1lIGNvbGxlY3Rpb24gYW5kIGFwcGx5XHJcbiAqIHRoZSBzYW1lIGNvbnN0cmFpbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbGVmdCAtIEEgYFF1ZXJ5YCB0byBjb21wYXJlLlxyXG4gKiBAcGFyYW0gcmlnaHQgLSBBIGBRdWVyeWAgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgc2FtZSBsb2NhdGlvbiBpbiB0aGUgc2FtZVxyXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeUVxdWFsKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBsZWZ0ID0gZ2V0TW9kdWxhckluc3RhbmNlKGxlZnQpO1xyXG4gICAgcmlnaHQgPSBnZXRNb2R1bGFySW5zdGFuY2UocmlnaHQpO1xyXG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBRdWVyeSAmJiByaWdodCBpbnN0YW5jZW9mIFF1ZXJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIChsZWZ0LmZpcmVzdG9yZSA9PT0gcmlnaHQuZmlyZXN0b3JlICYmXHJcbiAgICAgICAgICAgIHF1ZXJ5RXF1YWxzKGxlZnQuX3F1ZXJ5LCByaWdodC5fcXVlcnkpICYmXHJcbiAgICAgICAgICAgIGxlZnQuY29udmVydGVyID09PSByaWdodC5jb252ZXJ0ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR19UQUcgPSAnQXN5bmNRdWV1ZSc7XHJcbmNsYXNzIEFzeW5jUXVldWVJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8vIFRoZSBsYXN0IHByb21pc2UgaW4gdGhlIHF1ZXVlLlxyXG4gICAgICAgIHRoaXMudGFpbCA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIC8vIEEgbGlzdCBvZiByZXRyeWFibGUgb3BlcmF0aW9ucy4gUmV0cnlhYmxlIG9wZXJhdGlvbnMgYXJlIHJ1biBpbiBvcmRlciBhbmRcclxuICAgICAgICAvLyByZXRyaWVkIHdpdGggYmFja29mZi5cclxuICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcyA9IFtdO1xyXG4gICAgICAgIC8vIElzIHRoaXMgQXN5bmNRdWV1ZSBiZWluZyBzaHV0IGRvd24/IE9uY2UgaXQgaXMgc2V0IHRvIHRydWUsIGl0IHdpbGwgbm90XHJcbiAgICAgICAgLy8gYmUgY2hhbmdlZCBhZ2Fpbi5cclxuICAgICAgICB0aGlzLl9pc1NodXR0aW5nRG93biA9IGZhbHNlO1xyXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgc2NoZWR1bGVkIHRvIGJlIHF1ZXVlZCBpbiB0aGUgZnV0dXJlLiBPcGVyYXRpb25zIGFyZVxyXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBhZnRlciB0aGV5IGFyZSBydW4gb3IgY2FuY2VsZWQuXHJcbiAgICAgICAgdGhpcy5kZWxheWVkT3BlcmF0aW9ucyA9IFtdO1xyXG4gICAgICAgIC8vIHZpc2libGUgZm9yIHRlc3RpbmdcclxuICAgICAgICB0aGlzLmZhaWx1cmUgPSBudWxsO1xyXG4gICAgICAgIC8vIEZsYWcgc2V0IHdoaWxlIHRoZXJlJ3MgYW4gb3V0c3RhbmRpbmcgQXN5bmNRdWV1ZSBvcGVyYXRpb24sIHVzZWQgZm9yXHJcbiAgICAgICAgLy8gYXNzZXJ0aW9uIHNhbml0eS1jaGVja3MuXHJcbiAgICAgICAgdGhpcy5vcGVyYXRpb25JblByb2dyZXNzID0gZmFsc2U7XHJcbiAgICAgICAgLy8gRW5hYmxlZCBkdXJpbmcgc2h1dGRvd24gb24gU2FmYXJpIHRvIHByZXZlbnQgZnV0dXJlIGFjY2VzcyB0byBJbmRleGVkREIuXHJcbiAgICAgICAgdGhpcy5za2lwTm9uUmVzdHJpY3RlZFRhc2tzID0gZmFsc2U7XHJcbiAgICAgICAgLy8gTGlzdCBvZiBUaW1lcklkcyB0byBmYXN0LWZvcndhcmQgZGVsYXlzIGZvci5cclxuICAgICAgICB0aGlzLnRpbWVySWRzVG9Ta2lwID0gW107XHJcbiAgICAgICAgLy8gQmFja29mZiB0aW1lciB1c2VkIHRvIHNjaGVkdWxlIHJldHJpZXMgZm9yIHJldHJ5YWJsZSBvcGVyYXRpb25zXHJcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IEV4cG9uZW50aWFsQmFja29mZih0aGlzLCBcImFzeW5jX3F1ZXVlX3JldHJ5XCIgLyogQXN5bmNRdWV1ZVJldHJ5ICovKTtcclxuICAgICAgICAvLyBWaXNpYmlsaXR5IGhhbmRsZXIgdGhhdCB0cmlnZ2VycyBhbiBpbW1lZGlhdGUgcmV0cnkgb2YgYWxsIHJldHJ5YWJsZVxyXG4gICAgICAgIC8vIG9wZXJhdGlvbnMuIE1lYW50IHRvIHNwZWVkIHVwIHJlY292ZXJ5IHdoZW4gd2UgcmVnYWluIGZpbGUgc3lzdGVtIGFjY2Vzc1xyXG4gICAgICAgIC8vIGFmdGVyIHBhZ2UgY29tZXMgaW50byBmb3JlZ3JvdW5kLlxyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5za2lwQmFja29mZigpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBnZXQgaXNTaHV0dGluZ0Rvd24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzU2h1dHRpbmdEb3duO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUgd2l0aG91dCB3YWl0aW5nIGZvciBpdCB0byBjb21wbGV0ZSAoaS5lLlxyXG4gICAgICogd2UgaWdub3JlIHRoZSBQcm9taXNlIHJlc3VsdCkuXHJcbiAgICAgKi9cclxuICAgIGVucXVldWVBbmRGb3JnZXQob3ApIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlKG9wKTtcclxuICAgIH1cclxuICAgIGVucXVldWVBbmRGb3JnZXRFdmVuV2hpbGVSZXN0cmljdGVkKG9wKSB7XHJcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlSW50ZXJuYWwob3ApO1xyXG4gICAgfVxyXG4gICAgZW50ZXJSZXN0cmljdGVkTW9kZShwdXJnZUV4aXN0aW5nVGFza3MpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzU2h1dHRpbmdEb3duKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzU2h1dHRpbmdEb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5za2lwTm9uUmVzdHJpY3RlZFRhc2tzID0gcHVyZ2VFeGlzdGluZ1Rhc2tzIHx8IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVucXVldWUob3ApIHtcclxuICAgICAgICB0aGlzLnZlcmlmeU5vdEZhaWxlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1NodXR0aW5nRG93bikge1xyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBQcm9taXNlIHdoaWNoIG5ldmVyIHJlc29sdmVzLlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4geyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgZGVmZXJyZWQgUHJvbWlzZSB0aGF0IHdlIGNhbiByZXR1cm4gdG8gdGhlIGNhbGxlZS4gVGhpc1xyXG4gICAgICAgIC8vIGFsbG93cyB1cyB0byByZXR1cm4gYSBcImhhbmdpbmcgUHJvbWlzZVwiIG9ubHkgdG8gdGhlIGNhbGxlZSBhbmQgc3RpbGxcclxuICAgICAgICAvLyBhZHZhbmNlIHRoZSBxdWV1ZSBldmVuIHdoZW4gdGhlIG9wZXJhdGlvbiBpcyBub3QgcnVuLlxyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnF1ZXVlSW50ZXJuYWwoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaHV0dGluZ0Rvd24gJiYgdGhpcy5za2lwTm9uUmVzdHJpY3RlZFRhc2tzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3QgcmVzb2x2ZSAndGFzaydcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCgpLnRoZW4odGFzay5yZXNvbHZlLCB0YXNrLnJlamVjdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0YXNrLnByb21pc2U7XHJcbiAgICAgICAgfSkudGhlbigoKSA9PiB0YXNrLnByb21pc2UpO1xyXG4gICAgfVxyXG4gICAgZW5xdWV1ZVJldHJ5YWJsZShvcCkge1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZUFuZEZvcmdldCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmV0cnlhYmxlT3BzLnB1c2gob3ApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXRyeU5leHRPcCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIHRoZSBuZXh0IG9wZXJhdGlvbiBmcm9tIHRoZSByZXRyeWFibGUgcXVldWUuIElmIHRoZSBvcGVyYXRpb24gZmFpbHMsXHJcbiAgICAgKiByZXNjaGVkdWxlcyB3aXRoIGJhY2tvZmYuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJldHJ5TmV4dE9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJldHJ5YWJsZU9wcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJldHJ5YWJsZU9wc1swXSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJldHJ5YWJsZU9wcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzSW5kZXhlZERiVHJhbnNhY3Rpb25FcnJvcihlKSkge1xyXG4gICAgICAgICAgICAgICAgbG9nRGVidWcoTE9HX1RBRywgJ09wZXJhdGlvbiBmYWlsZWQgd2l0aCByZXRyeWFibGUgZXJyb3I6ICcgKyBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7IC8vIEZhaWx1cmUgd2lsbCBiZSBoYW5kbGVkIGJ5IEFzeW5jUXVldWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yZXRyeWFibGVPcHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYWRkaXRpb25hbCBvcGVyYXRpb25zLCB3ZSByZS1zY2hlZHVsZSBgcmV0cnlOZXh0T3AoKWAuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHJ1biByZXRyeWFibGUgb3BlcmF0aW9ucyB0aGF0IGZhaWxlZCBkdXJpbmdcclxuICAgICAgICAgICAgLy8gdGhlaXIgaW5pdGlhbCBhdHRlbXB0IHNpbmNlIHdlIGRvbid0IGtub3cgd2hldGhlciB0aGV5IGFyZSBhbHJlYWR5XHJcbiAgICAgICAgICAgIC8vIGVucXVldWVkLiBJZiwgZm9yIGV4YW1wbGUsIGBvcDFgLCBgb3AyYCwgYG9wM2AgYXJlIGVucXVldWVkIGFuZCBgb3AxYFxyXG4gICAgICAgICAgICAvLyBuZWVkcyB0byAgYmUgcmUtcnVuLCB3ZSB3aWxsIHJ1biBgb3AxYCwgYG9wMWAsIGBvcDJgIHVzaW5nIHRoZVxyXG4gICAgICAgICAgICAvLyBhbHJlYWR5IGVucXVldWVkIGNhbGxzIHRvIGByZXRyeU5leHRPcCgpYC4gYG9wMygpYCB3aWxsIHRoZW4gcnVuIGluIHRoZVxyXG4gICAgICAgICAgICAvLyBjYWxsIHNjaGVkdWxlZCBoZXJlLlxyXG4gICAgICAgICAgICAvLyBTaW5jZSBgYmFja29mZkFuZFJ1bigpYCBjYW5jZWxzIGFuIGV4aXN0aW5nIGJhY2tvZmYgYW5kIHNjaGVkdWxlcyBhXHJcbiAgICAgICAgICAgIC8vIG5ldyBiYWNrb2ZmIG9uIGV2ZXJ5IGNhbGwsIHRoZXJlIGlzIG9ubHkgZXZlciBhIHNpbmdsZSBhZGRpdGlvbmFsXHJcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBpbiB0aGUgcXVldWUuXHJcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5iYWNrb2ZmQW5kUnVuKCgpID0+IHRoaXMucmV0cnlOZXh0T3AoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZW5xdWV1ZUludGVybmFsKG9wKSB7XHJcbiAgICAgICAgY29uc3QgbmV3VGFpbCA9IHRoaXMudGFpbC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25JblByb2dyZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG9wKClcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFpbHVyZSA9IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25JblByb2dyZXNzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2V0TWVzc2FnZU9yU3RhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoJ0lOVEVSTkFMIFVOSEFORExFRCBFUlJPUjogJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGUgZXJyb3Igc28gdGhhdCB0aGlzLnRhaWwgYmVjb21lcyBhIHJlamVjdGVkIFByb21pc2UgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhbGwgZnVydGhlciBhdHRlbXB0cyB0byBjaGFpbiAodmlhIC50aGVuKSB3aWxsIGp1c3Qgc2hvcnQtY2lyY3VpdFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiB0aGUgcmVqZWN0ZWQgUHJvbWlzZS5cclxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3BlcmF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy50YWlsID0gbmV3VGFpbDtcclxuICAgICAgICByZXR1cm4gbmV3VGFpbDtcclxuICAgIH1cclxuICAgIGVucXVldWVBZnRlckRlbGF5KHRpbWVySWQsIGRlbGF5TXMsIG9wKSB7XHJcbiAgICAgICAgdGhpcy52ZXJpZnlOb3RGYWlsZWQoKTtcclxuICAgICAgICAvLyBGYXN0LWZvcndhcmQgZGVsYXlzIGZvciB0aW1lcklkcyB0aGF0IGhhdmUgYmVlbiBvdmVycmlkZW4uXHJcbiAgICAgICAgaWYgKHRoaXMudGltZXJJZHNUb1NraXAuaW5kZXhPZih0aW1lcklkKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIGRlbGF5TXMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWxheWVkT3AgPSBEZWxheWVkT3BlcmF0aW9uLmNyZWF0ZUFuZFNjaGVkdWxlKHRoaXMsIHRpbWVySWQsIGRlbGF5TXMsIG9wLCByZW1vdmVkT3AgPT4gdGhpcy5yZW1vdmVEZWxheWVkT3BlcmF0aW9uKHJlbW92ZWRPcCkpO1xyXG4gICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMucHVzaChkZWxheWVkT3ApO1xyXG4gICAgICAgIHJldHVybiBkZWxheWVkT3A7XHJcbiAgICB9XHJcbiAgICB2ZXJpZnlOb3RGYWlsZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmFpbHVyZSkge1xyXG4gICAgICAgICAgICBmYWlsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmVyaWZ5T3BlcmF0aW9uSW5Qcm9ncmVzcygpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2FpdHMgdW50aWwgYWxsIGN1cnJlbnRseSBxdWV1ZWQgdGFza3MgYXJlIGZpbmlzaGVkIGV4ZWN1dGluZy4gRGVsYXllZFxyXG4gICAgICogb3BlcmF0aW9ucyBhcmUgbm90IHJ1bi5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZHJhaW4oKSB7XHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyBpbiB0aGUgcXVldWUgcHJpb3IgdG8gZHJhaW5pbmcgbWF5IGhhdmUgZW5xdWV1ZWQgYWRkaXRpb25hbFxyXG4gICAgICAgIC8vIG9wZXJhdGlvbnMuIEtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZSB0YWlsIGlzIG5vIGxvbmdlciBhZHZhbmNlZCxcclxuICAgICAgICAvLyB3aGljaCBpbmRpY2F0ZXMgdGhhdCBubyBtb3JlIG5ldyBvcGVyYXRpb25zIHdlcmUgZW5xdWV1ZWQgYW5kIHRoYXQgYWxsXHJcbiAgICAgICAgLy8gb3BlcmF0aW9ucyB3ZXJlIGV4ZWN1dGVkLlxyXG4gICAgICAgIGxldCBjdXJyZW50VGFpbDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRUYWlsID0gdGhpcy50YWlsO1xyXG4gICAgICAgICAgICBhd2FpdCBjdXJyZW50VGFpbDtcclxuICAgICAgICB9IHdoaWxlIChjdXJyZW50VGFpbCAhPT0gdGhpcy50YWlsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yIFRlc3RzOiBEZXRlcm1pbmUgaWYgYSBkZWxheWVkIG9wZXJhdGlvbiB3aXRoIGEgcGFydGljdWxhciBUaW1lcklkXHJcbiAgICAgKiBleGlzdHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zRGVsYXllZE9wZXJhdGlvbih0aW1lcklkKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBvcCBvZiB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChvcC50aW1lcklkID09PSB0aW1lcklkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvciBUZXN0czogUnVucyBzb21lIG9yIGFsbCBkZWxheWVkIG9wZXJhdGlvbnMgZWFybHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxhc3RUaW1lcklkIC0gRGVsYXllZCBvcGVyYXRpb25zIHVwIHRvIGFuZCBpbmNsdWRpbmcgdGhpcyBUaW1lcklkXHJcbiAgICAgKiB3aWxsIGJlIGRyYWluZWQuIFBhc3MgVGltZXJJZC5BbGwgdG8gcnVuIGFsbCBkZWxheWVkIG9wZXJhdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFsbCBvcGVyYXRpb25zIGhhdmUgYmVlbiBydW4uXHJcbiAgICAgKi9cclxuICAgIHJ1bkFsbERlbGF5ZWRPcGVyYXRpb25zVW50aWwobGFzdFRpbWVySWQpIHtcclxuICAgICAgICAvLyBOb3RlIHRoYXQgZHJhaW5pbmcgbWF5IGdlbmVyYXRlIG1vcmUgZGVsYXllZCBvcHMsIHNvIHdlIGRvIHRoYXQgZmlyc3QuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW4oKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgLy8gUnVuIG9wcyBpbiB0aGUgc2FtZSBvcmRlciB0aGV5J2QgcnVuIGlmIHRoZXkgcmFuIG5hdHVyYWxseS5cclxuICAgICAgICAgICAgdGhpcy5kZWxheWVkT3BlcmF0aW9ucy5zb3J0KChhLCBiKSA9PiBhLnRhcmdldFRpbWVNcyAtIGIudGFyZ2V0VGltZU1zKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBvcCBvZiB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBvcC5za2lwRGVsYXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0VGltZXJJZCAhPT0gXCJhbGxcIiAvKiBBbGwgKi8gJiYgb3AudGltZXJJZCA9PT0gbGFzdFRpbWVySWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmFpbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgVGVzdHM6IFNraXAgYWxsIHN1YnNlcXVlbnQgZGVsYXlzIGZvciBhIHRpbWVyIGlkLlxyXG4gICAgICovXHJcbiAgICBza2lwRGVsYXlzRm9yVGltZXJJZCh0aW1lcklkKSB7XHJcbiAgICAgICAgdGhpcy50aW1lcklkc1RvU2tpcC5wdXNoKHRpbWVySWQpO1xyXG4gICAgfVxyXG4gICAgLyoqIENhbGxlZCBvbmNlIGEgRGVsYXllZE9wZXJhdGlvbiBpcyBydW4gb3IgY2FuY2VsZWQuICovXHJcbiAgICByZW1vdmVEZWxheWVkT3BlcmF0aW9uKG9wKSB7XHJcbiAgICAgICAgLy8gTk9URTogaW5kZXhPZiAvIHNsaWNlIGFyZSBPKG4pLCBidXQgZGVsYXllZE9wZXJhdGlvbnMgaXMgZXhwZWN0ZWQgdG8gYmUgc21hbGwuXHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRlbGF5ZWRPcGVyYXRpb25zLmluZGV4T2Yob3ApO1xyXG4gICAgICAgIHRoaXMuZGVsYXllZE9wZXJhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXdBc3luY1F1ZXVlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBc3luY1F1ZXVlSW1wbCgpO1xyXG59XHJcbi8qKlxyXG4gKiBDaHJvbWUgaW5jbHVkZXMgRXJyb3IubWVzc2FnZSBpbiBFcnJvci5zdGFjay4gT3RoZXIgYnJvd3NlcnMgZG8gbm90LlxyXG4gKiBUaGlzIHJldHVybnMgZXhwZWN0ZWQgb3V0cHV0IG9mIG1lc3NhZ2UgKyBzdGFjayB3aGVuIGF2YWlsYWJsZS5cclxuICogQHBhcmFtIGVycm9yIC0gRXJyb3Igb3IgRmlyZXN0b3JlRXJyb3JcclxuICovXHJcbmZ1bmN0aW9uIGdldE1lc3NhZ2VPclN0YWNrKGVycm9yKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgJyc7XHJcbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcclxuICAgICAgICBpZiAoZXJyb3Iuc3RhY2suaW5jbHVkZXMoZXJyb3IubWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLnN0YWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgKyAnXFxuJyArIGVycm9yLnN0YWNrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSB0YXNrIG9mIGxvYWRpbmcgYSBGaXJlc3RvcmUgYnVuZGxlLiBJdCBwcm92aWRlcyBwcm9ncmVzcyBvZiBidW5kbGVcclxuICogbG9hZGluZywgYXMgd2VsbCBhcyB0YXNrIGNvbXBsZXRpb24gYW5kIGVycm9yIGV2ZW50cy5cclxuICpcclxuICogVGhlIEFQSSBpcyBjb21wYXRpYmxlIHdpdGggYFByb21pc2U8TG9hZEJ1bmRsZVRhc2tQcm9ncmVzcz5gLlxyXG4gKi9cclxuY2xhc3MgTG9hZEJ1bmRsZVRhc2sge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NPYnNlcnZlciA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSB7XHJcbiAgICAgICAgICAgIHRhc2tTdGF0ZTogJ1J1bm5pbmcnLFxyXG4gICAgICAgICAgICB0b3RhbEJ5dGVzOiAwLFxyXG4gICAgICAgICAgICB0b3RhbERvY3VtZW50czogMCxcclxuICAgICAgICAgICAgYnl0ZXNMb2FkZWQ6IDAsXHJcbiAgICAgICAgICAgIGRvY3VtZW50c0xvYWRlZDogMFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBmdW5jdGlvbnMgdG8gbGlzdGVuIHRvIGJ1bmRsZSBsb2FkaW5nIHByb2dyZXNzIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBuZXh0IC0gQ2FsbGVkIHdoZW4gdGhlcmUgaXMgYSBwcm9ncmVzcyB1cGRhdGUgZnJvbSBidW5kbGUgbG9hZGluZy4gVHlwaWNhbGx5IGBuZXh0YCBjYWxscyBvY2N1clxyXG4gICAgICogICBlYWNoIHRpbWUgYSBGaXJlc3RvcmUgZG9jdW1lbnQgaXMgbG9hZGVkIGZyb20gdGhlIGJ1bmRsZS5cclxuICAgICAqIEBwYXJhbSBlcnJvciAtIENhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgYnVuZGxlIGxvYWRpbmcuIFRoZSB0YXNrIGFib3J0cyBhZnRlciByZXBvcnRpbmcgdGhlXHJcbiAgICAgKiAgIGVycm9yLCBhbmQgdGhlcmUgc2hvdWxkIGJlIG5vIG1vcmUgdXBkYXRlcyBhZnRlciB0aGlzLlxyXG4gICAgICogQHBhcmFtIGNvbXBsZXRlIC0gQ2FsbGVkIHdoZW4gdGhlIGxvYWRpbmcgdGFzayBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgb25Qcm9ncmVzcyhuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyID0ge1xyXG4gICAgICAgICAgICBuZXh0LFxyXG4gICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgY29tcGxldGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbXBsZW1lbnRzIHRoZSBgUHJvbWlzZTxMb2FkQnVuZGxlVGFza1Byb2dyZXNzPi5jYXRjaGAgaW50ZXJmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIC0gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBidW5kbGUgbG9hZGluZy5cclxuICAgICAqL1xyXG4gICAgY2F0Y2gob25SZWplY3RlZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyLnByb21pc2UuY2F0Y2gob25SZWplY3RlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEltcGxlbWVudHMgdGhlIGBQcm9taXNlPExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3M+LnRoZW5gIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb25GdWxmaWxsZWQgLSBDYWxsZWQgb24gdGhlIGNvbXBsZXRpb24gb2YgdGhlIGxvYWRpbmcgdGFzayB3aXRoIGEgZmluYWwgYExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3NgIHVwZGF0ZS5cclxuICAgICAqICAgVGhlIHVwZGF0ZSB3aWxsIGFsd2F5cyBoYXZlIGl0cyBgdGFza1N0YXRlYCBzZXQgdG8gYFwiU3VjY2Vzc1wiYC5cclxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIC0gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBidW5kbGUgbG9hZGluZy5cclxuICAgICAqL1xyXG4gICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YXNrQ29tcGxldGlvblJlc29sdmVyLnByb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vdGlmaWVzIGFsbCBvYnNlcnZlcnMgdGhhdCBidW5kbGUgbG9hZGluZyBoYXMgY29tcGxldGVkLCB3aXRoIGEgcHJvdmlkZWRcclxuICAgICAqIGBMb2FkQnVuZGxlVGFza1Byb2dyZXNzYCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2NvbXBsZXRlV2l0aChwcm9ncmVzcykge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVByb2dyZXNzKHByb2dyZXNzKTtcclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5jb21wbGV0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Rhc2tDb21wbGV0aW9uUmVzb2x2ZXIucmVzb2x2ZShwcm9ncmVzcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vdGlmaWVzIGFsbCBvYnNlcnZlcnMgdGhhdCBidW5kbGUgbG9hZGluZyBoYXMgZmFpbGVkLCB3aXRoIGEgcHJvdmlkZWRcclxuICAgICAqIGBFcnJvcmAgYXMgdGhlIHJlYXNvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZmFpbFdpdGgoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MudGFza1N0YXRlID0gJ0Vycm9yJztcclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5uZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dCh0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5lcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc09ic2VydmVyLmVycm9yKGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGFza0NvbXBsZXRpb25SZXNvbHZlci5yZWplY3QoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3RpZmllcyBhIHByb2dyZXNzIHVwZGF0ZSBvZiBsb2FkaW5nIGEgYnVuZGxlLlxyXG4gICAgICogQHBhcmFtIHByb2dyZXNzIC0gVGhlIG5ldyBwcm9ncmVzcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlUHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcclxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBwcm9ncmVzcztcclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NPYnNlcnZlci5uZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyZXNzT2JzZXJ2ZXIubmV4dChwcm9ncmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKiBET01FeGNlcHRpb24gZXJyb3IgY29kZSBjb25zdGFudHMuICovXHJcbmNvbnN0IERPTV9FWENFUFRJT05fSU5WQUxJRF9TVEFURSA9IDExO1xyXG5jb25zdCBET01fRVhDRVBUSU9OX0FCT1JURUQgPSAyMDtcclxuY29uc3QgRE9NX0VYQ0VQVElPTl9RVU9UQV9FWENFRURFRCA9IDIyO1xyXG4vKipcclxuICogQ29uc3RhbnQgdXNlZCB0byBpbmRpY2F0ZSB0aGUgTFJVIGdhcmJhZ2UgY29sbGVjdGlvbiBzaG91bGQgYmUgZGlzYWJsZWQuXHJcbiAqIFNldCB0aGlzIHZhbHVlIGFzIHRoZSBgY2FjaGVTaXplQnl0ZXNgIG9uIHRoZSBzZXR0aW5ncyBwYXNzZWQgdG8gdGhlXHJcbiAqIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlLlxyXG4gKi9cclxuY29uc3QgQ0FDSEVfU0laRV9VTkxJTUlURUQgPSBMUlVfQ09MTEVDVElPTl9ESVNBQkxFRDtcclxuLyoqXHJcbiAqIFRoZSBDbG91ZCBGaXJlc3RvcmUgc2VydmljZSBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSB7QGxpbmsgZ2V0RmlyZXN0b3JlfS5cclxuICovXHJcbmNsYXNzIEZpcmVzdG9yZSBleHRlbmRzIEZpcmVzdG9yZSQxIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhYmFzZUlkT3JBcHAsIGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLCBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihkYXRhYmFzZUlkT3JBcHAsIGF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyLCBhcHBDaGVja0NyZWRlbnRpYWxzUHJvdmlkZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgaXQncyBhIHtAbGluayBGaXJlc3RvcmV9IG9yIEZpcmVzdG9yZSBMaXRlIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdmaXJlc3RvcmUnO1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3QXN5bmNRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX3BlcnNpc3RlbmNlS2V5ID1cclxuICAgICAgICAgICAgJ25hbWUnIGluIGRhdGFiYXNlSWRPckFwcCA/IGRhdGFiYXNlSWRPckFwcC5uYW1lIDogJ1tERUZBVUxUXSc7XHJcbiAgICB9XHJcbiAgICBfdGVybWluYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZmlyZXN0b3JlQ2xpZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBjbGllbnQgbXVzdCBiZSBpbml0aWFsaXplZCB0byBlbnN1cmUgdGhhdCBhbGwgc3Vic2VxdWVudCBBUElcclxuICAgICAgICAgICAgLy8gdXNhZ2UgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cclxuICAgICAgICAgICAgY29uZmlndXJlRmlyZXN0b3JlKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlyZXN0b3JlQ2xpZW50LnRlcm1pbmF0ZSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgRmlyZXN0b3JlfSB3aXRoIHRoZSBwcm92aWRlZCBzZXR0aW5ncy5cclxuICogQ2FuIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBhbnkgb3RoZXIgZnVuY3Rpb24sIGluY2x1ZGluZ1xyXG4gKiB7QGxpbmsgZ2V0RmlyZXN0b3JlfS4gSWYgdGhlIGN1c3RvbSBzZXR0aW5ncyBhcmUgZW1wdHksIHRoaXMgZnVuY3Rpb24gaXNcclxuICogZXF1aXZhbGVudCB0byBjYWxsaW5nIHtAbGluayBnZXRGaXJlc3RvcmV9LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSB3aXRoIHdoaWNoIHRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB3aWxsXHJcbiAqIGJlIGFzc29jaWF0ZWQuXHJcbiAqIEBwYXJhbSBzZXR0aW5ncyAtIEEgc2V0dGluZ3Mgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXHJcbiAqIEByZXR1cm5zIEEgbmV3bHkgaW5pdGlhbGl6ZWQge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0aWFsaXplRmlyZXN0b3JlKGFwcCwgc2V0dGluZ3MpIHtcclxuICAgIGNvbnN0IHByb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgJ2ZpcmVzdG9yZScpO1xyXG4gICAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBpbml0aWFsU2V0dGluZ3MgPSBwcm92aWRlci5nZXRPcHRpb25zKCk7XHJcbiAgICAgICAgaWYgKGRlZXBFcXVhbChpbml0aWFsU2V0dGluZ3MsIHNldHRpbmdzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04sICdpbml0aWFsaXplRmlyZXN0b3JlKCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCAnICtcclxuICAgICAgICAgICAgICAgICdkaWZmZXJlbnQgb3B0aW9ucy4gVG8gYXZvaWQgdGhpcyBlcnJvciwgY2FsbCBpbml0aWFsaXplRmlyZXN0b3JlKCkgd2l0aCB0aGUgJyArXHJcbiAgICAgICAgICAgICAgICAnc2FtZSBvcHRpb25zIGFzIHdoZW4gaXQgd2FzIG9yaWdpbmFsbHkgY2FsbGVkLCBvciBjYWxsIGdldEZpcmVzdG9yZSgpIHRvIHJldHVybiB0aGUnICtcclxuICAgICAgICAgICAgICAgICcgYWxyZWFkeSBpbml0aWFsaXplZCBpbnN0YW5jZS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzICE9PSBDQUNIRV9TSVpFX1VOTElNSVRFRCAmJlxyXG4gICAgICAgIHNldHRpbmdzLmNhY2hlU2l6ZUJ5dGVzIDwgTFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFUykge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBjYWNoZVNpemVCeXRlcyBtdXN0IGJlIGF0IGxlYXN0ICR7TFJVX01JTklNVU1fQ0FDSEVfU0laRV9CWVRFU31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm92aWRlci5pbml0aWFsaXplKHsgb3B0aW9uczogc2V0dGluZ3MgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGV4aXN0aW5nIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZVxyXG4gKiBwcm92aWRlZCB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0uIElmIG5vIGluc3RhbmNlIGV4aXN0cywgaW5pdGlhbGl6ZXMgYSBuZXdcclxuICogaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IHNldHRpbmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZSB0aGF0IHRoZSByZXR1cm5lZCB7QGxpbmsgRmlyZXN0b3JlfVxyXG4gKiBpbnN0YW5jZSBpcyBhc3NvY2lhdGVkIHdpdGguXHJcbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSBvZiB0aGUgcHJvdmlkZWQgYXBwLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RmlyZXN0b3JlKGFwcCA9IGdldEFwcCgpKSB7XHJcbiAgICByZXR1cm4gX2dldFByb3ZpZGVyKGFwcCwgJ2ZpcmVzdG9yZScpLmdldEltbWVkaWF0ZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKSB7XHJcbiAgICBpZiAoIWZpcmVzdG9yZS5fZmlyZXN0b3JlQ2xpZW50KSB7XHJcbiAgICAgICAgY29uZmlndXJlRmlyZXN0b3JlKGZpcmVzdG9yZSk7XHJcbiAgICB9XHJcbiAgICBmaXJlc3RvcmUuX2ZpcmVzdG9yZUNsaWVudC52ZXJpZnlOb3RUZXJtaW5hdGVkKCk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlLl9maXJlc3RvcmVDbGllbnQ7XHJcbn1cclxuZnVuY3Rpb24gY29uZmlndXJlRmlyZXN0b3JlKGZpcmVzdG9yZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XHJcbiAgICBjb25zdCBkYXRhYmFzZUluZm8gPSBtYWtlRGF0YWJhc2VJbmZvKGZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgKChfYSA9IGZpcmVzdG9yZS5fYXBwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW9ucy5hcHBJZCkgfHwgJycsIGZpcmVzdG9yZS5fcGVyc2lzdGVuY2VLZXksIHNldHRpbmdzKTtcclxuICAgIGZpcmVzdG9yZS5fZmlyZXN0b3JlQ2xpZW50ID0gbmV3IEZpcmVzdG9yZUNsaWVudChmaXJlc3RvcmUuX2F1dGhDcmVkZW50aWFscywgZmlyZXN0b3JlLl9hcHBDaGVja0NyZWRlbnRpYWxzLCBmaXJlc3RvcmUuX3F1ZXVlLCBkYXRhYmFzZUluZm8pO1xyXG59XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBlbmFibGUgcGVyc2lzdGVudCBzdG9yYWdlLCBpZiBwb3NzaWJsZS5cclxuICpcclxuICogTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGFueSBvdGhlciBmdW5jdGlvbnMgKG90aGVyIHRoYW5cclxuICoge0BsaW5rIGluaXRpYWxpemVGaXJlc3RvcmV9LCB7QGxpbmsgZ2V0RmlyZXN0b3JlfSBvclxyXG4gKiB7QGxpbmsgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZX0uXHJcbiAqXHJcbiAqIElmIHRoaXMgZmFpbHMsIGBlbmFibGVJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBpdFxyXG4gKiByZXR1cm5zLiBOb3RlIHRoYXQgZXZlbiBhZnRlciB0aGlzIGZhaWx1cmUsIHRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB3aWxsXHJcbiAqIHJlbWFpbiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxyXG4gKlxyXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCByZWFzb25zIHdoeSB0aGlzIGNhbiBmYWlsLCB3aGljaCBjYW4gYmUgaWRlbnRpZmllZCBieVxyXG4gKiB0aGUgYGNvZGVgIG9uIHRoZSBlcnJvci5cclxuICpcclxuICogICAqIGZhaWxlZC1wcmVjb25kaXRpb246IFRoZSBhcHAgaXMgYWxyZWFkeSBvcGVuIGluIGFub3RoZXIgYnJvd3NlciB0YWIuXHJcbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZVxyXG4gKiAgICAgcGVyc2lzdGVuY2UgaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gZW5hYmxlIHBlcnNpc3RlbmNlIGZvci5cclxuICogQHBhcmFtIHBlcnNpc3RlbmNlU2V0dGluZ3MgLSBPcHRpb25hbCBzZXR0aW5ncyBvYmplY3QgdG8gY29uZmlndXJlXHJcbiAqIHBlcnNpc3RlbmNlLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlcHJlc2VudHMgc3VjY2Vzc2Z1bGx5IGVuYWJsaW5nIHBlcnNpc3RlbnQgc3RvcmFnZS5cclxuICovXHJcbmZ1bmN0aW9uIGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSwgcGVyc2lzdGVuY2VTZXR0aW5ncykge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICB2ZXJpZnlOb3RJbml0aWFsaXplZChmaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XHJcbiAgICBjb25zdCBvbmxpbmVDb21wb25lbnRQcm92aWRlciA9IG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpO1xyXG4gICAgY29uc3Qgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IEluZGV4ZWREYk9mZmxpbmVDb21wb25lbnRQcm92aWRlcihvbmxpbmVDb21wb25lbnRQcm92aWRlciwgc2V0dGluZ3MuY2FjaGVTaXplQnl0ZXMsIHBlcnNpc3RlbmNlU2V0dGluZ3MgPT09IG51bGwgfHwgcGVyc2lzdGVuY2VTZXR0aW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVyc2lzdGVuY2VTZXR0aW5ncy5mb3JjZU93bmVyc2hpcCk7XHJcbiAgICByZXR1cm4gc2V0UGVyc2lzdGVuY2VQcm92aWRlcnMoY2xpZW50LCBvbmxpbmVDb21wb25lbnRQcm92aWRlciwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKTtcclxufVxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZW5hYmxlIG11bHRpLXRhYiBwZXJzaXN0ZW50IHN0b3JhZ2UsIGlmIHBvc3NpYmxlLiBJZiBlbmFibGVkXHJcbiAqIGFjcm9zcyBhbGwgdGFicywgYWxsIG9wZXJhdGlvbnMgc2hhcmUgYWNjZXNzIHRvIGxvY2FsIHBlcnNpc3RlbmNlLCBpbmNsdWRpbmdcclxuICogc2hhcmVkIGV4ZWN1dGlvbiBvZiBxdWVyaWVzIGFuZCBsYXRlbmN5LWNvbXBlbnNhdGVkIGxvY2FsIGRvY3VtZW50IHVwZGF0ZXNcclxuICogYWNyb3NzIGFsbCBjb25uZWN0ZWQgaW5zdGFuY2VzLlxyXG4gKlxyXG4gKiBJZiB0aGlzIGZhaWxzLCBgZW5hYmxlTXVsdGlUYWJJbmRleGVkRGJQZXJzaXN0ZW5jZSgpYCB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZVxyXG4gKiBpdCByZXR1cm5zLiBOb3RlIHRoYXQgZXZlbiBhZnRlciB0aGlzIGZhaWx1cmUsIHRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSB3aWxsXHJcbiAqIHJlbWFpbiB1c2FibGUsIGhvd2V2ZXIgb2ZmbGluZSBwZXJzaXN0ZW5jZSB3aWxsIGJlIGRpc2FibGVkLlxyXG4gKlxyXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCByZWFzb25zIHdoeSB0aGlzIGNhbiBmYWlsLCB3aGljaCBjYW4gYmUgaWRlbnRpZmllZCBieVxyXG4gKiB0aGUgYGNvZGVgIG9uIHRoZSBlcnJvci5cclxuICpcclxuICogICAqIGZhaWxlZC1wcmVjb25kaXRpb246IFRoZSBhcHAgaXMgYWxyZWFkeSBvcGVuIGluIGFub3RoZXIgYnJvd3NlciB0YWIgYW5kXHJcbiAqICAgICBtdWx0aS10YWIgaXMgbm90IGVuYWJsZWQuXHJcbiAqICAgKiB1bmltcGxlbWVudGVkOiBUaGUgYnJvd3NlciBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgb2ZmbGluZVxyXG4gKiAgICAgcGVyc2lzdGVuY2UgaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gZW5hYmxlIHBlcnNpc3RlbmNlIGZvci5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXByZXNlbnRzIHN1Y2Nlc3NmdWxseSBlbmFibGluZyBwZXJzaXN0ZW50XHJcbiAqIHN0b3JhZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmFibGVNdWx0aVRhYkluZGV4ZWREYlBlcnNpc3RlbmNlKGZpcmVzdG9yZSkge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICB2ZXJpZnlOb3RJbml0aWFsaXplZChmaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XHJcbiAgICBjb25zdCBvbmxpbmVDb21wb25lbnRQcm92aWRlciA9IG5ldyBPbmxpbmVDb21wb25lbnRQcm92aWRlcigpO1xyXG4gICAgY29uc3Qgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyID0gbmV3IE11bHRpVGFiT2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBzZXR0aW5ncy5jYWNoZVNpemVCeXRlcyk7XHJcbiAgICByZXR1cm4gc2V0UGVyc2lzdGVuY2VQcm92aWRlcnMoY2xpZW50LCBvbmxpbmVDb21wb25lbnRQcm92aWRlciwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKTtcclxufVxyXG4vKipcclxuICogUmVnaXN0ZXJzIGJvdGggdGhlIGBPZmZsaW5lQ29tcG9uZW50UHJvdmlkZXJgIGFuZCBgT25saW5lQ29tcG9uZW50UHJvdmlkZXJgLlxyXG4gKiBJZiB0aGUgb3BlcmF0aW9uIGZhaWxzIHdpdGggYSByZWNvdmVyYWJsZSBlcnJvciAoc2VlXHJcbiAqIGBjYW5SZWNvdmVyRnJvbUluZGV4ZWREYkVycm9yKClgIGJlbG93KSwgdGhlIHJldHVybmVkIFByb21pc2UgaXMgcmVqZWN0ZWRcclxuICogYnV0IHRoZSBjbGllbnQgcmVtYWlucyB1c2FibGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRQZXJzaXN0ZW5jZVByb3ZpZGVycyhjbGllbnQsIG9ubGluZUNvbXBvbmVudFByb3ZpZGVyLCBvZmZsaW5lQ29tcG9uZW50UHJvdmlkZXIpIHtcclxuICAgIGNvbnN0IHBlcnNpc3RlbmNlUmVzdWx0ID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXR1cm4gY2xpZW50LmFzeW5jUXVldWVcclxuICAgICAgICAuZW5xdWV1ZShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgc2V0T2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKGNsaWVudCwgb2ZmbGluZUNvbXBvbmVudFByb3ZpZGVyKTtcclxuICAgICAgICAgICAgYXdhaXQgc2V0T25saW5lQ29tcG9uZW50UHJvdmlkZXIoY2xpZW50LCBvbmxpbmVDb21wb25lbnRQcm92aWRlcik7XHJcbiAgICAgICAgICAgIHBlcnNpc3RlbmNlUmVzdWx0LnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaWYgKCFjYW5GYWxsYmFja0Zyb21JbmRleGVkRGJFcnJvcihlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGVuYWJsaW5nIG9mZmxpbmUgcGVyc2lzdGVuY2UuIEZhbGxpbmcgYmFjayB0byAnICtcclxuICAgICAgICAgICAgICAgICdwZXJzaXN0ZW5jZSBkaXNhYmxlZDogJyArXHJcbiAgICAgICAgICAgICAgICBlKTtcclxuICAgICAgICAgICAgcGVyc2lzdGVuY2VSZXN1bHQucmVqZWN0KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcbiAgICAgICAgLnRoZW4oKCkgPT4gcGVyc2lzdGVuY2VSZXN1bHQucHJvbWlzZSk7XHJcbn1cclxuLyoqXHJcbiAqIERlY2lkZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgZXJyb3IgYWxsb3dzIHVzIHRvIGdyYWNlZnVsbHkgZGlzYWJsZVxyXG4gKiBwZXJzaXN0ZW5jZSAoYXMgb3Bwb3NlZCB0byBjcmFzaGluZyB0aGUgY2xpZW50KS5cclxuICovXHJcbmZ1bmN0aW9uIGNhbkZhbGxiYWNrRnJvbUluZGV4ZWREYkVycm9yKGVycm9yKSB7XHJcbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0ZpcmViYXNlRXJyb3InKSB7XHJcbiAgICAgICAgcmV0dXJuIChlcnJvci5jb2RlID09PSBDb2RlLkZBSUxFRF9QUkVDT05ESVRJT04gfHxcclxuICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gQ29kZS5VTklNUExFTUVOVEVEKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBET01FeGNlcHRpb24gIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBET01FeGNlcHRpb24pIHtcclxuICAgICAgICAvLyBUaGVyZSBhcmUgYSBmZXcga25vd24gY2lyY3Vtc3RhbmNlcyB3aGVyZSB3ZSBjYW4gb3BlbiBJbmRleGVkRGIgYnV0XHJcbiAgICAgICAgLy8gdHJ5aW5nIHRvIHJlYWQvd3JpdGUgd2lsbCBmYWlsIChlLmcuIHF1b3RhIGV4Y2VlZGVkKS4gRm9yXHJcbiAgICAgICAgLy8gd2VsbC11bmRlcnN0b29kIGNhc2VzLCB3ZSBhdHRlbXB0IHRvIGRldGVjdCB0aGVzZSBhbmQgdGhlbiBncmFjZWZ1bGx5XHJcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIG1lbW9yeSBwZXJzaXN0ZW5jZS5cclxuICAgICAgICAvLyBOT1RFOiBSYXRoZXIgdGhhbiBjb250aW51ZSB0byBhZGQgdG8gdGhpcyBsaXN0LCB3ZSBjb3VsZCBkZWNpZGUgdG9cclxuICAgICAgICAvLyBhbHdheXMgZmFsbCBiYWNrLCB3aXRoIHRoZSByaXNrIHRoYXQgd2UgbWlnaHQgYWNjaWRlbnRhbGx5IGhpZGUgZXJyb3JzXHJcbiAgICAgICAgLy8gcmVwcmVzZW50aW5nIGFjdHVhbCBTREsgYnVncy5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgIC8vIFdoZW4gdGhlIGJyb3dzZXIgaXMgb3V0IG9mIHF1b3RhIHdlIGNvdWxkIGdldCBlaXRoZXIgcXVvdGEgZXhjZWVkZWRcclxuICAgICAgICAvLyBvciBhbiBhYm9ydGVkIGVycm9yIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlcnJvciBoYXBwZW5lZCBkdXJpbmdcclxuICAgICAgICAvLyBzY2hlbWEgbWlncmF0aW9uLlxyXG4gICAgICAgIGVycm9yLmNvZGUgPT09IERPTV9FWENFUFRJT05fUVVPVEFfRVhDRUVERUQgfHxcclxuICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gRE9NX0VYQ0VQVElPTl9BQk9SVEVEIHx8XHJcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggUHJpdmF0ZSBCcm93c2luZyBtb2RlIGRpc2FibGVzIEluZGV4ZWREYiBhbmQgcmV0dXJuc1xyXG4gICAgICAgICAgICAvLyBJTlZBTElEX1NUQVRFIGZvciBhbnkgdXNhZ2UuXHJcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IERPTV9FWENFUFRJT05fSU5WQUxJRF9TVEFURSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQ2xlYXJzIHRoZSBwZXJzaXN0ZW50IHN0b3JhZ2UuIFRoaXMgaW5jbHVkZXMgcGVuZGluZyB3cml0ZXMgYW5kIGNhY2hlZFxyXG4gKiBkb2N1bWVudHMuXHJcbiAqXHJcbiAqIE11c3QgYmUgY2FsbGVkIHdoaWxlIHRoZSB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSBpcyBub3Qgc3RhcnRlZCAoYWZ0ZXIgdGhlIGFwcCBpc1xyXG4gKiB0ZXJtaW5hdGVkIG9yIHdoZW4gdGhlIGFwcCBpcyBmaXJzdCBpbml0aWFsaXplZCkuIE9uIHN0YXJ0dXAsIHRoaXMgZnVuY3Rpb25cclxuICogbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG90aGVyIGZ1bmN0aW9ucyAob3RoZXIgdGhhbiB7QGxpbmtcclxuICogaW5pdGlhbGl6ZUZpcmVzdG9yZX0gb3Ige0BsaW5rIGdldEZpcmVzdG9yZX0pKS4gSWYgdGhlIHtAbGluayBGaXJlc3RvcmV9XHJcbiAqIGluc3RhbmNlIGlzIHN0aWxsIHJ1bm5pbmcsIHRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IgY29kZVxyXG4gKiBvZiBgZmFpbGVkLXByZWNvbmRpdGlvbmAuXHJcbiAqXHJcbiAqIE5vdGU6IGBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlKClgIGlzIHByaW1hcmlseSBpbnRlbmRlZCB0byBoZWxwIHdyaXRlXHJcbiAqIHJlbGlhYmxlIHRlc3RzIHRoYXQgdXNlIENsb3VkIEZpcmVzdG9yZS4gSXQgdXNlcyBhbiBlZmZpY2llbnQgbWVjaGFuaXNtIGZvclxyXG4gKiBkcm9wcGluZyBleGlzdGluZyBkYXRhIGJ1dCBkb2VzIG5vdCBhdHRlbXB0IHRvIHNlY3VyZWx5IG92ZXJ3cml0ZSBvclxyXG4gKiBvdGhlcndpc2UgbWFrZSBjYWNoZWQgZGF0YSB1bnJlY292ZXJhYmxlLiBGb3IgYXBwbGljYXRpb25zIHRoYXQgYXJlIHNlbnNpdGl2ZVxyXG4gKiB0byB0aGUgZGlzY2xvc3VyZSBvZiBjYWNoZWQgZGF0YSBpbiBiZXR3ZWVuIHVzZXIgc2Vzc2lvbnMsIHdlIHN0cm9uZ2x5XHJcbiAqIHJlY29tbWVuZCBub3QgZW5hYmxpbmcgcGVyc2lzdGVuY2UgYXQgYWxsLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmlyZXN0b3JlIC0gVGhlIHtAbGluayBGaXJlc3RvcmV9IGluc3RhbmNlIHRvIGNsZWFyIHBlcnNpc3RlbmNlIGZvci5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCB3aGVuIHRoZSBwZXJzaXN0ZW50IHN0b3JhZ2UgaXNcclxuICogY2xlYXJlZC4gT3RoZXJ3aXNlLCB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZShmaXJlc3RvcmUpIHtcclxuICAgIGlmIChmaXJlc3RvcmUuX2luaXRpYWxpemVkICYmICFmaXJlc3RvcmUuX3Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnUGVyc2lzdGVuY2UgY2FuIG9ubHkgYmUgY2xlYXJlZCBiZWZvcmUgYSBGaXJlc3RvcmUgaW5zdGFuY2UgaXMgJyArXHJcbiAgICAgICAgICAgICdpbml0aWFsaXplZCBvciBhZnRlciBpdCBpcyB0ZXJtaW5hdGVkLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGZpcmVzdG9yZS5fcXVldWUuZW5xdWV1ZUFuZEZvcmdldEV2ZW5XaGlsZVJlc3RyaWN0ZWQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGluZGV4ZWREYkNsZWFyUGVyc2lzdGVuY2UoaW5kZXhlZERiU3RvcmFnZVByZWZpeChmaXJlc3RvcmUuX2RhdGFiYXNlSWQsIGZpcmVzdG9yZS5fcGVyc2lzdGVuY2VLZXkpKTtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogV2FpdHMgdW50aWwgYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBmb3IgdGhlIGFjdGl2ZSB1c2VyIGhhdmUgYmVlblxyXG4gKiBhY2tub3dsZWRnZWQgYnkgdGhlIGJhY2tlbmQuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyBvdXRzdGFuZGluZyB3cml0ZXMuXHJcbiAqIE90aGVyd2lzZSwgdGhlIHByb21pc2Ugd2FpdHMgZm9yIGFsbCBwcmV2aW91c2x5IGlzc3VlZCB3cml0ZXMgKGluY2x1ZGluZ1xyXG4gKiB0aG9zZSB3cml0dGVuIGluIGEgcHJldmlvdXMgYXBwIHNlc3Npb24pLCBidXQgaXQgZG9lcyBub3Qgd2FpdCBmb3Igd3JpdGVzXHJcbiAqIHRoYXQgd2VyZSBhZGRlZCBhZnRlciB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiBJZiB5b3Ugd2FudCB0byB3YWl0IGZvclxyXG4gKiBhZGRpdGlvbmFsIHdyaXRlcywgY2FsbCBgd2FpdEZvclBlbmRpbmdXcml0ZXMoKWAgYWdhaW4uXHJcbiAqXHJcbiAqIEFueSBvdXRzdGFuZGluZyBgd2FpdEZvclBlbmRpbmdXcml0ZXMoKWAgcHJvbWlzZXMgYXJlIHJlamVjdGVkIGR1cmluZyB1c2VyXHJcbiAqIGNoYW5nZXMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHdoaWNoIHJlc29sdmVzIHdoZW4gYWxsIGN1cnJlbnRseSBwZW5kaW5nIHdyaXRlcyBoYXZlIGJlZW5cclxuICogYWNrbm93bGVkZ2VkIGJ5IHRoZSBiYWNrZW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gd2FpdEZvclBlbmRpbmdXcml0ZXMoZmlyZXN0b3JlKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRXYWl0Rm9yUGVuZGluZ1dyaXRlcyhjbGllbnQpO1xyXG59XHJcbi8qKlxyXG4gKiBSZS1lbmFibGVzIHVzZSBvZiB0aGUgbmV0d29yayBmb3IgdGhpcyB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZSBhZnRlciBhIHByaW9yXHJcbiAqIGNhbGwgdG8ge0BsaW5rIGRpc2FibGVOZXR3b3JrfS5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIGVuYWJsZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmFibGVOZXR3b3JrKGZpcmVzdG9yZSkge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50RW5hYmxlTmV0d29yayhjbGllbnQpO1xyXG59XHJcbi8qKlxyXG4gKiBEaXNhYmxlcyBuZXR3b3JrIHVzYWdlIGZvciB0aGlzIGluc3RhbmNlLiBJdCBjYW4gYmUgcmUtZW5hYmxlZCB2aWEge0BsaW5rXHJcbiAqIGVuYWJsZU5ldHdvcmt9LiBXaGlsZSB0aGUgbmV0d29yayBpcyBkaXNhYmxlZCwgYW55IHNuYXBzaG90IGxpc3RlbmVycyxcclxuICogYGdldERvYygpYCBvciBgZ2V0RG9jcygpYCBjYWxscyB3aWxsIHJldHVybiByZXN1bHRzIGZyb20gY2FjaGUsIGFuZCBhbnkgd3JpdGVcclxuICogb3BlcmF0aW9ucyB3aWxsIGJlIHF1ZXVlZCB1bnRpbCB0aGUgbmV0d29yayBpcyByZXN0b3JlZC5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCBpcyByZXNvbHZlZCBvbmNlIHRoZSBuZXR3b3JrIGhhcyBiZWVuIGRpc2FibGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gZGlzYWJsZU5ldHdvcmsoZmlyZXN0b3JlKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnREaXNhYmxlTmV0d29yayhjbGllbnQpO1xyXG59XHJcbi8qKlxyXG4gKiBUZXJtaW5hdGVzIHRoZSBwcm92aWRlZCB7QGxpbmsgRmlyZXN0b3JlfSBpbnN0YW5jZS5cclxuICpcclxuICogQWZ0ZXIgY2FsbGluZyBgdGVybWluYXRlKClgIG9ubHkgdGhlIGBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlKClgIGZ1bmN0aW9uXHJcbiAqIG1heSBiZSB1c2VkLiBBbnkgb3RoZXIgZnVuY3Rpb24gd2lsbCB0aHJvdyBhIGBGaXJlc3RvcmVFcnJvcmAuXHJcbiAqXHJcbiAqIFRvIHJlc3RhcnQgYWZ0ZXIgdGVybWluYXRpb24sIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBGaXJlYmFzZUZpcmVzdG9yZSB3aXRoXHJcbiAqIHtAbGluayBnZXRGaXJlc3RvcmV9LlxyXG4gKlxyXG4gKiBUZXJtaW5hdGlvbiBkb2VzIG5vdCBjYW5jZWwgYW55IHBlbmRpbmcgd3JpdGVzLCBhbmQgYW55IHByb21pc2VzIHRoYXQgYXJlXHJcbiAqIGF3YWl0aW5nIGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIHdpbGwgbm90IGJlIHJlc29sdmVkLiBJZiB5b3UgaGF2ZVxyXG4gKiBwZXJzaXN0ZW5jZSBlbmFibGVkLCB0aGUgbmV4dCB0aW1lIHlvdSBzdGFydCB0aGlzIGluc3RhbmNlLCBpdCB3aWxsIHJlc3VtZVxyXG4gKiBzZW5kaW5nIHRoZXNlIHdyaXRlcyB0byB0aGUgc2VydmVyLlxyXG4gKlxyXG4gKiBOb3RlOiBVbmRlciBub3JtYWwgY2lyY3Vtc3RhbmNlcywgY2FsbGluZyBgdGVybWluYXRlKClgIGlzIG5vdCByZXF1aXJlZC4gVGhpc1xyXG4gKiBmdW5jdGlvbiBpcyB1c2VmdWwgb25seSB3aGVuIHlvdSB3YW50IHRvIGZvcmNlIHRoaXMgaW5zdGFuY2UgdG8gcmVsZWFzZSBhbGxcclxuICogb2YgaXRzIHJlc291cmNlcyBvciBpbiBjb21iaW5hdGlvbiB3aXRoIGBjbGVhckluZGV4ZWREYlBlcnNpc3RlbmNlKClgIHRvXHJcbiAqIGVuc3VyZSB0aGF0IGFsbCBsb2NhbCBzdGF0ZSBpcyBkZXN0cm95ZWQgYmV0d2VlbiB0ZXN0IHJ1bnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgaW5zdGFuY2UgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5XHJcbiAqIHRlcm1pbmF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0ZXJtaW5hdGUoZmlyZXN0b3JlKSB7XHJcbiAgICBfcmVtb3ZlU2VydmljZUluc3RhbmNlKGZpcmVzdG9yZS5hcHAsICdmaXJlc3RvcmUnKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmUuX2RlbGV0ZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBMb2FkcyBhIEZpcmVzdG9yZSBidW5kbGUgaW50byB0aGUgbG9jYWwgY2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gbG9hZCBidW5kbGVzIGZvci5cclxuICogQHBhcmFtIGJ1bmRsZURhdGEgLSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBidW5kbGUgdG8gYmUgbG9hZGVkLiBWYWxpZFxyXG4gKiBvYmplY3RzIGFyZSBgQXJyYXlCdWZmZXJgLCBgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5gIG9yIGBzdHJpbmdgLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBMb2FkQnVuZGxlVGFza2Agb2JqZWN0LCB3aGljaCBub3RpZmllcyBjYWxsZXJzIHdpdGggcHJvZ3Jlc3NcclxuICogdXBkYXRlcywgYW5kIGNvbXBsZXRpb24gb3IgZXJyb3IgZXZlbnRzLiBJdCBjYW4gYmUgdXNlZCBhcyBhXHJcbiAqIGBQcm9taXNlPExvYWRCdW5kbGVUYXNrUHJvZ3Jlc3M+YC5cclxuICovXHJcbmZ1bmN0aW9uIGxvYWRCdW5kbGUoZmlyZXN0b3JlLCBidW5kbGVEYXRhKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHJlc3VsdFRhc2sgPSBuZXcgTG9hZEJ1bmRsZVRhc2soKTtcclxuICAgIGZpcmVzdG9yZUNsaWVudExvYWRCdW5kbGUoY2xpZW50LCBmaXJlc3RvcmUuX2RhdGFiYXNlSWQsIGJ1bmRsZURhdGEsIHJlc3VsdFRhc2spO1xyXG4gICAgcmV0dXJuIHJlc3VsdFRhc2s7XHJcbn1cclxuLyoqXHJcbiAqIFJlYWRzIGEgRmlyZXN0b3JlIHtAbGluayBRdWVyeX0gZnJvbSBsb2NhbCBjYWNoZSwgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW5cclxuICogbmFtZS5cclxuICpcclxuICogVGhlIG5hbWVkIHF1ZXJpZXMgYXJlIHBhY2thZ2VkICBpbnRvIGJ1bmRsZXMgb24gdGhlIHNlcnZlciBzaWRlIChhbG9uZ1xyXG4gKiB3aXRoIHJlc3VsdGluZyBkb2N1bWVudHMpLCBhbmQgbG9hZGVkIHRvIGxvY2FsIGNhY2hlIHVzaW5nIGBsb2FkQnVuZGxlYC4gT25jZVxyXG4gKiBpbiBsb2NhbCBjYWNoZSwgdXNlIHRoaXMgbWV0aG9kIHRvIGV4dHJhY3QgYSB7QGxpbmsgUXVlcnl9IGJ5IG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaXJlc3RvcmUgLSBUaGUge0BsaW5rIEZpcmVzdG9yZX0gaW5zdGFuY2UgdG8gcmVhZCB0aGUgcXVlcnkgZnJvbS5cclxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVlcnkuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgUXVlcnkgb3IgYG51bGxgLlxyXG4gKi9cclxuZnVuY3Rpb24gbmFtZWRRdWVyeShmaXJlc3RvcmUsIG5hbWUpIHtcclxuICAgIGZpcmVzdG9yZSA9IGNhc3QoZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudEdldE5hbWVkUXVlcnkoY2xpZW50LCBuYW1lKS50aGVuKG5hbWVkUXVlcnkgPT4ge1xyXG4gICAgICAgIGlmICghbmFtZWRRdWVyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShmaXJlc3RvcmUsIG51bGwsIG5hbWVkUXVlcnkucXVlcnkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdmVyaWZ5Tm90SW5pdGlhbGl6ZWQoZmlyZXN0b3JlKSB7XHJcbiAgICBpZiAoZmlyZXN0b3JlLl9pbml0aWFsaXplZCB8fCBmaXJlc3RvcmUuX3Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5GQUlMRURfUFJFQ09ORElUSU9OLCAnRmlyZXN0b3JlIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCBhbmQgcGVyc2lzdGVuY2UgY2FuIG5vIGxvbmdlciBiZSAnICtcclxuICAgICAgICAgICAgJ2VuYWJsZWQuIFlvdSBjYW4gb25seSBlbmFibGUgcGVyc2lzdGVuY2UgYmVmb3JlIGNhbGxpbmcgYW55IG90aGVyICcgK1xyXG4gICAgICAgICAgICAnbWV0aG9kcyBvbiBhIEZpcmVzdG9yZSBvYmplY3QuJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJGaXJlc3RvcmUodmFyaWFudCwgdXNlRmV0Y2hTdHJlYW1zID0gdHJ1ZSkge1xyXG4gICAgc2V0U0RLVmVyc2lvbihTREtfVkVSU0lPTiQxKTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdmaXJlc3RvcmUnLCAoY29udGFpbmVyLCB7IG9wdGlvbnM6IHNldHRpbmdzIH0pID0+IHtcclxuICAgICAgICBjb25zdCBhcHAgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2FwcCcpLmdldEltbWVkaWF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGZpcmVzdG9yZUluc3RhbmNlID0gbmV3IEZpcmVzdG9yZShhcHAsIG5ldyBGaXJlYmFzZUF1dGhDcmVkZW50aWFsc1Byb3ZpZGVyKGNvbnRhaW5lci5nZXRQcm92aWRlcignYXV0aC1pbnRlcm5hbCcpKSwgbmV3IEZpcmViYXNlQXBwQ2hlY2tUb2tlblByb3ZpZGVyKGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJykpKTtcclxuICAgICAgICBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oeyB1c2VGZXRjaFN0cmVhbXMgfSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIGZpcmVzdG9yZUluc3RhbmNlLl9zZXRTZXR0aW5ncyhzZXR0aW5ncyk7XHJcbiAgICAgICAgcmV0dXJuIGZpcmVzdG9yZUluc3RhbmNlO1xyXG4gICAgfSwgJ1BVQkxJQycpKTtcclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uJDEsIHZhcmlhbnQpO1xyXG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgYEZpZWxkUGF0aGAgcmVmZXJzIHRvIGEgZmllbGQgaW4gYSBkb2N1bWVudC4gVGhlIHBhdGggbWF5IGNvbnNpc3Qgb2YgYVxyXG4gKiBzaW5nbGUgZmllbGQgbmFtZSAocmVmZXJyaW5nIHRvIGEgdG9wLWxldmVsIGZpZWxkIGluIHRoZSBkb2N1bWVudCksIG9yIGFcclxuICogbGlzdCBvZiBmaWVsZCBuYW1lcyAocmVmZXJyaW5nIHRvIGEgbmVzdGVkIGZpZWxkIGluIHRoZSBkb2N1bWVudCkuXHJcbiAqXHJcbiAqIENyZWF0ZSBhIGBGaWVsZFBhdGhgIGJ5IHByb3ZpZGluZyBmaWVsZCBuYW1lcy4gSWYgbW9yZSB0aGFuIG9uZSBmaWVsZFxyXG4gKiBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgcGF0aCB3aWxsIHBvaW50IHRvIGEgbmVzdGVkIGZpZWxkIGluIGEgZG9jdW1lbnQuXHJcbiAqL1xyXG5jbGFzcyBGaWVsZFBhdGgge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYEZpZWxkUGF0aGAgZnJvbSB0aGUgcHJvdmlkZWQgZmllbGQgbmFtZXMuIElmIG1vcmUgdGhhbiBvbmUgZmllbGRcclxuICAgICAqIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBwYXRoIHdpbGwgcG9pbnQgdG8gYSBuZXN0ZWQgZmllbGQgaW4gYSBkb2N1bWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmllbGROYW1lcyAtIEEgbGlzdCBvZiBmaWVsZCBuYW1lcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoLi4uZmllbGROYW1lcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIGZpZWxkIG5hbWUgYXQgYXJndW1lbnQgJChpICsgMSkuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICdGaWVsZCBuYW1lcyBtdXN0IG5vdCBiZSBlbXB0eS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbnRlcm5hbFBhdGggPSBuZXcgRmllbGRQYXRoJDEoZmllbGROYW1lcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBGaWVsZFBhdGhgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBGaWVsZFBhdGhgIHRvIGNvbXBhcmUgYWdhaW5zdC5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBgRmllbGRQYXRoYCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsUGF0aC5pc0VxdWFsKG90aGVyLl9pbnRlcm5hbFBhdGgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCBzZW50aW5lbCBgRmllbGRQYXRoYCB0byByZWZlciB0byB0aGUgSUQgb2YgYSBkb2N1bWVudC5cclxuICogSXQgY2FuIGJlIHVzZWQgaW4gcXVlcmllcyB0byBzb3J0IG9yIGZpbHRlciBieSB0aGUgZG9jdW1lbnQgSUQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkb2N1bWVudElkKCkge1xyXG4gICAgcmV0dXJuIG5ldyBGaWVsZFBhdGgoRE9DVU1FTlRfS0VZX05BTUUpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhbiBhcnJheSBvZiBieXRlcy5cclxuICovXHJcbmNsYXNzIEJ5dGVzIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihieXRlU3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fYnl0ZVN0cmluZyA9IGJ5dGVTdHJpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYEJ5dGVzYCBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gQmFzZTY0IHN0cmluZywgY29udmVydGluZyBpdCB0b1xyXG4gICAgICogYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJhc2U2NCAtIFRoZSBCYXNlNjQgc3RyaW5nIHVzZWQgdG8gY3JlYXRlIHRoZSBgQnl0ZXNgIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21CYXNlNjRTdHJpbmcoYmFzZTY0KSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlcyhCeXRlU3RyaW5nLmZyb21CYXNlNjRTdHJpbmcoYmFzZTY0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdGYWlsZWQgdG8gY29uc3RydWN0IGRhdGEgZnJvbSBCYXNlNjQgc3RyaW5nOiAnICsgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCeXRlc2Agb2JqZWN0IGZyb20gdGhlIGdpdmVuIFVpbnQ4QXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFycmF5IC0gVGhlIFVpbnQ4QXJyYXkgdXNlZCB0byBjcmVhdGUgdGhlIGBCeXRlc2Agb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVVpbnQ4QXJyYXkoYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJ5dGVzKEJ5dGVTdHJpbmcuZnJvbVVpbnQ4QXJyYXkoYXJyYXkpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBieXRlcyBhcyBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgQmFzZTY0LWVuY29kZWQgc3RyaW5nIGNyZWF0ZWQgZnJvbSB0aGUgYEJ5dGVzYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvQmFzZTY0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ieXRlU3RyaW5nLnRvQmFzZTY0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcgYnl0ZXMgaW4gYSBuZXcgYFVpbnQ4QXJyYXlgLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBVaW50OEFycmF5IGNyZWF0ZWQgZnJvbSB0aGUgYEJ5dGVzYCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvVWludDhBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy50b1VpbnQ4QXJyYXkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYEJ5dGVzYCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGBCeXRlc2Agb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJ0J5dGVzKGJhc2U2NDogJyArIHRoaXMudG9CYXNlNjQoKSArICcpJztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYEJ5dGVzYCBvYmplY3QgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYEJ5dGVzYCBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIGBCeXRlc2Agb2JqZWN0IGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKi9cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnl0ZVN0cmluZy5pc0VxdWFsKG90aGVyLl9ieXRlU3RyaW5nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogU2VudGluZWwgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiB3cml0aW5nIGRvY3VtZW50IGZpZWxkcyB3aXRoIGBzZXQoKWBcclxuICogb3IgYHVwZGF0ZSgpYC5cclxuICovXHJcbmNsYXNzIEZpZWxkVmFsdWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gX21ldGhvZE5hbWUgLSBUaGUgcHVibGljIEFQSSBlbmRwb2ludCB0aGF0IHJldHVybnMgdGhpcyBjbGFzcy5cclxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX21ldGhvZE5hbWUpIHtcclxuICAgICAgICB0aGlzLl9tZXRob2ROYW1lID0gX21ldGhvZE5hbWU7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIGEgZ2VvZ3JhcGhpYyBsb2NhdGlvbiBpbiBGaXJlc3RvcmUuIFRoZVxyXG4gKiBsb2NhdGlvbiBpcyByZXByZXNlbnRlZCBhcyBsYXRpdHVkZS9sb25naXR1ZGUgcGFpci5cclxuICpcclxuICogTGF0aXR1ZGUgdmFsdWVzIGFyZSBpbiB0aGUgcmFuZ2Ugb2YgWy05MCwgOTBdLlxyXG4gKiBMb25naXR1ZGUgdmFsdWVzIGFyZSBpbiB0aGUgcmFuZ2Ugb2YgWy0xODAsIDE4MF0uXHJcbiAqL1xyXG5jbGFzcyBHZW9Qb2ludCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW1tdXRhYmxlIGBHZW9Qb2ludGAgb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIGxhdGl0dWRlIGFuZFxyXG4gICAgICogbG9uZ2l0dWRlIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBsYXRpdHVkZSAtIFRoZSBsYXRpdHVkZSBhcyBudW1iZXIgYmV0d2VlbiAtOTAgYW5kIDkwLlxyXG4gICAgICogQHBhcmFtIGxvbmdpdHVkZSAtIFRoZSBsb25naXR1ZGUgYXMgbnVtYmVyIGJldHdlZW4gLTE4MCBhbmQgMTgwLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihsYXRpdHVkZSwgbG9uZ2l0dWRlKSB7XHJcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsYXRpdHVkZSkgfHwgbGF0aXR1ZGUgPCAtOTAgfHwgbGF0aXR1ZGUgPiA5MCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnTGF0aXR1ZGUgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIC05MCBhbmQgOTAsIGJ1dCB3YXM6ICcgKyBsYXRpdHVkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNGaW5pdGUobG9uZ2l0dWRlKSB8fCBsb25naXR1ZGUgPCAtMTgwIHx8IGxvbmdpdHVkZSA+IDE4MCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnTG9uZ2l0dWRlIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAtMTgwIGFuZCAxODAsIGJ1dCB3YXM6ICcgKyBsb25naXR1ZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sYXQgPSBsYXRpdHVkZTtcclxuICAgICAgICB0aGlzLl9sb25nID0gbG9uZ2l0dWRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGF0aXR1ZGUgb2YgdGhpcyBgR2VvUG9pbnRgIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbGF0aXR1ZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvbmdpdHVkZSBvZiB0aGlzIGBHZW9Qb2ludGAgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldCBsb25naXR1ZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGBHZW9Qb2ludGAgaXMgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgYEdlb1BvaW50YCB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYEdlb1BvaW50YCBpcyBlcXVhbCB0byB0aGUgcHJvdmlkZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBpc0VxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhdCA9PT0gb3RoZXIuX2xhdCAmJiB0aGlzLl9sb25nID09PSBvdGhlci5fbG9uZztcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBHZW9Qb2ludC4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBsYXRpdHVkZTogdGhpcy5fbGF0LCBsb25naXR1ZGU6IHRoaXMuX2xvbmcgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWN0dWFsbHkgcHJpdmF0ZSB0byBKUyBjb25zdW1lcnMgb2Ygb3VyIEFQSSwgc28gdGhpcyBmdW5jdGlvbiBpcyBwcmVmaXhlZFxyXG4gICAgICogd2l0aCBhbiB1bmRlcnNjb3JlLlxyXG4gICAgICovXHJcbiAgICBfY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChwcmltaXRpdmVDb21wYXJhdG9yKHRoaXMuX2xhdCwgb3RoZXIuX2xhdCkgfHxcclxuICAgICAgICAgICAgcHJpbWl0aXZlQ29tcGFyYXRvcih0aGlzLl9sb25nLCBvdGhlci5fbG9uZykpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFJFU0VSVkVEX0ZJRUxEX1JFR0VYID0gL15fXy4qX18kLztcclxuLyoqIFRoZSByZXN1bHQgb2YgcGFyc2luZyBkb2N1bWVudCBkYXRhIChlLmcuIGZvciBhIHNldERhdGEgY2FsbCkuICovXHJcbmNsYXNzIFBhcnNlZFNldERhdGEge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSwgZmllbGRNYXNrLCBmaWVsZFRyYW5zZm9ybXMpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgfVxyXG4gICAgdG9NdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLmZpZWxkTWFzayAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGNoTXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHRoaXMuZmllbGRNYXNrLCBwcmVjb25kaXRpb24sIHRoaXMuZmllbGRUcmFuc2Zvcm1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0TXV0YXRpb24oa2V5LCB0aGlzLmRhdGEsIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKiogVGhlIHJlc3VsdCBvZiBwYXJzaW5nIFwidXBkYXRlXCIgZGF0YSAoaS5lLiBmb3IgYW4gdXBkYXRlRGF0YSBjYWxsKS4gKi9cclxuY2xhc3MgUGFyc2VkVXBkYXRlRGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBcclxuICAgIC8vIFRoZSBmaWVsZE1hc2sgZG9lcyBub3QgaW5jbHVkZSBkb2N1bWVudCB0cmFuc2Zvcm1zLlxyXG4gICAgZmllbGRNYXNrLCBmaWVsZFRyYW5zZm9ybXMpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuZmllbGRNYXNrID0gZmllbGRNYXNrO1xyXG4gICAgICAgIHRoaXMuZmllbGRUcmFuc2Zvcm1zID0gZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgfVxyXG4gICAgdG9NdXRhdGlvbihrZXksIHByZWNvbmRpdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGF0Y2hNdXRhdGlvbihrZXksIHRoaXMuZGF0YSwgdGhpcy5maWVsZE1hc2ssIHByZWNvbmRpdGlvbiwgdGhpcy5maWVsZFRyYW5zZm9ybXMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzV3JpdGUoZGF0YVNvdXJjZSkge1xyXG4gICAgc3dpdGNoIChkYXRhU291cmNlKSB7XHJcbiAgICAgICAgY2FzZSAwIC8qIFNldCAqLzogLy8gZmFsbCB0aHJvdWdoXHJcbiAgICAgICAgY2FzZSAyIC8qIE1lcmdlU2V0ICovOiAvLyBmYWxsIHRocm91Z2hcclxuICAgICAgICBjYXNlIDEgLyogVXBkYXRlICovOlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBjYXNlIDMgLyogQXJndW1lbnQgKi86XHJcbiAgICAgICAgY2FzZSA0IC8qIEFycmF5QXJndW1lbnQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqIEEgXCJjb250ZXh0XCIgb2JqZWN0IHBhc3NlZCBhcm91bmQgd2hpbGUgcGFyc2luZyB1c2VyIGRhdGEuICovXHJcbmNsYXNzIFBhcnNlQ29udGV4dEltcGwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBhIFBhcnNlQ29udGV4dCB3aXRoIHRoZSBnaXZlbiBzb3VyY2UgYW5kIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNldHRpbmdzIC0gVGhlIHNldHRpbmdzIGZvciB0aGUgcGFyc2VyLlxyXG4gICAgICogQHBhcmFtIGRhdGFiYXNlSWQgLSBUaGUgZGF0YWJhc2UgSUQgb2YgdGhlIEZpcmVzdG9yZSBpbnN0YW5jZS5cclxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVyIC0gVGhlIHNlcmlhbGl6ZXIgdG8gdXNlIHRvIGdlbmVyYXRlIHRoZSBWYWx1ZSBwcm90by5cclxuICAgICAqIEBwYXJhbSBpZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzIC0gV2hldGhlciB0byBpZ25vcmUgdW5kZWZpbmVkIHByb3BlcnRpZXNcclxuICAgICAqIHJhdGhlciB0aGFuIHRocm93LlxyXG4gICAgICogQHBhcmFtIGZpZWxkVHJhbnNmb3JtcyAtIEEgbXV0YWJsZSBsaXN0IG9mIGZpZWxkIHRyYW5zZm9ybXMgZW5jb3VudGVyZWRcclxuICAgICAqIHdoaWxlIHBhcnNpbmcgdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gZmllbGRNYXNrIC0gQSBtdXRhYmxlIGxpc3Qgb2YgZmllbGQgcGF0aHMgZW5jb3VudGVyZWQgd2hpbGUgcGFyc2luZ1xyXG4gICAgICogdGhlIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyhiLzM0ODcxMTMxKTogV2UgZG9uJ3Qgc3VwcG9ydCBhcnJheSBwYXRocyByaWdodCBub3csIHNvIHBhdGggY2FuIGJlXHJcbiAgICAgKiBudWxsIHRvIGluZGljYXRlIHRoZSBjb250ZXh0IHJlcHJlc2VudHMgYW55IGxvY2F0aW9uIHdpdGhpbiBhbiBhcnJheSAoaW5cclxuICAgICAqIHdoaWNoIGNhc2UgY2VydGFpbiBmZWF0dXJlcyB3aWxsIG5vdCB3b3JrIGFuZCBlcnJvcnMgd2lsbCBiZSBzb21ld2hhdFxyXG4gICAgICogY29tcHJvbWlzZWQpLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgZGF0YWJhc2VJZCwgc2VyaWFsaXplciwgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgZmllbGRUcmFuc2Zvcm1zLCBmaWVsZE1hc2spIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgdGhpcy5kYXRhYmFzZUlkID0gZGF0YWJhc2VJZDtcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xyXG4gICAgICAgIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcyA9IGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXM7XHJcbiAgICAgICAgLy8gTWlub3IgaGFjazogSWYgZmllbGRUcmFuc2Zvcm1zIGlzIHVuZGVmaW5lZCwgd2UgYXNzdW1lIHRoaXMgaXMgYW5cclxuICAgICAgICAvLyBleHRlcm5hbCBjYWxsIGFuZCB3ZSBuZWVkIHRvIHZhbGlkYXRlIHRoZSBlbnRpcmUgcGF0aC5cclxuICAgICAgICBpZiAoZmllbGRUcmFuc2Zvcm1zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhdGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5maWVsZFRyYW5zZm9ybXMgPSBmaWVsZFRyYW5zZm9ybXMgfHwgW107XHJcbiAgICAgICAgdGhpcy5maWVsZE1hc2sgPSBmaWVsZE1hc2sgfHwgW107XHJcbiAgICB9XHJcbiAgICBnZXQgcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5wYXRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRhdGFTb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZGF0YVNvdXJjZTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGEgbmV3IGNvbnRleHQgd2l0aCB0aGUgc3BlY2lmaWVkIHNldHRpbmdzIG92ZXJ3cml0dGVuLiAqL1xyXG4gICAgY29udGV4dFdpdGgoY29uZmlndXJhdGlvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0SW1wbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2V0dGluZ3MpLCBjb25maWd1cmF0aW9uKSwgdGhpcy5kYXRhYmFzZUlkLCB0aGlzLnNlcmlhbGl6ZXIsIHRoaXMuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgdGhpcy5maWVsZFRyYW5zZm9ybXMsIHRoaXMuZmllbGRNYXNrKTtcclxuICAgIH1cclxuICAgIGNoaWxkQ29udGV4dEZvckZpZWxkKGZpZWxkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IChfYSA9IHRoaXMucGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkKGZpZWxkKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0V2l0aCh7IHBhdGg6IGNoaWxkUGF0aCwgYXJyYXlFbGVtZW50OiBmYWxzZSB9KTtcclxuICAgICAgICBjb250ZXh0LnZhbGlkYXRlUGF0aFNlZ21lbnQoZmllbGQpO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfVxyXG4gICAgY2hpbGRDb250ZXh0Rm9yRmllbGRQYXRoKGZpZWxkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IChfYSA9IHRoaXMucGF0aCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNoaWxkKGZpZWxkKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0V2l0aCh7IHBhdGg6IGNoaWxkUGF0aCwgYXJyYXlFbGVtZW50OiBmYWxzZSB9KTtcclxuICAgICAgICBjb250ZXh0LnZhbGlkYXRlUGF0aCgpO1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgfVxyXG4gICAgY2hpbGRDb250ZXh0Rm9yQXJyYXkoaW5kZXgpIHtcclxuICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBXZSBkb24ndCBzdXBwb3J0IGFycmF5IHBhdGhzIHJpZ2h0IG5vdzsgc28gbWFrZSBwYXRoXHJcbiAgICAgICAgLy8gdW5kZWZpbmVkLlxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRXaXRoKHsgcGF0aDogdW5kZWZpbmVkLCBhcnJheUVsZW1lbnQ6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVFcnJvcihyZWFzb24pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRXJyb3IocmVhc29uLCB0aGlzLnNldHRpbmdzLm1ldGhvZE5hbWUsIHRoaXMuc2V0dGluZ3MuaGFzQ29udmVydGVyIHx8IGZhbHNlLCB0aGlzLnBhdGgsIHRoaXMuc2V0dGluZ3MudGFyZ2V0RG9jKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zICd0cnVlJyBpZiAnZmllbGRQYXRoJyB3YXMgdHJhdmVyc2VkIHdoZW4gY3JlYXRpbmcgdGhpcyBjb250ZXh0LiAqL1xyXG4gICAgY29udGFpbnMoZmllbGRQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmZpZWxkTWFzay5maW5kKGZpZWxkID0+IGZpZWxkUGF0aC5pc1ByZWZpeE9mKGZpZWxkKSkgIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICB0aGlzLmZpZWxkVHJhbnNmb3Jtcy5maW5kKHRyYW5zZm9ybSA9PiBmaWVsZFBhdGguaXNQcmVmaXhPZih0cmFuc2Zvcm0uZmllbGQpKSAhPT0gdW5kZWZpbmVkKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aCgpIHtcclxuICAgICAgICAvLyBUT0RPKGIvMzQ4NzExMzEpOiBSZW1vdmUgbnVsbCBjaGVjayBvbmNlIHdlIGhhdmUgcHJvcGVyIHBhdGhzIGZvciBmaWVsZHNcclxuICAgICAgICAvLyB3aXRoaW4gYXJyYXlzLlxyXG4gICAgICAgIGlmICghdGhpcy5wYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBhdGhTZWdtZW50KHRoaXMucGF0aC5nZXQoaSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aFNlZ21lbnQoc2VnbWVudCkge1xyXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyB0aGlzLmNyZWF0ZUVycm9yKCdEb2N1bWVudCBmaWVsZHMgbXVzdCBub3QgYmUgZW1wdHknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzV3JpdGUodGhpcy5kYXRhU291cmNlKSAmJiBSRVNFUlZFRF9GSUVMRF9SRUdFWC50ZXN0KHNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IHRoaXMuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IGZpZWxkcyBjYW5ub3QgYmVnaW4gYW5kIGVuZCB3aXRoIFwiX19cIicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIGZvciBwYXJzaW5nIHJhdyB1c2VyIGlucHV0IChwcm92aWRlZCB2aWEgdGhlIEFQSSkgaW50byBpbnRlcm5hbCBtb2RlbFxyXG4gKiBjbGFzc2VzLlxyXG4gKi9cclxuY2xhc3MgVXNlckRhdGFSZWFkZXIge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YWJhc2VJZCwgaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgc2VyaWFsaXplcikge1xyXG4gICAgICAgIHRoaXMuZGF0YWJhc2VJZCA9IGRhdGFiYXNlSWQ7XHJcbiAgICAgICAgdGhpcy5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzID0gaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcztcclxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyIHx8IG5ld1NlcmlhbGl6ZXIoZGF0YWJhc2VJZCk7XHJcbiAgICB9XHJcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyB0b3AtbGV2ZWwgcGFyc2UgY29udGV4dC4gKi9cclxuICAgIGNyZWF0ZUNvbnRleHQoZGF0YVNvdXJjZSwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBoYXNDb252ZXJ0ZXIgPSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0SW1wbCh7XHJcbiAgICAgICAgICAgIGRhdGFTb3VyY2UsXHJcbiAgICAgICAgICAgIG1ldGhvZE5hbWUsXHJcbiAgICAgICAgICAgIHRhcmdldERvYyxcclxuICAgICAgICAgICAgcGF0aDogRmllbGRQYXRoJDEuZW1wdHlQYXRoKCksXHJcbiAgICAgICAgICAgIGFycmF5RWxlbWVudDogZmFsc2UsXHJcbiAgICAgICAgICAgIGhhc0NvbnZlcnRlclxyXG4gICAgICAgIH0sIHRoaXMuZGF0YWJhc2VJZCwgdGhpcy5zZXJpYWxpemVyLCB0aGlzLmlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1VzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZSkge1xyXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBmaXJlc3RvcmUuX2ZyZWV6ZVNldHRpbmdzKCk7XHJcbiAgICBjb25zdCBzZXJpYWxpemVyID0gbmV3U2VyaWFsaXplcihmaXJlc3RvcmUuX2RhdGFiYXNlSWQpO1xyXG4gICAgcmV0dXJuIG5ldyBVc2VyRGF0YVJlYWRlcihmaXJlc3RvcmUuX2RhdGFiYXNlSWQsICEhc2V0dGluZ3MuaWdub3JlVW5kZWZpbmVkUHJvcGVydGllcywgc2VyaWFsaXplcik7XHJcbn1cclxuLyoqIFBhcnNlIGRvY3VtZW50IGRhdGEgZnJvbSBhIHNldCgpIGNhbGwuICovXHJcbmZ1bmN0aW9uIHBhcnNlU2V0RGF0YSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdGFyZ2V0RG9jLCBpbnB1dCwgaGFzQ29udmVydGVyLCBvcHRpb25zID0ge30pIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KG9wdGlvbnMubWVyZ2UgfHwgb3B0aW9ucy5tZXJnZUZpZWxkc1xyXG4gICAgICAgID8gMiAvKiBNZXJnZVNldCAqL1xyXG4gICAgICAgIDogMCAvKiBTZXQgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYywgaGFzQ29udmVydGVyKTtcclxuICAgIHZhbGlkYXRlUGxhaW5PYmplY3QoJ0RhdGEgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCBpdCB3YXM6JywgY29udGV4dCwgaW5wdXQpO1xyXG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IHBhcnNlT2JqZWN0KGlucHV0LCBjb250ZXh0KTtcclxuICAgIGxldCBmaWVsZE1hc2s7XHJcbiAgICBsZXQgZmllbGRUcmFuc2Zvcm1zO1xyXG4gICAgaWYgKG9wdGlvbnMubWVyZ2UpIHtcclxuICAgICAgICBmaWVsZE1hc2sgPSBuZXcgRmllbGRNYXNrKGNvbnRleHQuZmllbGRNYXNrKTtcclxuICAgICAgICBmaWVsZFRyYW5zZm9ybXMgPSBjb250ZXh0LmZpZWxkVHJhbnNmb3JtcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdGlvbnMubWVyZ2VGaWVsZHMpIHtcclxuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGaWVsZFBhdGhzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBzdHJpbmdPckZpZWxkUGF0aCBvZiBvcHRpb25zLm1lcmdlRmllbGRzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKG1ldGhvZE5hbWUsIHN0cmluZ09yRmllbGRQYXRoLCB0YXJnZXREb2MpO1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRleHQuY29udGFpbnMoZmllbGRQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZpZWxkICcke2ZpZWxkUGF0aH0nIGlzIHNwZWNpZmllZCBpbiB5b3VyIGZpZWxkIG1hc2sgYnV0IG1pc3NpbmcgZnJvbSB5b3VyIGlucHV0IGRhdGEuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFmaWVsZE1hc2tDb250YWlucyh2YWxpZGF0ZWRGaWVsZFBhdGhzLCBmaWVsZFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZWRGaWVsZFBhdGhzLnB1c2goZmllbGRQYXRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaWVsZE1hc2sgPSBuZXcgRmllbGRNYXNrKHZhbGlkYXRlZEZpZWxkUGF0aHMpO1xyXG4gICAgICAgIGZpZWxkVHJhbnNmb3JtcyA9IGNvbnRleHQuZmllbGRUcmFuc2Zvcm1zLmZpbHRlcih0cmFuc2Zvcm0gPT4gZmllbGRNYXNrLmNvdmVycyh0cmFuc2Zvcm0uZmllbGQpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZpZWxkTWFzayA9IG51bGw7XHJcbiAgICAgICAgZmllbGRUcmFuc2Zvcm1zID0gY29udGV4dC5maWVsZFRyYW5zZm9ybXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlZFNldERhdGEobmV3IE9iamVjdFZhbHVlKHVwZGF0ZURhdGEpLCBmaWVsZE1hc2ssIGZpZWxkVHJhbnNmb3Jtcyk7XHJcbn1cclxuY2xhc3MgRGVsZXRlRmllbGRWYWx1ZUltcGwgZXh0ZW5kcyBGaWVsZFZhbHVlIHtcclxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcclxuICAgICAgICBpZiAoY29udGV4dC5kYXRhU291cmNlID09PSAyIC8qIE1lcmdlU2V0ICovKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHRyYW5zZm9ybSB0byBhZGQgZm9yIGEgZGVsZXRlLCBidXQgd2UgbmVlZCB0byBhZGQgaXQgdG8gb3VyXHJcbiAgICAgICAgICAgIC8vIGZpZWxkTWFzayBzbyBpdCBnZXRzIGRlbGV0ZWQuXHJcbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29udGV4dC5kYXRhU291cmNlID09PSAxIC8qIFVwZGF0ZSAqLykge1xyXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3RoaXMuX21ldGhvZE5hbWV9KCkgY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWwgYCArXHJcbiAgICAgICAgICAgICAgICAnb2YgeW91ciB1cGRhdGUgZGF0YScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkbid0IGVuY291bnRlciBkZWxldGUgc2VudGluZWxzIGZvciBxdWVyaWVzIG9yIG5vbi1tZXJnZSBzZXQoKSBjYWxscy5cclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgJHt0aGlzLl9tZXRob2ROYW1lfSgpIGNhbm5vdCBiZSB1c2VkIHdpdGggc2V0KCkgdW5sZXNzIHlvdSBwYXNzIGAgK1xyXG4gICAgICAgICAgICAgICAgJ3ttZXJnZTp0cnVlfScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBEZWxldGVGaWVsZFZhbHVlSW1wbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNoaWxkIGNvbnRleHQgZm9yIHBhcnNpbmcgU2VyaWFsaXphYmxlRmllbGRWYWx1ZXMuXHJcbiAqXHJcbiAqIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gY2FsbGluZyBgUGFyc2VDb250ZXh0LmNvbnRleHRXaXRoYCBiZWNhdXNlIGl0IGtlZXBzXHJcbiAqIHRoZSBmaWVsZFRyYW5zZm9ybXMgYW5kIGZpZWxkTWFzayBzZXBhcmF0ZS5cclxuICpcclxuICogVGhlIGNyZWF0ZWQgY29udGV4dCBoYXMgaXRzIGBkYXRhU291cmNlYCBzZXQgdG8gYFVzZXJEYXRhU291cmNlLkFyZ3VtZW50YC5cclxuICogQWx0aG91Z2ggdGhlc2UgdmFsdWVzIGFyZSB1c2VkIHdpdGggd3JpdGVzLCBhbnkgZWxlbWVudHMgaW4gdGhlc2UgRmllbGRWYWx1ZXNcclxuICogYXJlIG5vdCBjb25zaWRlcmVkIHdyaXRlcyBzaW5jZSB0aGV5IGNhbm5vdCBjb250YWluIGFueSBGaWVsZFZhbHVlIHNlbnRpbmVscyxcclxuICogZXRjLlxyXG4gKlxyXG4gKiBAcGFyYW0gZmllbGRWYWx1ZSAtIFRoZSBzZW50aW5lbCBGaWVsZFZhbHVlIGZvciB3aGljaCB0byBjcmVhdGUgYSBjaGlsZFxyXG4gKiAgICAgY29udGV4dC5cclxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgcGFyZW50IGNvbnRleHQuXHJcbiAqIEBwYXJhbSBhcnJheUVsZW1lbnQgLSBXaGV0aGVyIG9yIG5vdCB0aGUgRmllbGRWYWx1ZSBoYXMgYW4gYXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dChmaWVsZFZhbHVlLCBjb250ZXh0LCBhcnJheUVsZW1lbnQpIHtcclxuICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0SW1wbCh7XHJcbiAgICAgICAgZGF0YVNvdXJjZTogMyAvKiBBcmd1bWVudCAqLyxcclxuICAgICAgICB0YXJnZXREb2M6IGNvbnRleHQuc2V0dGluZ3MudGFyZ2V0RG9jLFxyXG4gICAgICAgIG1ldGhvZE5hbWU6IGZpZWxkVmFsdWUuX21ldGhvZE5hbWUsXHJcbiAgICAgICAgYXJyYXlFbGVtZW50XHJcbiAgICB9LCBjb250ZXh0LmRhdGFiYXNlSWQsIGNvbnRleHQuc2VyaWFsaXplciwgY29udGV4dC5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKTtcclxufVxyXG5jbGFzcyBTZXJ2ZXJUaW1lc3RhbXBGaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xyXG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBuZXcgU2VydmVyVGltZXN0YW1wVHJhbnNmb3JtKCkpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFNlcnZlclRpbWVzdGFtcEZpZWxkVmFsdWVJbXBsO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEFycmF5VW5pb25GaWVsZFZhbHVlSW1wbCBleHRlbmRzIEZpZWxkVmFsdWUge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kTmFtZSwgX2VsZW1lbnRzKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBfZWxlbWVudHM7XHJcbiAgICB9XHJcbiAgICBfdG9GaWVsZFRyYW5zZm9ybShjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VDb250ZXh0ID0gY3JlYXRlU2VudGluZWxDaGlsZENvbnRleHQodGhpcywgY29udGV4dCwgXHJcbiAgICAgICAgLyphcnJheT0qLyB0cnVlKTtcclxuICAgICAgICBjb25zdCBwYXJzZWRFbGVtZW50cyA9IHRoaXMuX2VsZW1lbnRzLm1hcChlbGVtZW50ID0+IHBhcnNlRGF0YShlbGVtZW50LCBwYXJzZUNvbnRleHQpKTtcclxuICAgICAgICBjb25zdCBhcnJheVVuaW9uID0gbmV3IEFycmF5VW5pb25UcmFuc2Zvcm1PcGVyYXRpb24ocGFyc2VkRWxlbWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBhcnJheVVuaW9uKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICAvLyBUT0RPKG1yc2NobWlkdCk6IEltcGxlbWVudCBpc0VxdWFsc1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBBcnJheVJlbW92ZUZpZWxkVmFsdWVJbXBsIGV4dGVuZHMgRmllbGRWYWx1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lLCBfZWxlbWVudHMpIHtcclxuICAgICAgICBzdXBlcihtZXRob2ROYW1lKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50cyA9IF9lbGVtZW50cztcclxuICAgIH1cclxuICAgIF90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwYXJzZUNvbnRleHQgPSBjcmVhdGVTZW50aW5lbENoaWxkQ29udGV4dCh0aGlzLCBjb250ZXh0LCBcclxuICAgICAgICAvKmFycmF5PSovIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHBhcnNlZEVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gcGFyc2VEYXRhKGVsZW1lbnQsIHBhcnNlQ29udGV4dCkpO1xyXG4gICAgICAgIGNvbnN0IGFycmF5VW5pb24gPSBuZXcgQXJyYXlSZW1vdmVUcmFuc2Zvcm1PcGVyYXRpb24ocGFyc2VkRWxlbWVudHMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBhcnJheVVuaW9uKTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICAvLyBUT0RPKG1yc2NobWlkdCk6IEltcGxlbWVudCBpc0VxdWFsc1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBOdW1lcmljSW5jcmVtZW50RmllbGRWYWx1ZUltcGwgZXh0ZW5kcyBGaWVsZFZhbHVlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIF9vcGVyYW5kKSB7XHJcbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSk7XHJcbiAgICAgICAgdGhpcy5fb3BlcmFuZCA9IF9vcGVyYW5kO1xyXG4gICAgfVxyXG4gICAgX3RvRmllbGRUcmFuc2Zvcm0oY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IG51bWVyaWNJbmNyZW1lbnQgPSBuZXcgTnVtZXJpY0luY3JlbWVudFRyYW5zZm9ybU9wZXJhdGlvbihjb250ZXh0LnNlcmlhbGl6ZXIsIHRvTnVtYmVyKGNvbnRleHQuc2VyaWFsaXplciwgdGhpcy5fb3BlcmFuZCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmllbGRUcmFuc2Zvcm0oY29udGV4dC5wYXRoLCBudW1lcmljSW5jcmVtZW50KTtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICAvLyBUT0RPKG1yc2NobWlkdCk6IEltcGxlbWVudCBpc0VxdWFsc1xyXG4gICAgICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcclxuICAgIH1cclxufVxyXG4vKiogUGFyc2UgdXBkYXRlIGRhdGEgZnJvbSBhbiB1cGRhdGUoKSBjYWxsLiAqL1xyXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZURhdGEodXNlckRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHRhcmdldERvYywgaW5wdXQpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KDEgLyogVXBkYXRlICovLCBtZXRob2ROYW1lLCB0YXJnZXREb2MpO1xyXG4gICAgdmFsaWRhdGVQbGFpbk9iamVjdCgnRGF0YSBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IGl0IHdhczonLCBjb250ZXh0LCBpbnB1dCk7XHJcbiAgICBjb25zdCBmaWVsZE1hc2tQYXRocyA9IFtdO1xyXG4gICAgY29uc3QgdXBkYXRlRGF0YSA9IE9iamVjdFZhbHVlLmVtcHR5KCk7XHJcbiAgICBmb3JFYWNoKGlucHV0LCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSBmaWVsZFBhdGhGcm9tRG90U2VwYXJhdGVkU3RyaW5nKG1ldGhvZE5hbWUsIGtleSwgdGFyZ2V0RG9jKTtcclxuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxyXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cclxuICAgICAgICB2YWx1ZSA9IGdldE1vZHVsYXJJbnN0YW5jZSh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZFBhdGgocGF0aCk7XHJcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGVsZXRlRmllbGRWYWx1ZUltcGwpIHtcclxuICAgICAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBmaWVsZCBtYXNrLCBidXQgZG9uJ3QgYWRkIGFueXRoaW5nIHRvIHVwZGF0ZURhdGEuXHJcbiAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWx1ZSwgY2hpbGRDb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhLnNldChwYXRoLCBwYXJzZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IG1hc2sgPSBuZXcgRmllbGRNYXNrKGZpZWxkTWFza1BhdGhzKTtcclxuICAgIHJldHVybiBuZXcgUGFyc2VkVXBkYXRlRGF0YSh1cGRhdGVEYXRhLCBtYXNrLCBjb250ZXh0LmZpZWxkVHJhbnNmb3Jtcyk7XHJcbn1cclxuLyoqIFBhcnNlIHVwZGF0ZSBkYXRhIGZyb20gYSBsaXN0IG9mIGZpZWxkL3ZhbHVlIGFyZ3VtZW50cy4gKi9cclxuZnVuY3Rpb24gcGFyc2VVcGRhdGVWYXJhcmdzKHVzZXJEYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB0YXJnZXREb2MsIGZpZWxkLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcykge1xyXG4gICAgY29uc3QgY29udGV4dCA9IHVzZXJEYXRhUmVhZGVyLmNyZWF0ZUNvbnRleHQoMSAvKiBVcGRhdGUgKi8sIG1ldGhvZE5hbWUsIHRhcmdldERvYyk7XHJcbiAgICBjb25zdCBrZXlzID0gW2ZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKG1ldGhvZE5hbWUsIGZpZWxkLCB0YXJnZXREb2MpXTtcclxuICAgIGNvbnN0IHZhbHVlcyA9IFt2YWx1ZV07XHJcbiAgICBpZiAobW9yZUZpZWxkc0FuZFZhbHVlcy5sZW5ndGggJSAyICE9PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEZ1bmN0aW9uICR7bWV0aG9kTmFtZX0oKSBuZWVkcyB0byBiZSBjYWxsZWQgd2l0aCBhbiBldmVuIG51bWJlciBgICtcclxuICAgICAgICAgICAgJ29mIGFyZ3VtZW50cyB0aGF0IGFsdGVybmF0ZSBiZXR3ZWVuIGZpZWxkIG5hbWVzIGFuZCB2YWx1ZXMuJyk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vcmVGaWVsZHNBbmRWYWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICBrZXlzLnB1c2goZmllbGRQYXRoRnJvbUFyZ3VtZW50JDEobWV0aG9kTmFtZSwgbW9yZUZpZWxkc0FuZFZhbHVlc1tpXSkpO1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKG1vcmVGaWVsZHNBbmRWYWx1ZXNbaSArIDFdKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZpZWxkTWFza1BhdGhzID0gW107XHJcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gT2JqZWN0VmFsdWUuZW1wdHkoKTtcclxuICAgIC8vIFdlIGl0ZXJhdGUgaW4gcmV2ZXJzZSBvcmRlciB0byBwaWNrIHRoZSBsYXN0IHZhbHVlIGZvciBhIGZpZWxkIGlmIHRoZVxyXG4gICAgLy8gdXNlciBzcGVjaWZpZWQgdGhlIGZpZWxkIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgZm9yIChsZXQgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICBpZiAoIWZpZWxkTWFza0NvbnRhaW5zKGZpZWxkTWFza1BhdGhzLCBrZXlzW2ldKSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxyXG4gICAgICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXHJcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0TW9kdWxhckluc3RhbmNlKHZhbHVlKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0ID0gY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZFBhdGgocGF0aCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlbGV0ZUZpZWxkVmFsdWVJbXBsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgdG8gdGhlIGZpZWxkIG1hc2ssIGJ1dCBkb24ndCBhZGQgYW55dGhpbmcgdG8gdXBkYXRlRGF0YS5cclxuICAgICAgICAgICAgICAgIGZpZWxkTWFza1BhdGhzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRGF0YSh2YWx1ZSwgY2hpbGRDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRNYXNrUGF0aHMucHVzaChwYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEYXRhLnNldChwYXRoLCBwYXJzZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXNrID0gbmV3IEZpZWxkTWFzayhmaWVsZE1hc2tQYXRocyk7XHJcbiAgICByZXR1cm4gbmV3IFBhcnNlZFVwZGF0ZURhdGEodXBkYXRlRGF0YSwgbWFzaywgY29udGV4dC5maWVsZFRyYW5zZm9ybXMpO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZSBhIFwicXVlcnkgdmFsdWVcIiAoZS5nLiB2YWx1ZSBpbiBhIHdoZXJlIGZpbHRlciBvciBhIHZhbHVlIGluIGEgY3Vyc29yXHJcbiAqIGJvdW5kKS5cclxuICpcclxuICogQHBhcmFtIGFsbG93QXJyYXlzIC0gV2hldGhlciB0aGUgcXVlcnkgdmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBtYXkgZGlyZWN0bHlcclxuICogY29udGFpbiBhZGRpdGlvbmFsIGFycmF5cyAoZS5nLiB0aGUgb3BlcmFuZCBvZiBhbiBgaW5gIHF1ZXJ5KS5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlUXVlcnlWYWx1ZSh1c2VyRGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgaW5wdXQsIGFsbG93QXJyYXlzID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VyRGF0YVJlYWRlci5jcmVhdGVDb250ZXh0KGFsbG93QXJyYXlzID8gNCAvKiBBcnJheUFyZ3VtZW50ICovIDogMyAvKiBBcmd1bWVudCAqLywgbWV0aG9kTmFtZSk7XHJcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZURhdGEoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgcmV0dXJuIHBhcnNlZDtcclxufVxyXG4vKipcclxuICogUGFyc2VzIHVzZXIgZGF0YSB0byBQcm90b2J1ZiBWYWx1ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnB1dCAtIERhdGEgdG8gYmUgcGFyc2VkLlxyXG4gKiBAcGFyYW0gY29udGV4dCAtIEEgY29udGV4dCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHBhdGggYmVpbmcgcGFyc2VkLFxyXG4gKiB0aGUgc291cmNlIG9mIHRoZSBkYXRhIGJlaW5nIHBhcnNlZCwgZXRjLlxyXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlLCBvciBudWxsIGlmIHRoZSB2YWx1ZSB3YXMgYSBGaWVsZFZhbHVlIHNlbnRpbmVsXHJcbiAqIHRoYXQgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIHBhcnNlZCBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEYXRhKGlucHV0LCBjb250ZXh0KSB7XHJcbiAgICAvLyBVbndyYXAgdGhlIEFQSSB0eXBlIGZyb20gdGhlIENvbXBhdCBTREsuIFRoaXMgd2lsbCByZXR1cm4gdGhlIEFQSSB0eXBlXHJcbiAgICAvLyBmcm9tIGZpcmVzdG9yZS1leHAuXHJcbiAgICBpbnB1dCA9IGdldE1vZHVsYXJJbnN0YW5jZShpbnB1dCk7XHJcbiAgICBpZiAobG9va3NMaWtlSnNvbk9iamVjdChpbnB1dCkpIHtcclxuICAgICAgICB2YWxpZGF0ZVBsYWluT2JqZWN0KCdVbnN1cHBvcnRlZCBmaWVsZCB2YWx1ZTonLCBjb250ZXh0LCBpbnB1dCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KGlucHV0LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRmllbGRWYWx1ZSkge1xyXG4gICAgICAgIC8vIEZpZWxkVmFsdWVzIHVzdWFsbHkgcGFyc2UgaW50byB0cmFuc2Zvcm1zIChleGNlcHQgZGVsZXRlRmllbGQoKSlcclxuICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIGluY2x1ZGUgdGhpcyBmaWVsZCBpbiBvdXIgcGFyc2VkIGRhdGFcclxuICAgICAgICAvLyAoYXMgZG9pbmcgc28gd2lsbCBvdmVyd3JpdGUgdGhlIGZpZWxkIGRpcmVjdGx5IHByaW9yIHRvIHRoZSB0cmFuc2Zvcm1cclxuICAgICAgICAvLyB0cnlpbmcgdG8gdHJhbnNmb3JtIGl0KS4gU28gd2UgZG9uJ3QgYWRkIHRoaXMgbG9jYXRpb24gdG9cclxuICAgICAgICAvLyBjb250ZXh0LmZpZWxkTWFzayBhbmQgd2UgcmV0dXJuIG51bGwgYXMgb3VyIHBhcnNpbmcgcmVzdWx0LlxyXG4gICAgICAgIHBhcnNlU2VudGluZWxGaWVsZFZhbHVlKGlucHV0LCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlucHV0ID09PSB1bmRlZmluZWQgJiYgY29udGV4dC5pZ25vcmVVbmRlZmluZWRQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIHVuZGVmaW5lZCBpdCBjYW4gbmV2ZXIgcGFydGljaXBhdGUgaW4gdGhlIGZpZWxkTWFzaywgc29cclxuICAgICAgICAvLyBkb24ndCBoYW5kbGUgdGhpcyBiZWxvdy4gSWYgYGlnbm9yZVVuZGVmaW5lZFByb3BlcnRpZXNgIGlzIGZhbHNlLFxyXG4gICAgICAgIC8vIGBwYXJzZVNjYWxhclZhbHVlYCB3aWxsIHJlamVjdCBhbiB1bmRlZmluZWQgdmFsdWUuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBJZiBjb250ZXh0LnBhdGggaXMgbnVsbCB3ZSBhcmUgaW5zaWRlIGFuIGFycmF5IGFuZCB3ZSBkb24ndCBzdXBwb3J0XHJcbiAgICAgICAgLy8gZmllbGQgbWFzayBwYXRocyBtb3JlIGdyYW51bGFyIHRoYW4gdGhlIHRvcC1sZXZlbCBhcnJheS5cclxuICAgICAgICBpZiAoY29udGV4dC5wYXRoKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyhiLzM0ODcxMTMxKTogSW5jbHVkZSB0aGUgcGF0aCBjb250YWluaW5nIHRoZSBhcnJheSBpbiB0aGUgZXJyb3JcclxuICAgICAgICAgICAgLy8gbWVzc2FnZS5cclxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgSU4gcXVlcmllcywgdGhlIHBhcnNlZCBkYXRhIGlzIGFuIGFycmF5IChyZXByZXNlbnRpbmdcclxuICAgICAgICAgICAgLy8gdGhlIHNldCBvZiB2YWx1ZXMgdG8gYmUgaW5jbHVkZWQgZm9yIHRoZSBJTiBxdWVyeSkgdGhhdCBtYXkgZGlyZWN0bHlcclxuICAgICAgICAgICAgLy8gY29udGFpbiBhZGRpdGlvbmFsIGFycmF5cyAoZWFjaCByZXByZXNlbnRpbmcgYW4gaW5kaXZpZHVhbCBmaWVsZFxyXG4gICAgICAgICAgICAvLyB2YWx1ZSksIHNvIHdlIGRpc2FibGUgdGhpcyB2YWxpZGF0aW9uLlxyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5zZXR0aW5ncy5hcnJheUVsZW1lbnQgJiZcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZGF0YVNvdXJjZSAhPT0gNCAvKiBBcnJheUFyZ3VtZW50ICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKCdOZXN0ZWQgYXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXkoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2NhbGFyVmFsdWUoaW5wdXQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmosIGNvbnRleHQpIHtcclxuICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xyXG4gICAgaWYgKGlzRW1wdHkob2JqKSkge1xyXG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlbXB0eSBvYmplY3QsIHdlIGV4cGxpY2l0bHkgYWRkIGl0IHRvIHRoZSB1cGRhdGVcclxuICAgICAgICAvLyBtYXNrIHRvIGVuc3VyZSB0aGF0IHRoZSBzZXJ2ZXIgY3JlYXRlcyBhIG1hcCBlbnRyeS5cclxuICAgICAgICBpZiAoY29udGV4dC5wYXRoICYmIGNvbnRleHQucGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmllbGRNYXNrLnB1c2goY29udGV4dC5wYXRoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3JFYWNoKG9iaiwgKGtleSwgdmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VEYXRhKHZhbCwgY29udGV4dC5jaGlsZENvbnRleHRGb3JGaWVsZChrZXkpKTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gcGFyc2VkVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG1hcFZhbHVlOiB7IGZpZWxkcyB9IH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VBcnJheShhcnJheSwgY29udGV4dCkge1xyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBsZXQgZW50cnlJbmRleCA9IDA7XHJcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGFycmF5KSB7XHJcbiAgICAgICAgbGV0IHBhcnNlZEVudHJ5ID0gcGFyc2VEYXRhKGVudHJ5LCBjb250ZXh0LmNoaWxkQ29udGV4dEZvckFycmF5KGVudHJ5SW5kZXgpKTtcclxuICAgICAgICBpZiAocGFyc2VkRW50cnkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBKdXN0IGluY2x1ZGUgbnVsbHMgaW4gdGhlIGFycmF5IGZvciBmaWVsZHMgYmVpbmcgcmVwbGFjZWQgd2l0aCBhXHJcbiAgICAgICAgICAgIC8vIHNlbnRpbmVsLlxyXG4gICAgICAgICAgICBwYXJzZWRFbnRyeSA9IHsgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRScgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkRW50cnkpO1xyXG4gICAgICAgIGVudHJ5SW5kZXgrKztcclxuICAgIH1cclxuICAgIHJldHVybiB7IGFycmF5VmFsdWU6IHsgdmFsdWVzIH0gfTtcclxufVxyXG4vKipcclxuICogXCJQYXJzZXNcIiB0aGUgcHJvdmlkZWQgRmllbGRWYWx1ZUltcGwsIGFkZGluZyBhbnkgbmVjZXNzYXJ5IHRyYW5zZm9ybXMgdG9cclxuICogY29udGV4dC5maWVsZFRyYW5zZm9ybXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZVNlbnRpbmVsRmllbGRWYWx1ZSh2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgLy8gU2VudGluZWxzIGFyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIHdyaXRlcywgYW5kIG5vdCB3aXRoaW4gYXJyYXlzLlxyXG4gICAgaWYgKCFpc1dyaXRlKGNvbnRleHQuZGF0YVNvdXJjZSkpIHtcclxuICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGAke3ZhbHVlLl9tZXRob2ROYW1lfSgpIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCB1cGRhdGUoKSBhbmQgc2V0KClgKTtcclxuICAgIH1cclxuICAgIGlmICghY29udGV4dC5wYXRoKSB7XHJcbiAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihgJHt2YWx1ZS5fbWV0aG9kTmFtZX0oKSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBpbnNpZGUgYXJyYXlzYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWVsZFRyYW5zZm9ybSA9IHZhbHVlLl90b0ZpZWxkVHJhbnNmb3JtKGNvbnRleHQpO1xyXG4gICAgaWYgKGZpZWxkVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgY29udGV4dC5maWVsZFRyYW5zZm9ybXMucHVzaChmaWVsZFRyYW5zZm9ybSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0byBwYXJzZSBhIHNjYWxhciB2YWx1ZSAoaS5lLiBub3QgYW4gT2JqZWN0LCBBcnJheSwgb3IgRmllbGRWYWx1ZSlcclxuICpcclxuICogQHJldHVybnMgVGhlIHBhcnNlZCB2YWx1ZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VTY2FsYXJWYWx1ZSh2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgdmFsdWUgPSBnZXRNb2R1bGFySW5zdGFuY2UodmFsdWUpO1xyXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgbnVsbFZhbHVlOiAnTlVMTF9WQUxVRScgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gdG9OdW1iZXIoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIHJldHVybiB7IGJvb2xlYW5WYWx1ZTogdmFsdWUgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4geyBzdHJpbmdWYWx1ZTogdmFsdWUgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IFRpbWVzdGFtcC5mcm9tRGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGltZXN0YW1wVmFsdWU6IHRvVGltZXN0YW1wKGNvbnRleHQuc2VyaWFsaXplciwgdGltZXN0YW1wKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRpbWVzdGFtcCkge1xyXG4gICAgICAgIC8vIEZpcmVzdG9yZSBiYWNrZW5kIHRydW5jYXRlcyBwcmVjaXNpb24gZG93biB0byBtaWNyb3NlY29uZHMuIFRvIGVuc3VyZVxyXG4gICAgICAgIC8vIG9mZmxpbmUgbW9kZSB3b3JrcyB0aGUgc2FtZSB3aXRoIHJlZ2FyZHMgdG8gdHJ1bmNhdGlvbiwgcGVyZm9ybSB0aGVcclxuICAgICAgICAvLyB0cnVuY2F0aW9uIGltbWVkaWF0ZWx5IHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIGJhY2tlbmQgdG8gZG8gdGhhdC5cclxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgVGltZXN0YW1wKHZhbHVlLnNlY29uZHMsIE1hdGguZmxvb3IodmFsdWUubmFub3NlY29uZHMgLyAxMDAwKSAqIDEwMDApO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcFZhbHVlOiB0b1RpbWVzdGFtcChjb250ZXh0LnNlcmlhbGl6ZXIsIHRpbWVzdGFtcClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBHZW9Qb2ludCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdlb1BvaW50VmFsdWU6IHtcclxuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiB2YWx1ZS5sYXRpdHVkZSxcclxuICAgICAgICAgICAgICAgIGxvbmdpdHVkZTogdmFsdWUubG9uZ2l0dWRlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBCeXRlcykge1xyXG4gICAgICAgIHJldHVybiB7IGJ5dGVzVmFsdWU6IHRvQnl0ZXMoY29udGV4dC5zZXJpYWxpemVyLCB2YWx1ZS5fYnl0ZVN0cmluZykgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcclxuICAgICAgICBjb25zdCB0aGlzRGIgPSBjb250ZXh0LmRhdGFiYXNlSWQ7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJEYiA9IHZhbHVlLmZpcmVzdG9yZS5fZGF0YWJhc2VJZDtcclxuICAgICAgICBpZiAoIW90aGVyRGIuaXNFcXVhbCh0aGlzRGIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IoJ0RvY3VtZW50IHJlZmVyZW5jZSBpcyBmb3IgZGF0YWJhc2UgJyArXHJcbiAgICAgICAgICAgICAgICBgJHtvdGhlckRiLnByb2plY3RJZH0vJHtvdGhlckRiLmRhdGFiYXNlfSBidXQgc2hvdWxkIGJlIGAgK1xyXG4gICAgICAgICAgICAgICAgYGZvciBkYXRhYmFzZSAke3RoaXNEYi5wcm9qZWN0SWR9LyR7dGhpc0RiLmRhdGFiYXNlfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZWZlcmVuY2VWYWx1ZTogdG9SZXNvdXJjZU5hbWUodmFsdWUuZmlyZXN0b3JlLl9kYXRhYmFzZUlkIHx8IGNvbnRleHQuZGF0YWJhc2VJZCwgdmFsdWUuX2tleS5wYXRoKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBjb250ZXh0LmNyZWF0ZUVycm9yKGBVbnN1cHBvcnRlZCBmaWVsZCB2YWx1ZTogJHt2YWx1ZURlc2NyaXB0aW9uKHZhbHVlKX1gKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGxvb2tzIGxpa2UgYSBKU09OIG9iamVjdCB0aGF0IHNob3VsZCBiZSBjb252ZXJ0ZWRcclxuICogaW50byBhIHN0cnVjdC4gTm9ybWFsIGNsYXNzL3Byb3RvdHlwZSBpbnN0YW5jZXMgYXJlIGNvbnNpZGVyZWQgdG8gbG9vayBsaWtlXHJcbiAqIEpTT04gb2JqZWN0cyBzaW5jZSB0aGV5IHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJ1Y3QgdmFsdWUuIEFycmF5cywgRGF0ZXMsXHJcbiAqIEdlb1BvaW50cywgZXRjLiBhcmUgbm90IGNvbnNpZGVyZWQgdG8gbG9vayBsaWtlIEpTT04gb2JqZWN0cyBzaW5jZSB0aGV5IG1hcFxyXG4gKiB0byBzcGVjaWZpYyBGaWVsZFZhbHVlIHR5cGVzIG90aGVyIHRoYW4gT2JqZWN0VmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb29rc0xpa2VKc29uT2JqZWN0KGlucHV0KSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICBpbnB1dCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkgJiZcclxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkgJiZcclxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgVGltZXN0YW1wKSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBHZW9Qb2ludCkgJiZcclxuICAgICAgICAhKGlucHV0IGluc3RhbmNlb2YgQnl0ZXMpICYmXHJcbiAgICAgICAgIShpbnB1dCBpbnN0YW5jZW9mIERvY3VtZW50UmVmZXJlbmNlKSAmJlxyXG4gICAgICAgICEoaW5wdXQgaW5zdGFuY2VvZiBGaWVsZFZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVQbGFpbk9iamVjdChtZXNzYWdlLCBjb250ZXh0LCBpbnB1dCkge1xyXG4gICAgaWYgKCFsb29rc0xpa2VKc29uT2JqZWN0KGlucHV0KSB8fCAhaXNQbGFpbk9iamVjdChpbnB1dCkpIHtcclxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHZhbHVlRGVzY3JpcHRpb24oaW5wdXQpO1xyXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJ2FuIG9iamVjdCcpIHtcclxuICAgICAgICAgICAgLy8gTWFzc2FnZSB0aGUgZXJyb3IgaWYgaXQgd2FzIGFuIG9iamVjdC5cclxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5jcmVhdGVFcnJvcihtZXNzYWdlICsgJyBhIGN1c3RvbSBvYmplY3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuY3JlYXRlRXJyb3IobWVzc2FnZSArICcgJyArIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciB0aGF0IGNhbGxzIGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoKSBidXQgd3JhcHMgYW55IGVycm9yIHRocm93bi5cclxuICovXHJcbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Bcmd1bWVudCQxKG1ldGhvZE5hbWUsIHBhdGgsIHRhcmdldERvYykge1xyXG4gICAgLy8gSWYgcmVxdWlyZWQsIHJlcGxhY2UgdGhlIEZpZWxkUGF0aCBDb21wYXQgY2xhc3Mgd2l0aCB3aXRoIHRoZSBmaXJlc3RvcmUtZXhwXHJcbiAgICAvLyBGaWVsZFBhdGguXHJcbiAgICBwYXRoID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhdGgpO1xyXG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5faW50ZXJuYWxQYXRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ZpZWxkIHBhdGggYXJndW1lbnRzIG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgJztcclxuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihtZXNzYWdlLCBtZXRob2ROYW1lLCBcclxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hdGNoZXMgYW55IGNoYXJhY3RlcnMgaW4gYSBmaWVsZCBwYXRoIHN0cmluZyB0aGF0IGFyZSByZXNlcnZlZC5cclxuICovXHJcbmNvbnN0IEZJRUxEX1BBVEhfUkVTRVJWRUQgPSBuZXcgUmVnRXhwKCdbflxcXFwqL1xcXFxbXFxcXF1dJyk7XHJcbi8qKlxyXG4gKiBXcmFwcyBmcm9tRG90U2VwYXJhdGVkU3RyaW5nIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCB0aGUgbWV0aG9kIHRoYXRcclxuICogd2FzIHRocm93bi5cclxuICogQHBhcmFtIG1ldGhvZE5hbWUgLSBUaGUgcHVibGljbHkgdmlzaWJsZSBtZXRob2QgbmFtZVxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBkb3Qtc2VwYXJhdGVkIHN0cmluZyBmb3JtIG9mIGEgZmllbGQgcGF0aCB3aGljaCB3aWxsIGJlXHJcbiAqIHNwbGl0IG9uIGRvdHMuXHJcbiAqIEBwYXJhbSB0YXJnZXREb2MgLSBUaGUgZG9jdW1lbnQgYWdhaW5zdCB3aGljaCB0aGUgZmllbGQgcGF0aCB3aWxsIGJlXHJcbiAqIGV2YWx1YXRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcobWV0aG9kTmFtZSwgcGF0aCwgdGFyZ2V0RG9jKSB7XHJcbiAgICBjb25zdCBmb3VuZCA9IHBhdGguc2VhcmNoKEZJRUxEX1BBVEhfUkVTRVJWRUQpO1xyXG4gICAgaWYgKGZvdW5kID49IDApIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihgSW52YWxpZCBmaWVsZCBwYXRoICgke3BhdGh9KS4gUGF0aHMgbXVzdCBub3QgY29udGFpbiBgICtcclxuICAgICAgICAgICAgYCd+JywgJyonLCAnLycsICdbJywgb3IgJ10nYCwgbWV0aG9kTmFtZSwgXHJcbiAgICAgICAgLyogaGFzQ29udmVydGVyPSAqLyBmYWxzZSwgXHJcbiAgICAgICAgLyogcGF0aD0gKi8gdW5kZWZpbmVkLCB0YXJnZXREb2MpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gbmV3IEZpZWxkUGF0aCguLi5wYXRoLnNwbGl0KCcuJykpLl9pbnRlcm5hbFBhdGg7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKGBJbnZhbGlkIGZpZWxkIHBhdGggKCR7cGF0aH0pLiBQYXRocyBtdXN0IG5vdCBiZSBlbXB0eSwgYCArXHJcbiAgICAgICAgICAgIGBiZWdpbiB3aXRoICcuJywgZW5kIHdpdGggJy4nLCBvciBjb250YWluICcuLidgLCBtZXRob2ROYW1lLCBcclxuICAgICAgICAvKiBoYXNDb252ZXJ0ZXI9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBwYXRoPSAqLyB1bmRlZmluZWQsIHRhcmdldERvYyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRXJyb3IocmVhc29uLCBtZXRob2ROYW1lLCBoYXNDb252ZXJ0ZXIsIHBhdGgsIHRhcmdldERvYykge1xyXG4gICAgY29uc3QgaGFzUGF0aCA9IHBhdGggJiYgIXBhdGguaXNFbXB0eSgpO1xyXG4gICAgY29uc3QgaGFzRG9jdW1lbnQgPSB0YXJnZXREb2MgIT09IHVuZGVmaW5lZDtcclxuICAgIGxldCBtZXNzYWdlID0gYEZ1bmN0aW9uICR7bWV0aG9kTmFtZX0oKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGRhdGFgO1xyXG4gICAgaWYgKGhhc0NvbnZlcnRlcikge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gJyAodmlhIGB0b0ZpcmVzdG9yZSgpYCknO1xyXG4gICAgfVxyXG4gICAgbWVzc2FnZSArPSAnLiAnO1xyXG4gICAgbGV0IGRlc2NyaXB0aW9uID0gJyc7XHJcbiAgICBpZiAoaGFzUGF0aCB8fCBoYXNEb2N1bWVudCkge1xyXG4gICAgICAgIGRlc2NyaXB0aW9uICs9ICcgKGZvdW5kJztcclxuICAgICAgICBpZiAoaGFzUGF0aCkge1xyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiArPSBgIGluIGZpZWxkICR7cGF0aH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzRG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYCBpbiBkb2N1bWVudCAke3RhcmdldERvY31gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXNjcmlwdGlvbiArPSAnKSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgbWVzc2FnZSArIHJlYXNvbiArIGRlc2NyaXB0aW9uKTtcclxufVxyXG4vKiogQ2hlY2tzIGBoYXlzdGFja2AgaWYgRmllbGRQYXRoIGBuZWVkbGVgIGlzIHByZXNlbnQuIFJ1bnMgaW4gTyhuKS4gKi9cclxuZnVuY3Rpb24gZmllbGRNYXNrQ29udGFpbnMoaGF5c3RhY2ssIG5lZWRsZSkge1xyXG4gICAgcmV0dXJuIGhheXN0YWNrLnNvbWUodiA9PiB2LmlzRXF1YWwobmVlZGxlKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgYERvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91ciBGaXJlc3RvcmVcclxuICogZGF0YWJhc2UuIFRoZSBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvXHJcbiAqIGdldCBhIHNwZWNpZmljIGZpZWxkLlxyXG4gKlxyXG4gKiBGb3IgYSBgRG9jdW1lbnRTbmFwc2hvdGAgdGhhdCBwb2ludHMgdG8gYSBub24tZXhpc3RpbmcgZG9jdW1lbnQsIGFueSBkYXRhXHJcbiAqIGFjY2VzcyB3aWxsIHJldHVybiAndW5kZWZpbmVkJy4gWW91IGNhbiB1c2UgdGhlIGBleGlzdHMoKWAgbWV0aG9kIHRvXHJcbiAqIGV4cGxpY2l0bHkgdmVyaWZ5IGEgZG9jdW1lbnQncyBleGlzdGVuY2UuXHJcbiAqL1xyXG5jbGFzcyBEb2N1bWVudFNuYXBzaG90JDEge1xyXG4gICAgLy8gTm90ZTogVGhpcyBjbGFzcyBpcyBzdHJpcHBlZCBkb3duIHZlcnNpb24gb2YgdGhlIERvY3VtZW50U25hcHNob3QgaW5cclxuICAgIC8vIHRoZSBsZWdhY3kgU0RLLiBUaGUgY2hhbmdlcyBhcmU6XHJcbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90TWV0YWRhdGEuXHJcbiAgICAvLyAtIE5vIHN1cHBvcnQgZm9yIFNuYXBzaG90T3B0aW9ucy5cclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yIHByb3RlY3RlZCAqL1xyXG4gICAgY29uc3RydWN0b3IoX2ZpcmVzdG9yZSwgX3VzZXJEYXRhV3JpdGVyLCBfa2V5LCBfZG9jdW1lbnQsIF9jb252ZXJ0ZXIpIHtcclxuICAgICAgICB0aGlzLl9maXJlc3RvcmUgPSBfZmlyZXN0b3JlO1xyXG4gICAgICAgIHRoaXMuX3VzZXJEYXRhV3JpdGVyID0gX3VzZXJEYXRhV3JpdGVyO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XHJcbiAgICAgICAgdGhpcy5fY29udmVydGVyID0gX2NvbnZlcnRlcjtcclxuICAgIH1cclxuICAgIC8qKiBQcm9wZXJ0eSBvZiB0aGUgYERvY3VtZW50U25hcHNob3RgIHRoYXQgcHJvdmlkZXMgdGhlIGRvY3VtZW50J3MgSUQuICovXHJcbiAgICBnZXQgaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleS5wYXRoLmxhc3RTZWdtZW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBgRG9jdW1lbnRSZWZlcmVuY2VgIGZvciB0aGUgZG9jdW1lbnQgaW5jbHVkZWQgaW4gdGhlIGBEb2N1bWVudFNuYXBzaG90YC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJlZigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UmVmZXJlbmNlKHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fY29udmVydGVyLCB0aGlzLl9rZXkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduYWxzIHdoZXRoZXIgb3Igbm90IHRoZSBkb2N1bWVudCBhdCB0aGUgc25hcHNob3QncyBsb2NhdGlvbiBleGlzdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZG9jdW1lbnQgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBleGlzdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50ICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWZcclxuICAgICAqIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgb3IgYHVuZGVmaW5lZGBcclxuICAgICAqIGlmIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICovXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB1c2UgdGhlIGNvbnZlcnRlciBhbmQgY3JlYXRlIGEgbmV3IERvY3VtZW50U25hcHNob3RcclxuICAgICAgICAgICAgLy8gaWYgYSBjb252ZXJ0ZXIgaGFzIGJlZW4gcHJvdmlkZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90ID0gbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCQxKHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fdXNlckRhdGFXcml0ZXIsIHRoaXMuX2tleSwgdGhpcy5fZG9jdW1lbnQsIFxyXG4gICAgICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydGVyLmZyb21GaXJlc3RvcmUoc25hcHNob3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh0aGlzLl9kb2N1bWVudC5kYXRhLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgZmllbGQgc3BlY2lmaWVkIGJ5IGBmaWVsZFBhdGhgLiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZVxyXG4gICAgICogZG9jdW1lbnQgb3IgZmllbGQgZG9lc24ndCBleGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggKGZvciBleGFtcGxlICdmb28nIG9yICdmb28uYmFyJykgdG8gYSBzcGVjaWZpY1xyXG4gICAgICogZmllbGQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGF0YSBhdCB0aGUgc3BlY2lmaWVkIGZpZWxkIGxvY2F0aW9uIG9yIHVuZGVmaW5lZCBpZiBubyBzdWNoXHJcbiAgICAgKiBmaWVsZCBleGlzdHMgaW4gdGhlIGRvY3VtZW50LlxyXG4gICAgICovXHJcbiAgICAvLyBXZSBhcmUgdXNpbmcgYGFueWAgaGVyZSB0byBhdm9pZCBhbiBleHBsaWNpdCBjYXN0IGJ5IG91ciB1c2Vycy5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBnZXQoZmllbGRQYXRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ0RvY3VtZW50U25hcHNob3QuZ2V0JywgZmllbGRQYXRoKSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgUXVlcnlEb2N1bWVudFNuYXBzaG90YCBjb250YWlucyBkYXRhIHJlYWQgZnJvbSBhIGRvY3VtZW50IGluIHlvdXJcclxuICogRmlyZXN0b3JlIGRhdGFiYXNlIGFzIHBhcnQgb2YgYSBxdWVyeS4gVGhlIGRvY3VtZW50IGlzIGd1YXJhbnRlZWQgdG8gZXhpc3RcclxuICogYW5kIGl0cyBkYXRhIGNhbiBiZSBleHRyYWN0ZWQgd2l0aCBgLmRhdGEoKWAgb3IgYC5nZXQoPGZpZWxkPilgIHRvIGdldCBhXHJcbiAqIHNwZWNpZmljIGZpZWxkLlxyXG4gKlxyXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIG9mZmVycyB0aGUgc2FtZSBBUEkgc3VyZmFjZSBhcyBhXHJcbiAqIGBEb2N1bWVudFNuYXBzaG90YC4gU2luY2UgcXVlcnkgcmVzdWx0cyBjb250YWluIG9ubHkgZXhpc3RpbmcgZG9jdW1lbnRzLCB0aGVcclxuICogYGV4aXN0c2AgcHJvcGVydHkgd2lsbCBhbHdheXMgYmUgdHJ1ZSBhbmQgYGRhdGEoKWAgd2lsbCBuZXZlciByZXR1cm5cclxuICogJ3VuZGVmaW5lZCcuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeURvY3VtZW50U25hcHNob3QkMSBleHRlbmRzIERvY3VtZW50U25hcHNob3QkMSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBhcyBhbiBgT2JqZWN0YC5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRhdGEoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIHRoYXQgY2FsbHMgYGZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoKWAgYnV0IHdyYXBzIGFueSBlcnJvciB0aHJvd24uXHJcbiAqL1xyXG5mdW5jdGlvbiBmaWVsZFBhdGhGcm9tQXJndW1lbnQobWV0aG9kTmFtZSwgYXJnKSB7XHJcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gZmllbGRQYXRoRnJvbURvdFNlcGFyYXRlZFN0cmluZyhtZXRob2ROYW1lLCBhcmcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRmllbGRQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyZy5faW50ZXJuYWxQYXRoO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGFyZy5fZGVsZWdhdGUuX2ludGVybmFsUGF0aDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTWV0YWRhdGEgYWJvdXQgYSBzbmFwc2hvdCwgZGVzY3JpYmluZyB0aGUgc3RhdGUgb2YgdGhlIHNuYXBzaG90LlxyXG4gKi9cclxuY2xhc3MgU25hcHNob3RNZXRhZGF0YSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoaGFzUGVuZGluZ1dyaXRlcywgZnJvbUNhY2hlKSB7XHJcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nV3JpdGVzID0gaGFzUGVuZGluZ1dyaXRlcztcclxuICAgICAgICB0aGlzLmZyb21DYWNoZSA9IGZyb21DYWNoZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgYFNuYXBzaG90TWV0YWRhdGFgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG90aGVyIC0gVGhlIGBTbmFwc2hvdE1ldGFkYXRhYCB0byBjb21wYXJlIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgYFNuYXBzaG90TWV0YWRhdGFgIGlzIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBvbmUuXHJcbiAgICAgKi9cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaGFzUGVuZGluZ1dyaXRlcyA9PT0gb3RoZXIuaGFzUGVuZGluZ1dyaXRlcyAmJlxyXG4gICAgICAgICAgICB0aGlzLmZyb21DYWNoZSA9PT0gb3RoZXIuZnJvbUNhY2hlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBgRG9jdW1lbnRTbmFwc2hvdGAgY29udGFpbnMgZGF0YSByZWFkIGZyb20gYSBkb2N1bWVudCBpbiB5b3VyIEZpcmVzdG9yZVxyXG4gKiBkYXRhYmFzZS4gVGhlIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG9cclxuICogZ2V0IGEgc3BlY2lmaWMgZmllbGQuXHJcbiAqXHJcbiAqIEZvciBhIGBEb2N1bWVudFNuYXBzaG90YCB0aGF0IHBvaW50cyB0byBhIG5vbi1leGlzdGluZyBkb2N1bWVudCwgYW55IGRhdGFcclxuICogYWNjZXNzIHdpbGwgcmV0dXJuICd1bmRlZmluZWQnLiBZb3UgY2FuIHVzZSB0aGUgYGV4aXN0cygpYCBtZXRob2QgdG9cclxuICogZXhwbGljaXRseSB2ZXJpZnkgYSBkb2N1bWVudCdzIGV4aXN0ZW5jZS5cclxuICovXHJcbmNsYXNzIERvY3VtZW50U25hcHNob3QgZXh0ZW5kcyBEb2N1bWVudFNuYXBzaG90JDEge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgcHJvdGVjdGVkICovXHJcbiAgICBjb25zdHJ1Y3RvcihfZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwga2V5LCBkb2N1bWVudCwgbWV0YWRhdGEsIGNvbnZlcnRlcikge1xyXG4gICAgICAgIHN1cGVyKF9maXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBrZXksIGRvY3VtZW50LCBjb252ZXJ0ZXIpO1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlSW1wbCA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkYXRhIGV4aXN0cy4gVHJ1ZSBpZiB0aGUgZG9jdW1lbnQgZXhpc3RzLlxyXG4gICAgICovXHJcbiAgICBleGlzdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmV4aXN0cygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWZcclxuICAgICAqIHRoZSBkb2N1bWVudCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIGBzZXJ2ZXJUaW1lc3RhbXAoKWAgdmFsdWVzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cclxuICAgICAqIHNldCB0byB0aGVpciBmaW5hbCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGFzIGBudWxsYC4gWW91IGNhbiBvdmVycmlkZVxyXG4gICAgICogdGhpcyBieSBwYXNzaW5nIGFuIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9ucyBvYmplY3QgdG8gY29uZmlndXJlIGhvdyBkYXRhIGlzIHJldHJpZXZlZCBmcm9tXHJcbiAgICAgKiB0aGUgc25hcHNob3QgKGZvciBleGFtcGxlIHRoZSBkZXNpcmVkIGJlaGF2aW9yIGZvciBzZXJ2ZXIgdGltZXN0YW1wcyB0aGF0XHJcbiAgICAgKiBoYXZlIG5vdCB5ZXQgYmVlbiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUpLlxyXG4gICAgICogQHJldHVybnMgQW4gYE9iamVjdGAgY29udGFpbmluZyBhbGwgZmllbGRzIGluIHRoZSBkb2N1bWVudCBvciBgdW5kZWZpbmVkYCBpZlxyXG4gICAgICogdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIGRhdGEob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jb252ZXJ0ZXIpIHtcclxuICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHVzZSB0aGUgY29udmVydGVyIGFuZCBjcmVhdGUgYSBuZXcgRG9jdW1lbnRTbmFwc2hvdFxyXG4gICAgICAgICAgICAvLyBpZiBhIGNvbnZlcnRlciBoYXMgYmVlbiBwcm92aWRlZC5cclxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdGhpcy5fdXNlckRhdGFXcml0ZXIsIHRoaXMuX2tleSwgdGhpcy5fZG9jdW1lbnQsIHRoaXMubWV0YWRhdGEsIFxyXG4gICAgICAgICAgICAvKiBjb252ZXJ0ZXI9ICovIG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydGVyLmZyb21GaXJlc3RvcmUoc25hcHNob3QsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh0aGlzLl9kb2N1bWVudC5kYXRhLnZhbHVlLCBvcHRpb25zLnNlcnZlclRpbWVzdGFtcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWVsZCBzcGVjaWZpZWQgYnkgYGZpZWxkUGF0aGAuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlXHJcbiAgICAgKiBkb2N1bWVudCBvciBmaWVsZCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIGEgYHNlcnZlclRpbWVzdGFtcCgpYCB0aGF0IGhhcyBub3QgeWV0IGJlZW4gc2V0IHRvXHJcbiAgICAgKiBpdHMgZmluYWwgdmFsdWUgd2lsbCBiZSByZXR1cm5lZCBhcyBgbnVsbGAuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBieVxyXG4gICAgICogcGFzc2luZyBhbiBvcHRpb25zIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmllbGRQYXRoIC0gVGhlIHBhdGggKGZvciBleGFtcGxlICdmb28nIG9yICdmb28uYmFyJykgdG8gYSBzcGVjaWZpY1xyXG4gICAgICogZmllbGQuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBob3cgdGhlIGZpZWxkIGlzIHJldHJpZXZlZFxyXG4gICAgICogZnJvbSB0aGUgc25hcHNob3QgKGZvciBleGFtcGxlIHRoZSBkZXNpcmVkIGJlaGF2aW9yIGZvciBzZXJ2ZXIgdGltZXN0YW1wc1xyXG4gICAgICogdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiBzZXQgdG8gdGhlaXIgZmluYWwgdmFsdWUpLlxyXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgYXQgdGhlIHNwZWNpZmllZCBmaWVsZCBsb2NhdGlvbiBvciB1bmRlZmluZWQgaWYgbm8gc3VjaFxyXG4gICAgICogZmllbGQgZXhpc3RzIGluIHRoZSBkb2N1bWVudC5cclxuICAgICAqL1xyXG4gICAgLy8gV2UgYXJlIHVzaW5nIGBhbnlgIGhlcmUgdG8gYXZvaWQgYW4gZXhwbGljaXQgY2FzdCBieSBvdXIgdXNlcnMuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgZ2V0KGZpZWxkUGF0aCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZG9jdW1lbnQuZGF0YS5maWVsZChmaWVsZFBhdGhGcm9tQXJndW1lbnQoJ0RvY3VtZW50U25hcHNob3QuZ2V0JywgZmllbGRQYXRoKSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhV3JpdGVyLmNvbnZlcnRWYWx1ZSh2YWx1ZSwgb3B0aW9ucy5zZXJ2ZXJUaW1lc3RhbXBzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeURvY3VtZW50U25hcHNob3RgIGNvbnRhaW5zIGRhdGEgcmVhZCBmcm9tIGEgZG9jdW1lbnQgaW4geW91clxyXG4gKiBGaXJlc3RvcmUgZGF0YWJhc2UgYXMgcGFydCBvZiBhIHF1ZXJ5LiBUaGUgZG9jdW1lbnQgaXMgZ3VhcmFudGVlZCB0byBleGlzdFxyXG4gKiBhbmQgaXRzIGRhdGEgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGAuZGF0YSgpYCBvciBgLmdldCg8ZmllbGQ+KWAgdG8gZ2V0IGFcclxuICogc3BlY2lmaWMgZmllbGQuXHJcbiAqXHJcbiAqIEEgYFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdGAgb2ZmZXJzIHRoZSBzYW1lIEFQSSBzdXJmYWNlIGFzIGFcclxuICogYERvY3VtZW50U25hcHNob3RgLiBTaW5jZSBxdWVyeSByZXN1bHRzIGNvbnRhaW4gb25seSBleGlzdGluZyBkb2N1bWVudHMsIHRoZVxyXG4gKiBgZXhpc3RzYCBwcm9wZXJ0eSB3aWxsIGFsd2F5cyBiZSB0cnVlIGFuZCBgZGF0YSgpYCB3aWxsIG5ldmVyIHJldHVyblxyXG4gKiAndW5kZWZpbmVkJy5cclxuICovXHJcbmNsYXNzIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCBleHRlbmRzIERvY3VtZW50U25hcHNob3Qge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQgYXMgYW4gYE9iamVjdGAuXHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCwgYHNlcnZlclRpbWVzdGFtcCgpYCB2YWx1ZXMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxyXG4gICAgICogc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQgYXMgYG51bGxgLiBZb3UgY2FuIG92ZXJyaWRlXHJcbiAgICAgKiB0aGlzIGJ5IHBhc3NpbmcgYW4gb3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSBob3cgZGF0YSBpcyByZXRyaWV2ZWQgZnJvbVxyXG4gICAgICogdGhlIHNuYXBzaG90IChmb3IgZXhhbXBsZSB0aGUgZGVzaXJlZCBiZWhhdmlvciBmb3Igc2VydmVyIHRpbWVzdGFtcHMgdGhhdFxyXG4gICAgICogaGF2ZSBub3QgeWV0IGJlZW4gc2V0IHRvIHRoZWlyIGZpbmFsIHZhbHVlKS5cclxuICAgICAqIEByZXR1cm5zIEFuIGBPYmplY3RgIGNvbnRhaW5pbmcgYWxsIGZpZWxkcyBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGRhdGEob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRhdGEob3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5U25hcHNob3RgIGNvbnRhaW5zIHplcm8gb3IgbW9yZSBgRG9jdW1lbnRTbmFwc2hvdGAgb2JqZWN0c1xyXG4gKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdHMgb2YgYSBxdWVyeS4gVGhlIGRvY3VtZW50cyBjYW4gYmUgYWNjZXNzZWQgYXMgYW5cclxuICogYXJyYXkgdmlhIHRoZSBgZG9jc2AgcHJvcGVydHkgb3IgZW51bWVyYXRlZCB1c2luZyB0aGUgYGZvckVhY2hgIG1ldGhvZC4gVGhlXHJcbiAqIG51bWJlciBvZiBkb2N1bWVudHMgY2FuIGJlIGRldGVybWluZWQgdmlhIHRoZSBgZW1wdHlgIGFuZCBgc2l6ZWBcclxuICogcHJvcGVydGllcy5cclxuICovXHJcbmNsYXNzIFF1ZXJ5U25hcHNob3Qge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF91c2VyRGF0YVdyaXRlciwgcXVlcnksIF9zbmFwc2hvdCkge1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5fdXNlckRhdGFXcml0ZXIgPSBfdXNlckRhdGFXcml0ZXI7XHJcbiAgICAgICAgdGhpcy5fc25hcHNob3QgPSBfc25hcHNob3Q7XHJcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG5ldyBTbmFwc2hvdE1ldGFkYXRhKF9zbmFwc2hvdC5oYXNQZW5kaW5nV3JpdGVzLCBfc25hcHNob3QuZnJvbUNhY2hlKTtcclxuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICB9XHJcbiAgICAvKiogQW4gYXJyYXkgb2YgYWxsIHRoZSBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBkb2NzKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChkb2MgPT4gcmVzdWx0LnB1c2goZG9jKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKiBUaGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgYFF1ZXJ5U25hcHNob3RgLiAqL1xyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NuYXBzaG90LmRvY3Muc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKiBUcnVlIGlmIHRoZXJlIGFyZSBubyBkb2N1bWVudHMgaW4gdGhlIGBRdWVyeVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnVtZXJhdGVzIGFsbCBvZiB0aGUgZG9jdW1lbnRzIGluIHRoZSBgUXVlcnlTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2l0aCBhIGBRdWVyeURvY3VtZW50U25hcHNob3RgIGZvclxyXG4gICAgICogZWFjaCBkb2N1bWVudCBpbiB0aGUgc25hcHNob3QuXHJcbiAgICAgKiBAcGFyYW0gdGhpc0FyZyAtIFRoZSBgdGhpc2AgYmluZGluZyBmb3IgdGhlIGNhbGxiYWNrLlxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgdGhpcy5fc25hcHNob3QuZG9jcy5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgbmV3IFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCh0aGlzLl9maXJlc3RvcmUsIHRoaXMuX3VzZXJEYXRhV3JpdGVyLCBkb2Mua2V5LCBkb2MsIG5ldyBTbmFwc2hvdE1ldGFkYXRhKHRoaXMuX3NuYXBzaG90Lm11dGF0ZWRLZXlzLmhhcyhkb2Mua2V5KSwgdGhpcy5fc25hcHNob3QuZnJvbUNhY2hlKSwgdGhpcy5xdWVyeS5jb252ZXJ0ZXIpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZG9jdW1lbnRzIGNoYW5nZXMgc2luY2UgdGhlIGxhc3Qgc25hcHNob3QuIElmIHRoaXNcclxuICAgICAqIGlzIHRoZSBmaXJzdCBzbmFwc2hvdCwgYWxsIGRvY3VtZW50cyB3aWxsIGJlIGluIHRoZSBsaXN0IGFzICdhZGRlZCdcclxuICAgICAqIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBgU25hcHNob3RMaXN0ZW5PcHRpb25zYCB0aGF0IGNvbnRyb2wgd2hldGhlciBtZXRhZGF0YS1vbmx5XHJcbiAgICAgKiBjaGFuZ2VzIChpLmUuIG9ubHkgYERvY3VtZW50U25hcHNob3QubWV0YWRhdGFgIGNoYW5nZWQpIHNob3VsZCB0cmlnZ2VyXHJcbiAgICAgKiBzbmFwc2hvdCBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGRvY0NoYW5nZXMob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyA9ICEhb3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzO1xyXG4gICAgICAgIGlmIChpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzICYmIHRoaXMuX3NuYXBzaG90LmV4Y2x1ZGVzTWV0YWRhdGFDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdUbyBpbmNsdWRlIG1ldGFkYXRhIGNoYW5nZXMgd2l0aCB5b3VyIGRvY3VtZW50IGNoYW5nZXMsIHlvdSBtdXN0ICcgK1xyXG4gICAgICAgICAgICAgICAgJ2Fsc28gcGFzcyB7IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6dHJ1ZSB9IHRvIG9uU25hcHNob3QoKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRDaGFuZ2VzIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXNJbmNsdWRlTWV0YWRhdGFDaGFuZ2VzICE9PSBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBjaGFuZ2VzRnJvbVNuYXBzaG90KHRoaXMsIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzSW5jbHVkZU1ldGFkYXRhQ2hhbmdlcyA9IGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRDaGFuZ2VzO1xyXG4gICAgfVxyXG59XHJcbi8qKiBDYWxjdWxhdGVzIHRoZSBhcnJheSBvZiBgRG9jdW1lbnRDaGFuZ2VgcyBmb3IgYSBnaXZlbiBgVmlld1NuYXBzaG90YC4gKi9cclxuZnVuY3Rpb24gY2hhbmdlc0Zyb21TbmFwc2hvdChxdWVyeVNuYXBzaG90LCBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzKSB7XHJcbiAgICBpZiAocXVlcnlTbmFwc2hvdC5fc25hcHNob3Qub2xkRG9jcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIHJldHVybiBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5kb2NDaGFuZ2VzLm1hcChjaGFuZ2UgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgUXVlcnlEb2N1bWVudFNuYXBzaG90KHF1ZXJ5U25hcHNob3QuX2ZpcmVzdG9yZSwgcXVlcnlTbmFwc2hvdC5fdXNlckRhdGFXcml0ZXIsIGNoYW5nZS5kb2Mua2V5LCBjaGFuZ2UuZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5tdXRhdGVkS2V5cy5oYXMoY2hhbmdlLmRvYy5rZXkpLCBxdWVyeVNuYXBzaG90Ll9zbmFwc2hvdC5mcm9tQ2FjaGUpLCBxdWVyeVNuYXBzaG90LnF1ZXJ5LmNvbnZlcnRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWRkZWQnLFxyXG4gICAgICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICAgICAgb2xkSW5kZXg6IC0xLFxyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXg6IGluZGV4KytcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEEgYERvY3VtZW50U2V0YCB0aGF0IGlzIHVwZGF0ZWQgaW5jcmVtZW50YWxseSBhcyBjaGFuZ2VzIGFyZSBhcHBsaWVkIHRvIHVzZVxyXG4gICAgICAgIC8vIHRvIGxvb2t1cCB0aGUgaW5kZXggb2YgYSBkb2N1bWVudC5cclxuICAgICAgICBsZXQgaW5kZXhUcmFja2VyID0gcXVlcnlTbmFwc2hvdC5fc25hcHNob3Qub2xkRG9jcztcclxuICAgICAgICByZXR1cm4gcXVlcnlTbmFwc2hvdC5fc25hcHNob3QuZG9jQ2hhbmdlc1xyXG4gICAgICAgICAgICAuZmlsdGVyKGNoYW5nZSA9PiBpbmNsdWRlTWV0YWRhdGFDaGFuZ2VzIHx8IGNoYW5nZS50eXBlICE9PSAzIC8qIE1ldGFkYXRhICovKVxyXG4gICAgICAgICAgICAubWFwKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBRdWVyeURvY3VtZW50U25hcHNob3QocXVlcnlTbmFwc2hvdC5fZmlyZXN0b3JlLCBxdWVyeVNuYXBzaG90Ll91c2VyRGF0YVdyaXRlciwgY2hhbmdlLmRvYy5rZXksIGNoYW5nZS5kb2MsIG5ldyBTbmFwc2hvdE1ldGFkYXRhKHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90Lm11dGF0ZWRLZXlzLmhhcyhjaGFuZ2UuZG9jLmtleSksIHF1ZXJ5U25hcHNob3QuX3NuYXBzaG90LmZyb21DYWNoZSksIHF1ZXJ5U25hcHNob3QucXVlcnkuY29udmVydGVyKTtcclxuICAgICAgICAgICAgbGV0IG9sZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGxldCBuZXdJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBpZiAoY2hhbmdlLnR5cGUgIT09IDAgLyogQWRkZWQgKi8pIHtcclxuICAgICAgICAgICAgICAgIG9sZEluZGV4ID0gaW5kZXhUcmFja2VyLmluZGV4T2YoY2hhbmdlLmRvYy5rZXkpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhUcmFja2VyID0gaW5kZXhUcmFja2VyLmRlbGV0ZShjaGFuZ2UuZG9jLmtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlICE9PSAxIC8qIFJlbW92ZWQgKi8pIHtcclxuICAgICAgICAgICAgICAgIGluZGV4VHJhY2tlciA9IGluZGV4VHJhY2tlci5hZGQoY2hhbmdlLmRvYyk7XHJcbiAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGluZGV4VHJhY2tlci5pbmRleE9mKGNoYW5nZS5kb2Mua2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogcmVzdWx0Q2hhbmdlVHlwZShjaGFuZ2UudHlwZSksXHJcbiAgICAgICAgICAgICAgICBkb2MsXHJcbiAgICAgICAgICAgICAgICBvbGRJbmRleCxcclxuICAgICAgICAgICAgICAgIG5ld0luZGV4XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzdWx0Q2hhbmdlVHlwZSh0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogQWRkZWQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAnYWRkZWQnO1xyXG4gICAgICAgIGNhc2UgMiAvKiBNb2RpZmllZCAqLzpcclxuICAgICAgICBjYXNlIDMgLyogTWV0YWRhdGEgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAnbW9kaWZpZWQnO1xyXG4gICAgICAgIGNhc2UgMSAvKiBSZW1vdmVkICovOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3JlbW92ZWQnO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICB9XHJcbn1cclxuLy8gVE9ETyhmaXJlc3RvcmVleHApOiBBZGQgdGVzdHMgZm9yIHNuYXBzaG90RXF1YWwgd2l0aCBkaWZmZXJlbnQgc25hcHNob3RcclxuLy8gbWV0YWRhdGFcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgc25hcHNob3RzIGFyZSBlcXVhbC5cclxuICpcclxuICogQHBhcmFtIGxlZnQgLSBBIHNuYXBzaG90IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSByaWdodCAtIEEgc25hcHNob3QgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc25hcHNob3RzIGFyZSBlcXVhbC5cclxuICovXHJcbmZ1bmN0aW9uIHNuYXBzaG90RXF1YWwobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgRG9jdW1lbnRTbmFwc2hvdCAmJiByaWdodCBpbnN0YW5jZW9mIERvY3VtZW50U25hcHNob3QpIHtcclxuICAgICAgICByZXR1cm4gKGxlZnQuX2ZpcmVzdG9yZSA9PT0gcmlnaHQuX2ZpcmVzdG9yZSAmJlxyXG4gICAgICAgICAgICBsZWZ0Ll9rZXkuaXNFcXVhbChyaWdodC5fa2V5KSAmJlxyXG4gICAgICAgICAgICAobGVmdC5fZG9jdW1lbnQgPT09IG51bGxcclxuICAgICAgICAgICAgICAgID8gcmlnaHQuX2RvY3VtZW50ID09PSBudWxsXHJcbiAgICAgICAgICAgICAgICA6IGxlZnQuX2RvY3VtZW50LmlzRXF1YWwocmlnaHQuX2RvY3VtZW50KSkgJiZcclxuICAgICAgICAgICAgbGVmdC5fY29udmVydGVyID09PSByaWdodC5fY29udmVydGVyKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxlZnQgaW5zdGFuY2VvZiBRdWVyeVNuYXBzaG90ICYmIHJpZ2h0IGluc3RhbmNlb2YgUXVlcnlTbmFwc2hvdCkge1xyXG4gICAgICAgIHJldHVybiAobGVmdC5fZmlyZXN0b3JlID09PSByaWdodC5fZmlyZXN0b3JlICYmXHJcbiAgICAgICAgICAgIHF1ZXJ5RXF1YWwobGVmdC5xdWVyeSwgcmlnaHQucXVlcnkpICYmXHJcbiAgICAgICAgICAgIGxlZnQubWV0YWRhdGEuaXNFcXVhbChyaWdodC5tZXRhZGF0YSkgJiZcclxuICAgICAgICAgICAgbGVmdC5fc25hcHNob3QuaXNFcXVhbChyaWdodC5fc25hcHNob3QpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHF1ZXJ5KSB7XHJcbiAgICBpZiAoaGFzTGltaXRUb0xhc3QocXVlcnkpICYmIHF1ZXJ5LmV4cGxpY2l0T3JkZXJCeS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5VTklNUExFTUVOVEVELCAnbGltaXRUb0xhc3QoKSBxdWVyaWVzIHJlcXVpcmUgc3BlY2lmeWluZyBhdCBsZWFzdCBvbmUgb3JkZXJCeSgpIGNsYXVzZScpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcclxuICogRmlyZXN0b3JlIHF1ZXJ5LiBgUXVlcnlDb25zdHJhaW50YHMgYXJlIGNyZWF0ZWQgYnkgaW52b2tpbmcge0BsaW5rIHdoZXJlfSxcclxuICoge0BsaW5rIG9yZGVyQnl9LCB7QGxpbmsgKHN0YXJ0QXQ6MSl9LCB7QGxpbmsgKHN0YXJ0QWZ0ZXI6MSl9LCB7QGxpbmtcclxuICogZW5kQmVmb3JlOjF9LCB7QGxpbmsgKGVuZEF0OjEpfSwge0BsaW5rIGxpbWl0fSBvciB7QGxpbmsgbGltaXRUb0xhc3R9IGFuZFxyXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIHF1ZXJ5fSB0byBjcmVhdGUgYSBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdFxyXG4gKiBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5Q29uc3RyYWludGAuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUNvbnN0cmFpbnQge1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBpbnN0YW5jZSBvZiB7QGxpbmsgUXVlcnl9IHRoYXQgaXMgZXh0ZW5kZWQgdG8gYWxzbyBpbmNsdWRlXHJcbiAqIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSB7QGxpbmsgUXVlcnl9IGluc3RhbmNlIHRvIHVzZSBhcyBhIGJhc2UgZm9yIHRoZSBuZXcgY29uc3RyYWludHMuXHJcbiAqIEBwYXJhbSBxdWVyeUNvbnN0cmFpbnRzIC0gVGhlIGxpc3Qgb2Yge0BsaW5rIFF1ZXJ5Q29uc3RyYWludH1zIHRvIGFwcGx5LlxyXG4gKiBAdGhyb3dzIGlmIGFueSBvZiB0aGUgcHJvdmlkZWQgcXVlcnkgY29uc3RyYWludHMgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggdGhlXHJcbiAqIGV4aXN0aW5nIG9yIG5ldyBjb25zdHJhaW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5KHF1ZXJ5LCAuLi5xdWVyeUNvbnN0cmFpbnRzKSB7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgcXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgICAgIHF1ZXJ5ID0gY29uc3RyYWludC5fYXBwbHkocXVlcnkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1ZXJ5O1xyXG59XHJcbmNsYXNzIFF1ZXJ5RmlsdGVyQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfZmllbGQsIF9vcCwgX3ZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9maWVsZCA9IF9maWVsZDtcclxuICAgICAgICB0aGlzLl9vcCA9IF9vcDtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnd2hlcmUnO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIocXVlcnkuZmlyZXN0b3JlKTtcclxuICAgICAgICBjb25zdCBmaWx0ZXIgPSBuZXdRdWVyeUZpbHRlcihxdWVyeS5fcXVlcnksICd3aGVyZScsIHJlYWRlciwgcXVlcnkuZmlyZXN0b3JlLl9kYXRhYmFzZUlkLCB0aGlzLl9maWVsZCwgdGhpcy5fb3AsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhBZGRlZEZpbHRlcihxdWVyeS5fcXVlcnksIGZpbHRlcikpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5Q29uc3RyYWludH0gdGhhdCBlbmZvcmNlcyB0aGF0IGRvY3VtZW50cyBtdXN0IGNvbnRhaW4gdGhlXHJcbiAqIHNwZWNpZmllZCBmaWVsZCBhbmQgdGhhdCB0aGUgdmFsdWUgc2hvdWxkIHNhdGlzZnkgdGhlIHJlbGF0aW9uIGNvbnN0cmFpbnRcclxuICogcHJvdmlkZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgcGF0aCB0byBjb21wYXJlXHJcbiAqIEBwYXJhbSBvcFN0ciAtIFRoZSBvcGVyYXRpb24gc3RyaW5nIChlLmcgXCImbHQ7XCIsIFwiJmx0Oz1cIiwgXCI9PVwiLCBcIiZsdDtcIixcclxuICogICBcIiZsdDs9XCIsIFwiIT1cIikuXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBmb3IgY29tcGFyaXNvblxyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCB7QGxpbmsgUXVlcnl9LlxyXG4gKi9cclxuZnVuY3Rpb24gd2hlcmUoZmllbGRQYXRoLCBvcFN0ciwgdmFsdWUpIHtcclxuICAgIGNvbnN0IG9wID0gb3BTdHI7XHJcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnd2hlcmUnLCBmaWVsZFBhdGgpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUZpbHRlckNvbnN0cmFpbnQoZmllbGQsIG9wLCB2YWx1ZSk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfZmllbGQsIF9kaXJlY3Rpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2ZpZWxkID0gX2ZpZWxkO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IF9kaXJlY3Rpb247XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnknO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3Qgb3JkZXJCeSA9IG5ld1F1ZXJ5T3JkZXJCeShxdWVyeS5fcXVlcnksIHRoaXMuX2ZpZWxkLCB0aGlzLl9kaXJlY3Rpb24pO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aEFkZGVkT3JkZXJCeShxdWVyeS5fcXVlcnksIG9yZGVyQnkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUNvbnN0cmFpbnR9IHRoYXQgc29ydHMgdGhlIHF1ZXJ5IHJlc3VsdCBieSB0aGVcclxuICogc3BlY2lmaWVkIGZpZWxkLCBvcHRpb25hbGx5IGluIGRlc2NlbmRpbmcgb3JkZXIgaW5zdGVhZCBvZiBhc2NlbmRpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBmaWVsZFBhdGggLSBUaGUgZmllbGQgdG8gc29ydCBieS5cclxuICogQHBhcmFtIGRpcmVjdGlvblN0ciAtIE9wdGlvbmFsIGRpcmVjdGlvbiB0byBzb3J0IGJ5ICgnYXNjJyBvciAnZGVzYycpLiBJZlxyXG4gKiBub3Qgc3BlY2lmaWVkLCBvcmRlciB3aWxsIGJlIGFzY2VuZGluZy5cclxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5fS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnkoZmllbGRQYXRoLCBkaXJlY3Rpb25TdHIgPSAnYXNjJykge1xyXG4gICAgY29uc3QgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyO1xyXG4gICAgY29uc3QgcGF0aCA9IGZpZWxkUGF0aEZyb21Bcmd1bWVudCgnb3JkZXJCeScsIGZpZWxkUGF0aCk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeUNvbnN0cmFpbnQocGF0aCwgZGlyZWN0aW9uKTtcclxufVxyXG5jbGFzcyBRdWVyeUxpbWl0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBfbGltaXQsIF9saW1pdFR5cGUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XHJcbiAgICAgICAgdGhpcy5fbGltaXRUeXBlID0gX2xpbWl0VHlwZTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aExpbWl0KHF1ZXJ5Ll9xdWVyeSwgdGhpcy5fbGltaXQsIHRoaXMuX2xpbWl0VHlwZSkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEge0BsaW5rIFF1ZXJ5Q29uc3RyYWludH0gdGhhdCBvbmx5IHJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nIGRvY3VtZW50cy5cclxuICpcclxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybi5cclxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQge0BsaW5rIFF1ZXJ5fS5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0KGxpbWl0KSB7XHJcbiAgICB2YWxpZGF0ZVBvc2l0aXZlTnVtYmVyKCdsaW1pdCcsIGxpbWl0KTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlMaW1pdENvbnN0cmFpbnQoJ2xpbWl0JywgbGltaXQsIFwiRlwiIC8qIEZpcnN0ICovKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHtAbGluayBRdWVyeUNvbnN0cmFpbnR9IHRoYXQgb25seSByZXR1cm5zIHRoZSBsYXN0IG1hdGNoaW5nIGRvY3VtZW50cy5cclxuICpcclxuICogWW91IG11c3Qgc3BlY2lmeSBhdCBsZWFzdCBvbmUgYG9yZGVyQnlgIGNsYXVzZSBmb3IgYGxpbWl0VG9MYXN0YCBxdWVyaWVzLFxyXG4gKiBvdGhlcndpc2UgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIGR1cmluZyBleGVjdXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0byByZXR1cm4uXHJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHtAbGluayBRdWVyeX0uXHJcbiAqL1xyXG5mdW5jdGlvbiBsaW1pdFRvTGFzdChsaW1pdCkge1xyXG4gICAgdmFsaWRhdGVQb3NpdGl2ZU51bWJlcignbGltaXRUb0xhc3QnLCBsaW1pdCk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRDb25zdHJhaW50KCdsaW1pdFRvTGFzdCcsIGxpbWl0LCBcIkxcIiAvKiBMYXN0ICovKTtcclxufVxyXG5jbGFzcyBRdWVyeVN0YXJ0QXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIF9kb2NPckZpZWxkcywgX2luY2x1c2l2ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLl9kb2NPckZpZWxkcyA9IF9kb2NPckZpZWxkcztcclxuICAgICAgICB0aGlzLl9pbmNsdXNpdmUgPSBfaW5jbHVzaXZlO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgYm91bmQgPSBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCB0aGlzLnR5cGUsIHRoaXMuX2RvY09yRmllbGRzLCB0aGlzLl9pbmNsdXNpdmUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnkocXVlcnkuZmlyZXN0b3JlLCBxdWVyeS5jb252ZXJ0ZXIsIHF1ZXJ5V2l0aFN0YXJ0QXQocXVlcnkuX3F1ZXJ5LCBib3VuZCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0QXQoLi4uZG9jT3JGaWVsZHMpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCgnc3RhcnRBdCcsIGRvY09yRmllbGRzLCBcclxuICAgIC8qaW5jbHVzaXZlPSovIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXJ0QWZ0ZXIoLi4uZG9jT3JGaWVsZHMpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCgnc3RhcnRBZnRlcicsIGRvY09yRmllbGRzLCBcclxuICAgIC8qaW5jbHVzaXZlPSovIGZhbHNlKTtcclxufVxyXG5jbGFzcyBRdWVyeUVuZEF0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBfZG9jT3JGaWVsZHMsIF9pbmNsdXNpdmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fZG9jT3JGaWVsZHMgPSBfZG9jT3JGaWVsZHM7XHJcbiAgICAgICAgdGhpcy5faW5jbHVzaXZlID0gX2luY2x1c2l2ZTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kID0gbmV3UXVlcnlCb3VuZEZyb21Eb2NPckZpZWxkcyhxdWVyeSwgdGhpcy50eXBlLCB0aGlzLl9kb2NPckZpZWxkcywgdGhpcy5faW5jbHVzaXZlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHF1ZXJ5LmZpcmVzdG9yZSwgcXVlcnkuY29udmVydGVyLCBxdWVyeVdpdGhFbmRBdChxdWVyeS5fcXVlcnksIGJvdW5kKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZW5kQmVmb3JlKC4uLmRvY09yRmllbGRzKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KCdlbmRCZWZvcmUnLCBkb2NPckZpZWxkcywgXHJcbiAgICAvKmluY2x1c2l2ZT0qLyBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gZW5kQXQoLi4uZG9jT3JGaWVsZHMpIHtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFbmRBdENvbnN0cmFpbnQoJ2VuZEF0JywgZG9jT3JGaWVsZHMsIC8qaW5jbHVzaXZlPSovIHRydWUpO1xyXG59XHJcbi8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgYm91bmQgZnJvbSBhIGRvY3VtZW50IG9yIGZpZWxkcyAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbURvY09yRmllbGRzKHF1ZXJ5LCBtZXRob2ROYW1lLCBkb2NPckZpZWxkcywgaW5jbHVzaXZlKSB7XHJcbiAgICBkb2NPckZpZWxkc1swXSA9IGdldE1vZHVsYXJJbnN0YW5jZShkb2NPckZpZWxkc1swXSk7XHJcbiAgICBpZiAoZG9jT3JGaWVsZHNbMF0gaW5zdGFuY2VvZiBEb2N1bWVudFNuYXBzaG90JDEpIHtcclxuICAgICAgICByZXR1cm4gbmV3UXVlcnlCb3VuZEZyb21Eb2N1bWVudChxdWVyeS5fcXVlcnksIHF1ZXJ5LmZpcmVzdG9yZS5fZGF0YWJhc2VJZCwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHNbMF0uX2RvY3VtZW50LCBpbmNsdXNpdmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIocXVlcnkuZmlyZXN0b3JlKTtcclxuICAgICAgICByZXR1cm4gbmV3UXVlcnlCb3VuZEZyb21GaWVsZHMocXVlcnkuX3F1ZXJ5LCBxdWVyeS5maXJlc3RvcmUuX2RhdGFiYXNlSWQsIHJlYWRlciwgbWV0aG9kTmFtZSwgZG9jT3JGaWVsZHMsIGluY2x1c2l2ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3UXVlcnlGaWx0ZXIocXVlcnksIG1ldGhvZE5hbWUsIGRhdGFSZWFkZXIsIGRhdGFiYXNlSWQsIGZpZWxkUGF0aCwgb3AsIHZhbHVlKSB7XHJcbiAgICBsZXQgZmllbGRWYWx1ZTtcclxuICAgIGlmIChmaWVsZFBhdGguaXNLZXlGaWVsZCgpKSB7XHJcbiAgICAgICAgaWYgKG9wID09PSBcImFycmF5LWNvbnRhaW5zXCIgLyogQVJSQVlfQ09OVEFJTlMgKi8gfHwgb3AgPT09IFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogQVJSQVlfQ09OVEFJTlNfQU5ZICovKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIFF1ZXJ5LiBZb3UgY2FuJ3QgcGVyZm9ybSAnJHtvcH0nIHF1ZXJpZXMgb24gZG9jdW1lbnRJZCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcCA9PT0gXCJpblwiIC8qIElOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE5PVF9JTiAqLykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wKTtcclxuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFycmF5VmFsdWUgb2YgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUxpc3QucHVzaChwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgYXJyYXlWYWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSB7IGFycmF5VmFsdWU6IHsgdmFsdWVzOiByZWZlcmVuY2VMaXN0IH0gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChvcCA9PT0gXCJpblwiIC8qIElOICovIHx8XHJcbiAgICAgICAgICAgIG9wID09PSBcIm5vdC1pblwiIC8qIE5PVF9JTiAqLyB8fFxyXG4gICAgICAgICAgICBvcCA9PT0gXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBBUlJBWV9DT05UQUlOU19BTlkgKi8pIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVEaXNqdW5jdGl2ZUZpbHRlckVsZW1lbnRzKHZhbHVlLCBvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpZWxkVmFsdWUgPSBwYXJzZVF1ZXJ5VmFsdWUoZGF0YVJlYWRlciwgbWV0aG9kTmFtZSwgdmFsdWUsIFxyXG4gICAgICAgIC8qIGFsbG93QXJyYXlzPSAqLyBvcCA9PT0gXCJpblwiIC8qIElOICovIHx8IG9wID09PSBcIm5vdC1pblwiIC8qIE5PVF9JTiAqLyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWx0ZXIgPSBGaWVsZEZpbHRlci5jcmVhdGUoZmllbGRQYXRoLCBvcCwgZmllbGRWYWx1ZSk7XHJcbiAgICB2YWxpZGF0ZU5ld0ZpbHRlcihxdWVyeSwgZmlsdGVyKTtcclxuICAgIHJldHVybiBmaWx0ZXI7XHJcbn1cclxuZnVuY3Rpb24gbmV3UXVlcnlPcmRlckJ5KHF1ZXJ5LCBmaWVsZFBhdGgsIGRpcmVjdGlvbikge1xyXG4gICAgaWYgKHF1ZXJ5LnN0YXJ0QXQgIT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IG11c3Qgbm90IGNhbGwgc3RhcnRBdCgpIG9yIHN0YXJ0QWZ0ZXIoKSBiZWZvcmUgJyArXHJcbiAgICAgICAgICAgICdjYWxsaW5nIG9yZGVyQnkoKS4nKTtcclxuICAgIH1cclxuICAgIGlmIChxdWVyeS5lbmRBdCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgbXVzdCBub3QgY2FsbCBlbmRBdCgpIG9yIGVuZEJlZm9yZSgpIGJlZm9yZSAnICtcclxuICAgICAgICAgICAgJ2NhbGxpbmcgb3JkZXJCeSgpLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3JkZXJCeSA9IG5ldyBPcmRlckJ5KGZpZWxkUGF0aCwgZGlyZWN0aW9uKTtcclxuICAgIHZhbGlkYXRlTmV3T3JkZXJCeShxdWVyeSwgb3JkZXJCeSk7XHJcbiAgICByZXR1cm4gb3JkZXJCeTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIGEgYEJvdW5kYCBmcm9tIGEgcXVlcnkgYW5kIGEgZG9jdW1lbnQuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgYEJvdW5kYCB3aWxsIGFsd2F5cyBpbmNsdWRlIHRoZSBrZXkgb2YgdGhlIGRvY3VtZW50XHJcbiAqIGFuZCBzbyBvbmx5IHRoZSBwcm92aWRlZCBkb2N1bWVudCB3aWxsIGNvbXBhcmUgZXF1YWwgdG8gdGhlIHJldHVybmVkXHJcbiAqIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBXaWxsIHRocm93IGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBjb250YWluIGFsbCBmaWVsZHMgb2YgdGhlIG9yZGVyIGJ5XHJcbiAqIG9mIHRoZSBxdWVyeSBvciBpZiBhbnkgb2YgdGhlIGZpZWxkcyBpbiB0aGUgb3JkZXIgYnkgYXJlIGFuIHVuY29tbWl0dGVkXHJcbiAqIHNlcnZlciB0aW1lc3RhbXAuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdRdWVyeUJvdW5kRnJvbURvY3VtZW50KHF1ZXJ5LCBkYXRhYmFzZUlkLCBtZXRob2ROYW1lLCBkb2MsIGluY2x1c2l2ZSkge1xyXG4gICAgaWYgKCFkb2MpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5OT1RfRk9VTkQsIGBDYW4ndCB1c2UgYSBEb2N1bWVudFNuYXBzaG90IHRoYXQgZG9lc24ndCBleGlzdCBmb3IgYCArXHJcbiAgICAgICAgICAgIGAke21ldGhvZE5hbWV9KCkuYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XHJcbiAgICAvLyBCZWNhdXNlIHBlb3BsZSBleHBlY3QgdG8gY29udGludWUvZW5kIGEgcXVlcnkgYXQgdGhlIGV4YWN0IGRvY3VtZW50XHJcbiAgICAvLyBwcm92aWRlZCwgd2UgbmVlZCB0byB1c2UgdGhlIGltcGxpY2l0IHNvcnQgb3JkZXIgcmF0aGVyIHRoYW4gdGhlIGV4cGxpY2l0XHJcbiAgICAvLyBzb3J0IG9yZGVyLCBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBjb250YWluIHRoZSBkb2N1bWVudCBrZXkuIFRoYXQgd2F5XHJcbiAgICAvLyB0aGUgcG9zaXRpb24gYmVjb21lcyB1bmFtYmlndW91cyBhbmQgdGhlIHF1ZXJ5IGNvbnRpbnVlcy9lbmRzIGV4YWN0bHkgYXRcclxuICAgIC8vIHRoZSBwcm92aWRlZCBkb2N1bWVudC4gV2l0aG91dCB0aGUga2V5IChieSB1c2luZyB0aGUgZXhwbGljaXQgc29ydFxyXG4gICAgLy8gb3JkZXJzKSwgbXVsdGlwbGUgZG9jdW1lbnRzIGNvdWxkIG1hdGNoIHRoZSBwb3NpdGlvbiwgeWllbGRpbmcgZHVwbGljYXRlXHJcbiAgICAvLyByZXN1bHRzLlxyXG4gICAgZm9yIChjb25zdCBvcmRlckJ5IG9mIHF1ZXJ5T3JkZXJCeShxdWVyeSkpIHtcclxuICAgICAgICBpZiAob3JkZXJCeS5maWVsZC5pc0tleUZpZWxkKCkpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHJlZlZhbHVlKGRhdGFiYXNlSWQsIGRvYy5rZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jLmRhdGEuZmllbGQob3JkZXJCeS5maWVsZCk7XHJcbiAgICAgICAgICAgIGlmIChpc1NlcnZlclRpbWVzdGFtcCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBZb3UgYXJlIHRyeWluZyB0byBzdGFydCBvciBlbmQgYSBxdWVyeSB1c2luZyBhICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdkb2N1bWVudCBmb3Igd2hpY2ggdGhlIGZpZWxkIFwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJCeS5maWVsZCArXHJcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGlzIGFuIHVuY29tbWl0dGVkIHNlcnZlciB0aW1lc3RhbXAuIChTaW5jZSB0aGUgdmFsdWUgb2YgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3RoaXMgZmllbGQgaXMgdW5rbm93biwgeW91IGNhbm5vdCBzdGFydC9lbmQgYSBxdWVyeSB3aXRoIGl0LiknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gb3JkZXJCeS5maWVsZC5jYW5vbmljYWxTdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBZb3UgYXJlIHRyeWluZyB0byBzdGFydCBvciBlbmQgYSBxdWVyeSB1c2luZyBhIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBkb2N1bWVudCBmb3Igd2hpY2ggdGhlIGZpZWxkICcke2ZpZWxkfScgKHVzZWQgYXMgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBvcmRlckJ5KSBkb2VzIG5vdCBleGlzdC5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQm91bmQoY29tcG9uZW50cywgaW5jbHVzaXZlKTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgYSBsaXN0IG9mIGZpZWxkIHZhbHVlcyB0byBhIGBCb3VuZGAgZm9yIHRoZSBnaXZlbiBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIG5ld1F1ZXJ5Qm91bmRGcm9tRmllbGRzKHF1ZXJ5LCBkYXRhYmFzZUlkLCBkYXRhUmVhZGVyLCBtZXRob2ROYW1lLCB2YWx1ZXMsIGluY2x1c2l2ZSkge1xyXG4gICAgLy8gVXNlIGV4cGxpY2l0IG9yZGVyIGJ5J3MgYmVjYXVzZSBpdCBoYXMgdG8gbWF0Y2ggdGhlIHF1ZXJ5IHRoZSB1c2VyIG1hZGVcclxuICAgIGNvbnN0IG9yZGVyQnkgPSBxdWVyeS5leHBsaWNpdE9yZGVyQnk7XHJcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IG9yZGVyQnkubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYFRvbyBtYW55IGFyZ3VtZW50cyBwcm92aWRlZCB0byAke21ldGhvZE5hbWV9KCkuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIG51bWJlciBvZiBhcmd1bWVudHMgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGAgK1xyXG4gICAgICAgICAgICBgbnVtYmVyIG9mIG9yZGVyQnkoKSBjbGF1c2VzYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb21wb25lbnRzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gdmFsdWVzW2ldO1xyXG4gICAgICAgIGNvbnN0IG9yZGVyQnlDb21wb25lbnQgPSBvcmRlckJ5W2ldO1xyXG4gICAgICAgIGlmIChvcmRlckJ5Q29tcG9uZW50LmZpZWxkLmlzS2V5RmllbGQoKSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJhd1ZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgYEludmFsaWQgcXVlcnkuIEV4cGVjdGVkIGEgc3RyaW5nIGZvciBkb2N1bWVudCBJRCBpbiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJHttZXRob2ROYW1lfSgpLCBidXQgZ290IGEgJHt0eXBlb2YgcmF3VmFsdWV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0NvbGxlY3Rpb25Hcm91cFF1ZXJ5KHF1ZXJ5KSAmJiByYXdWYWx1ZS5pbmRleE9mKCcvJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gYW5kIG9yZGVyaW5nIGJ5IGRvY3VtZW50SWQoKSwgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHRoZSB2YWx1ZSBwYXNzZWQgdG8gJHttZXRob2ROYW1lfSgpIG11c3QgYmUgYSBwbGFpbiBkb2N1bWVudCBJRCwgYnV0IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGAnJHtyYXdWYWx1ZX0nIGNvbnRhaW5zIGEgc2xhc2guYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHF1ZXJ5LnBhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcocmF3VmFsdWUpKTtcclxuICAgICAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyBhIGNvbGxlY3Rpb24gZ3JvdXAgYW5kIG9yZGVyaW5nIGJ5IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHRoZSB2YWx1ZSBwYXNzZWQgdG8gJHttZXRob2ROYW1lfSgpIG11c3QgcmVzdWx0IGluIGEgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHZhbGlkIGRvY3VtZW50IHBhdGgsIGJ1dCAnJHtwYXRofScgaXMgbm90IGJlY2F1c2UgaXQgY29udGFpbnMgYW4gb2RkIG51bWJlciBgICtcclxuICAgICAgICAgICAgICAgICAgICBgb2Ygc2VnbWVudHMuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IERvY3VtZW50S2V5KHBhdGgpO1xyXG4gICAgICAgICAgICBjb21wb25lbnRzLnB1c2gocmVmVmFsdWUoZGF0YWJhc2VJZCwga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVkID0gcGFyc2VRdWVyeVZhbHVlKGRhdGFSZWFkZXIsIG1ldGhvZE5hbWUsIHJhd1ZhbHVlKTtcclxuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHdyYXBwZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgQm91bmQoY29tcG9uZW50cywgaW5jbHVzaXZlKTtcclxufVxyXG4vKipcclxuICogUGFyc2VzIHRoZSBnaXZlbiBgZG9jdW1lbnRJZFZhbHVlYCBpbnRvIGEgYFJlZmVyZW5jZVZhbHVlYCwgdGhyb3dpbmdcclxuICogYXBwcm9wcmlhdGUgZXJyb3JzIGlmIHRoZSB2YWx1ZSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGEgYERvY3VtZW50UmVmZXJlbmNlYFxyXG4gKiBvciBgc3RyaW5nYCwgb3IgaWYgdGhlIHN0cmluZyBpcyBtYWxmb3JtZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50SWRWYWx1ZShkYXRhYmFzZUlkLCBxdWVyeSwgZG9jdW1lbnRJZFZhbHVlKSB7XHJcbiAgICBkb2N1bWVudElkVmFsdWUgPSBnZXRNb2R1bGFySW5zdGFuY2UoZG9jdW1lbnRJZFZhbHVlKTtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZFZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChkb2N1bWVudElkVmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIHdpdGggZG9jdW1lbnRJZCgpLCB5b3UgJyArXHJcbiAgICAgICAgICAgICAgICAnbXVzdCBwcm92aWRlIGEgdmFsaWQgZG9jdW1lbnQgSUQsIGJ1dCBpdCB3YXMgYW4gZW1wdHkgc3RyaW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzQ29sbGVjdGlvbkdyb3VwUXVlcnkocXVlcnkpICYmIGRvY3VtZW50SWRWYWx1ZS5pbmRleE9mKCcvJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBieSBgICtcclxuICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHlvdSBtdXN0IHByb3ZpZGUgYSBwbGFpbiBkb2N1bWVudCBJRCwgYnV0IGAgK1xyXG4gICAgICAgICAgICAgICAgYCcke2RvY3VtZW50SWRWYWx1ZX0nIGNvbnRhaW5zIGEgJy8nIGNoYXJhY3Rlci5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGF0aCA9IHF1ZXJ5LnBhdGguY2hpbGQoUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcoZG9jdW1lbnRJZFZhbHVlKSk7XHJcbiAgICAgICAgaWYgKCFEb2N1bWVudEtleS5pc0RvY3VtZW50S2V5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBXaGVuIHF1ZXJ5aW5nIGEgY29sbGVjdGlvbiBncm91cCBieSBgICtcclxuICAgICAgICAgICAgICAgIGBkb2N1bWVudElkKCksIHRoZSB2YWx1ZSBwcm92aWRlZCBtdXN0IHJlc3VsdCBpbiBhIHZhbGlkIGRvY3VtZW50IHBhdGgsIGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1dCAnJHtwYXRofScgaXMgbm90IGJlY2F1c2UgaXQgaGFzIGFuIG9kZCBudW1iZXIgb2Ygc2VnbWVudHMgKCR7cGF0aC5sZW5ndGh9KS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZlZhbHVlKGRhdGFiYXNlSWQsIG5ldyBEb2N1bWVudEtleShwYXRoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkb2N1bWVudElkVmFsdWUgaW5zdGFuY2VvZiBEb2N1bWVudFJlZmVyZW5jZSkge1xyXG4gICAgICAgIHJldHVybiByZWZWYWx1ZShkYXRhYmFzZUlkLCBkb2N1bWVudElkVmFsdWUuX2tleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCBgSW52YWxpZCBxdWVyeS4gV2hlbiBxdWVyeWluZyB3aXRoIGRvY3VtZW50SWQoKSwgeW91IG11c3QgcHJvdmlkZSBhIHZhbGlkIGAgK1xyXG4gICAgICAgICAgICBgc3RyaW5nIG9yIGEgRG9jdW1lbnRSZWZlcmVuY2UsIGJ1dCBpdCB3YXM6IGAgK1xyXG4gICAgICAgICAgICBgJHt2YWx1ZURlc2NyaXB0aW9uKGRvY3VtZW50SWRWYWx1ZSl9LmApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgcGFzc2VkIGludG8gYSBkaXNqdW5jdGl2ZSBmaWx0ZXIgc2F0aXNmaWVzIGFsbFxyXG4gKiBhcnJheSByZXF1aXJlbWVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZURpc2p1bmN0aXZlRmlsdGVyRWxlbWVudHModmFsdWUsIG9wZXJhdG9yKSB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdJbnZhbGlkIFF1ZXJ5LiBBIG5vbi1lbXB0eSBhcnJheSBpcyByZXF1aXJlZCBmb3IgJyArXHJcbiAgICAgICAgICAgIGAnJHtvcGVyYXRvci50b1N0cmluZygpfScgZmlsdGVycy5gKTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIFF1ZXJ5LiAnJHtvcGVyYXRvci50b1N0cmluZygpfScgZmlsdGVycyBzdXBwb3J0IGEgYCArXHJcbiAgICAgICAgICAgICdtYXhpbXVtIG9mIDEwIGVsZW1lbnRzIGluIHRoZSB2YWx1ZSBhcnJheS4nKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYW4gb3BlcmF0b3IsIHJldHVybnMgdGhlIHNldCBvZiBvcGVyYXRvcnMgdGhhdCBjYW5ub3QgYmUgdXNlZCB3aXRoIGl0LlxyXG4gKlxyXG4gKiBPcGVyYXRvcnMgaW4gYSBxdWVyeSBtdXN0IGFkaGVyZSB0byB0aGUgZm9sbG93aW5nIHNldCBvZiBydWxlczpcclxuICogMS4gT25seSBvbmUgYXJyYXkgb3BlcmF0b3IgaXMgYWxsb3dlZC5cclxuICogMi4gT25seSBvbmUgZGlzanVuY3RpdmUgb3BlcmF0b3IgaXMgYWxsb3dlZC5cclxuICogMy4gYE5PVF9FUVVBTGAgY2Fubm90IGJlIHVzZWQgd2l0aCBhbm90aGVyIGBOT1RfRVFVQUxgIG9wZXJhdG9yLlxyXG4gKiA0LiBgTk9UX0lOYCBjYW5ub3QgYmUgdXNlZCB3aXRoIGFycmF5LCBkaXNqdW5jdGl2ZSwgb3IgYE5PVF9FUVVBTGAgb3BlcmF0b3JzLlxyXG4gKlxyXG4gKiBBcnJheSBvcGVyYXRvcnM6IGBBUlJBWV9DT05UQUlOU2AsIGBBUlJBWV9DT05UQUlOU19BTllgXHJcbiAqIERpc2p1bmN0aXZlIG9wZXJhdG9yczogYElOYCwgYEFSUkFZX0NPTlRBSU5TX0FOWWAsIGBOT1RfSU5gXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25mbGljdGluZ09wcyhvcCkge1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgIGNhc2UgXCIhPVwiIC8qIE5PVF9FUVVBTCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcIiE9XCIgLyogTk9UX0VRVUFMICovLCBcIm5vdC1pblwiIC8qIE5PVF9JTiAqL107XHJcbiAgICAgICAgY2FzZSBcImFycmF5LWNvbnRhaW5zXCIgLyogQVJSQVlfQ09OVEFJTlMgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBcImFycmF5LWNvbnRhaW5zXCIgLyogQVJSQVlfQ09OVEFJTlMgKi8sXHJcbiAgICAgICAgICAgICAgICBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIEFSUkFZX0NPTlRBSU5TX0FOWSAqLyxcclxuICAgICAgICAgICAgICAgIFwibm90LWluXCIgLyogTk9UX0lOICovXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgY2FzZSBcImluXCIgLyogSU4gKi86XHJcbiAgICAgICAgICAgIHJldHVybiBbXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBBUlJBWV9DT05UQUlOU19BTlkgKi8sIFwiaW5cIiAvKiBJTiAqLywgXCJub3QtaW5cIiAvKiBOT1RfSU4gKi9dO1xyXG4gICAgICAgIGNhc2UgXCJhcnJheS1jb250YWlucy1hbnlcIiAvKiBBUlJBWV9DT05UQUlOU19BTlkgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBcImFycmF5LWNvbnRhaW5zXCIgLyogQVJSQVlfQ09OVEFJTlMgKi8sXHJcbiAgICAgICAgICAgICAgICBcImFycmF5LWNvbnRhaW5zLWFueVwiIC8qIEFSUkFZX0NPTlRBSU5TX0FOWSAqLyxcclxuICAgICAgICAgICAgICAgIFwiaW5cIiAvKiBJTiAqLyxcclxuICAgICAgICAgICAgICAgIFwibm90LWluXCIgLyogTk9UX0lOICovXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgY2FzZSBcIm5vdC1pblwiIC8qIE5PVF9JTiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIFwiYXJyYXktY29udGFpbnNcIiAvKiBBUlJBWV9DT05UQUlOUyAqLyxcclxuICAgICAgICAgICAgICAgIFwiYXJyYXktY29udGFpbnMtYW55XCIgLyogQVJSQVlfQ09OVEFJTlNfQU5ZICovLFxyXG4gICAgICAgICAgICAgICAgXCJpblwiIC8qIElOICovLFxyXG4gICAgICAgICAgICAgICAgXCJub3QtaW5cIiAvKiBOT1RfSU4gKi8sXHJcbiAgICAgICAgICAgICAgICBcIiE9XCIgLyogTk9UX0VRVUFMICovXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlTmV3RmlsdGVyKHF1ZXJ5LCBmaWx0ZXIpIHtcclxuICAgIGlmIChmaWx0ZXIuaXNJbmVxdWFsaXR5KCkpIHtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0ZpZWxkID0gZ2V0SW5lcXVhbGl0eUZpbHRlckZpZWxkKHF1ZXJ5KTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdGaWVsZCAhPT0gbnVsbCAmJiAhZXhpc3RpbmdGaWVsZC5pc0VxdWFsKGZpbHRlci5maWVsZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ0ludmFsaWQgcXVlcnkuIEFsbCB3aGVyZSBmaWx0ZXJzIHdpdGggYW4gaW5lcXVhbGl0eScgK1xyXG4gICAgICAgICAgICAgICAgJyAoPCwgPD0sICE9LCBub3QtaW4sID4sIG9yID49KSBtdXN0IGJlIG9uIHRoZSBzYW1lIGZpZWxkLiBCdXQgeW91IGhhdmUnICtcclxuICAgICAgICAgICAgICAgIGAgaW5lcXVhbGl0eSBmaWx0ZXJzIG9uICcke2V4aXN0aW5nRmllbGQudG9TdHJpbmcoKX0nYCArXHJcbiAgICAgICAgICAgICAgICBgIGFuZCAnJHtmaWx0ZXIuZmllbGQudG9TdHJpbmcoKX0nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpcnN0T3JkZXJCeUZpZWxkID0gZ2V0Rmlyc3RPcmRlckJ5RmllbGQocXVlcnkpO1xyXG4gICAgICAgIGlmIChmaXJzdE9yZGVyQnlGaWVsZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZU9yZGVyQnlBbmRJbmVxdWFsaXR5TWF0Y2gocXVlcnksIGZpbHRlci5maWVsZCwgZmlyc3RPcmRlckJ5RmllbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGNvbmZsaWN0aW5nT3AgPSBmaW5kRmlsdGVyT3BlcmF0b3IocXVlcnksIGNvbmZsaWN0aW5nT3BzKGZpbHRlci5vcCkpO1xyXG4gICAgaWYgKGNvbmZsaWN0aW5nT3AgIT09IG51bGwpIHtcclxuICAgICAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiBpdCdzIGEgZHVwbGljYXRlIG9wIHRvIGdpdmUgYSBzbGlnaHRseSBjbGVhcmVyIGVycm9yIG1lc3NhZ2UuXHJcbiAgICAgICAgaWYgKGNvbmZsaWN0aW5nT3AgPT09IGZpbHRlci5vcCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBxdWVyeS4gWW91IGNhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSAnICtcclxuICAgICAgICAgICAgICAgIGAnJHtmaWx0ZXIub3AudG9TdHJpbmcoKX0nIGZpbHRlci5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBZb3UgY2Fubm90IHVzZSAnJHtmaWx0ZXIub3AudG9TdHJpbmcoKX0nIGZpbHRlcnMgYCArXHJcbiAgICAgICAgICAgICAgICBgd2l0aCAnJHtjb25mbGljdGluZ09wLnRvU3RyaW5nKCl9JyBmaWx0ZXJzLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZU5ld09yZGVyQnkocXVlcnksIG9yZGVyQnkpIHtcclxuICAgIGlmIChnZXRGaXJzdE9yZGVyQnlGaWVsZChxdWVyeSkgPT09IG51bGwpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBvcmRlciBieS4gSXQgbXVzdCBtYXRjaCBhbnkgaW5lcXVhbGl0eS5cclxuICAgICAgICBjb25zdCBpbmVxdWFsaXR5RmllbGQgPSBnZXRJbmVxdWFsaXR5RmlsdGVyRmllbGQocXVlcnkpO1xyXG4gICAgICAgIGlmIChpbmVxdWFsaXR5RmllbGQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVPcmRlckJ5QW5kSW5lcXVhbGl0eU1hdGNoKHF1ZXJ5LCBpbmVxdWFsaXR5RmllbGQsIG9yZGVyQnkuZmllbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZU9yZGVyQnlBbmRJbmVxdWFsaXR5TWF0Y2goYmFzZVF1ZXJ5LCBpbmVxdWFsaXR5LCBvcmRlckJ5KSB7XHJcbiAgICBpZiAoIW9yZGVyQnkuaXNFcXVhbChpbmVxdWFsaXR5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsIGBJbnZhbGlkIHF1ZXJ5LiBZb3UgaGF2ZSBhIHdoZXJlIGZpbHRlciB3aXRoIGFuIGluZXF1YWxpdHkgYCArXHJcbiAgICAgICAgICAgIGAoPCwgPD0sICE9LCBub3QtaW4sID4sIG9yID49KSBvbiBmaWVsZCAnJHtpbmVxdWFsaXR5LnRvU3RyaW5nKCl9JyBgICtcclxuICAgICAgICAgICAgYGFuZCBzbyB5b3UgbXVzdCBhbHNvIHVzZSAnJHtpbmVxdWFsaXR5LnRvU3RyaW5nKCl9JyBgICtcclxuICAgICAgICAgICAgYGFzIHlvdXIgZmlyc3QgYXJndW1lbnQgdG8gb3JkZXJCeSgpLCBidXQgeW91ciBmaXJzdCBvcmRlckJ5KCkgYCArXHJcbiAgICAgICAgICAgIGBpcyBvbiBmaWVsZCAnJHtvcmRlckJ5LnRvU3RyaW5nKCl9JyBpbnN0ZWFkLmApO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBGaXJlc3RvcmUncyBpbnRlcm5hbCB0eXBlcyB0byB0aGUgSmF2YVNjcmlwdCB0eXBlcyB0aGF0IHdlIGV4cG9zZVxyXG4gKiB0byB0aGUgdXNlci5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdFVzZXJEYXRhV3JpdGVyIHtcclxuICAgIGNvbnZlcnRWYWx1ZSh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IgPSAnbm9uZScpIHtcclxuICAgICAgICBzd2l0Y2ggKHR5cGVPcmRlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgY2FzZSAwIC8qIE51bGxWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogQm9vbGVhblZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmJvb2xlYW5WYWx1ZTtcclxuICAgICAgICAgICAgY2FzZSAyIC8qIE51bWJlclZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU51bWJlcih2YWx1ZS5pbnRlZ2VyVmFsdWUgfHwgdmFsdWUuZG91YmxlVmFsdWUpO1xyXG4gICAgICAgICAgICBjYXNlIDMgLyogVGltZXN0YW1wVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0VGltZXN0YW1wKHZhbHVlLnRpbWVzdGFtcFZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSA0IC8qIFNlcnZlclRpbWVzdGFtcFZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNlcnZlclRpbWVzdGFtcCh2YWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgICAgICBjYXNlIDUgLyogU3RyaW5nVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc3RyaW5nVmFsdWU7XHJcbiAgICAgICAgICAgIGNhc2UgNiAvKiBCbG9iVmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0Qnl0ZXMobm9ybWFsaXplQnl0ZVN0cmluZyh2YWx1ZS5ieXRlc1ZhbHVlKSk7XHJcbiAgICAgICAgICAgIGNhc2UgNyAvKiBSZWZWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRSZWZlcmVuY2UodmFsdWUucmVmZXJlbmNlVmFsdWUpO1xyXG4gICAgICAgICAgICBjYXNlIDggLyogR2VvUG9pbnRWYWx1ZSAqLzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRHZW9Qb2ludCh2YWx1ZS5nZW9Qb2ludFZhbHVlKTtcclxuICAgICAgICAgICAgY2FzZSA5IC8qIEFycmF5VmFsdWUgKi86XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0QXJyYXkodmFsdWUuYXJyYXlWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgICAgICBjYXNlIDEwIC8qIE9iamVjdFZhbHVlICovOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydE9iamVjdCh2YWx1ZS5tYXBWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnZlcnRPYmplY3QobWFwVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XHJcbiAgICAgICAgZm9yRWFjaChtYXBWYWx1ZS5maWVsZHMsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpcy5jb252ZXJ0VmFsdWUodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgY29udmVydEdlb1BvaW50KHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHZW9Qb2ludChub3JtYWxpemVOdW1iZXIodmFsdWUubGF0aXR1ZGUpLCBub3JtYWxpemVOdW1iZXIodmFsdWUubG9uZ2l0dWRlKSk7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0QXJyYXkoYXJyYXlWYWx1ZSwgc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpIHtcclxuICAgICAgICByZXR1cm4gKGFycmF5VmFsdWUudmFsdWVzIHx8IFtdKS5tYXAodmFsdWUgPT4gdGhpcy5jb252ZXJ0VmFsdWUodmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKSk7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0U2VydmVyVGltZXN0YW1wKHZhbHVlLCBzZXJ2ZXJUaW1lc3RhbXBCZWhhdmlvcikge1xyXG4gICAgICAgIHN3aXRjaCAoc2VydmVyVGltZXN0YW1wQmVoYXZpb3IpIHtcclxuICAgICAgICAgICAgY2FzZSAncHJldmlvdXMnOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IGdldFByZXZpb3VzVmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFZhbHVlKHByZXZpb3VzVmFsdWUsIHNlcnZlclRpbWVzdGFtcEJlaGF2aW9yKTtcclxuICAgICAgICAgICAgY2FzZSAnZXN0aW1hdGUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFRpbWVzdGFtcChnZXRMb2NhbFdyaXRlVGltZSh2YWx1ZSkpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29udmVydFRpbWVzdGFtcCh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZVRpbWVzdGFtcCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAobm9ybWFsaXplZFZhbHVlLnNlY29uZHMsIG5vcm1hbGl6ZWRWYWx1ZS5uYW5vcyk7XHJcbiAgICB9XHJcbiAgICBjb252ZXJ0RG9jdW1lbnRLZXkobmFtZSwgZXhwZWN0ZWREYXRhYmFzZUlkKSB7XHJcbiAgICAgICAgY29uc3QgcmVzb3VyY2VQYXRoID0gUmVzb3VyY2VQYXRoLmZyb21TdHJpbmcobmFtZSk7XHJcbiAgICAgICAgaGFyZEFzc2VydChpc1ZhbGlkUmVzb3VyY2VOYW1lKHJlc291cmNlUGF0aCkpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBuZXcgRGF0YWJhc2VJZChyZXNvdXJjZVBhdGguZ2V0KDEpLCByZXNvdXJjZVBhdGguZ2V0KDMpKTtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRG9jdW1lbnRLZXkocmVzb3VyY2VQYXRoLnBvcEZpcnN0KDUpKTtcclxuICAgICAgICBpZiAoIWRhdGFiYXNlSWQuaXNFcXVhbChleHBlY3RlZERhdGFiYXNlSWQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8oYi82NDEzMDIwMik6IFNvbWVob3cgc3VwcG9ydCBmb3JlaWduIHJlZmVyZW5jZXMuXHJcbiAgICAgICAgICAgIGxvZ0Vycm9yKGBEb2N1bWVudCAke2tleX0gY29udGFpbnMgYSBkb2N1bWVudCBgICtcclxuICAgICAgICAgICAgICAgIGByZWZlcmVuY2Ugd2l0aGluIGEgZGlmZmVyZW50IGRhdGFiYXNlIChgICtcclxuICAgICAgICAgICAgICAgIGAke2RhdGFiYXNlSWQucHJvamVjdElkfS8ke2RhdGFiYXNlSWQuZGF0YWJhc2V9KSB3aGljaCBpcyBub3QgYCArXHJcbiAgICAgICAgICAgICAgICBgc3VwcG9ydGVkLiBJdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSByZWZlcmVuY2UgaW4gdGhlIGN1cnJlbnQgYCArXHJcbiAgICAgICAgICAgICAgICBgZGF0YWJhc2UgKCR7ZXhwZWN0ZWREYXRhYmFzZUlkLnByb2plY3RJZH0vJHtleHBlY3RlZERhdGFiYXNlSWQuZGF0YWJhc2V9KSBgICtcclxuICAgICAgICAgICAgICAgIGBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBjdXN0b20gbW9kZWwgb2JqZWN0IG9mIHR5cGUgVCBpbnRvIGBEb2N1bWVudERhdGFgIGJ5IGFwcGx5aW5nIHRoZVxyXG4gKiBjb252ZXJ0ZXIgaWYgaXQgZXhpc3RzLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgd2hlbiBjb252ZXJ0aW5nIHVzZXIgb2JqZWN0cyB0byBgRG9jdW1lbnREYXRhYFxyXG4gKiBiZWNhdXNlIHdlIHdhbnQgdG8gcHJvdmlkZSB0aGUgdXNlciB3aXRoIGEgbW9yZSBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIGlmXHJcbiAqIHRoZWlyIGBzZXQoKWAgb3IgZmFpbHMgZHVlIHRvIGludmFsaWQgZGF0YSBvcmlnaW5hdGluZyBmcm9tIGEgYHRvRmlyZXN0b3JlKClgXHJcbiAqIGNhbGwuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIoY29udmVydGVyLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgbGV0IGNvbnZlcnRlZFZhbHVlO1xyXG4gICAgaWYgKGNvbnZlcnRlcikge1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIChvcHRpb25zLm1lcmdlIHx8IG9wdGlvbnMubWVyZ2VGaWVsZHMpKSB7XHJcbiAgICAgICAgICAgIC8vIENhc3QgdG8gYGFueWAgaW4gb3JkZXIgdG8gc2F0aXNmeSB0aGUgdW5pb24gdHlwZSBjb25zdHJhaW50IG9uXHJcbiAgICAgICAgICAgIC8vIHRvRmlyZXN0b3JlKCkuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnZlcnRlZFZhbHVlID0gY29udmVydGVyLnRvRmlyZXN0b3JlKHZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnZlcnRlZFZhbHVlID0gY29udmVydGVyLnRvRmlyZXN0b3JlKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbnZlcnRlZFZhbHVlO1xyXG59XHJcbmNsYXNzIExpdGVVc2VyRGF0YVdyaXRlciBleHRlbmRzIEFic3RyYWN0VXNlckRhdGFXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcclxuICAgIH1cclxuICAgIGNvbnZlcnRCeXRlcyhieXRlcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXMoYnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgY29udmVydFJlZmVyZW5jZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5jb252ZXJ0RG9jdW1lbnRLZXkobmFtZSwgdGhpcy5maXJlc3RvcmUuX2RhdGFiYXNlSWQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwga2V5KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB3cml0ZSBiYXRjaCwgdXNlZCB0byBwZXJmb3JtIG11bHRpcGxlIHdyaXRlcyBhcyBhIHNpbmdsZSBhdG9taWMgdW5pdC5cclxuICpcclxuICogQSBgV3JpdGVCYXRjaGAgb2JqZWN0IGNhbiBiZSBhY3F1aXJlZCBieSBjYWxsaW5nIHtAbGluayB3cml0ZUJhdGNofS4gSXRcclxuICogcHJvdmlkZXMgbWV0aG9kcyBmb3IgYWRkaW5nIHdyaXRlcyB0byB0aGUgd3JpdGUgYmF0Y2guIE5vbmUgb2YgdGhlIHdyaXRlc1xyXG4gKiB3aWxsIGJlIGNvbW1pdHRlZCAob3IgdmlzaWJsZSBsb2NhbGx5KSB1bnRpbCB7QGxpbmsgV3JpdGVCYXRjaC5jb21taXR9IGlzXHJcbiAqIGNhbGxlZC5cclxuICovXHJcbmNsYXNzIFdyaXRlQmF0Y2gge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF9jb21taXRIYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcclxuICAgICAgICB0aGlzLl9jb21taXRIYW5kbGVyID0gX2NvbW1pdEhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5fY29tbWl0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKF9maXJlc3RvcmUpO1xyXG4gICAgfVxyXG4gICAgc2V0KGRvY3VtZW50UmVmLCBkYXRhLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmLmNvbnZlcnRlciwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTZXREYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdXcml0ZUJhdGNoLnNldCcsIHJlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmLmNvbnZlcnRlciAhPT0gbnVsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zLnB1c2gocGFyc2VkLnRvTXV0YXRpb24ocmVmLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHVwZGF0ZShkb2N1bWVudFJlZiwgZmllbGRPclVwZGF0ZURhdGEsIHZhbHVlLCAuLi5tb3JlRmllbGRzQW5kVmFsdWVzKSB7XHJcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgLy8gRm9yIENvbXBhdCB0eXBlcywgd2UgaGF2ZSB0byBcImV4dHJhY3RcIiB0aGUgdW5kZXJseWluZyB0eXBlcyBiZWZvcmVcclxuICAgICAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXHJcbiAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgPSBnZXRNb2R1bGFySW5zdGFuY2UoZmllbGRPclVwZGF0ZURhdGEpO1xyXG4gICAgICAgIGxldCBwYXJzZWQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZE9yVXBkYXRlRGF0YSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICAgICAgZmllbGRPclVwZGF0ZURhdGEgaW5zdGFuY2VvZiBGaWVsZFBhdGgpIHtcclxuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVWYXJhcmdzKHRoaXMuX2RhdGFSZWFkZXIsICdXcml0ZUJhdGNoLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIG1vcmVGaWVsZHNBbmRWYWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVEYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdXcml0ZUJhdGNoLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX211dGF0aW9ucy5wdXNoKHBhcnNlZC50b011dGF0aW9uKHJlZi5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHJldHVybnMgVGhpcyBgV3JpdGVCYXRjaGAgaW5zdGFuY2UuIFVzZWQgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgZGVsZXRlKGRvY3VtZW50UmVmKSB7XHJcbiAgICAgICAgdGhpcy5fdmVyaWZ5Tm90Q29tbWl0dGVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgdGhpcy5fbXV0YXRpb25zID0gdGhpcy5fbXV0YXRpb25zLmNvbmNhdChuZXcgRGVsZXRlTXV0YXRpb24ocmVmLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0cyBhbGwgb2YgdGhlIHdyaXRlcyBpbiB0aGlzIHdyaXRlIGJhdGNoIGFzIGEgc2luZ2xlIGF0b21pYyB1bml0LlxyXG4gICAgICpcclxuICAgICAqIFRoZSByZXN1bHQgb2YgdGhlc2Ugd3JpdGVzIHdpbGwgb25seSBiZSByZWZsZWN0ZWQgaW4gZG9jdW1lbnQgcmVhZHMgdGhhdFxyXG4gICAgICogb2NjdXIgYWZ0ZXIgdGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMuIElmIHRoZSBjbGllbnQgaXMgb2ZmbGluZSwgdGhlXHJcbiAgICAgKiB3cml0ZSBmYWlscy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGxvY2FsIG1vZGlmaWNhdGlvbnMgb3IgYnVmZmVyIHdyaXRlc1xyXG4gICAgICogdW50aWwgdGhlIGNsaWVudCBpcyBvbmxpbmUsIHVzZSB0aGUgZnVsbCBGaXJlc3RvcmUgU0RLLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIG9uY2UgYWxsIG9mIHRoZSB3cml0ZXMgaW4gdGhlIGJhdGNoIGhhdmUgYmVlblxyXG4gICAgICogc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4gdG8gdGhlIGJhY2tlbmQgYXMgYW4gYXRvbWljIHVuaXQgKG5vdGUgdGhhdCBpdCB3b24ndFxyXG4gICAgICogcmVzb2x2ZSB3aGlsZSB5b3UncmUgb2ZmbGluZSkuXHJcbiAgICAgKi9cclxuICAgIGNvbW1pdCgpIHtcclxuICAgICAgICB0aGlzLl92ZXJpZnlOb3RDb21taXR0ZWQoKTtcclxuICAgICAgICB0aGlzLl9jb21taXR0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9tdXRhdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tbWl0SGFuZGxlcih0aGlzLl9tdXRhdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBfdmVyaWZ5Tm90Q29tbWl0dGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb21taXR0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuRkFJTEVEX1BSRUNPTkRJVElPTiwgJ0Egd3JpdGUgYmF0Y2ggY2FuIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyIGNvbW1pdCgpICcgK1xyXG4gICAgICAgICAgICAgICAgJ2hhcyBiZWVuIGNhbGxlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIGZpcmVzdG9yZSkge1xyXG4gICAgZG9jdW1lbnRSZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UoZG9jdW1lbnRSZWYpO1xyXG4gICAgaWYgKGRvY3VtZW50UmVmLmZpcmVzdG9yZSAhPT0gZmlyZXN0b3JlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVzdG9yZUVycm9yKENvZGUuSU5WQUxJRF9BUkdVTUVOVCwgJ1Byb3ZpZGVkIGRvY3VtZW50IHJlZmVyZW5jZSBpcyBmcm9tIGEgZGlmZmVyZW50IEZpcmVzdG9yZSBpbnN0YW5jZS4nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudFJlZjtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBUT0RPKG1yc2NobWlkdCkgQ29uc2lkZXIgdXNpbmcgYEJhc2VUcmFuc2FjdGlvbmAgYXMgdGhlIGJhc2UgY2xhc3MgaW4gdGhlXHJcbi8vIGxlZ2FjeSBTREsuXHJcbi8qKlxyXG4gKiBBIHJlZmVyZW5jZSB0byBhIHRyYW5zYWN0aW9uLlxyXG4gKlxyXG4gKiBUaGUgYFRyYW5zYWN0aW9uYCBvYmplY3QgcGFzc2VkIHRvIGEgdHJhbnNhY3Rpb24ncyBgdXBkYXRlRnVuY3Rpb25gIHByb3ZpZGVzXHJcbiAqIHRoZSBtZXRob2RzIHRvIHJlYWQgYW5kIHdyaXRlIGRhdGEgd2l0aGluIHRoZSB0cmFuc2FjdGlvbiBjb250ZXh0LiBTZWVcclxuICoge0BsaW5rIHJ1blRyYW5zYWN0aW9ufS5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uJDEge1xyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2ZpcmVzdG9yZSA9IF9maXJlc3RvcmU7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBfdHJhbnNhY3Rpb247XHJcbiAgICAgICAgdGhpcy5fZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKF9maXJlc3RvcmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aGUgZG9jdW1lbnQgcmVmZXJlbmNlZCBieSB0aGUgcHJvdmlkZWQge0BsaW5rIERvY3VtZW50UmVmZXJlbmNlfS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWYgLSBBIHJlZmVyZW5jZSB0byB0aGUgZG9jdW1lbnQgdG8gYmUgcmVhZC5cclxuICAgICAqIEByZXR1cm5zIEEgYERvY3VtZW50U25hcHNob3RgIHdpdGggdGhlIHJlYWQgZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0KGRvY3VtZW50UmVmKSB7XHJcbiAgICAgICAgY29uc3QgcmVmID0gdmFsaWRhdGVSZWZlcmVuY2UoZG9jdW1lbnRSZWYsIHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgTGl0ZVVzZXJEYXRhV3JpdGVyKHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uLmxvb2t1cChbcmVmLl9rZXldKS50aGVuKGRvY3MgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWRvY3MgfHwgZG9jcy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZG9jID0gZG9jc1swXTtcclxuICAgICAgICAgICAgaWYgKGRvYy5pc0ZvdW5kRG9jdW1lbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudFNuYXBzaG90JDEodGhpcy5fZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgZG9jLmtleSwgZG9jLCByZWYuY29udmVydGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkb2MuaXNOb0RvY3VtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRTbmFwc2hvdCQxKHRoaXMuX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHJlZi5fa2V5LCBudWxsLCByZWYuY29udmVydGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGZhaWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0KGRvY3VtZW50UmVmLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xyXG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZi5jb252ZXJ0ZXIsIHZhbHVlLCBvcHRpb25zKTtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldERhdGEodGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnNldCcsIHJlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmLmNvbnZlcnRlciAhPT0gbnVsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24uc2V0KHJlZi5fa2V5LCBwYXJzZWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRvY3VtZW50UmVmLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcclxuICAgICAgICBjb25zdCByZWYgPSB2YWxpZGF0ZVJlZmVyZW5jZShkb2N1bWVudFJlZiwgdGhpcy5fZmlyZXN0b3JlKTtcclxuICAgICAgICAvLyBGb3IgQ29tcGF0IHR5cGVzLCB3ZSBoYXZlIHRvIFwiZXh0cmFjdFwiIHRoZSB1bmRlcmx5aW5nIHR5cGVzIGJlZm9yZVxyXG4gICAgICAgIC8vIHBlcmZvcm1pbmcgdmFsaWRhdGlvbi5cclxuICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSA9IGdldE1vZHVsYXJJbnN0YW5jZShmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICAgICAgbGV0IHBhcnNlZDtcclxuICAgICAgICBpZiAodHlwZW9mIGZpZWxkT3JVcGRhdGVEYXRhID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xyXG4gICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZVZhcmFyZ3ModGhpcy5fZGF0YVJlYWRlciwgJ1RyYW5zYWN0aW9uLnVwZGF0ZScsIHJlZi5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIG1vcmVGaWVsZHNBbmRWYWx1ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VVcGRhdGVEYXRhKHRoaXMuX2RhdGFSZWFkZXIsICdUcmFuc2FjdGlvbi51cGRhdGUnLCByZWYuX2tleSwgZmllbGRPclVwZGF0ZURhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbi51cGRhdGUocmVmLl9rZXksIHBhcnNlZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoZSBwcm92aWRlZCB7QGxpbmsgRG9jdW1lbnRSZWZlcmVuY2V9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudFJlZiAtIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCB0byBiZSBkZWxldGVkLlxyXG4gICAgICogQHJldHVybnMgVGhpcyBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBVc2VkIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZShkb2N1bWVudFJlZikge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLmRlbGV0ZShyZWYuX2tleSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQYXJ0aWFsT2JzZXJ2ZXIob2JqKSB7XHJcbiAgICByZXR1cm4gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBbJ25leHQnLCAnZXJyb3InLCAnY29tcGxldGUnXSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYW4gb2JqZWN0IGFuZCBjb250YWlucyBhdCBsZWFzdCBvbmUgb2YgdGhlIHNwZWNpZmllZFxyXG4gKiBtZXRob2RzLlxyXG4gKi9cclxuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBtZXRob2RzKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2JqZWN0ID0gb2JqO1xyXG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xyXG4gICAgICAgIGlmIChtZXRob2QgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJlYWRzIHRoZSBkb2N1bWVudCByZWZlcnJlZCB0byBieSB0aGlzIGBEb2N1bWVudFJlZmVyZW5jZWAuXHJcbiAqXHJcbiAqIE5vdGU6IGBnZXREb2MoKWAgYXR0ZW1wdHMgdG8gcHJvdmlkZSB1cC10by1kYXRlIGRhdGEgd2hlbiBwb3NzaWJsZSBieSB3YWl0aW5nXHJcbiAqIGZvciBkYXRhIGZyb20gdGhlIHNlcnZlciwgYnV0IGl0IG1heSByZXR1cm4gY2FjaGVkIGRhdGEgb3IgZmFpbCBpZiB5b3UgYXJlXHJcbiAqIG9mZmxpbmUgYW5kIHRoZSBzZXJ2ZXIgY2Fubm90IGJlIHJlYWNoZWQuIFRvIHNwZWNpZnkgdGhpcyBiZWhhdmlvciwgaW52b2tlXHJcbiAqIHtAbGluayBnZXREb2NGcm9tQ2FjaGV9IG9yIHtAbGluayBnZXREb2NGcm9tU2VydmVyfS5cclxuICpcclxuICogQHBhcmFtIHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2Ugb2YgdGhlIGRvY3VtZW50IHRvIGZldGNoLlxyXG4gKiBAcmV0dXJucyBBIFByb21pc2UgcmVzb2x2ZWQgd2l0aCBhIGBEb2N1bWVudFNuYXBzaG90YCBjb250YWluaW5nIHRoZVxyXG4gKiBjdXJyZW50IGRvY3VtZW50IGNvbnRlbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jKHJlZmVyZW5jZSkge1xyXG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudFZpYVNuYXBzaG90TGlzdGVuZXIoY2xpZW50LCByZWZlcmVuY2UuX2tleSkudGhlbihzbmFwc2hvdCA9PiBjb252ZXJ0VG9Eb2NTbmFwc2hvdChmaXJlc3RvcmUsIHJlZmVyZW5jZSwgc25hcHNob3QpKTtcclxufVxyXG5jbGFzcyBFeHBVc2VyRGF0YVdyaXRlciBleHRlbmRzIEFic3RyYWN0VXNlckRhdGFXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZmlyZXN0b3JlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmZpcmVzdG9yZSA9IGZpcmVzdG9yZTtcclxuICAgIH1cclxuICAgIGNvbnZlcnRCeXRlcyhieXRlcykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQnl0ZXMoYnl0ZXMpO1xyXG4gICAgfVxyXG4gICAgY29udmVydFJlZmVyZW5jZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5jb252ZXJ0RG9jdW1lbnRLZXkobmFtZSwgdGhpcy5maXJlc3RvcmUuX2RhdGFiYXNlSWQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRSZWZlcmVuY2UodGhpcy5maXJlc3RvcmUsIC8qIGNvbnZlcnRlcj0gKi8gbnVsbCwga2V5KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVhZHMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoaXMgYERvY3VtZW50UmVmZXJlbmNlYCBmcm9tIGNhY2hlLlxyXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIHRoZSBkb2N1bWVudCBpcyBub3QgY3VycmVudGx5IGNhY2hlZC5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgd2l0aCBhIGBEb2N1bWVudFNuYXBzaG90YCBjb250YWluaW5nIHRoZVxyXG4gKiBjdXJyZW50IGRvY3VtZW50IGNvbnRlbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jRnJvbUNhY2hlKHJlZmVyZW5jZSkge1xyXG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRGcm9tTG9jYWxDYWNoZShjbGllbnQsIHJlZmVyZW5jZS5fa2V5KS50aGVuKGRvYyA9PiBuZXcgRG9jdW1lbnRTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWZlcmVuY2UuX2tleSwgZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShkb2MgIT09IG51bGwgJiYgZG9jLmhhc0xvY2FsTXV0YXRpb25zLCBcclxuICAgIC8qIGZyb21DYWNoZT0gKi8gdHJ1ZSksIHJlZmVyZW5jZS5jb252ZXJ0ZXIpKTtcclxufVxyXG4vKipcclxuICogUmVhZHMgdGhlIGRvY3VtZW50IHJlZmVycmVkIHRvIGJ5IHRoaXMgYERvY3VtZW50UmVmZXJlbmNlYCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIG5ldHdvcmsgaXMgbm90IGF2YWlsYWJsZS5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgcmVzb2x2ZWQgd2l0aCBhIGBEb2N1bWVudFNuYXBzaG90YCBjb250YWluaW5nIHRoZVxyXG4gKiBjdXJyZW50IGRvY3VtZW50IGNvbnRlbnRzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jRnJvbVNlcnZlcihyZWZlcmVuY2UpIHtcclxuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRWaWFTbmFwc2hvdExpc3RlbmVyKGNsaWVudCwgcmVmZXJlbmNlLl9rZXksIHtcclxuICAgICAgICBzb3VyY2U6ICdzZXJ2ZXInXHJcbiAgICB9KS50aGVuKHNuYXBzaG90ID0+IGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmZXJlbmNlLCBzbmFwc2hvdCkpO1xyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgYW5kIHJldHVybnMgdGhlIHJlc3VsdHMgYXMgYSBgUXVlcnlTbmFwc2hvdGAuXHJcbiAqXHJcbiAqIE5vdGU6IGBnZXREb2NzKClgIGF0dGVtcHRzIHRvIHByb3ZpZGUgdXAtdG8tZGF0ZSBkYXRhIHdoZW4gcG9zc2libGUgYnlcclxuICogd2FpdGluZyBmb3IgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIGJ1dCBpdCBtYXkgcmV0dXJuIGNhY2hlZCBkYXRhIG9yIGZhaWwgaWZcclxuICogeW91IGFyZSBvZmZsaW5lIGFuZCB0aGUgc2VydmVyIGNhbm5vdCBiZSByZWFjaGVkLiBUbyBzcGVjaWZ5IHRoaXMgYmVoYXZpb3IsXHJcbiAqIGludm9rZSB7QGxpbmsgZ2V0RG9jc0Zyb21DYWNoZX0gb3Ige0BsaW5rIGdldERvY3NGcm9tU2VydmVyfS5cclxuICpcclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jcyhxdWVyeSkge1xyXG4gICAgcXVlcnkgPSBjYXN0KHF1ZXJ5LCBRdWVyeSk7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XHJcbiAgICB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHF1ZXJ5Ll9xdWVyeSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzVmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIHF1ZXJ5Ll9xdWVyeSkudGhlbihzbmFwc2hvdCA9PiBuZXcgUXVlcnlTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBxdWVyeSwgc25hcHNob3QpKTtcclxufVxyXG4vKipcclxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgYFF1ZXJ5U25hcHNob3RgIGZyb20gY2FjaGUuXHJcbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgdGhlIGRvY3VtZW50IGlzIG5vdCBjdXJyZW50bHkgY2FjaGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2NzRnJvbUNhY2hlKHF1ZXJ5KSB7XHJcbiAgICBxdWVyeSA9IGNhc3QocXVlcnksIFF1ZXJ5KTtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocXVlcnkuZmlyZXN0b3JlLCBGaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRHZXREb2N1bWVudHNGcm9tTG9jYWxDYWNoZShjbGllbnQsIHF1ZXJ5Ll9xdWVyeSkudGhlbihzbmFwc2hvdCA9PiBuZXcgUXVlcnlTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCBxdWVyeSwgc25hcHNob3QpKTtcclxufVxyXG4vKipcclxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIGFzIGEgYFF1ZXJ5U25hcHNob3RgIGZyb20gdGhlXHJcbiAqIHNlcnZlci4gUmV0dXJucyBhbiBlcnJvciBpZiB0aGUgbmV0d29yayBpcyBub3QgYXZhaWxhYmxlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREb2NzRnJvbVNlcnZlcihxdWVyeSkge1xyXG4gICAgcXVlcnkgPSBjYXN0KHF1ZXJ5LCBRdWVyeSk7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHF1ZXJ5LmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50R2V0RG9jdW1lbnRzVmlhU25hcHNob3RMaXN0ZW5lcihjbGllbnQsIHF1ZXJ5Ll9xdWVyeSwge1xyXG4gICAgICAgIHNvdXJjZTogJ3NlcnZlcidcclxuICAgIH0pLnRoZW4oc25hcHNob3QgPT4gbmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0RG9jKHJlZmVyZW5jZSwgZGF0YSwgb3B0aW9ucykge1xyXG4gICAgcmVmZXJlbmNlID0gY2FzdChyZWZlcmVuY2UsIERvY3VtZW50UmVmZXJlbmNlKTtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gYXBwbHlGaXJlc3RvcmVEYXRhQ29udmVydGVyKHJlZmVyZW5jZS5jb252ZXJ0ZXIsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgY29uc3QgZGF0YVJlYWRlciA9IG5ld1VzZXJEYXRhUmVhZGVyKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldERhdGEoZGF0YVJlYWRlciwgJ3NldERvYycsIHJlZmVyZW5jZS5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmZXJlbmNlLmNvbnZlcnRlciAhPT0gbnVsbCwgb3B0aW9ucyk7XHJcbiAgICBjb25zdCBtdXRhdGlvbiA9IHBhcnNlZC50b011dGF0aW9uKHJlZmVyZW5jZS5fa2V5LCBQcmVjb25kaXRpb24ubm9uZSgpKTtcclxuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBbbXV0YXRpb25dKTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVEb2MocmVmZXJlbmNlLCBmaWVsZE9yVXBkYXRlRGF0YSwgdmFsdWUsIC4uLm1vcmVGaWVsZHNBbmRWYWx1ZXMpIHtcclxuICAgIHJlZmVyZW5jZSA9IGNhc3QocmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSk7XHJcbiAgICBjb25zdCBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBkYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIoZmlyZXN0b3JlKTtcclxuICAgIC8vIEZvciBDb21wYXQgdHlwZXMsIHdlIGhhdmUgdG8gXCJleHRyYWN0XCIgdGhlIHVuZGVybHlpbmcgdHlwZXMgYmVmb3JlXHJcbiAgICAvLyBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXHJcbiAgICBmaWVsZE9yVXBkYXRlRGF0YSA9IGdldE1vZHVsYXJJbnN0YW5jZShmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICBsZXQgcGFyc2VkO1xyXG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yVXBkYXRlRGF0YSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICBmaWVsZE9yVXBkYXRlRGF0YSBpbnN0YW5jZW9mIEZpZWxkUGF0aCkge1xyXG4gICAgICAgIHBhcnNlZCA9IHBhcnNlVXBkYXRlVmFyYXJncyhkYXRhUmVhZGVyLCAndXBkYXRlRG9jJywgcmVmZXJlbmNlLl9rZXksIGZpZWxkT3JVcGRhdGVEYXRhLCB2YWx1ZSwgbW9yZUZpZWxkc0FuZFZhbHVlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXJzZWQgPSBwYXJzZVVwZGF0ZURhdGEoZGF0YVJlYWRlciwgJ3VwZGF0ZURvYycsIHJlZmVyZW5jZS5fa2V5LCBmaWVsZE9yVXBkYXRlRGF0YSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtdXRhdGlvbiA9IHBhcnNlZC50b011dGF0aW9uKHJlZmVyZW5jZS5fa2V5LCBQcmVjb25kaXRpb24uZXhpc3RzKHRydWUpKTtcclxuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBbbXV0YXRpb25dKTtcclxufVxyXG4vKipcclxuICogRGVsZXRlcyB0aGUgZG9jdW1lbnQgcmVmZXJyZWQgdG8gYnkgdGhlIHNwZWNpZmllZCBgRG9jdW1lbnRSZWZlcmVuY2VgLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGRlbGV0ZS5cclxuICogQHJldHVybnMgQSBQcm9taXNlIHJlc29sdmVkIG9uY2UgdGhlIGRvY3VtZW50IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseVxyXG4gKiBkZWxldGVkIGZyb20gdGhlIGJhY2tlbmQgKG5vdGUgdGhhdCBpdCB3b24ndCByZXNvbHZlIHdoaWxlIHlvdSdyZSBvZmZsaW5lKS5cclxuICovXHJcbmZ1bmN0aW9uIGRlbGV0ZURvYyhyZWZlcmVuY2UpIHtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IG11dGF0aW9ucyA9IFtuZXcgRGVsZXRlTXV0YXRpb24ocmVmZXJlbmNlLl9rZXksIFByZWNvbmRpdGlvbi5ub25lKCkpXTtcclxuICAgIHJldHVybiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBtdXRhdGlvbnMpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGQgYSBuZXcgZG9jdW1lbnQgdG8gc3BlY2lmaWVkIGBDb2xsZWN0aW9uUmVmZXJlbmNlYCB3aXRoIHRoZSBnaXZlbiBkYXRhLFxyXG4gKiBhc3NpZ25pbmcgaXQgYSBkb2N1bWVudCBJRCBhdXRvbWF0aWNhbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmZXJlbmNlIC0gQSByZWZlcmVuY2UgdG8gdGhlIGNvbGxlY3Rpb24gdG8gYWRkIHRoaXMgZG9jdW1lbnQgdG8uXHJcbiAqIEBwYXJhbSBkYXRhIC0gQW4gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgZm9yIHRoZSBuZXcgZG9jdW1lbnQuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHJlc29sdmVkIHdpdGggYSBgRG9jdW1lbnRSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZVxyXG4gKiBuZXdseSBjcmVhdGVkIGRvY3VtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHdyaXR0ZW4gdG8gdGhlIGJhY2tlbmQgKE5vdGUgdGhhdCBpdFxyXG4gKiB3b24ndCByZXNvbHZlIHdoaWxlIHlvdSdyZSBvZmZsaW5lKS5cclxuICovXHJcbmZ1bmN0aW9uIGFkZERvYyhyZWZlcmVuY2UsIGRhdGEpIHtcclxuICAgIGNvbnN0IGZpcmVzdG9yZSA9IGNhc3QocmVmZXJlbmNlLmZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhyZWZlcmVuY2UpO1xyXG4gICAgY29uc3QgY29udmVydGVkVmFsdWUgPSBhcHBseUZpcmVzdG9yZURhdGFDb252ZXJ0ZXIocmVmZXJlbmNlLmNvbnZlcnRlciwgZGF0YSk7XHJcbiAgICBjb25zdCBkYXRhUmVhZGVyID0gbmV3VXNlckRhdGFSZWFkZXIocmVmZXJlbmNlLmZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNldERhdGEoZGF0YVJlYWRlciwgJ2FkZERvYycsIGRvY1JlZi5fa2V5LCBjb252ZXJ0ZWRWYWx1ZSwgcmVmZXJlbmNlLmNvbnZlcnRlciAhPT0gbnVsbCwge30pO1xyXG4gICAgY29uc3QgbXV0YXRpb24gPSBwYXJzZWQudG9NdXRhdGlvbihkb2NSZWYuX2tleSwgUHJlY29uZGl0aW9uLmV4aXN0cyhmYWxzZSkpO1xyXG4gICAgcmV0dXJuIGV4ZWN1dGVXcml0ZShmaXJlc3RvcmUsIFttdXRhdGlvbl0pLnRoZW4oKCkgPT4gZG9jUmVmKTtcclxufVxyXG5mdW5jdGlvbiBvblNuYXBzaG90KHJlZmVyZW5jZSwgLi4uYXJncykge1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICByZWZlcmVuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmZXJlbmNlKTtcclxuICAgIGxldCBvcHRpb25zID0ge1xyXG4gICAgICAgIGluY2x1ZGVNZXRhZGF0YUNoYW5nZXM6IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgbGV0IGN1cnJBcmcgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiBhcmdzW2N1cnJBcmddID09PSAnb2JqZWN0JyAmJiAhaXNQYXJ0aWFsT2JzZXJ2ZXIoYXJnc1tjdXJyQXJnXSkpIHtcclxuICAgICAgICBvcHRpb25zID0gYXJnc1tjdXJyQXJnXTtcclxuICAgICAgICBjdXJyQXJnKys7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnRlcm5hbE9wdGlvbnMgPSB7XHJcbiAgICAgICAgaW5jbHVkZU1ldGFkYXRhQ2hhbmdlczogb3B0aW9ucy5pbmNsdWRlTWV0YWRhdGFDaGFuZ2VzXHJcbiAgICB9O1xyXG4gICAgaWYgKGlzUGFydGlhbE9ic2VydmVyKGFyZ3NbY3VyckFyZ10pKSB7XHJcbiAgICAgICAgY29uc3QgdXNlck9ic2VydmVyID0gYXJnc1tjdXJyQXJnXTtcclxuICAgICAgICBhcmdzW2N1cnJBcmddID0gKF9hID0gdXNlck9ic2VydmVyLm5leHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKHVzZXJPYnNlcnZlcik7XHJcbiAgICAgICAgYXJnc1tjdXJyQXJnICsgMV0gPSAoX2IgPSB1c2VyT2JzZXJ2ZXIuZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iaW5kKHVzZXJPYnNlcnZlcik7XHJcbiAgICAgICAgYXJnc1tjdXJyQXJnICsgMl0gPSAoX2MgPSB1c2VyT2JzZXJ2ZXIuY29tcGxldGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iaW5kKHVzZXJPYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICBsZXQgb2JzZXJ2ZXI7XHJcbiAgICBsZXQgZmlyZXN0b3JlO1xyXG4gICAgbGV0IGludGVybmFsUXVlcnk7XHJcbiAgICBpZiAocmVmZXJlbmNlIGluc3RhbmNlb2YgRG9jdW1lbnRSZWZlcmVuY2UpIHtcclxuICAgICAgICBmaXJlc3RvcmUgPSBjYXN0KHJlZmVyZW5jZS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICAgICAgaW50ZXJuYWxRdWVyeSA9IG5ld1F1ZXJ5Rm9yUGF0aChyZWZlcmVuY2UuX2tleS5wYXRoKTtcclxuICAgICAgICBvYnNlcnZlciA9IHtcclxuICAgICAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NbY3VyckFyZ10pIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2N1cnJBcmddKGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmZXJlbmNlLCBzbmFwc2hvdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcnJvcjogYXJnc1tjdXJyQXJnICsgMV0sXHJcbiAgICAgICAgICAgIGNvbXBsZXRlOiBhcmdzW2N1cnJBcmcgKyAyXVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBxdWVyeSA9IGNhc3QocmVmZXJlbmNlLCBRdWVyeSk7XHJcbiAgICAgICAgZmlyZXN0b3JlID0gY2FzdChxdWVyeS5maXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICAgICAgaW50ZXJuYWxRdWVyeSA9IHF1ZXJ5Ll9xdWVyeTtcclxuICAgICAgICBjb25zdCB1c2VyRGF0YVdyaXRlciA9IG5ldyBFeHBVc2VyRGF0YVdyaXRlcihmaXJlc3RvcmUpO1xyXG4gICAgICAgIG9ic2VydmVyID0ge1xyXG4gICAgICAgICAgICBuZXh0OiBzbmFwc2hvdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tjdXJyQXJnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbY3VyckFyZ10obmV3IFF1ZXJ5U25hcHNob3QoZmlyZXN0b3JlLCB1c2VyRGF0YVdyaXRlciwgcXVlcnksIHNuYXBzaG90KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yOiBhcmdzW2N1cnJBcmcgKyAxXSxcclxuICAgICAgICAgICAgY29tcGxldGU6IGFyZ3NbY3VyckFyZyArIDJdXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YWxpZGF0ZUhhc0V4cGxpY2l0T3JkZXJCeUZvckxpbWl0VG9MYXN0KHJlZmVyZW5jZS5fcXVlcnkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY2xpZW50ID0gZW5zdXJlRmlyZXN0b3JlQ29uZmlndXJlZChmaXJlc3RvcmUpO1xyXG4gICAgcmV0dXJuIGZpcmVzdG9yZUNsaWVudExpc3RlbihjbGllbnQsIGludGVybmFsUXVlcnksIGludGVybmFsT3B0aW9ucywgb2JzZXJ2ZXIpO1xyXG59XHJcbmZ1bmN0aW9uIG9uU25hcHNob3RzSW5TeW5jKGZpcmVzdG9yZSwgYXJnKSB7XHJcbiAgICBmaXJlc3RvcmUgPSBjYXN0KGZpcmVzdG9yZSwgRmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIGNvbnN0IG9ic2VydmVyID0gaXNQYXJ0aWFsT2JzZXJ2ZXIoYXJnKVxyXG4gICAgICAgID8gYXJnXHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIG5leHQ6IGFyZ1xyXG4gICAgICAgIH07XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50QWRkU25hcHNob3RzSW5TeW5jTGlzdGVuZXIoY2xpZW50LCBvYnNlcnZlcik7XHJcbn1cclxuLyoqXHJcbiAqIExvY2FsbHkgd3JpdGVzIGBtdXRhdGlvbnNgIG9uIHRoZSBhc3luYyBxdWV1ZS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBleGVjdXRlV3JpdGUoZmlyZXN0b3JlLCBtdXRhdGlvbnMpIHtcclxuICAgIGNvbnN0IGNsaWVudCA9IGVuc3VyZUZpcmVzdG9yZUNvbmZpZ3VyZWQoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBmaXJlc3RvcmVDbGllbnRXcml0ZShjbGllbnQsIG11dGF0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEge0BsaW5rIFZpZXdTbmFwc2hvdH0gdGhhdCBjb250YWlucyB0aGUgc2luZ2xlIGRvY3VtZW50IHNwZWNpZmllZCBieSBgcmVmYFxyXG4gKiB0byBhIHtAbGluayBEb2N1bWVudFNuYXBzaG90fS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRUb0RvY1NuYXBzaG90KGZpcmVzdG9yZSwgcmVmLCBzbmFwc2hvdCkge1xyXG4gICAgY29uc3QgZG9jID0gc25hcHNob3QuZG9jcy5nZXQocmVmLl9rZXkpO1xyXG4gICAgY29uc3QgdXNlckRhdGFXcml0ZXIgPSBuZXcgRXhwVXNlckRhdGFXcml0ZXIoZmlyZXN0b3JlKTtcclxuICAgIHJldHVybiBuZXcgRG9jdW1lbnRTbmFwc2hvdChmaXJlc3RvcmUsIHVzZXJEYXRhV3JpdGVyLCByZWYuX2tleSwgZG9jLCBuZXcgU25hcHNob3RNZXRhZGF0YShzbmFwc2hvdC5oYXNQZW5kaW5nV3JpdGVzLCBzbmFwc2hvdC5mcm9tQ2FjaGUpLCByZWYuY29udmVydGVyKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSByZWZlcmVuY2UgdG8gYSB0cmFuc2FjdGlvbi5cclxuICpcclxuICogVGhlIGBUcmFuc2FjdGlvbmAgb2JqZWN0IHBhc3NlZCB0byBhIHRyYW5zYWN0aW9uJ3MgYHVwZGF0ZUZ1bmN0aW9uYCBwcm92aWRlc1xyXG4gKiB0aGUgbWV0aG9kcyB0byByZWFkIGFuZCB3cml0ZSBkYXRhIHdpdGhpbiB0aGUgdHJhbnNhY3Rpb24gY29udGV4dC4gU2VlXHJcbiAqIHtAbGluayBydW5UcmFuc2FjdGlvbn0uXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zYWN0aW9uJDEge1xyXG4gICAgLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBzYW1lIGxvZ2ljIGFzIHRoZSBUcmFuc2FjdGlvbiBBUEkgaW4gdGhlIExpdGUgU0RLXHJcbiAgICAvLyBidXQgaXMgc3ViY2xhc3NlZCBpbiBvcmRlciB0byByZXR1cm4gaXRzIG93biBEb2N1bWVudFNuYXBzaG90IHR5cGVzLlxyXG4gICAgLyoqIEBoaWRlY29uc3RydWN0b3IgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbikge1xyXG4gICAgICAgIHN1cGVyKF9maXJlc3RvcmUsIF90cmFuc2FjdGlvbik7XHJcbiAgICAgICAgdGhpcy5fZmlyZXN0b3JlID0gX2ZpcmVzdG9yZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgdGhlIGRvY3VtZW50IHJlZmVyZW5jZWQgYnkgdGhlIHByb3ZpZGVkIHtAbGluayBEb2N1bWVudFJlZmVyZW5jZX0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50UmVmIC0gQSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50IHRvIGJlIHJlYWQuXHJcbiAgICAgKiBAcmV0dXJucyBBIGBEb2N1bWVudFNuYXBzaG90YCB3aXRoIHRoZSByZWFkIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldChkb2N1bWVudFJlZikge1xyXG4gICAgICAgIGNvbnN0IHJlZiA9IHZhbGlkYXRlUmVmZXJlbmNlKGRvY3VtZW50UmVmLCB0aGlzLl9maXJlc3RvcmUpO1xyXG4gICAgICAgIGNvbnN0IHVzZXJEYXRhV3JpdGVyID0gbmV3IEV4cFVzZXJEYXRhV3JpdGVyKHRoaXMuX2ZpcmVzdG9yZSk7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyXHJcbiAgICAgICAgICAgIC5nZXQoZG9jdW1lbnRSZWYpXHJcbiAgICAgICAgICAgIC50aGVuKGxpdGVEb2N1bWVudFNuYXBzaG90ID0+IG5ldyBEb2N1bWVudFNuYXBzaG90KHRoaXMuX2ZpcmVzdG9yZSwgdXNlckRhdGFXcml0ZXIsIHJlZi5fa2V5LCBsaXRlRG9jdW1lbnRTbmFwc2hvdC5fZG9jdW1lbnQsIG5ldyBTbmFwc2hvdE1ldGFkYXRhKFxyXG4gICAgICAgIC8qIGhhc1BlbmRpbmdXcml0ZXM9ICovIGZhbHNlLCBcclxuICAgICAgICAvKiBmcm9tQ2FjaGU9ICovIGZhbHNlKSwgcmVmLmNvbnZlcnRlcikpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFeGVjdXRlcyB0aGUgZ2l2ZW4gYHVwZGF0ZUZ1bmN0aW9uYCBhbmQgdGhlbiBhdHRlbXB0cyB0byBjb21taXQgdGhlIGNoYW5nZXNcclxuICogYXBwbGllZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uLiBJZiBhbnkgZG9jdW1lbnQgcmVhZCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXHJcbiAqIGhhcyBjaGFuZ2VkLCBDbG91ZCBGaXJlc3RvcmUgcmV0cmllcyB0aGUgYHVwZGF0ZUZ1bmN0aW9uYC4gSWYgaXQgZmFpbHMgdG9cclxuICogY29tbWl0IGFmdGVyIDUgYXR0ZW1wdHMsIHRoZSB0cmFuc2FjdGlvbiBmYWlscy5cclxuICpcclxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHdyaXRlcyBhbGxvd2VkIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uIGlzIDUwMC5cclxuICpcclxuICogQHBhcmFtIGZpcmVzdG9yZSAtIEEgcmVmZXJlbmNlIHRvIHRoZSBGaXJlc3RvcmUgZGF0YWJhc2UgdG8gcnVuIHRoaXNcclxuICogdHJhbnNhY3Rpb24gYWdhaW5zdC5cclxuICogQHBhcmFtIHVwZGF0ZUZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2l0aGluIHRoZSB0cmFuc2FjdGlvblxyXG4gKiBjb250ZXh0LlxyXG4gKiBAcmV0dXJucyBJZiB0aGUgdHJhbnNhY3Rpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBvciB3YXMgZXhwbGljaXRseSBhYm9ydGVkXHJcbiAqICh0aGUgYHVwZGF0ZUZ1bmN0aW9uYCByZXR1cm5lZCBhIGZhaWxlZCBwcm9taXNlKSwgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlXHJcbiAqIGB1cGRhdGVGdW5jdGlvbiBgaXMgcmV0dXJuZWQgaGVyZS4gT3RoZXJ3aXNlLCBpZiB0aGUgdHJhbnNhY3Rpb24gZmFpbGVkLCBhXHJcbiAqIHJlamVjdGVkIHByb21pc2Ugd2l0aCB0aGUgY29ycmVzcG9uZGluZyBmYWlsdXJlIGVycm9yIGlzIHJldHVybmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcnVuVHJhbnNhY3Rpb24oZmlyZXN0b3JlLCB1cGRhdGVGdW5jdGlvbikge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBjbGllbnQgPSBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gZmlyZXN0b3JlQ2xpZW50VHJhbnNhY3Rpb24oY2xpZW50LCBpbnRlcm5hbFRyYW5zYWN0aW9uID0+IHVwZGF0ZUZ1bmN0aW9uKG5ldyBUcmFuc2FjdGlvbihmaXJlc3RvcmUsIGludGVybmFsVHJhbnNhY3Rpb24pKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzZW50aW5lbCBmb3IgdXNlIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSModXBkYXRlRG9jOjEpfSBvclxyXG4gKiB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IHdpdGggYHttZXJnZTogdHJ1ZX1gIHRvIG1hcmsgYSBmaWVsZCBmb3IgZGVsZXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWxldGVGaWVsZCgpIHtcclxuICAgIHJldHVybiBuZXcgRGVsZXRlRmllbGRWYWx1ZUltcGwoJ2RlbGV0ZUZpZWxkJyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzZW50aW5lbCB1c2VkIHdpdGgge0BsaW5rIEBmaXJlYmFzZS9maXJlc3RvcmUvbGl0ZSMoc2V0RG9jOjEpfSBvciB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyh1cGRhdGVEb2M6MSl9IHRvXHJcbiAqIGluY2x1ZGUgYSBzZXJ2ZXItZ2VuZXJhdGVkIHRpbWVzdGFtcCBpbiB0aGUgd3JpdHRlbiBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VydmVyVGltZXN0YW1wKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXJUaW1lc3RhbXBGaWVsZFZhbHVlSW1wbCgnc2VydmVyVGltZXN0YW1wJyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IG9yIHtAbGlua1xyXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIHVuaW9uIHRoZSBnaXZlbiBlbGVtZW50cyB3aXRoIGFueSBhcnJheVxyXG4gKiB2YWx1ZSB0aGF0IGFscmVhZHkgZXhpc3RzIG9uIHRoZSBzZXJ2ZXIuIEVhY2ggc3BlY2lmaWVkIGVsZW1lbnQgdGhhdCBkb2Vzbid0XHJcbiAqIGFscmVhZHkgZXhpc3QgaW4gdGhlIGFycmF5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZC4gSWYgdGhlIGZpZWxkIGJlaW5nXHJcbiAqIG1vZGlmaWVkIGlzIG5vdCBhbHJlYWR5IGFuIGFycmF5IGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhbiBhcnJheVxyXG4gKiBjb250YWluaW5nIGV4YWN0bHkgdGhlIHNwZWNpZmllZCBlbGVtZW50cy5cclxuICpcclxuICogQHBhcmFtIGVsZW1lbnRzIC0gVGhlIGVsZW1lbnRzIHRvIHVuaW9uIGludG8gdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyBUaGUgYEZpZWxkVmFsdWVgIHNlbnRpbmVsIGZvciB1c2UgaW4gYSBjYWxsIHRvIGBzZXREb2MoKWAgb3JcclxuICogYHVwZGF0ZURvYygpYC5cclxuICovXHJcbmZ1bmN0aW9uIGFycmF5VW5pb24oLi4uZWxlbWVudHMpIHtcclxuICAgIC8vIE5PVEU6IFdlIGRvbid0IGFjdHVhbGx5IHBhcnNlIHRoZSBkYXRhIHVudGlsIGl0J3MgdXNlZCBpbiBzZXQoKSBvclxyXG4gICAgLy8gdXBkYXRlKCkgc2luY2Ugd2UnZCBuZWVkIHRoZSBGaXJlc3RvcmUgaW5zdGFuY2UgdG8gZG8gdGhpcy5cclxuICAgIHJldHVybiBuZXcgQXJyYXlVbmlvbkZpZWxkVmFsdWVJbXBsKCdhcnJheVVuaW9uJywgZWxlbWVudHMpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3BlY2lhbCB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge0BsaW5rIChzZXREb2M6MSl9IG9yIHtAbGlua1xyXG4gKiB1cGRhdGVEb2M6MX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIHJlbW92ZSB0aGUgZ2l2ZW4gZWxlbWVudHMgZnJvbSBhbnlcclxuICogYXJyYXkgdmFsdWUgdGhhdCBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgc2VydmVyLiBBbGwgaW5zdGFuY2VzIG9mIGVhY2ggZWxlbWVudFxyXG4gKiBzcGVjaWZpZWQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGFycmF5LiBJZiB0aGUgZmllbGQgYmVpbmcgbW9kaWZpZWQgaXMgbm90XHJcbiAqIGFscmVhZHkgYW4gYXJyYXkgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbiB3aXRoIGFuIGVtcHR5IGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbWVudHMgLSBUaGUgZWxlbWVudHMgdG8gcmVtb3ZlIGZyb20gdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyBUaGUgYEZpZWxkVmFsdWVgIHNlbnRpbmVsIGZvciB1c2UgaW4gYSBjYWxsIHRvIGBzZXREb2MoKWAgb3JcclxuICogYHVwZGF0ZURvYygpYFxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlSZW1vdmUoLi4uZWxlbWVudHMpIHtcclxuICAgIC8vIE5PVEU6IFdlIGRvbid0IGFjdHVhbGx5IHBhcnNlIHRoZSBkYXRhIHVudGlsIGl0J3MgdXNlZCBpbiBzZXQoKSBvclxyXG4gICAgLy8gdXBkYXRlKCkgc2luY2Ugd2UnZCBuZWVkIHRoZSBGaXJlc3RvcmUgaW5zdGFuY2UgdG8gZG8gdGhpcy5cclxuICAgIHJldHVybiBuZXcgQXJyYXlSZW1vdmVGaWVsZFZhbHVlSW1wbCgnYXJyYXlSZW1vdmUnLCBlbGVtZW50cyk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzcGVjaWFsIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB7QGxpbmsgQGZpcmViYXNlL2ZpcmVzdG9yZS9saXRlIyhzZXREb2M6MSl9IG9yIHtAbGlua1xyXG4gKiBAZmlyZWJhc2UvZmlyZXN0b3JlL2xpdGUjKHVwZGF0ZURvYzoxKX0gdGhhdCB0ZWxscyB0aGUgc2VydmVyIHRvIGluY3JlbWVudCB0aGUgZmllbGQncyBjdXJyZW50IHZhbHVlIGJ5XHJcbiAqIHRoZSBnaXZlbiB2YWx1ZS5cclxuICpcclxuICogSWYgZWl0aGVyIHRoZSBvcGVyYW5kIG9yIHRoZSBjdXJyZW50IGZpZWxkIHZhbHVlIHVzZXMgZmxvYXRpbmcgcG9pbnRcclxuICogcHJlY2lzaW9uLCBhbGwgYXJpdGhtZXRpYyBmb2xsb3dzIElFRUUgNzU0IHNlbWFudGljcy4gSWYgYm90aCB2YWx1ZXMgYXJlXHJcbiAqIGludGVnZXJzLCB2YWx1ZXMgb3V0c2lkZSBvZiBKYXZhU2NyaXB0J3Mgc2FmZSBudW1iZXIgcmFuZ2VcclxuICogKGBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUmAgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYCkgYXJlIGFsc28gc3ViamVjdCB0b1xyXG4gKiBwcmVjaXNpb24gbG9zcy4gRnVydGhlcm1vcmUsIG9uY2UgcHJvY2Vzc2VkIGJ5IHRoZSBGaXJlc3RvcmUgYmFja2VuZCwgYWxsXHJcbiAqIGludGVnZXIgb3BlcmF0aW9ucyBhcmUgY2FwcGVkIGJldHdlZW4gLTJeNjMgYW5kIDJeNjMtMS5cclxuICpcclxuICogSWYgdGhlIGN1cnJlbnQgZmllbGQgdmFsdWUgaXMgbm90IG9mIHR5cGUgYG51bWJlcmAsIG9yIGlmIHRoZSBmaWVsZCBkb2VzIG5vdFxyXG4gKiB5ZXQgZXhpc3QsIHRoZSB0cmFuc2Zvcm1hdGlvbiBzZXRzIHRoZSBmaWVsZCB0byB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBuIC0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBieS5cclxuICogQHJldHVybnMgVGhlIGBGaWVsZFZhbHVlYCBzZW50aW5lbCBmb3IgdXNlIGluIGEgY2FsbCB0byBgc2V0RG9jKClgIG9yXHJcbiAqIGB1cGRhdGVEb2MoKWBcclxuICovXHJcbmZ1bmN0aW9uIGluY3JlbWVudChuKSB7XHJcbiAgICByZXR1cm4gbmV3IE51bWVyaWNJbmNyZW1lbnRGaWVsZFZhbHVlSW1wbCgnaW5jcmVtZW50Jywgbik7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cml0ZSBiYXRjaCwgdXNlZCBmb3IgcGVyZm9ybWluZyBtdWx0aXBsZSB3cml0ZXMgYXMgYSBzaW5nbGVcclxuICogYXRvbWljIG9wZXJhdGlvbi4gVGhlIG1heGltdW0gbnVtYmVyIG9mIHdyaXRlcyBhbGxvd2VkIGluIGEgc2luZ2xlIHtAbGluayBXcml0ZUJhdGNofVxyXG4gKiBpcyA1MDAuXHJcbiAqXHJcbiAqIFVubGlrZSB0cmFuc2FjdGlvbnMsIHdyaXRlIGJhdGNoZXMgYXJlIHBlcnNpc3RlZCBvZmZsaW5lIGFuZCB0aGVyZWZvcmUgYXJlXHJcbiAqIHByZWZlcmFibGUgd2hlbiB5b3UgZG9uJ3QgbmVlZCB0byBjb25kaXRpb24geW91ciB3cml0ZXMgb24gcmVhZCBkYXRhLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIHtAbGluayBXcml0ZUJhdGNofSB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0b21pY2FsbHkgZXhlY3V0ZSBtdWx0aXBsZVxyXG4gKiB3cml0ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZUJhdGNoKGZpcmVzdG9yZSkge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICByZXR1cm4gbmV3IFdyaXRlQmF0Y2goZmlyZXN0b3JlLCBtdXRhdGlvbnMgPT4gZXhlY3V0ZVdyaXRlKGZpcmVzdG9yZSwgbXV0YXRpb25zKSk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0SW5kZXhDb25maWd1cmF0aW9uKGZpcmVzdG9yZSwganNvbk9yQ29uZmlndXJhdGlvbikge1xyXG4gICAgZmlyZXN0b3JlID0gY2FzdChmaXJlc3RvcmUsIEZpcmVzdG9yZSk7XHJcbiAgICBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkKGZpcmVzdG9yZSk7XHJcbiAgICBjb25zdCBpbmRleENvbmZpZ3VyYXRpb24gPSB0eXBlb2YganNvbk9yQ29uZmlndXJhdGlvbiA9PT0gJ3N0cmluZydcclxuICAgICAgICA/IHRyeVBhcnNlSnNvbihqc29uT3JDb25maWd1cmF0aW9uKVxyXG4gICAgICAgIDoganNvbk9yQ29uZmlndXJhdGlvbjtcclxuICAgIGNvbnN0IHBhcnNlZEluZGV4ZXMgPSBbXTtcclxuICAgIC8vIFBPUlRJTkcgTk9URTogV2UgZG9uJ3QgcmV0dXJuIGFuIGVycm9yIGlmIHRoZSB1c2VyIGhhcyBub3QgZW5hYmxlZFxyXG4gICAgLy8gcGVyc2lzdGVuY2Ugc2luY2UgYGVuYWJsZUluZGV4ZWRkYlBlcnNpc3RlbmNlKClgIGNhbiBmYWlsIG9uIHRoZSBXZWIuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleENvbmZpZ3VyYXRpb24uaW5kZXhlcykpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4Q29uZmlndXJhdGlvbi5pbmRleGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb25Hcm91cCA9IHRyeUdldFN0cmluZyhpbmRleCwgJ2NvbGxlY3Rpb25Hcm91cCcpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleC5maWVsZHMpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4LmZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aFN0cmluZyA9IHRyeUdldFN0cmluZyhmaWVsZCwgJ2ZpZWxkUGF0aCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUGF0aCA9IGZpZWxkUGF0aEZyb21Eb3RTZXBhcmF0ZWRTdHJpbmcoJ3NldEluZGV4Q29uZmlndXJhdGlvbicsIGZpZWxkUGF0aFN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLmFycmF5Q29uZmlnID09PSAnQ09OVEFJTlMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWVsZFBhdGgsIDIgLyogQ09OVEFJTlMgKi8pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQub3JkZXIgPT09ICdBU0NFTkRJTkcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEluZGV4U2VnbWVudChmaWVsZFBhdGgsIDAgLyogQVNDRU5ESU5HICovKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLm9yZGVyID09PSAnREVTQ0VORElORycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChuZXcgSW5kZXhTZWdtZW50KGZpZWxkUGF0aCwgMSAvKiBERVNDRU5ESU5HICovKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcnNlZEluZGV4ZXMucHVzaChuZXcgRmllbGRJbmRleChGaWVsZEluZGV4LlVOS05PV05fSUQsIGNvbGxlY3Rpb25Hcm91cCwgc2VnbWVudHMsIEluZGV4U3RhdGUuZW1wdHkoKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFRPRE8oaW5kZXhpbmcpOiBDb25maWd1cmUgaW5kZXhlc1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG59XHJcbmZ1bmN0aW9uIHRyeVBhcnNlSnNvbihqc29uKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGpzb24pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRmlyZXN0b3JlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnRmFpbGVkIHRvIHBhcnNlIEpTT046JyArIGUubWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJ5R2V0U3RyaW5nKGRhdGEsIHByb3BlcnR5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRhdGFbcHJvcGVydHldICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBGaXJlc3RvcmVFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlQsICdNaXNzaW5nIHN0cmluZyB2YWx1ZSBmb3I6ICcgKyBwcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YVtwcm9wZXJ0eV07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxucmVnaXN0ZXJGaXJlc3RvcmUoJ25vZGUnKTtcblxuZXhwb3J0IHsgQWJzdHJhY3RVc2VyRGF0YVdyaXRlciwgQnl0ZXMsIENBQ0hFX1NJWkVfVU5MSU1JVEVELCBDb2xsZWN0aW9uUmVmZXJlbmNlLCBEb2N1bWVudFJlZmVyZW5jZSwgRG9jdW1lbnRTbmFwc2hvdCwgRmllbGRQYXRoLCBGaWVsZFZhbHVlLCBGaXJlc3RvcmUsIEZpcmVzdG9yZUVycm9yLCBHZW9Qb2ludCwgTG9hZEJ1bmRsZVRhc2ssIFF1ZXJ5LCBRdWVyeUNvbnN0cmFpbnQsIFF1ZXJ5RG9jdW1lbnRTbmFwc2hvdCwgUXVlcnlTbmFwc2hvdCwgU25hcHNob3RNZXRhZGF0YSwgVGltZXN0YW1wLCBUcmFuc2FjdGlvbiwgV3JpdGVCYXRjaCwgRGF0YWJhc2VJZCBhcyBfRGF0YWJhc2VJZCwgRG9jdW1lbnRLZXkgYXMgX0RvY3VtZW50S2V5LCBFbXB0eUFwcENoZWNrVG9rZW5Qcm92aWRlciBhcyBfRW1wdHlBcHBDaGVja1Rva2VuUHJvdmlkZXIsIEVtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIgYXMgX0VtcHR5QXV0aENyZWRlbnRpYWxzUHJvdmlkZXIsIEZpZWxkUGF0aCQxIGFzIF9GaWVsZFBhdGgsIGNhc3QgYXMgX2Nhc3QsIGRlYnVnQXNzZXJ0IGFzIF9kZWJ1Z0Fzc2VydCwgaXNCYXNlNjRBdmFpbGFibGUgYXMgX2lzQmFzZTY0QXZhaWxhYmxlLCBsb2dXYXJuIGFzIF9sb2dXYXJuLCBzZXRJbmRleENvbmZpZ3VyYXRpb24gYXMgX3NldEluZGV4Q29uZmlndXJhdGlvbiwgdmFsaWRhdGVJc05vdFVzZWRUb2dldGhlciBhcyBfdmFsaWRhdGVJc05vdFVzZWRUb2dldGhlciwgYWRkRG9jLCBhcnJheVJlbW92ZSwgYXJyYXlVbmlvbiwgY2xlYXJJbmRleGVkRGJQZXJzaXN0ZW5jZSwgY29sbGVjdGlvbiwgY29sbGVjdGlvbkdyb3VwLCBjb25uZWN0RmlyZXN0b3JlRW11bGF0b3IsIGRlbGV0ZURvYywgZGVsZXRlRmllbGQsIGRpc2FibGVOZXR3b3JrLCBkb2MsIGRvY3VtZW50SWQsIGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlLCBlbmFibGVNdWx0aVRhYkluZGV4ZWREYlBlcnNpc3RlbmNlLCBlbmFibGVOZXR3b3JrLCBlbmRBdCwgZW5kQmVmb3JlLCBlbnN1cmVGaXJlc3RvcmVDb25maWd1cmVkLCBleGVjdXRlV3JpdGUsIGdldERvYywgZ2V0RG9jRnJvbUNhY2hlLCBnZXREb2NGcm9tU2VydmVyLCBnZXREb2NzLCBnZXREb2NzRnJvbUNhY2hlLCBnZXREb2NzRnJvbVNlcnZlciwgZ2V0RmlyZXN0b3JlLCBpbmNyZW1lbnQsIGluaXRpYWxpemVGaXJlc3RvcmUsIGxpbWl0LCBsaW1pdFRvTGFzdCwgbG9hZEJ1bmRsZSwgbmFtZWRRdWVyeSwgb25TbmFwc2hvdCwgb25TbmFwc2hvdHNJblN5bmMsIG9yZGVyQnksIHF1ZXJ5LCBxdWVyeUVxdWFsLCByZWZFcXVhbCwgcnVuVHJhbnNhY3Rpb24sIHNlcnZlclRpbWVzdGFtcCwgc2V0RG9jLCBzZXRMb2dMZXZlbCwgc25hcHNob3RFcXVhbCwgc3RhcnRBZnRlciwgc3RhcnRBdCwgdGVybWluYXRlLCB1cGRhdGVEb2MsIHdhaXRGb3JQZW5kaW5nV3JpdGVzLCB3aGVyZSwgd3JpdGVCYXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@firebase/firestore/dist/index.node.mjs\n");

/***/ }),

/***/ "./node_modules/firebase/app/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/firebase/app/dist/index.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"@firebase/app\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_firebase_app__WEBPACK_IMPORTED_MODULE_0__]);\n_firebase_app__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _firebase_app__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _firebase_app__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\nvar name = \"firebase\";\nvar version = \"9.6.8\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'app');\n//# sourceMappingURL=index.mjs.map\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYXBwL2Rpc3QvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdEO0FBQ2xCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9hcHAvZGlzdC9pbmRleC5tanM/YTliZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWdpc3RlclZlcnNpb24gfSBmcm9tICdAZmlyZWJhc2UvYXBwJztcbmV4cG9ydCAqIGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuXG52YXIgbmFtZSA9IFwiZmlyZWJhc2VcIjtcbnZhciB2ZXJzaW9uID0gXCI5LjYuOFwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5yZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ2FwcCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/firebase/app/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/firebase/firestore/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/firebase/firestore/dist/index.mjs ***!
  \********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/firestore */ \"./node_modules/@firebase/firestore/dist/index.node.mjs\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_firebase_firestore__WEBPACK_IMPORTED_MODULE_0__]);\n_firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _firebase_firestore__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n//# sourceMappingURL=index.mjs.map\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvZmlyZXN0b3JlL2Rpc3QvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2ZpcmVzdG9yZS9kaXN0L2luZGV4Lm1qcz8xNjI0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJ0BmaXJlYmFzZS9maXJlc3RvcmUnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/firebase/firestore/dist/index.mjs\n");

/***/ }),

/***/ "./node_modules/firebase/storage/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/firebase/storage/dist/index.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__) => {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _firebase_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/storage */ \"@firebase/storage\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_firebase_storage__WEBPACK_IMPORTED_MODULE_0__]);\n_firebase_storage__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? await __webpack_async_dependencies__ : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _firebase_storage__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _firebase_storage__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n//# sourceMappingURL=index.mjs.map\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2luZGV4Lm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrQztBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9zdG9yYWdlL2Rpc3QvaW5kZXgubWpzPzk1N2QiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnQGZpcmViYXNlL3N0b3JhZ2UnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/firebase/storage/dist/index.mjs\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("./pages/index.js"));
module.exports = __webpack_exports__;

})();